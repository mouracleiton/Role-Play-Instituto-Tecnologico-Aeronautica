{
  "formatVersion": "1.0",
  "exportDate": "2025-12-04T22:47:00.423Z",
  "appVersion": "1.0",
  "curriculumData": {
    "metadata": {
      "baseOn": "Catálogo dos Cursos de Graduação 2025 - TC-55",
      "lastUpdated": "2025-12-04",
      "totalAtomicSkills": 320,
      "startDate": "2025-02-01",
      "duration": "5 years",
      "dailyStudyHours": 6,
      "version": "TC-55",
      "institution": "Instituto Tecnológico de Aeronáutica (ITA)",
      "basedOn": "Catálogo dos Cursos de Graduação 2025 - TC-55"
    },
    "areas": [
      {
        "id": "10",
        "name": "Metodologias de Computação",
        "description": "Área do Departamento de Metodologias de Computação (IEC-M) focada em algoritmos e estruturas avançadas em computação.",
        "disciplines": [
          {
            "id": "10.1",
            "name": "TC-55 - Algoritmos Avançados",
            "description": "Programação dinâmica. Métodos exaustivos. Algoritmos gulosos. Ordenação topológica. Manipulação de cadeias de caracteres. Algoritmos em árvores: árvore geradora mínima. Algoritmos em grafos: caminho mais curto, fluxo máximo, problemas de emparelhamento.",
            "mainTopics": [
              {
                "id": "10.1.1",
                "name": "Programação Dinâmica",
                "description": "Técnica de resolução de problemas de otimização por meio de subproblemas sobrepostos, com armazenamento de soluções intermediárias para evitar recomputações.",
                "totalSkills": 54,
                "atomicTopics": [
                  {
                    "id": "10.1.1.1",
                    "name": "Definição de Programação Dinâmica",
                    "description": "Técnica para resolver problemas de otimização dividindo em subproblemas sobrepostos com armazenamento de soluções intermediárias.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.1.1",
                        "name": "Estrutura Ótima",
                        "description": "Propriedade fundamental da Programação Dinâmica onde a solução ótima para um problema pode ser construída de forma eficiente a partir das soluções ótimas de seus subproblemas menores.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.1.1",
                            "name": "Identificar estrutura ótima em problemas",
                            "description": "Analisar um problema de otimização para determinar se ele possui estrutura ótima, verificando se a escolha ótima em cada etapa leva a soluções ótimas nos subproblemas recursivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de estrutura ótima",
                                  "subSteps": [
                                    "Leia a definição formal: uma solução ótima para o problema contém soluções ótimas para todos os subproblemas relevantes.",
                                    "Estude exemplos clássicos como o problema de fazer troco ótimo ou multiplicação de cadeias de matrizes.",
                                    "Anote os componentes chave: otimização, subproblemas recursivos e composição de soluções ótimas.",
                                    "Compare com problemas sem estrutura ótima, como alguns problemas NP-completos sem essa propriedade.",
                                    "Resuma em suas próprias palavras a diferença entre estrutura ótima e mera recursão."
                                  ],
                                  "verification": "Escreva um parágrafo explicando a definição e dê um exemplo simples; verifique se menciona composição de subótimos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Algoritmos (ex: CLRS), notas em papel, acesso a slides de Programação Dinâmica.",
                                  "tips": "Use analogias como 'construir uma casa ótima requer cômodos ótimos interconectados'.",
                                  "learningObjective": "Dominar a definição conceitual de estrutura ótima em problemas de otimização.",
                                  "commonMistakes": "Confundir com sobreposição de subproblemas; lembrar que estrutura ótima é sobre qualidade das soluções, não frequência."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o problema para identificar subproblemas potenciais",
                                  "subSteps": [
                                    "Leia o enunciado do problema e destaque palavras como 'mínimo', 'máximo', 'ótimo' para confirmar ser de otimização.",
                                    "Defina o problema principal e liste possíveis subproblemas menores (ex: para tamanho n, sub de tamanho n-1).",
                                    "Desenhe um diagrama de dependências mostrando como o problema maior depende de menores.",
                                    "Escreva uma relação recursiva informal: opt(P(n)) em termos de opt(P(m)) para m < n.",
                                    "Questione se todos os subproblemas são definidos de forma consistente."
                                  ],
                                  "verification": "Crie um diagrama de subproblemas com pelo menos 3 níveis; confirme se flui recursivamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, canetas coloridas, exemplo de problema impresso.",
                                  "tips": "Comece do menor subproblema e construa para cima, como em uma árvore de recursão.",
                                  "learningObjective": "Identificar e mapear subproblemas recursivos em um problema de otimização.",
                                  "commonMistakes": "Ignorar subproblemas não-adjacentes; sempre verifique independência relativa."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a propriedade de optimalidade",
                                  "subSteps": [
                                    "Assuma uma solução ótima para o problema principal e isole as escolhas feitas nos subproblemas.",
                                    "Prove por contradição: suponha que um subótimo não seja ótimo; mostre que isso contradiz a otimalidade global.",
                                    "Teste com uma escolha subótima em um subproblema e veja se piora a solução global.",
                                    "Formalize a recursão: opt(n) = min/max { c + opt(sub(n')) } sobre escolhas válidas.",
                                    "Documente se a propriedade segura para todas as instâncias do problema."
                                  ],
                                  "verification": "Escreva uma prova curta (3-5 linhas) para um exemplo específico; valide com um contraexemplo se falhar.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de texto para pseudocódigo, calculadora para valores numéricos pequenos.",
                                  "tips": "Use indução em n: base para pequenos n, assume para menores, prova para n.",
                                  "learningObjective": "Validar se escolhas ótimas em subproblemas levam à solução ótima global.",
                                  "commonMistakes": "Assumir sem prova; sempre teste com números concretos antes de generalizar."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e testar a identificação",
                                  "subSteps": [
                                    "Resuma: o problema tem estrutura ótima? Liste evidências pró e contra.",
                                    "Aplique a verificação em um segundo problema similar para prática.",
                                    "Escreva a equação de recorrência final que captura a estrutura.",
                                    "Discuta limitações: quando a estrutura ótima falha (ex: dependências não-recursivas).",
                                    "Prepare um relatório de 1 página com diagrama, prova e recorrência."
                                  ],
                                  "verification": "Identifique corretamente em 2 problemas de teste; relatório aprovado por auto-revisão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Dois problemas de exemplo (um com, um sem estrutura ótima), modelo de relatório.",
                                  "tips": "Use checklist: otimização? Subproblemas recursivos? Composição ótima?",
                                  "learningObjective": "Sintetizar análise e confirmar presença de estrutura ótima de forma conclusiva.",
                                  "commonMistakes": "Concluir prematuramente sem teste múltiplo; sempre valide com exemplo numérico."
                                }
                              ],
                              "practicalExample": "No problema de fazer troco ótimo com moedas de valores {1,5,10} para valor 13: a solução ótima é 1 moeda de 10 + 3 de 1 (ou melhor 1x10 + 1x1 + 2x1? Wait, ótimo é 1x10 + 1x1 + 2x1 no, 1x10 + 3x1=4 moedas, mas 2x5 + 3x1=5 pior; subproblema para 13-10=3 é 3x1 ótimo, e compõe o global.",
                              "finalVerifications": [
                                "Explica a definição de estrutura ótima em termos próprios sem erros.",
                                "Mapeia corretamente subproblemas para um problema dado.",
                                "Fornece prova válida por contradição ou indução.",
                                "Escreve recorrência que captura a estrutura.",
                                "Identifica corretamente em 80% dos problemas de teste.",
                                "Discute quando a propriedade não segura."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definição e componentes): 0-5 pontos.",
                                "Qualidade da análise de subproblemas (diagrama e mapeamento): 0-5 pontos.",
                                "Robustez da verificação de optimalidade (prova e testes): 0-5 pontos.",
                                "Clareza da recorrência e conclusão: 0-5 pontos.",
                                "Aplicação prática em exemplos: 0-5 pontos.",
                                "Profundidade geral e ausência de erros comuns: 0-5 pontos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências e indução matemática.",
                                "Economia: Otimização de recursos e alocação ótima.",
                                "Ciência da Computação: Análise de algoritmos e complexidade.",
                                "Engenharia: Otimização em design de sistemas e roteamento."
                              ],
                              "realWorldApplication": "Em logística para otimizar rotas de entrega (shortest path com PD), onde o caminho ótimo para uma cidade inclui caminhos ótimos para sub-cidades; ou em finanças para portfólios ótimos via PD em alocação dinâmica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.2",
                            "name": "Construir recorrência para estrutura ótima",
                            "description": "Formular uma equação de recorrência que exprima a solução ótima de um problema em termos das soluções ótimas de subproblemas, como em problemas clássicos como Fibonacci ou mochila.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema e identificar a estrutura ótima",
                                  "subSteps": [
                                    "Leia e compreenda o problema, identificando o objetivo de otimização (minimizar ou maximizar).",
                                    "Divida o problema em subproblemas menores, observando padrões repetitivos.",
                                    "Desenhe um diagrama de decisão ou árvore de recursão para visualizar escolhas ótimas.",
                                    "Identifique as escolhas locais que levam à solução global ótima.",
                                    "Documente as dependências entre subproblemas."
                                  ],
                                  "verification": "Crie um esboço escrito ou diagrama mostrando subproblemas e sua interconexão.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e caneta, ou ferramenta de diagramação como Draw.io",
                                  "tips": "Comece com problemas pequenos para visualizar a estrutura antes de generalizar.",
                                  "learningObjective": "Reconhecer padrões de estrutura ótima em problemas de otimização.",
                                  "commonMistakes": "Ignorar escolhas exaustivas ou assumir independência entre subproblemas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os parâmetros do estado da recorrência",
                                  "subSteps": [
                                    "Escolha variáveis que capturem todos os subproblemas relevantes (ex: tamanho do subproblema, capacidade restante).",
                                    "Defina T(i, ...) como a solução ótima para o subproblema i.",
                                    "Garanta que o estado seja mínimo e suficiente para reconstruir a solução.",
                                    "Teste o estado com exemplos pequenos para verificar unicidade.",
                                    "Anote restrições nos parâmetros (ex: i de 0 a n)."
                                  ],
                                  "verification": "Escreva a definição formal de T(i, ...) e teste com 2-3 subproblemas.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Caderno de anotações, exemplos de problemas impressos",
                                  "tips": "Priorize estados com poucos parâmetros para simplicidade computacional.",
                                  "learningObjective": "Criar uma definição de estado concisa e completa para subproblemas.",
                                  "commonMistakes": "Incluir parâmetros desnecessários ou omitir fatores críticos como restrições."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a equação de recorrência",
                                  "subSteps": [
                                    "Liste todas as escolhas possíveis no estado atual (ex: incluir ou excluir item).",
                                    "Expresse T(i, ...) como o máximo/mínimo entre opções baseadas em T de subproblemas menores.",
                                    "Inclua o custo/benefício da escolha atual na recursão.",
                                    "Simplifique a equação usando max/min ou somas.",
                                    "Verifique consistência com o diagrama do Step 1."
                                  ],
                                  "verification": "Escreva a equação e substitua valores pequenos para checar lógica.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Editor de texto ou LaTeX para equações, calculadora",
                                  "tips": "Use notação consistente e evite ambiguidades nos índices.",
                                  "learningObjective": "Construir relações recursivas que garantam otimalidade.",
                                  "commonMistakes": "Esquecer de considerar todas as branches ou sobrepor subproblemas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Estabelecer condições base e validar",
                                  "subSteps": [
                                    "Defina T(0, ...) ou casos triviais onde a solução é conhecida (ex: capacidade 0 = 0).",
                                    "Escreva todas as condições base explicitamente.",
                                    "Compute soluções para instâncias pequenas usando a recorrência.",
                                    "Compare com solução exaustiva ou conhecida para validar.",
                                    "Ajuste se houver discrepâncias."
                                  ],
                                  "verification": "Calcule T para n=1,2,3 e confirme igualdade com brute-force.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Planilha Excel ou Python para computação manual",
                                  "tips": "Sempre teste condições base primeiro, pois erros ali propagam.",
                                  "learningObjective": "Completar a recorrência com bases sólidas e validar empiricamente.",
                                  "commonMistakes": "Condições base inconsistentes ou indefinidas para bordas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refinar e documentar a recorrência completa",
                                  "subSteps": [
                                    "Revise toda a recorrência por clareza e correção.",
                                    "Adicione pseudocódigo ou implementação simples.",
                                    "Discuta complexidade temporal em termos de estados.",
                                    "Gere tabela de valores para visualização.",
                                    "Prepare explicação para apresentação."
                                  ],
                                  "verification": "Explique a recorrência para um par ou auto-grave um vídeo de 2min.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Python/Jupyter Notebook, gravador de tela",
                                  "tips": "Visualize com tabelas DP para confirmar otimalidade.",
                                  "learningObjective": "Produzir uma recorrência pronta para implementação em PD.",
                                  "commonMistakes": "Não documentar ou pular validação final."
                                }
                              ],
                              "practicalExample": "No problema da Mochila 0/1 com capacidade W=5 e itens (peso 2 valor 3, peso 3 valor 4, peso 4 valor 5): Defina T(i,w) = valor máximo com primeiros i itens e capacidade w. Recorrência: T(i,w) = max(T(i-1,w), T(i-1,w-peso[i]) + valor[i]) se w >= peso[i], senão T(i-1,w). Bases: T(0,w)=0, T(i,0)=0. Compute T(3,5)=7 (itens 1 e 2).",
                              "finalVerifications": [
                                "A recorrência resolve corretamente instâncias pequenas (n<=5).",
                                "Condições base são consistentes e cobrem todos os casos.",
                                "Cada estado é computado apenas de estados menores (sem ciclos).",
                                "Solução ótima bate com brute-force para exemplos médios.",
                                "Equação captura todas as escolhas viáveis sem sobreposições.",
                                "Complexidade é O(n * restrições), polinomial."
                              ],
                              "assessmentCriteria": [
                                "Definição de estado captura exatamente os subproblemas necessários (precisão 100%).",
                                "Equação de recorrência é correta e exaustiva (validação em 3+ exemplos).",
                                "Condições base são completas e corretas.",
                                "Documentação clara com notação consistente.",
                                "Validação empírica demonstra otimalidade.",
                                "Explicação oral/written é fluida e precisa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Equações de recorrência e indução matemática.",
                                "Economia: Otimização de recursos limitados (alocação orçamentária).",
                                "Engenharia de Software: Design de algoritmos eficientes.",
                                "Estatística: Modelagem de processos sequenciais ótimos."
                              ],
                              "realWorldApplication": "Em logística, otimizar carregamento de caminhões (mochila); em finanças, portfólio ótimo com restrições de risco; em bioinformática, alinhamento de sequências genéticas maximizando similaridade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.1.3",
                            "name": "Diferenciar de problemas sem estrutura ótima",
                            "description": "Comparar problemas com e sem estrutura ótima, reconhecendo quando algoritmos gulosos ou exaustivos são mais adequados em vez de Programação Dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Definição de Estrutura Ótima em Programação Dinâmica",
                                  "subSteps": [
                                    "Leia a definição formal: uma solução ótima para um problema inclui soluções ótimas para seus subproblemas.",
                                    "Analise os requisitos: sobreposição de subproblemas e estrutura ótima são pilares da PD.",
                                    "Compare com recursão simples: note como PD memoiza para eficiência.",
                                    "Anote exemplos iniciais de problemas que violam isso, como buscas exaustivas."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a definição e dê um exemplo simples de violação.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro de Algoritmos (ex: CLRS), caderno para anotações",
                                  "tips": "Use analogias como 'construir uma casa: cada andar depende do anterior perfeitamente'.",
                                  "learningObjective": "Compreender conceitualmente o que constitui 'estrutura ótima' em PD.",
                                  "commonMistakes": "Confundir com mera recursão; ignorar a parte 'ótima' dos subproblemas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Problemas com Estrutura Ótima",
                                  "subSteps": [
                                    "Estude exemplos clássicos: Fibonacci (fib(n) = fib(n-1) + fib(n-2)), Mochila 0/1.",
                                    "Desenhe a árvore de recursão e destaque subproblemas sobrepostos e ótimos.",
                                    "Implemente uma versão recursiva simples e observe a explosão exponencial sem memoização.",
                                    "Verifique: solução ótima de subproblema é usada na solução global?",
                                    "Liste 3 problemas com essa propriedade."
                                  ],
                                  "verification": "Crie uma tabela comparando recursão vs. PD para Fibonacci.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (Python), papel para diagramas",
                                  "tips": "Sempre pergunte: 'A escolha ótima aqui depende só de escolhas ótimas menores?'",
                                  "learningObjective": "Reconhecer padrões de problemas aptos para PD pela presença de estrutura ótima.",
                                  "commonMistakes": "Assumir que todo problema recursivo tem estrutura ótima; esquecer sobreposição."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Problemas sem Estrutura Ótima e Alternativas",
                                  "subSteps": [
                                    "Examine exemplos: Problema do Caixeiro Viajante (TSP) - solução ótima não compõe de sub-caminhos ótimos facilmente.",
                                    "Estude guloso: Agendamento de Intervalos (escolha o que acaba primeiro).",
                                    "Explore exaustivo: Subconjunto Soma com restrições não-PD.",
                                    "Compare complexidades: PD O(nW) vs. guloso O(n log n) vs. exaustivo O(2^n).",
                                    "Identifique quando cada um é preferível."
                                  ],
                                  "verification": "Classifique 4 problemas conhecidos em 'PD', 'Guloso' ou 'Exaustivo'.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Lista de problemas de algoritmos online (LeetCode, GeeksforGeeks)",
                                  "tips": "Pense em 'independência': se escolhas locais não garantem global ótimo, evite PD.",
                                  "learningObjective": "Diferenciar problemas sem estrutura ótima e mapear para algoritmos alternativos.",
                                  "commonMistakes": "Forçar PD em problemas onde subestruturas não são ótimas; subestimar guloso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Diferenciação e Comparação",
                                  "subSteps": [
                                    "Pegue um problema novo (ex: Matrix Chain Multiplication vs. Clique Problem).",
                                    "Desconstrua: tem estrutura ótima? Sobreposição? Alternativa melhor?",
                                    "Crie fluxograma de decisão: 'Estrutura ótima? -> PD; Independente? -> Guloso; NP? -> Exaustivo'.",
                                    "Resolva 2 exercícios mistos.",
                                    "Autoavalie com critérios de Step 1-3."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que um problema usa PD e outro não.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exercícios de algoritmos, timer para prática",
                                  "tips": "Use pseudocódigo para testar hipóteses rapidamente.",
                                  "learningObjective": "Aplicar diferenciação em cenários reais para escolha de algoritmo.",
                                  "commonMistakes": "Ignorar restrições de tempo/espaço; rotular erroneamente problemas NP-completos como PD."
                                }
                              ],
                              "practicalExample": "Compare 'Mochila 0/1' (estrutura ótima: dp[i][w] usa dp[i-1][w] e dp[i-1][w-weight]; PD ideal) com 'Caixeiro Viajante' (sem estrutura ótima simples: ciclo ótimo não é soma de caminhos ótimos locais; use branch-and-bound ou exaustivo). Guloso para 'Agendamento de Salas' (selecione intervalo mais curto primeiro).",
                              "finalVerifications": [
                                "Classifique corretamente 5 problemas como PD, guloso ou exaustivo com justificativa.",
                                "Desenhe recursão para um problema com/sem estrutura ótima mostrando diferença.",
                                "Explique por que PD falha em TSP em menos de 1 minuto.",
                                "Crie fluxograma de decisão funcional.",
                                "Resolva um problema híbrido escolhendo o algoritmo certo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de estrutura ótima (80% acerto em exemplos).",
                                "Justificativas claras baseadas em subproblemas e optimalidade.",
                                "Correta sugestão de alternativas (guloso/exaustivo) com análise de complexidade.",
                                "Uso de exemplos concretos e diagramas em explicações.",
                                "Capacidade de generalizar para novos problemas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização combinatória e teoria de grafos.",
                                "Inteligência Artificial: Algoritmos de busca (A*, guloso) vs. PD em planejamento.",
                                "Engenharia de Software: Análise de complexidade e escolha de design patterns.",
                                "Economia: Modelos de otimização linear vs. não-linear."
                              ],
                              "realWorldApplication": "Em logística, diferenciar PD para 'otimização de estoque com restrições' (estrutura ótima) vs. guloso para 'roteirização rápida de entregas' (aproximação local), evitando ineficiências em apps como Uber ou Amazon."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.2",
                        "name": "Subproblemas Sobrepostos",
                        "description": "Característica onde os mesmos subproblemas são resolvidos múltiplas vezes em uma abordagem recursiva ingênua, justificando a necessidade de armazenamento para evitar recomputações.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.2.1",
                            "name": "Detectar subproblemas sobrepostos",
                            "description": "Em uma árvore de recursão de um problema, identificar nós repetidos que representam os mesmos subproblemas, como na computação de números de Fibonacci.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a estrutura de uma árvore de recursão",
                                  "subSteps": [
                                    "Revise a definição de recursão: uma função que chama a si mesma com subproblemas menores.",
                                    "Desenhe uma árvore genérica para uma recursão simples, como f(n) = f(n-1) + f(n-2).",
                                    "Identifique o nó raiz como o problema original e folhas como casos base.",
                                    "Marque os ramos como chamadas recursivas.",
                                    "Anote os argumentos de cada nó para rastrear subproblemas."
                                  ],
                                  "verification": "Desenhe corretamente a árvore de recursão para f(3) sem erros nos ramos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama de exemplo de recursão impresso"
                                  ],
                                  "tips": "Comece sempre do nó raiz e expanda simetricamente para ambos os lados.",
                                  "learningObjective": "Compreender visualmente como a recursão gera uma árvore de chamadas.",
                                  "commonMistakes": [
                                    "Confundir ordem dos argumentos",
                                    "Esquecer casos base nas folhas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a árvore de recursão para Fibonacci",
                                  "subSteps": [
                                    "Defina Fibonacci: fib(n) = fib(n-1) + fib(n-2), com fib(0)=0, fib(1)=1.",
                                    "Desenhe a árvore completa para fib(4), expandindo todos os nós.",
                                    "Conte o número total de nós e chamadas de função.",
                                    "Rotule cada nó com seu valor de n.",
                                    "Observe o crescimento exponencial da árvore."
                                  ],
                                  "verification": "A árvore para fib(4) deve ter 15 nós, incluindo 2 folhas fib(1) e 1 fib(2) duplicado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Código Python simples de fib recursivo para executar e contar chamadas"
                                  ],
                                  "tips": "Use cores diferentes para ramos esquerdos e direitos para facilitar visualização.",
                                  "learningObjective": "Construir e analisar a árvore de recursão específica do Fibonacci.",
                                  "commonMistakes": [
                                    "Parar expansão prematuramente",
                                    "Erro na contagem de nós duplicados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar nós repetidos e subproblemas sobrepostos",
                                  "subSteps": [
                                    "Percorra a árvore e circule nós com o mesmo argumento (ex: múltiplos fib(2)).",
                                    "Conte quantas vezes cada subproblema único aparece (fib(2) aparece 3 vezes em fib(4)).",
                                    "Destaque caminhos que levam aos mesmos nós de diferentes ramos.",
                                    "Calcule o custo computacional devido a recomputações.",
                                    "Compare com uma versão memoizada para validar."
                                  ],
                                  "verification": "Liste todos os subproblemas sobrepostos em fib(4): fib(2) (3x), fib(1) (2x).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Árvore desenhada do step 2",
                                    "Ferramenta online como Python Tutor para visualização"
                                  ],
                                  "tips": "Use setas para conectar nós idênticos e evitar confusão visual.",
                                  "learningObjective": "Detectar padrões de repetição que indicam sobreposição de subproblemas.",
                                  "commonMistakes": [
                                    "Ignorar sobreposições em níveis profundos",
                                    "Confundir sobreposição com independência"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar detecção para outros problemas recursivos",
                                  "subSteps": [
                                    "Escolha outro problema, como soma de subconjuntos ou Hanoi, e desenhe sua árvore.",
                                    "Aplique o método: construir, rotular, identificar repetições.",
                                    "Documente os subproblemas sobrepostos encontrados.",
                                    "Discuta por que isso qualifica para Programação Dinâmica.",
                                    "Teste com código: rode recursão ingênua e observe tempo vs. memoizado."
                                  ],
                                  "verification": "Identifique corretamente sobreposições em pelo menos um problema adicional.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de problemas recursivos",
                                    "Editor de código (VS Code ou Jupyter)"
                                  ],
                                  "tips": "Sempre normalize argumentos dos nós para comparação exata.",
                                  "learningObjective": "Aplicar a detecção de sobreposições de forma independente em novos contextos.",
                                  "commonMistakes": [
                                    "Assumir sobreposição sem contagem precisa",
                                    "Não generalizar para não-Fibonacci"
                                  ]
                                }
                              ],
                              "practicalExample": "Para fib(4): Raiz fib(4) ramifica para fib(3)+fib(2). fib(3) para fib(2)+fib(1). Note fib(2) aparece em fib(4)->fib(2), fib(3)->fib(2), e fib(3)->fib(1)->fib(0) não sobrepõe diretamente, mas fib(2) é recalculado 3 vezes.",
                              "finalVerifications": [
                                "Desenhar árvore de fib(5) com todos nós rotulados corretamente.",
                                "Listar todos subproblemas sobrepostos e suas frequências.",
                                "Explicar verbalmente por que recursão ingênua é ineficiente.",
                                "Identificar sobreposições em torre de Hanoi para n=3.",
                                "Comparar tempo de execução recursivo vs. iterativo para fib(30)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da árvore (100% dos nós corretos).",
                                "Correta identificação de todos nós sobrepostos (sem falsos positivos/negativos).",
                                "Explicação clara do impacto na complexidade (exponencial devido a recomputações).",
                                "Generalização para pelo menos 2 problemas diferentes.",
                                "Uso de visualizações ou código para suporte empírico.",
                                "Compreensão de pré-requisito para memoização/PD."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de árvores e grafos direcionados.",
                                "Ciência da Computação: Complexidade de algoritmos e Big O.",
                                "Otimização: Problemas de programação linear inteira.",
                                "Engenharia de Software: Refatoração de código recursivo ineficiente."
                              ],
                              "realWorldApplication": "Em algoritmos de roteamento (ex: Dijkstra com PD para caminhos mais curtos), processamento de linguagem natural (árvores de parsing com subestruturas repetidas), e bioinformática (alinhamento de sequências genéticas evitando recomputações caras)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.2",
                            "name": "Quantificar o ganho de evitar sobreposições",
                            "description": "Calcular o número de chamadas redundantes em recursão pura versus com memoização, demonstrando a redução exponencial para polinomial em problemas com sobreposições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar recursão pura e contar chamadas iniciais",
                                  "subSteps": [
                                    "Escolha um problema clássico como Fibonacci (fib(n)).",
                                    "Implemente a função recursiva pura em Python ou JavaScript.",
                                    "Adicione um contador global para registrar todas as chamadas da função.",
                                    "Execute para valores pequenos (n=5, n=6) e registre o número total de chamadas.",
                                    "Desenhe manualmente a árvore de recursão para n=4 para visualizar ramificações."
                                  ],
                                  "verification": "Verifique se o contador registra o número correto de chamadas (ex: fib(5) deve ter 15 chamadas).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (VS Code), papel e caneta para árvore de recursão.",
                                  "tips": "Use print statements ou um contador para rastrear chamadas sem alterar a lógica.",
                                  "learningObjective": "Compreender como a recursão pura gera chamadas repetidas para os mesmos subproblemas.",
                                  "commonMistakes": "Contar apenas chamadas de fib(n) e ignorar recursões internas; confundir chamadas com computações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar e quantificar redundâncias na recursão pura",
                                  "subSteps": [
                                    "Conte manualmente quantas vezes cada subproblema fib(k) é computado para n=5 e n=6.",
                                    "Calcule o número total de chamadas usando a recorrência T(n) = T(n-1) + T(n-2) + 1.",
                                    "Identifique padrões de sobreposição (ex: fib(3) chamado múltiplas vezes).",
                                    "Estime o crescimento exponencial: prove que T(n) ≈ φ^n onde φ é a razão áurea.",
                                    "Registre uma tabela: n | chamadas | fib(n)."
                                  ],
                                  "verification": "Tabela completa mostrando crescimento exponencial (ex: fib(10) ~ 177 chamadas).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha (Excel/Google Sheets) para tabela, calculadora.",
                                  "tips": "Comece com n pequeno para evitar explosão; foque em fib(2) a fib(n).",
                                  "learningObjective": "Quantificar o custo exponencial devido a sobreposições em recursão pura.",
                                  "commonMistakes": "Ignorar a chamada inicial (+1); confundir complexidade temporal com número de chamadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar memoização e medir chamadas otimizadas",
                                  "subSteps": [
                                    "Modifique a função para usar um dicionário/memo como cache para subproblemas.",
                                    "Mantenha o contador de chamadas, distinguindo hits (cache) e misses (recursão).",
                                    "Execute para os mesmos n=5,6,10 e compare contadores.",
                                    "Verifique que cada fib(k) é computado exatamente uma vez.",
                                    "Meça o tempo de execução para n=30 (recursivo falha, memoizado ok)."
                                  ],
                                  "verification": "Contador mostra ~2n chamadas lineares (ex: fib(10) ~21 chamadas).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Mesmo editor de código, cronômetro para tempo.",
                                  "tips": "Use @lru_cache em Python para simplicidade inicial, depois implemente manualmente.",
                                  "learningObjective": "Demonstrar como memoização elimina redundâncias, reduzindo para O(n).",
                                  "commonMistakes": "Não zerar cache entre testes; esquecer de contar cache hits como chamadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar ganhos e generalizar para problemas sobrepostos",
                                  "subSteps": [
                                    "Calcule a redução: razão chamadas_recursivo / chamadas_memo para vários n.",
                                    "Plote gráfico (n vs log(chamadas)) mostrando exponencial vs linear.",
                                    "Aplique a um segundo problema (ex: binomial coefficients ou knapsack simples).",
                                    "Discuta quando sobreposições ocorrem e critérios para PD.",
                                    "Escreva fórmula geral: de O(φ^n) para O(n) ou polinomial."
                                  ],
                                  "verification": "Gráfico e tabela comprovando redução exponencial para polinomial.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramenta de plotagem (Matplotlib ou Google Sheets).",
                                  "tips": "Use log escala para visualizar diferenças; teste n até 40 com memo.",
                                  "learningObjective": "Generalizar o ganho quantitativo da memoização em PD.",
                                  "commonMistakes": "Comparar apenas tempo, ignorando contagem exata; generalizar sem segundo exemplo."
                                }
                              ],
                              "practicalExample": "Para Fibonacci fib(10): recursão pura faz 177 chamadas (exponencial), memoização faz 21 chamadas (linear), redução de ~8x; para fib(30), recursivo é impraticável (milhões de chamadas), memoizado instantâneo.",
                              "finalVerifications": [
                                "Calcula corretamente chamadas para fib(n) recursivo e memoizado (n=5 a 15).",
                                "Desenha árvore de recursão mostrando sobreposições para n=5.",
                                "Implementa memoização funcional com contador preciso.",
                                "Mostra gráfico exponencial vs linear.",
                                "Aplica quantificação a um problema não-Fibonacci como coeficientes binomiais.",
                                "Explica verbalmente redução de tempo exponencial para polinomial."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de chamadas (erro <5%).",
                                "Correta identificação e visualização de subproblemas sobrepostos.",
                                "Implementação correta de memoização sem bugs.",
                                "Análise quantitativa clara com razões e gráficos.",
                                "Generalização para outros problemas de PD.",
                                "Compreensão conceitual demonstrada em explicação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências lineares e análise assintótica (O(φ^n) vs O(n)).",
                                "Estatística: Modelagem de complexidade computacional e redução de variância em simulações.",
                                "Economia: Otimização de recursos e análise custo-benefício em processos repetitivos.",
                                "Física: Simulações recursivas em sistemas dinâmicos (ex: fractais)."
                              ],
                              "realWorldApplication": "Em roteamento de redes (ex: Dijkstra com PD para caminhos ótimos), onde memoização evita recomputar sub-rotas em grafos grandes, reduzindo tempo de bilhões para milhões de operações em telecomunicações; ou em machine learning para computar probabilidades em árvores de decisão sem redundâncias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.2.3",
                            "name": "Exemplificar problemas com e sem sobreposições",
                            "description": "Classificar problemas como busca em grafos acíclicos (sem sobreposições) versus sequências ou cadeias (com sobreposições), relacionando à ementa de algoritmos em grafos e cadeias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Subproblemas Sobrepostos",
                                  "subSteps": [
                                    "Defina subproblemas sobrepostos como aqueles que são resolvidos múltiplas vezes em uma recursão padrão.",
                                    "Explique a diferença entre problemas com estrutura ótima e sobreposições usando diagramas de árvore de recursão.",
                                    "Compare com problemas sem sobreposições, onde cada subproblema é único.",
                                    "Estude a definição de Programação Dinâmica (DP) e seus requisitos: sobreposições e estrutura ótima.",
                                    "Revise exemplos clássicos como Fibonacci para sobreposições."
                                  ],
                                  "verification": "Crie um diagrama de árvore de recursão para Fibonacci mostrando overlaps e para um DAG sem overlaps.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Slides ou vídeo sobre DP (ex: YouTube - MIT OCW Algorithms), caderno para diagramas"
                                  ],
                                  "tips": "Use cores diferentes no diagrama para destacar subproblemas repetidos.",
                                  "learningObjective": "Diferenciar conceitualmente problemas com e sem subproblemas sobrepostos.",
                                  "commonMistakes": "Confundir sobreposições com dependências hierárquicas sem repetição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Problemas sem Sobreposições em Grafos Acíclicos (DAGs)",
                                  "subSteps": [
                                    "Identifique características de DAGs: ausência de ciclos, topological sort possível.",
                                    "Estude o problema de longest path in DAG como exemplo sem overlaps.",
                                    "Implemente uma solução bottom-up usando topological order.",
                                    "Desenhe o grafo e trace a computação para ver que cada nó é visitado uma vez.",
                                    "Compare com recursão top-down: sem memoização necessária."
                                  ],
                                  "verification": "Resolva um longest path in DAG manualmente e confirme ausência de subproblemas repetidos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Ferramenta de visualização de grafos (ex: Graphviz online), pseudocódigo de topological sort"
                                  ],
                                  "tips": "Comece com grafos pequenos (5-10 nós) para visualizar facilmente.",
                                  "learningObjective": "Reconhecer e exemplificar problemas sem sobreposições usando DAGs.",
                                  "commonMistakes": "Assumir overlaps em grafos acíclicos devido a caminhos múltiplos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Problemas com Sobreposições em Sequências e Cadeias",
                                  "subSteps": [
                                    "Analise Fibonacci e Longest Common Subsequence (LCS) como exemplos com overlaps.",
                                    "Estude Matrix Chain Multiplication e sua árvore de multiplicações com subproblemas repetidos.",
                                    "Implemente recursão ingênua e observe chamadas redundantes com memoização.",
                                    "Compare com cadeias: problemas lineares onde sub-sequências se sobrepõem.",
                                    "Crie uma tabela de DP para LCS ilustrando preenchimento com overlaps."
                                  ],
                                  "verification": "Conte o número de chamadas recursivas em Fibonacci sem memo vs. com memo.",
                                  "estimatedTime": "1 hora 15 minutos",
                                  "materials": [
                                    "Editor de código (ex: Python online como Replit), exemplos de LCS em strings"
                                  ],
                                  "tips": "Use print statements para logar chamadas recursivas e visualizar overlaps.",
                                  "learningObjective": "Identificar e exemplificar problemas com sobreposições em sequências e cadeias.",
                                  "commonMistakes": "Ignorar overlaps em problemas lineares como achar subsequências."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Classificar e Relacionar Problemas à Ementa de Algoritmos",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: coluna para problema, tipo (com/sem overlaps), relação com grafos/cadeias.",
                                    "Classifique 5 problemas novos: ex. shortest path in DAG (sem), knapsack (com).",
                                    "Relacione à ementa: grafos acíclicos vs. DP em sequências.",
                                    "Discuta quando usar memoização ou bottom-up puro.",
                                    "Pratique explicando a classificação oralmente ou por escrito."
                                  ],
                                  "verification": "Classifique corretamente 3 problemas dados e justifique com diagramas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de problemas de algoritmos (ex: LeetCode DP tag), tabela em Excel/Google Sheets"
                                  ],
                                  "tips": "Agrupe problemas por domínio: grafos vs. strings/arrays.",
                                  "learningObjective": "Classificar problemas e relacioná-los à ementa de algoritmos em grafos e cadeias.",
                                  "commonMistakes": "Classificar erroneamente problemas com dependências como overlaps."
                                }
                              ],
                              "practicalExample": "Classifique o problema 'Longest Increasing Subsequence (LIS)': tem sobreposições porque sub-sequências terminando em índices anteriores são reutilizadas múltiplas vezes em DP table. Contrastar com 'Longest Path in DAG': sem overlaps, cada nó computado uma vez via topological order.",
                              "finalVerifications": [
                                "Pode desenhar árvore de recursão destacando overlaps em Fibonacci?",
                                "Classifica corretamente longest path in DAG como sem overlaps?",
                                "Explica LCS com tabela DP mostrando reuso de subproblemas?",
                                "Compara 3 problemas com/sem overlaps usando tabela?",
                                "Justifica por que memoização é essencial só com overlaps?",
                                "Relaciona exemplos à ementa de grafos e cadeias?"
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de overlaps (90%+ acerto).",
                                "Exemplos relevantes: pelo menos 2 sem e 2 com overlaps bem justificados.",
                                "Visualizações claras: diagramas ou tabelas legíveis e corretos.",
                                "Classificação lógica: relaciona corretamente a grafos acíclicos vs. sequências.",
                                "Profundidade: discute implicações para escolha de abordagem DP.",
                                "Clareza na explicação: comunicação acionável e sem ambiguidades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências lineares e análise assintótica de T(n).",
                                "Ciência da Computação: Algoritmos em Grafos (topological sort) e Strings (LCS).",
                                "Engenharia de Software: Otimização de código com memoização.",
                                "Lógica e Raciocínio: Identificação de padrões em problemas NP.",
                                "Estatística: Modelagem de sequências probabilísticas com DP."
                              ],
                              "realWorldApplication": "Em bioinformática, LCS exemplifica alinhamento de sequências genéticas com overlaps para identificar similaridades evolutivas; em logística, longest path in DAG otimiza rotas acíclicas sem recomputação redundante em supply chains."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.1.3",
                        "name": "Armazenamento de Soluções Intermediárias",
                        "description": "Técnica de memoização ou tabelas bottom-up para guardar resultados de subproblemas, permitindo reutilização e transformando tempo exponencial em polinomial.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.1.3.1",
                            "name": "Implementar memoização top-down",
                            "description": "Usar um array ou mapa para armazenar resultados de subproblemas em uma função recursiva, verificando se já foi computado antes de recalcular.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a função recursiva e definir os subproblemas",
                                  "subSteps": [
                                    "Analise a função recursiva existente e identifique os parâmetros que representam os subproblemas (ex: índice ou tamanho).",
                                    "Defina o estado do subproblema com base nos parâmetros de entrada da recursão.",
                                    "Crie uma representação chave para o cache baseada nesses parâmetros (ex: tupla ou string concatenada).",
                                    "Inicialize mentalmente o cache com valores sentinelas (ex: -1 para indicar não computado).",
                                    "Documente os casos base da recursão para garantir que não sejam cacheados incorretamente."
                                  ],
                                  "verification": "Confirme que todos os subproblemas foram mapeados e que as chaves do cache cobrem todos os estados possíveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código fonte da função recursiva original",
                                    "Papel e caneta para diagrama de recursão"
                                  ],
                                  "tips": "Desenhe a árvore de recursão para visualizar chamadas duplicadas.",
                                  "learningObjective": "Compreender como os parâmetros definem estados únicos em recursão.",
                                  "commonMistakes": [
                                    "Ignorar parâmetros variáveis",
                                    "Confundir casos base com subproblemas computáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e inicializar a estrutura de cache",
                                  "subSteps": [
                                    "Decida entre array (para índices inteiros contíguos) ou Map/object (para chaves complexas).",
                                    "Defina o tamanho inicial do cache se usar array (ex: n+1 para problema de tamanho n).",
                                    "Inicialize o cache com valores padrão indicando 'não computado' (ex: null, -1 ou undefined).",
                                    "Posicione o cache como parâmetro da função ou variável externa para persistência entre chamadas.",
                                    "Teste a inicialização com um print ou log para verificar estrutura vazia."
                                  ],
                                  "verification": "Execute um teste simples para confirmar que o cache retorna o valor sentinel para chaves não vistas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Documentação de JavaScript/Python para Map/Array"
                                  ],
                                  "tips": "Use Map para flexibilidade em linguagens como JS; array para performance em índices numéricos.",
                                  "learningObjective": "Selecionar a estrutura de dados ótima para memoização baseada no problema.",
                                  "commonMistakes": [
                                    "Cache muito pequeno causando IndexError",
                                    "Usar objeto {} sem verificar propriedades undefined"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modificar a função para integrar verificação e armazenamento no cache",
                                  "subSteps": [
                                    "No início da função, gere a chave do subproblema e cheque se existe no cache.",
                                    "Se existir no cache, retorne o valor armazenado imediatamente.",
                                    "Se não existir, prossiga com a recursão, compute o resultado e armazene no cache com a chave.",
                                    "Retorne o resultado computado após armazenamento.",
                                    "Adicione logs opcionais para rastrear hits e misses no cache."
                                  ],
                                  "verification": "Simule chamadas recursivas manualmente para verificar se valores são reutilizados do cache.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código com debugger",
                                    "Console para logs"
                                  ],
                                  "tips": "Sempre cheque o cache ANTES de qualquer computação recursiva para evitar chamadas desnecessárias.",
                                  "learningObjective": "Implementar o padrão if-check-store-return corretamente.",
                                  "commonMistakes": [
                                    "Armazenar antes de checar",
                                    "Chaves inconsistentes entre check e store"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar a implementação e otimizar",
                                  "subSteps": [
                                    "Execute a função com entrada pequena e compare tempo/resultados com versão sem memo.",
                                    "Use debugger para inspecionar o cache populado após execução.",
                                    "Meça o número de chamadas recursivas (hits vs misses) com contadores.",
                                    "Teste casos edge: entradas zero, negativas, máximas.",
                                    "Otimize chaves ou estrutura se houver overhead excessivo."
                                  ],
                                  "verification": "Confirme redução drástica no tempo de execução (ex: de exponencial para linear).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramentas de profiling (ex: console.time em JS)",
                                    "Casos de teste pré-definidos"
                                  ],
                                  "tips": "Compare com versão bottom-up para validar corretude.",
                                  "learningObjective": "Validar eficiência e corretude da memoização.",
                                  "commonMistakes": [
                                    "Cache não persistindo entre chamadas",
                                    "Sobrecarga de cache maior que ganho"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente memoização top-down para calcular o n-ésimo número de Fibonacci. Função base: function fib(n) { if (n <= 1) return n; return fib(n-1) + fib(n-2); }. Com memo: use um Map com chave n, cheque se memo.has(n), senão compute e memo.set(n, result). Para n=40, tempo cai de segundos para milissegundos.",
                              "finalVerifications": [
                                "Cache contém todos os subproblemas computados sem duplicatas.",
                                "Função retorna mesmos resultados da recursão pura.",
                                "Tempo de execução é O(n) em vez de O(2^n).",
                                "Nenhum erro de recursão infinita ou stack overflow.",
                                "Casos base são tratados corretamente sem cache.",
                                "Cache é limpo ou resetável para múltiplas execuções."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Resultados idênticos à solução sem memo.",
                                "Eficiência: Redução comprovada no número de chamadas recursivas.",
                                "Estrutura de cache apropriada ao problema (array vs map).",
                                "Tratamento robusto de chaves e valores sentinel.",
                                "Código limpo com comentários explicando memo hits/misses.",
                                "Testes cobrindo edges e performance."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências e análise assintótica (O(n) vs O(φ^n)).",
                                "Ciência da Computação: Estruturas de dados (hash tables para cache).",
                                "Otimização: Princípios de caching em sistemas distribuídos.",
                                "Engenharia de Software: Refatoração para performance sem alterar lógica."
                              ],
                              "realWorldApplication": "Em APIs de recomendação (Netflix), memoização top-down evita recomputar similaridades de usuários em consultas recursivas; em jogos, cacheia caminhos em árvores de busca minimax para IA eficiente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.2",
                            "name": "Construir tabela bottom-up",
                            "description": "Preencher uma tabela de soluções em ordem iterativa, começando dos casos base e progredindo para o problema completo, como na soma de subconjuntos ou alinhamento de sequências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e inicializar os casos base",
                                  "subSteps": [
                                    "Analise o problema para determinar os subproblemas base, como dp[0][0] = true para soma de subconjuntos com soma 0.",
                                    "Crie a tabela de tamanho apropriado (ex: (n+1) x (target+1) para soma de subconjuntos).",
                                    "Inicialize todos os elementos com valores padrão (false ou 0).",
                                    "Preencha explicitamente os casos base, como a primeira linha/coluna.",
                                    "Teste manualmente com um subproblema mínimo para validar."
                                  ],
                                  "verification": "Casos base preenchidos corretamente e validados com cálculo manual em um exemplo pequeno.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código ou papel/caneta",
                                    "Exemplo de problema como soma de subconjuntos"
                                  ],
                                  "tips": "Use índices 0 para representar subproblemas vazios ou iniciais.",
                                  "learningObjective": "Compreender e aplicar os casos base como fundação da tabela bottom-up.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar a tabela inteira",
                                    "Índices incorretos nos casos base",
                                    "Não testar casos base isoladamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a recorrência e ordem iterativa",
                                  "subSteps": [
                                    "Escreva a fórmula de recorrência (ex: dp[i][s] = dp[i-1][s] || dp[i-1][s - nums[i-1]]).",
                                    "Determine a ordem de iteração: tipicamente for i de 1 a n, for s de 1 a target.",
                                    "Garanta que dependências sejam resolvidas antes (bottom-up garante isso).",
                                    "Anotar pseudocódigo para o loop duplo.",
                                    "Verifique dependências com um diagrama de setas na tabela."
                                  ],
                                  "verification": "Fórmula de recorrência escrita e ordem de iteração confirmada sem ciclos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel para diagrama de dependências",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Sempre itere do menor para o maior subproblema para evitar uso de valores não computados.",
                                  "learningObjective": "Definir recorrências que permitam preenchimento iterativo bottom-up.",
                                  "commonMistakes": [
                                    "Ordem de loop invertida causando uso de valores futuros",
                                    "Recorrência que referencia índices não preenchidos",
                                    "Confundir bottom-up com top-down"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o preenchimento iterativo da tabela",
                                  "subSteps": [
                                    "Implemente o loop externo sobre os itens (i de 1 a n).",
                                    "Dentro, loop interno sobre somas possíveis (s de 0 a target).",
                                    "Aplique a recorrência para cada célula, atualizando dp[i][s].",
                                    "Otimize espaço se possível (use array 1D para reduzir memória).",
                                    "Execute com dados de teste e imprima tabela intermediária para debug."
                                  ],
                                  "verification": "Tabela preenchida via código e impressa para inspeção visual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python/Java)",
                                    "Dados de teste como [1,3,4] target=5"
                                  ],
                                  "tips": "Imprima a tabela após cada iteração para visualizar o progresso.",
                                  "learningObjective": "Executar preenchimento bottom-up de forma eficiente e correta.",
                                  "commonMistakes": [
                                    "Off-by-one em loops",
                                    "Não otimizar espaço quando aplicável",
                                    "Sobrescrita incorreta em otimizações 1D"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair solução final e validar a tabela",
                                  "subSteps": [
                                    "Acesse a célula final (ex: dp[n][target] para soma de subconjuntos).",
                                    "Reconstrua a solução se necessário (backtracking da tabela).",
                                    "Compare com solução conhecida ou brute-force para casos pequenos.",
                                    "Meça tempo/espaço e compare com recursão ingênua.",
                                    "Documente a tabela final com explicação de valores chave."
                                  ],
                                  "verification": "Solução final correta e tabela validada contra múltiplos testes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código executável",
                                    "Casos de teste variados"
                                  ],
                                  "tips": "Sempre valide com input/output esperado antes de prosseguir.",
                                  "learningObjective": "Usar a tabela completa para obter e validar a solução ótima.",
                                  "commonMistakes": [
                                    "Acessar índice errado na solução final",
                                    "Ignorar reconstrução do caminho",
                                    "Não testar casos edge como target=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Soma de Subconjuntos com nums=[1,3,4], target=5. Tabela dp[i+1][s+1] (4x6):\nCasos base: dp[0][0]=true, resto false.\nRecorrência: dp[i][s] = dp[i-1][s] or (s>=nums[i-1] and dp[i-1][s-nums[i-1]]).\nApós preenchimento: dp[4][6]=true (subconjunto [1,4]).",
                              "finalVerifications": [
                                "Tabela preenchida completamente sem valores indefinidos.",
                                "Casos base corretos e propagados adequadamente.",
                                "Solução final bate com brute-force em exemplos pequenos.",
                                "Tempo/espaço otimizados (O(n*target)).",
                                "Backtracking reconstrói o caminho correto.",
                                "Testes edge (target=0, array vazio) funcionam."
                              ],
                              "assessmentCriteria": [
                                "Correção dos casos base (20%)",
                                "Recorrência e ordem iterativa precisas (25%)",
                                "Implementação do loop sem erros de índice (30%)",
                                "Validação e extração da solução (15%)",
                                "Otimização de espaço demonstrada (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução matemática e tabelas de recorrência.",
                                "Engenharia de Software: Otimização de algoritmos e depuração.",
                                "Ciência de Dados: Modelagem de otimização em machine learning.",
                                "Economia: Problemas de alocação ótima de recursos."
                              ],
                              "realWorldApplication": "Em logística, resolve o problema da mochila (knapsack) para maximizar valor de itens em um caminhão sem exceder peso, ou em bioinformática para alinhamento ótimo de sequências genéticas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.3",
                            "name": "Comparar abordagens top-down e bottom-up",
                            "description": "Avaliar trade-offs de espaço e tempo entre memoização (top-down, preguiçosa) e preenchimento tabular (bottom-up, eager), considerando referências bibliográficas como Cormen.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Abordagem Top-Down (Memoização Preguiçosa)",
                                  "subSteps": [
                                    "Revise o conceito de recursão com memoização: função recursiva que armazena resultados em um cache para evitar recomputações.",
                                    "Implemente memoização manualmente usando um dicionário ou array para armazenar subproblemas resolvidos.",
                                    "Analise o fluxo: computa apenas subproblemas necessários, 'preguiçoso' pois resolve sob demanda.",
                                    "Calcule complexidades: tempo O(n*k) onde k é o número de chamadas únicas, espaço O(n) para o cache + pilha de recursão.",
                                    "Teste com um exemplo simples como Fibonacci para observar o cache em ação."
                                  ],
                                  "verification": "Implemente código funcional de Fibonacci top-down e verifique se o número de chamadas recursivas é reduzido após memoização.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python), Livro 'Introduction to Algorithms' de Cormen (Capítulo 15), Notebook Jupyter.",
                                  "tips": "Use @lru_cache em Python para memoização automática e compare com versão sem cache.",
                                  "learningObjective": "Compreender como a memoização evita recomputações em recursão, identificando sua natureza preguiçosa.",
                                  "commonMistakes": "Confundir memoização com tabulação; esquecer de inicializar o cache corretamente levando a KeyError."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Abordagem Bottom-Up (Preenchimento Tabular Eager)",
                                  "subSteps": [
                                    "Revise iteração bottom-up: resolva subproblemas menores primeiro em ordem dependente, preenchendo uma tabela.",
                                    "Implemente preenchimento tabular iterativamente, usando loops para computar todos os subproblemas possíveis.",
                                    "Analise o fluxo: 'eager' pois computa tudo antecipadamente, independentemente de necessidade.",
                                    "Calcule complexidades: tempo O(n^2) ou similar para problemas DP padrão, espaço O(n^2) para tabela completa.",
                                    "Teste com o mesmo exemplo de Fibonacci, preenchendo array de baixo para cima."
                                  ],
                                  "verification": "Implemente código bottom-up para Fibonacci e confirme que a tabela é preenchida sequencialmente sem recursão.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python), Livro Cormen (Capítulo 15), Notebook Jupyter.",
                                  "tips": "Comece com índices base (ex: dp[0]=0, dp[1]=1) e construa para cima para evitar erros de dependência.",
                                  "learningObjective": "Dominar o preenchimento tabular iterativo e sua natureza eager em Programação Dinâmica.",
                                  "commonMistakes": "Usar ordem errada nos loops, causando dependências não resolvidas; alocar espaço desnecessário."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Trade-offs de Tempo e Espaço Entre as Abordagens",
                                  "subSteps": [
                                    "Compare tempo: top-down só computa necessários (potencialmente mais rápido se poucos subproblemas), bottom-up sempre todos.",
                                    "Compare espaço: top-down usa cache + pilha recursão (risco de stack overflow), bottom-up tabela fixa (pode otimizar para O(n)).",
                                    "Discuta cenários: top-down bom para grafos esparsos, bottom-up para densa dependência.",
                                    "Meça empiricamente: rode benchmarks em código para diferentes tamanhos de input.",
                                    "Considere overheads: recursão vs iteração (chamadas de função custosas)."
                                  ],
                                  "verification": "Crie tabela comparativa de Big-O tempo/espaço e benchmarks numéricos mostrando diferenças.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python com timeit module, planilha ou Markdown para tabela, Cormen para teoria.",
                                  "tips": "Otimize espaço bottom-up com variáveis scrolling para reduzir de O(n^2) para O(n).",
                                  "learningObjective": "Avaliar quantitativamente trade-offs de tempo e espaço das duas abordagens.",
                                  "commonMistakes": "Ignorar profundidade de recursão em top-down; assumir bottom-up sempre mais lento sem testes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Exemplos Práticos e Referências Bibliográficas",
                                  "subSteps": [
                                    "Aplique ambas abordagens a LCS (Longest Common Subsequence) e compare códigos.",
                                    "Referencie Cormen (Seções 15.3-15.4) para formalização matemática e provas.",
                                    "Discuta prós/contras: top-down flexível mas debug difícil; bottom-up previsível mas desperdício.",
                                    "Avalie reconstrução de solução: ambos suportam, mas bottom-up via tabela reversa.",
                                    "Sintetize em um relatório curto com diagramas de dependência."
                                  ],
                                  "verification": "Escreva um resumo de 1 página comparando as abordagens com código e referências.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro Cormen (físico/PDF), Draw.io para diagramas, código de LCS em Python.",
                                  "tips": "Use recursão com memo para top-down em LCS; loops duplos para bottom-up.",
                                  "learningObjective": "Integrar teoria e prática para uma comparação holística, ancorada em literatura.",
                                  "commonMistakes": "Citar referências sem ler; confundir LCS com edit distance sem alinhar subproblemas."
                                }
                              ],
                              "practicalExample": "No problema de Fibonacci(n), top-down memoiza chamadas recursivas F(n) = F(n-1) + F(n-2), computando apenas 2n entradas únicas. Bottom-up preenche dp[i] para i=0 a n, usando todas n+1 entradas. Para n=100, top-down evita explosão exponencial, mas pode stack overflow; bottom-up usa O(n) espaço fixo e é mais rápido em prática devido a menos overhead.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças entre preguiçosa e eager com exemplos.",
                                "Implementar ambas abordagens para um problema DP padrão sem erros.",
                                "Calcular e justificar Big-O tempo/espaço para um caso dado.",
                                "Identificar quando preferir uma sobre a outra baseado em input size.",
                                "Referenciar corretamente seções de Cormen sobre PD.",
                                "Benchmarkar e interpretar resultados empíricos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na distinção conceitual top-down vs bottom-up (80%+ correto).",
                                "Correção de implementações de código testadas (passa unit tests).",
                                "Análise quantitativa de trade-offs com cálculos Big-O exatos.",
                                "Uso apropriado de referências bibliográficas com citações.",
                                "Profundidade em trade-offs práticos (tempo real, espaço, debugabilidade).",
                                "Clareza na comunicação via relatório ou apresentação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de recorrências e complexidade assintótica (equações de recorrência).",
                                "Engenharia de Software: Otimização de performance e escolha de algoritmos em design de sistemas.",
                                "Ciência da Computação Geral: Grafos e caminhos ótimos (DAGs em PD).",
                                "Economia/Finanças: Otimização de portfólios via PD bottom-up em modelos dinâmicos."
                              ],
                              "realWorldApplication": "Em machine learning, top-down memoização é usada em recursão de árvores de decisão ou beam search; bottom-up em processamento de imagens (DP para visão computacional) ou jogos (AlphaGo-like pathfinding), onde trade-offs determinam escalabilidade em produção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.1.3.4",
                            "name": "Gerenciar espaço em tabelas de PD",
                            "description": "Otimizar o uso de memória em tabelas DP, identificando quando colunas ou linhas podem ser descartadas, como em problemas de cadeias de caracteres.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Consumo de Memória em Tabelas DP 2D Padrão",
                                  "subSteps": [
                                    "Revise um problema DP clássico como Fibonacci ou 0/1 Knapsack, implementando com tabela 2D completa.",
                                    "Calcule o espaço: para dimensões m x n, espaço é O(m*n) células, cada uma armazenando um valor inteiro.",
                                    "Trace dependências: observe que cada célula dp[i][j] depende apenas de dp[i-1][j], dp[i][j-1] e dp[i-1][j-1].",
                                    "Meça impacto: simule com strings longas para ver explosão de memória.",
                                    "Documente o preenchimento da tabela linha por linha."
                                  ],
                                  "verification": "Desenhe uma tabela 4x4 para um exemplo e anote o espaço total usado (ex: 16 inteiros).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e lápis, pseudocódigo de DP 2D, calculadora para O(n^2).",
                                  "tips": "Visualize a tabela como uma grade; pinte células usadas para destacar dependências.",
                                  "learningObjective": "Identificar o overhead de memória em implementações DP ingênuas.",
                                  "commonMistakes": "Confundir complexidade de tempo O(n^2) com espaço; assumir que toda tabela é sempre necessária."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Oportunidades de Otimização Espacial",
                                  "subSteps": [
                                    "Analise padrões de dependência: verifique se após preencher linha i, linhas anteriores a i-1 são obsoletas.",
                                    "Classifique problemas: em strings (LCS, Edit Distance), colunas podem ser descartadas se processadas sequencialmente.",
                                    "Desenhe fluxos: use setas para mostrar quais células sobrevivem após cada iteração.",
                                    "Liste critérios: otimização possível se dependência for apenas na linha/coluna anterior.",
                                    "Compare com casos não-otimizáveis: problemas que precisam de toda tabela (ex: alguns paths).",
                                    "Pratique com 2-3 exemplos de strings."
                                  ],
                                  "verification": "Para um problema dado, escreva uma lista de células acessíveis após 50% do preenchimento.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Exemplos de problemas DP (LCS, Fibonacci), ferramenta de desenho como Draw.io.",
                                  "tips": "Pense em 'janelas deslizantes': só mantenha o que a próxima iteração precisa.",
                                  "learningObjective": "Reconhecer quando reduzir de 2D para 1D sem perder corretude.",
                                  "commonMistakes": "Ignorar direção do preenchimento; otimizar prematuramente sem validar dependências."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Tabelas DP Otimizadas em 1D",
                                  "subSteps": [
                                    "Comece com duas arrays: prev[] e curr[], alternando a cada linha.",
                                    "Otimize para uma única array: atualize in-place da direita para esquerda em problemas de strings.",
                                    "Codifique para Edit Distance: reduza de O(m*n) para O(2*n) ou O(n).",
                                    "Teste com inputs variados: strings iguais, vazias, longas.",
                                    "Meça memória: use sys.getsizeof() em Python ou valgrind em C++.",
                                    "Refatore código original para versão otimizada."
                                  ],
                                  "verification": "Execute ambas versões; confirme outputs iguais e memória reduzida em pelo menos 50%.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "IDE (VS Code/PyCharm), linguagem Python ou C++, profiler de memória (memory_profiler).",
                                  "tips": "Atualize array da extremidade oposta para evitar sobrescrita de dados necessários.",
                                  "learningObjective": "Converter implementações 2D em 1D eficientes.",
                                  "commonMistakes": "Sobrescrever valores antes de usá-los; esquecer índices off-by-one."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Otimização em Problemas de Cadeias de Caracteres",
                                  "subSteps": [
                                    "Aplique em LCS: implemente full 2D e otimizada O(min(m,n)).",
                                    "Crie testes unitários para edge cases: strings vazias, idênticas, uma char.",
                                    "Compare performance: tempo e espaço com inputs n=1000.",
                                    "Analise trade-offs: perda de reconstrução de solução se precisar do path.",
                                    "Generalize: adapte para outro problema como Longest Palindromic Substring."
                                  ],
                                  "verification": "Relatório com métricas: memória original vs otimizada, % redução, corretude 100%.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código fonte, framework de testes (pytest/unittest), grandes datasets de strings.",
                                  "tips": "Use asserts para outputs; log memória em cada versão.",
                                  "learningObjective": "Aplicar e debugar otimizações em contextos reais de DP.",
                                  "commonMistakes": "Não testar grandes inputs; ignorar que algumas otimizações impedem reconstruir a solução."
                                }
                              ],
                              "practicalExample": "No problema de Distância de Edição entre 'kitten' e 'sitting': tabela 2D padrão usa O(7x7)=49 células. Otimize para array de tamanho 7 (comprimento da menor string), usando apenas prev e curr, reduzindo para O(14) ou O(7) células, economizando ~80% de memória sem alterar o resultado (distância=3).",
                              "finalVerifications": [
                                "Explica corretamente dependências que permitem descarte de linhas/colunas.",
                                "Implementa DP 1D funcional para Edit Distance ou LCS.",
                                "Demonstra redução de memória >50% em testes.",
                                "Identifica quando otimização não é viável (ex: precisa de toda tabela para path).",
                                "Aplica técnica em um novo problema de strings com sucesso.",
                                "Discute trade-offs como perda de reconstrução de solução."
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise de dependências (90%+ acurácia).",
                                "Corretude da implementação otimizada (100% testes passados).",
                                "Demonstração quantitativa de redução de memória.",
                                "Clareza na explicação de steps e justificativas.",
                                "Tratamento completo de edge cases e erros comuns.",
                                "Generalização para problemas similares."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estudo de recorrências lineares e análise assintótica O(1) espaço.",
                                "Ciência da Computação: Otimização de algoritmos e análise de complexidade.",
                                "Engenharia de Software: Gerenciamento de recursos em sistemas com constraints.",
                                "Análise de Dados: Otimização espacial em bioinformática (sequence alignment)."
                              ],
                              "realWorldApplication": "Em apps móveis ou dispositivos IoT com RAM limitada (ex: smartphones antigos), otimizar DP permite spell-checkers, autocorrect ou alignment de DNA em bioapps sem OutOfMemory errors, escalando para sequências longas em produção."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.2",
                    "name": "Subproblemas Sobrepostos",
                    "description": "Propriedade onde subproblemas se repetem em diferentes ramos da recursão, justificando o uso de memoização.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.2.1",
                        "name": "Definição de Subproblemas Sobrepostos",
                        "description": "Conceito fundamental que descreve a recorrência de subproblemas idênticos em diferentes chamadas recursivas, caracterizando uma propriedade essencial para a aplicação de programação dinâmica.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.1.1",
                            "name": "Definir subproblemas sobrepostos",
                            "description": "Explicar com precisão o que significa subproblemas sobrepostos, destacando que subproblemas idênticos são resolvidos múltiplas vezes em uma recursão ingênua.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Recursão Ingênua e Seus Problemas de Eficiência",
                                  "subSteps": [
                                    "Revise o conceito básico de recursão: uma função que chama a si mesma para resolver problemas menores.",
                                    "Implemente uma função recursiva simples, como cálculo de fatorial, e observe o número de chamadas.",
                                    "Meça o tempo de execução para entradas grandes e note a lentidão exponencial.",
                                    "Desenhe a árvore de recursão para visualizar chamadas repetidas.",
                                    "Compare com versão iterativa para destacar ineficiência."
                                  ],
                                  "verification": "Desenhe a árvore de recursão de um exemplo e calcule o número de chamadas leaf nodes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (Python ou JavaScript), papel e caneta para diagrama.",
                                  "tips": "Use print statements na função recursiva para rastrear chamadas.",
                                  "learningObjective": "Identificar ineficiências causadas por recomputações em recursão ingênua.",
                                  "commonMistakes": "Confundir recursão com iteração; ignorar o custo exponencial para n grande."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Subproblemas em Problemas Recursivos",
                                  "subSteps": [
                                    "Escolha um problema clássico como Fibonacci: defina fib(n) = fib(n-1) + fib(n-2).",
                                    "Liste todos os subproblemas únicos gerados pela recursão para fib(5).",
                                    "Marque subproblemas que aparecem mais de uma vez na árvore de recursão.",
                                    "Conte quantas vezes cada subproblema é resolvido.",
                                    "Registre o total de computações redundantes."
                                  ],
                                  "verification": "Crie uma tabela listando subproblemas e suas frequências de resolução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Caderno para árvore e tabela, calculadora para contagens.",
                                  "tips": "Comece com n pequeno (ex: 4 ou 5) para evitar complexidade.",
                                  "learningObjective": "Reconhecer subproblemas como instâncias menores do problema original.",
                                  "commonMistakes": "Listar apenas chamadas leaf; não diferenciar subproblemas idênticos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Sobreposição de Subproblemas",
                                  "subSteps": [
                                    "Defina 'sobrepostos' como subproblemas idênticos resolvidos múltiplas vezes.",
                                    "No exemplo Fibonacci, destaque fib(3) chamado de fib(5) e fib(4).",
                                    "Simule execução passo a passo, marcando recomputações com asteriscos.",
                                    "Calcule economia se cada subproblema fosse resolvido apenas uma vez.",
                                    "Compare árvores de recursão ingênua vs. memoizada."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que fib(3) é sobreposto em fib(5).",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramenta de visualização de recursão online (ex: Python Tutor).",
                                  "tips": "Use cores diferentes na árvore para sobreposições.",
                                  "learningObjective": "Diferenciar subproblemas independentes de sobrepostos.",
                                  "commonMistakes": "Confundir sobreposição com dependência hierárquica."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a Definição de Subproblemas Sobrepostos",
                                  "subSteps": [
                                    "Escreva uma definição precisa: 'Subproblemas sobrepostos ocorrem quando subproblemas idênticos são resolvidos múltiplas vezes em recursão ingênua.'",
                                    "Inclua critérios: 1) Subproblemas recorrentes; 2) Idênticos em parâmetros; 3) Recomputados independentemente.",
                                    "Aplique a definição a outro problema, como soma de subconjuntos.",
                                    "Discuta pré-requisito para Programação Dinâmica: sobreposição + estrutura ótima.",
                                    "Resuma em um fluxograma de detecção."
                                  ],
                                  "verification": "Redija uma definição de 1 parágrafo e valide com exemplo Fibonacci.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documento de texto para redação, fluxograma tool (ex: Draw.io).",
                                  "tips": "Use sinônimos como 'recomputados desnecessariamente' para clareza.",
                                  "learningObjective": "Articular definição precisa e aplicá-la a novos contextos.",
                                  "commonMistakes": "Definição vaga sem menção a 'idênticos' ou 'múltiplas vezes'."
                                }
                              ],
                              "practicalExample": "No cálculo recursivo ingênuo de Fibonacci(5), fib(3) é computado duas vezes: uma via fib(5)->fib(4)->fib(3) e outra via fib(5)->fib(3). Isso resulta em 8 chamadas totais ao invés de 5 únicas, exemplificando subproblemas sobrepostos.",
                              "finalVerifications": [
                                "Explica corretamente a definição de subproblemas sobrepostos em próprias palavras.",
                                "Identifica sobreposições na árvore de recursão de Fibonacci(6).",
                                "Distingue problemas com sobreposição (Fibonacci) de sem (Fatorial).",
                                "Calcula corretamente o número de recomputações em um exemplo dado.",
                                "Descreve como memoização resolve o problema.",
                                "Aplica conceito a um problema não-Fibonacci simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão da definição (inclui 'idênticos' e 'múltiplas resoluções') - 25%.",
                                "Uso de exemplos visuais (árvores/diagramas) - 20%.",
                                "Análise quantitativa de redundâncias - 20%.",
                                "Diferenciação de conceitos relacionados (ex: vs. subestrutura ótima) - 15%.",
                                "Clareza e concisão na explicação - 10%.",
                                "Aplicação a novos problemas - 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de recorrência e complexidade assintótica (O(2^n)).",
                                "Física: Modelagem de sistemas caóticos com recursão (ex: fractais).",
                                "Economia: Otimização de portfólios com subproblemas sobrepostos.",
                                "Engenharia de Software: Refatoração de código recursivo ineficiente."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, detectar subproblemas sobrepostos permite otimizar algoritmos recursivos com memoização ou DP, como em pathfinding em jogos (ex: Google Maps rotas) ou processamento de linguagem natural (ex: parsing de árvores sintáticas), reduzindo tempo de execução de horas para segundos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.2",
                            "name": "Comparar com subproblemas independentes",
                            "description": "Diferenciar subproblemas sobrepostos de subproblemas que não se repetem, usando exemplos simples como Fibonacci para ilustrar a distinção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender subproblemas em algoritmos recursivos",
                                  "subSteps": [
                                    "Defina recursão como um método onde uma função chama a si mesma para resolver subproblemas menores.",
                                    "Identifique subproblemas como instâncias menores do problema original resolvidas durante a execução recursiva.",
                                    "Desenhe uma árvore de recursão simples para um problema básico, como fatorial.",
                                    "Explique como subproblemas formam a base da recursão.",
                                    "Discuta a importância de analisar a estrutura dos subproblemas para otimização."
                                  ],
                                  "verification": "Desenhar e rotular corretamente a árvore de recursão de fatorial(5), identificando subproblemas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta como draw.io",
                                  "tips": "Use números pequenos para evitar complexidade visual.",
                                  "learningObjective": "Dominar a definição e visualização de subproblemas recursivos.",
                                  "commonMistakes": "Confundir subproblema com chamadas de função únicas, ignorando repetições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar subproblemas sobrepostos com exemplo Fibonacci",
                                  "subSteps": [
                                    "Implemente Fibonacci recursivo: fib(n) = fib(n-1) + fib(n-2).",
                                    "Execute fib(5) manualmente e trace todas as chamadas, destacando repetições como fib(3).",
                                    "Conte o número de chamadas para cada subproblema e observe overlaps.",
                                    "Desenhe a árvore de recursão de fib(5), marcando subproblemas repetidos.",
                                    "Calcule o tempo exponencial devido aos overlaps."
                                  ],
                                  "verification": "Traçar fib(5) mostrando pelo menos 3 subproblemas sobrepostos (ex: fib(3) chamado 2x).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (Python/JS), papel para árvore",
                                  "tips": "Implemente com print() para visualizar chamadas reais.",
                                  "learningObjective": "Reconhecer padrões de sobreposição em recursões ineficientes.",
                                  "commonMistakes": "Ignorar chamadas idênticas em ramos diferentes da árvore."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar subproblemas independentes com Merge Sort",
                                  "subSteps": [
                                    "Revise Merge Sort: divide array em metades, ordena recursivamente e mescla.",
                                    "Trace Merge Sort em um array pequeno [4,2,7,1], desenhando a árvore de divisão.",
                                    "Identifique subproblemas (ordenar subarrays) e verifique ausência de repetições.",
                                    "Compare contagem de subproblemas: cada um único.",
                                    "Calcule complexidade O(n log n) devido à independência."
                                  ],
                                  "verification": "Desenhar árvore de Merge Sort para [4,2,7,1] sem overlaps de subproblemas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de código, papel ou whiteboard virtual",
                                  "tips": "Foquem nas divisões: esquerda e direita nunca se repetem.",
                                  "learningObjective": "Identificar independência em algoritmos divide-and-conquer.",
                                  "commonMistakes": "Confundir mesclagem com sobreposição de subproblemas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e diferenciar os dois tipos de subproblemas",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: overlaps (Fibonacci) vs independentes (Merge Sort).",
                                    "Use critérios: repetição de subproblemas, complexidade, otimização necessária.",
                                    "Aplique a distinção a um novo problema (ex: Hanoi vs Busca Binária).",
                                    "Discuta quando usar PD (overlaps) vs Divide-and-Conquer (independentes).",
                                    "Resolva exercício: classifique subproblemas de 2 algoritmos dados."
                                  ],
                                  "verification": "Preencher tabela comparativa com 4 critérios corretos e 1 exemplo adicional.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha ou papel para tabela, exemplos de código",
                                  "tips": "Use setas na árvore para mostrar caminhos sobrepostos vs únicos.",
                                  "learningObjective": "Diferenciar precisamente e justificar com evidências visuais.",
                                  "commonMistakes": "Classificar erroneamente independência em problemas com overlaps leves."
                                }
                              ],
                              "practicalExample": "Implemente Fibonacci recursivo e conte chamadas para fib(6): observe fib(4) chamado 3 vezes (overlap). Compare com Merge Sort em array de 8 elementos: cada subarray ordenado é único, sem repetições.",
                              "finalVerifications": [
                                "Explicar com palavras próprias a diferença entre subproblemas sobrepostos e independentes.",
                                "Traçar árvore de recursão de Fibonacci(5) destacando 2+ overlaps.",
                                "Identificar independência em Merge Sort com diagrama correto.",
                                "Classificar corretamente 3 problemas exemplo (ex: Fibonacci=overlap, Merge Sort=independente, Fatorial=independente).",
                                "Propor otimização para overlap usando memoização.",
                                "Discutir impacto na complexidade temporal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de overlaps vs independência (90% acerto em exercícios).",
                                "Qualidade de diagramas de árvores de recursão (clareza e rotulagem).",
                                "Uso correto de exemplos como Fibonacci e Merge Sort.",
                                "Justificativa lógica na comparação (critérios explícitos).",
                                "Capacidade de aplicar a novos problemas sem erros.",
                                "Compreensão de implicações para PD e complexidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de recorrências e árvores de chamadas.",
                                "Análise de Algoritmos: Estudo de complexidade assintótica T(n).",
                                "Estruturas de Dados: Uso de tabelas/memoização para overlaps.",
                                "Lógica e Raciocínio: Padrões de divisão de problemas.",
                                "Programação: Implementação recursiva vs iterativa."
                              ],
                              "realWorldApplication": "Em roteamento de entregas (ex: Google Maps), sub-rotas sobrepostas entre destinos são computadas múltiplas vezes sem PD, causando lentidão; independentes em buscas locais otimizam eficiência em apps de logística."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.2.1.3",
                            "name": "Identificar características essenciais",
                            "description": "Listar e descrever as principais características dos subproblemas sobrepostos, como dependência de parâmetros iguais em ramos diferentes da árvore de recursão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Árvore de Recursão",
                                  "subSteps": [
                                    "Revise a definição de recursão e como ela forma uma árvore de chamadas.",
                                    "Desenhe a árvore de recursão para um problema simples como Fibonacci(n).",
                                    "Identifique os nós da árvore representando chamadas recursivas.",
                                    "Marque os parâmetros de entrada em cada nó.",
                                    "Observe os ramos que se ramificam de cada chamada."
                                  ],
                                  "verification": "A árvore desenhada mostra corretamente as chamadas recursivas com parâmetros anotados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; código de exemplo em Python para Fibonacci.",
                                  "tips": "Comece com n pequeno (ex: 5) para evitar árvores muito grandes.",
                                  "learningObjective": "Entender a estrutura visual da recursão como base para detectar sobreposições.",
                                  "commonMistakes": "Confundir profundidade da árvore com sobreposições; ignorar parâmetros exatos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Subproblemas Individuais",
                                  "subSteps": [
                                    "Defina o que é um subproblema: uma instância menor do problema original com parâmetros específicos.",
                                    "Liste todos os subproblemas únicos na árvore de recursão.",
                                    "Registre os parâmetros exatos (ex: fib(3), fib(2)) para cada um.",
                                    "Classifique subproblemas por seus parâmetros de estado.",
                                    "Compare subproblemas para notar potenciais duplicatas."
                                  ],
                                  "verification": "Lista completa de subproblemas com parâmetros únicos e potenciais duplicados anotados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Árvore de recursão do Step 1; planilha ou tabela para listar subproblemas.",
                                  "tips": "Use pares (índice, tamanho) ou similares para representar estados em problemas como mochila.",
                                  "learningObjective": "Reconhecer subproblemas como estados definidos por parâmetros.",
                                  "commonMistakes": "Considerar subproblemas apenas pelo valor computado, não pelos parâmetros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar Sobreposições de Subproblemas",
                                  "subSteps": [
                                    "Percorra a árvore e destaque nós com parâmetros idênticos em ramos diferentes.",
                                    "Conte quantas vezes cada subproblema é computado.",
                                    "Trace caminhos desde a raiz até esses nós duplicados.",
                                    "Anote dependências: como ramos independentes levam ao mesmo subproblema.",
                                    "Calcule o número total de chamadas vs. subproblemas únicos."
                                  ],
                                  "verification": "Mapa de sobreposições mostrando pelo menos 3 exemplos de parâmetros iguais em ramos distintos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Árvore anotada; contador de ocorrências por subproblema.",
                                  "tips": "Use cores diferentes para destacar duplicatas na árvore.",
                                  "learningObjective": "Identificar padrões de sobreposição como dependência de parâmetros iguais.",
                                  "commonMistakes": "Ignorar ordem dos parâmetros ou considerar variações mínimas como iguais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Listar e Descrever Características Essenciais",
                                  "subSteps": [
                                    "Compile uma lista das principais características: sobreposição de estados, computação redundante, independência de ramos.",
                                    "Descreva cada uma com exemplos da árvore analisada.",
                                    "Explique impacto: tempo exponencial devido a recomputações.",
                                    "Compare com problemas sem sobreposições (ex: recursão linear).",
                                    "Resuma em bullet points claros."
                                  ],
                                  "verification": "Lista de 4-6 características descritas com referências à árvore.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas dos steps anteriores; template de lista de características.",
                                  "tips": "Priorize características como 'parâmetros idênticos em ramos não-adjacentes'.",
                                  "learningObjective": "Articular verbalmente as propriedades chave de subproblemas sobrepostos.",
                                  "commonMistakes": "Listar características genéricas de recursão em vez de específicas de sobreposições."
                                }
                              ],
                              "practicalExample": "No problema de Fibonacci, fib(5) gera árvore com fib(3) aparecendo em ramos de fib(4) e fib(5) diretamente, computado múltiplas vezes com os mesmos parâmetros (n=3), exemplificando dependência de parâmetros iguais em ramos distintos.",
                              "finalVerifications": [
                                "Pode desenhar árvore de recursão e destacar sobreposições corretamente.",
                                "Lista pelo menos 4 características essenciais com descrições precisas.",
                                "Identifica dependências de parâmetros em exemplos como Fibonacci ou mochila.",
                                "Explica por que sobreposições causam ineficiência exponencial.",
                                "Diferencia subproblemas sobrepostos de problemas sem sobreposições.",
                                "Aplica detecção em um novo problema recursivo simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de parâmetros idênticos (90% de acerto).",
                                "Profundidade das descrições de características (detalhadas e contextualizadas).",
                                "Correção na árvore de recursão desenhada.",
                                "Quantidade e relevância de exemplos fornecidos.",
                                "Capacidade de explicar impacto na complexidade.",
                                "Clareza na lista final de características."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações de recorrência e sequências.",
                                "Análise de Algoritmos: Complexidade temporal e otimização.",
                                "Engenharia de Software: Memoização e caching em programação.",
                                "Estatística: Modelos probabilísticos com estados sobrepostos."
                              ],
                              "realWorldApplication": "Em otimização de rotas (ex: Google Maps com DP para caminhos curtos), detectar sobreposições permite memoização, reduzindo tempo de computação de horas para segundos em redes grandes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.2",
                        "name": "Detecção em Árvores de Recursão",
                        "description": "Processo de análise da árvore de recursão para visualizar e confirmar a presença de subproblemas sobrepostos em algoritmos recursivos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.2.1",
                            "name": "Construir árvore de recursão",
                            "description": "Desenhar a árvore de recursão completa para um problema clássico como Fibonacci ou soma de subconjuntos, destacando nós repetidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema recursivo e casos base",
                                  "subSteps": [
                                    "Escolha um problema clássico como Fibonacci: fib(n) = fib(n-1) + fib(n-2), com fib(0)=0 e fib(1)=1.",
                                    "Anote a definição recursiva exata, incluindo condições de parada (casos base).",
                                    "Liste todos os parâmetros de entrada, como n=5 para Fibonacci.",
                                    "Desenhe um esboço inicial da assinatura da função recursiva.",
                                    "Verifique se a recursão é bem definida, sem loops infinitos."
                                  ],
                                  "verification": "Confirme que os casos base estão corretamente identificados e anotados em um papel ou editor.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io/Lucidchart",
                                    "Referência do problema (ex: pseudocódigo de Fibonacci)"
                                  ],
                                  "tips": "Sempre comece pelos casos base para evitar confusão nas ramificações.",
                                  "learningObjective": "Compreender a estrutura recursiva fundamental e condições de término.",
                                  "commonMistakes": [
                                    "Esquecer casos base, levando a ramificações infinitas no desenho",
                                    "Confundir parâmetros de entrada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenhar o nó raiz e primeiras ramificações",
                                  "subSteps": [
                                    "Crie o nó raiz rotulado com o problema inicial, ex: fib(5).",
                                    "Desenhe as duas ramificações principais: fib(4) e fib(3).",
                                    "Rotule cada nó com o valor exato do subproblema.",
                                    "Use setas para indicar chamadas recursivas.",
                                    "Adicione valores computados se possível nos nós folha iniciais."
                                  ],
                                  "verification": "O nó raiz está conectado corretamente às duas chamadas filhos, com rótulos precisos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação",
                                    "Papel quadriculado para alinhamento"
                                  ],
                                  "tips": "Mantenha o diagrama hierárquico, com níveis representando profundidade recursiva.",
                                  "learningObjective": "Visualizar a primeira camada de decomposição recursiva.",
                                  "commonMistakes": [
                                    "Desenhar ramificações erradas, ex: fib(5) -> fib(5) em vez de fib(4)",
                                    "Falta de rótulos claros nos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expandir recursivamente todos os nós",
                                  "subSteps": [
                                    "Para cada nó não-folha, expanda em suas chamadas recursivas (ex: fib(4) -> fib(3) + fib(2)).",
                                    "Continue até atingir todos os casos base em todas as branches.",
                                    "Mantenha consistência no formato: nó -> (filho1, filho2).",
                                    "Numere os nós sequencialmente para rastreamento.",
                                    "Pausas periódicas para verificar simetria na árvore."
                                  ],
                                  "verification": "Todos os nós folia (casos base) estão presentes e sem ramificações pendentes.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação com zoom",
                                    "Cronômetro para gerenciar tempo"
                                  ],
                                  "tips": "Expanda breadth-first (nível por nível) para evitar erros de profundidade.",
                                  "learningObjective": "Construir a árvore completa, expondo a estrutura exponencial da recursão.",
                                  "commonMistakes": [
                                    "Parar prematuramente em branches",
                                    "Erro aritmético nos argumentos, ex: fib(3)->fib(2)+fib(1) errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e destacar nós repetidos (sobreposições)",
                                  "subSteps": [
                                    "Percorra a árvore e marque nós idênticos (ex: múltiplos fib(3)).",
                                    "Use cores ou símbolos para destacar sobreposições (ex: círculo vermelho).",
                                    "Conte o número de ocorrências de cada subproblema repetido.",
                                    "Adicione uma legenda explicando as marcações.",
                                    "Calcule o número total de nós para quantificar ineficiência."
                                  ],
                                  "verification": "Todos os nós sobrepostos estão marcados, com contagem precisa de duplicatas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Marcadores coloridos ou ferramenta com highlights"
                                  ],
                                  "tips": "Procure padrões simétricos em problemas como Fibonacci para agilizar.",
                                  "learningObjective": "Detectar subproblemas sobrepostos, justificando Programação Dinâmica.",
                                  "commonMistakes": [
                                    "Ignorar sobreposições sutis em problemas assimétricos",
                                    "Marcar nós errados como repetidos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar a árvore completa",
                                  "subSteps": [
                                    "Verifique se a soma dos valores folia reconstrói o resultado raiz (ex: fib(5)=5).",
                                    "Confira alinhamento e legibilidade do diagrama.",
                                    "Adicione anotações de custo computacional (número de folhas).",
                                    "Compare com uma referência conhecida para o problema.",
                                    "Documente insights sobre sobreposições."
                                  ],
                                  "verification": "O diagrama reconstrói o resultado correto e destaca todas as sobreposições.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Referência de solução conhecida",
                                    "Calculadora para verificação numérica"
                                  ],
                                  "tips": "Teste com n pequeno primeiro (ex: fib(3)) antes de escalar.",
                                  "learningObjective": "Garantir precisão e utilidade da árvore para análise.",
                                  "commonMistakes": [
                                    "Erro na propagação de valores das folhas para cima",
                                    "Diagrama ilegível por superlotação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Fibonacci fib(4): Nó raiz fib(4) → [fib(3), fib(2)]. fib(3) → [fib(2), fib(1)]. Segundo fib(2) → [fib(1), fib(0)]. Sobreposições: fib(2) aparece duas vezes, fib(1) três vezes. Árvore completa tem 15 nós, mas apenas 5 únicos, destacados em vermelho.",
                              "finalVerifications": [
                                "Árvore reconstrói o valor correto do problema original.",
                                "Todos os casos base estão presentes nas folhas.",
                                "Nós repetidos estão claramente destacados com contagem.",
                                "Diagrama é hierárquico e legível.",
                                "Número total de nós reflete crescimento exponencial.",
                                "Legenda explica marcações e convenções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição recursiva e ramificações (30%)",
                                "Completude da expansão até casos base (25%)",
                                "Identificação correta de todos os nós sobrepostos (20%)",
                                "Clareza visual e legibilidade do diagrama (15%)",
                                "Validação numérica e anotações de custo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de árvores e grafos binomial.",
                                "Visualização de Dados: Diagramação para análise de complexidade.",
                                "Lógica e Raciocínio: Detecção de padrões em estruturas repetitivas.",
                                "Design de Sistemas: Modelagem de dependências em software."
                              ],
                              "realWorldApplication": "Em otimização de algoritmos, como em sistemas de recomendação (Netflix) ou roteamento (GPS), onde árvores de recursão revelam sobreposições para aplicar memoização, reduzindo tempo de execução de exponencial para polinomial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.2",
                            "name": "Detectar padrões de sobreposição",
                            "description": "Analisar a árvore de recursão para identificar padrões onde subproblemas com os mesmos argumentos aparecem em ramos distintos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de recursão e árvores de recursão",
                                  "subSteps": [
                                    "Revise a definição de recursão: uma função que chama a si mesma com argumentos menores.",
                                    "Entenda a árvore de recursão: representação visual das chamadas recursivas como nós pai-filho.",
                                    "Identifique folhas (casos base) e nós internos (chamadas recursivas).",
                                    "Estude exemplos simples como fatorial ou soma de array recursiva.",
                                    "Diferencie recursão linear de recursão em árvore (múltiplas chamadas)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que é uma árvore de recursão e desenhe um exemplo simples de fatorial(4).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Documentação de recursão online (ex: GeeksforGeeks)"
                                  ],
                                  "tips": "Comece com exemplos lineares antes de árvores para fixar o conceito.",
                                  "learningObjective": "Dominar os termos e estrutura básica da recursão para análise posterior.",
                                  "commonMistakes": [
                                    "Confundir recursão com iteração",
                                    "Ignorar casos base nas folhas da árvore"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a árvore de recursão para um problema candidato a PD",
                                  "subSteps": [
                                    "Escolha um problema recursivo clássico com potencial sobreposição, como Fibonacci(n).",
                                    "Desenhe manualmente a raiz como fib(n) e expanda os filhos: fib(n-1) e fib(n-2).",
                                    "Continue expandindo até atingir os casos base (fib(0) e fib(1)).",
                                    "Anote os argumentos exatos em cada nó para rastreamento preciso.",
                                    "Use uma ferramenta digital se preferir para árvores maiores."
                                  ],
                                  "verification": "A árvore desenhada reproduz corretamente o número total de chamadas recursivas (verifique com código executado).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado ou ferramenta como draw.io",
                                    "Código fonte do problema em Python ou C++"
                                  ],
                                  "tips": "Limite a profundidade inicial (n=5 ou 6) para evitar árvores muito grandes.",
                                  "learningObjective": "Capacitar a visualização completa da execução recursiva.",
                                  "commonMistakes": [
                                    "Parar expansão prematuramente",
                                    "Erros nos argumentos dos filhos (ex: fib(n-1) vira fib(n+1) por distração)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a árvore para detectar padrões de sobreposição",
                                  "subSteps": [
                                    "Percorra a árvore de cima para baixo, listando todos os subproblemas únicos por argumentos.",
                                    "Marque nós com os mesmos argumentos em ramos distintos (ex: fib(3) aparece múltiplas vezes).",
                                    "Conte a frequência de cada subproblema repetido.",
                                    "Destaque ramos diferentes que compartilham o mesmo nó (não irmãos diretos).",
                                    "Registre o número total de subproblemas vs. únicos para quantificar sobreposição."
                                  ],
                                  "verification": "Liste pelo menos 3 subproblemas sobrepostos com suas posições na árvore.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Árvore impressa ou digital destacável",
                                    "Planilha para contar frequências (Google Sheets)"
                                  ],
                                  "tips": "Use cores diferentes para marcar ocorrências do mesmo subproblema.",
                                  "learningObjective": "Identificar visual e quantitativamente onde subproblemas se repetem.",
                                  "commonMistakes": [
                                    "Considerar irmãos como sobrepostos (são independentes)",
                                    "Ignorar variações sutis nos argumentos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar sobreposição e preparar para memoização",
                                  "subSteps": [
                                    "Compare o número de chamadas totais com o número de subproblemas únicos.",
                                    "Se frequência >1 para subproblemas em ramos distintos, confirme sobreposição.",
                                    "Discuta como memoização resolveria: armazene resultados em tabela por argumentos.",
                                    "Teste executando o código recursivo com contadores para validar a árvore.",
                                    "Documente o padrão para uso em PD."
                                  ],
                                  "verification": "Implemente um contador simples no código e confirme que matches a contagem da árvore.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code)",
                                    "Exemplo de código Fibonacci com prints de chamadas"
                                  ],
                                  "tips": "Adicione prints nos argumentos para simular a árvore em runtime.",
                                  "learningObjective": "Validar detecção e conectar à solução PD.",
                                  "commonMistakes": [
                                    "Confundir sobreposição com ordenação ótima",
                                    "Não distinguir ramos distintos"
                                  ]
                                }
                              ],
                              "practicalExample": "No cálculo de Fibonacci(5): fib(5) → fib(4)+fib(3) → ... fib(2) aparece em ramos de fib(4) e fib(3), fib(1) em múltiplos ramos. Sobreposição detectada: fib(3) chamado 2x, fib(2) 3x, fib(1) 3x em ramos distintos.",
                              "finalVerifications": [
                                "Desenha corretamente a árvore de recursão para Fibonacci(6).",
                                "Identifica todos os subproblemas sobrepostos com frequência >1.",
                                "Quantifica economia de PD (chamadas únicas vs. totais).",
                                "Explica por que irmãos não contam como sobrepostos.",
                                "Aplica detecção em um novo problema como 'binom(n,k)'."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da árvore (100% das chamadas corretas).",
                                "Identificação correta de pelo menos 80% dos padrões sobrepostos.",
                                "Explicação clara de ramos distintos vs. irmãos.",
                                "Quantificação quantitativa precisa (frequências exatas).",
                                "Conexão explícita à memoização/PD.",
                                "Tempo de análise eficiente sem erros comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de árvores e grafos direcionados.",
                                "Análise de Dados: Detecção de duplicatas e padrões repetitivos em datasets.",
                                "Inteligência Artificial: Otimização de buscas recursivas em árvores de decisão.",
                                "Engenharia de Software: Profiling e otimização de performance recursiva."
                              ],
                              "realWorldApplication": "Em algoritmos de roteamento GPS (ex: calcular caminhos ótimos em mapas), detectar sobreposições em sub-rotas recursivas permite usar PD para reduzir tempo de computação de horas para segundos em grandes grafos urbanos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.2.3",
                            "name": "Quantificar o grau de sobreposição",
                            "description": "Calcular o número de vezes que um subproblema específico é resolvido na recursão ingênua, comparando com o número de subproblemas únicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar e Traçar a Recursão Ingênua",
                                  "subSteps": [
                                    "Escreva o código da recursão ingênua para o problema (ex: Fibonacci).",
                                    "Execute o código com um valor pequeno de entrada (n=5) e use print statements para registrar todas as chamadas de função.",
                                    "Registre manualmente a sequência de chamadas em uma lista ou diagrama inicial.",
                                    "Identifique o padrão de chamadas repetidas observando os prints."
                                  ],
                                  "verification": "Verifique se o trace lista todas as chamadas corretamente e o resultado final bate com o esperado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (Python ou similar)",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use prints com indentação para visualizar a profundidade da recursão.",
                                  "learningObjective": "Compreender como a recursão ingênua gera múltiplas chamadas idênticas.",
                                  "commonMistakes": "Esquecer de imprimir argumentos das chamadas ou confundir chamadas pai-filho."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Árvore de Recursão Completa",
                                  "subSteps": [
                                    "Baseado no trace, desenhe a árvore de chamadas com nós representando subproblemas (ex: fib(k)).",
                                    "Marque cada nó com seu argumento e ramifique para chamadas filhas.",
                                    "Inclua folhas (casos base) e conte o número total de nós.",
                                    "Rotule nós duplicados com contadores iniciais.",
                                    "Valide a árvore executando o trace novamente e comparando."
                                  ],
                                  "verification": "A árvore deve reproduzir exatamente o trace de chamadas e o resultado final.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado ou ferramenta de diagramação (Draw.io, Lucidchart)"
                                  ],
                                  "tips": "Comece da raiz e expanda level por level para evitar erros de ramificação.",
                                  "learningObjective": "Visualizar graficamente a explosão exponencial de chamadas na recursão.",
                                  "commonMistakes": "Desenhar ramificações erradas ou esquecer chamadas simétricas (ex: fib(n-1) e fib(n-2))."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Subproblemas Únicos",
                                  "subSteps": [
                                    "Percorra a árvore e liste todos os subproblemas distintos pelo argumento (ex: fib(1), fib(2), etc.).",
                                    "Conte o número total de subproblemas únicos (tipicamente O(n) para problemas lineares).",
                                    "Crie uma tabela com colunas: Subproblema, Ocorrências Iniciais (1 por único).",
                                    "Verifique se todos os nós da árvore estão representados na lista.",
                                    "Atualize a tabela com frequência observada visualmente."
                                  ],
                                  "verification": "O número de únicos deve ser igual ao esperado para o problema (ex: n para fib(n)).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel"
                                  ],
                                  "tips": "Ordene a lista por tamanho do subproblema para facilitar contagem posterior.",
                                  "learningObjective": "Reconhecer que apesar de poucas instâncias únicas, há muitas redundâncias.",
                                  "commonMistakes": "Contar variantes como únicos (ex: confundir fib(2) de diferentes caminhos)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contar Ocorrências de um Subproblema Específico",
                                  "subSteps": [
                                    "Escolha um subproblema específico (ex: fib(2) em fib(5)).",
                                    "Conte manualmente todas as ocorrências desse subproblema na árvore inteira.",
                                    "Registre o número total de resoluções (nós com esse argumento).",
                                    "Compare com 1 (único) para medir sobreposição local.",
                                    "Repita para 2-3 subproblemas para validar consistência."
                                  ],
                                  "verification": "O contador deve coincidir com uma contagem manual dupla na árvore.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Árvore desenhada do Step 2",
                                    "Marcadores coloridos para destacar"
                                  ],
                                  "tips": "Use cores diferentes para marcar ocorrências e facilite a contagem.",
                                  "learningObjective": "Quantificar precisamente a redundância de um subproblema individual.",
                                  "commonMistakes": "Contar apenas folhas ou ignorar chamadas intermediárias."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Calcular e Interpretar o Grau de Sobreposição",
                                  "subSteps": [
                                    "Defina o grau como: vezes_resolvido_específico / 1 (para único) ou total_chamadas / num_unicos para global.",
                                    "Calcule o valor numérico (ex: fib(2) resolvido 3 vezes em fib(5)).",
                                    "Compare com número total de únicos (ex: 5 únicos, mas 15 chamadas totais).",
                                    "Interprete: alto grau indica bom candidato para memoização em PD.",
                                    "Documente em relatório com árvore, tabela e métricas."
                                  ],
                                  "verification": "Os cálculos devem ser exatos e a interpretação alinhada com teoria de PD.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora ou planilha para ratios"
                                  ],
                                  "tips": "Use fórmula: grau_local = ocorrências - 1 (sobreposições extras).",
                                  "learningObjective": "Avaliar quantitativamente quando PD otimiza recursão.",
                                  "commonMistakes": "Confundir grau local com global ou dividir incorretamente."
                                }
                              ],
                              "practicalExample": "No Fibonacci fib(5): Árvore tem 15 chamadas totais, 5 subproblemas únicos (fib(1) a fib(5)). Subproblema específico fib(2) é resolvido 3 vezes. Grau de sobreposição para fib(2): 3 (vs 1 único), indicando 200% de redundância local. Total: 15/5 = 3x sobreposição média.",
                              "finalVerifications": [
                                "Árvore de recursão desenhada corretamente reproduz o trace.",
                                "Lista de subproblemas únicos está completa e precisa.",
                                "Contagem de ocorrências para subproblema específico é exata.",
                                "Grau de sobreposição calculado numericamente com comparação aos únicos.",
                                "Interpretação justifica uso de Programação Dinâmica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da árvore (sem erros de ramificação).",
                                "Correção na identificação e contagem de subproblemas únicos.",
                                "Exatidão no cálculo de ocorrências e grau de sobreposição.",
                                "Clareza na visualização e documentação (diagramas legíveis).",
                                "Profundidade na interpretação de implicações para otimização.",
                                "Eficiência no tempo estimado sem sacrificar qualidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (árvores de chamadas como grafos direcionados).",
                                "Estatística: Análise de Frequências e Distribuição de Dados em Chamadas.",
                                "Engenharia de Software: Análise de Complexidade e Otimização de Código.",
                                "Lógica: Raciocínio Dedutivo em Contagens Recursivas."
                              ],
                              "realWorldApplication": "Em compiladores ou jogos (ex: paths em labirintos), quantificar sobreposição guia memoização, reduzindo tempo de execução de exponencial para linear, como em roteamento de redes ou processamento de linguagem natural."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.2.3",
                        "name": "Justificativa para Memoização",
                        "description": "Explicação de como a sobreposição de subproblemas motiva o uso de memoização para evitar recomputações desnecessárias em programação dinâmica.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.2.3.1",
                            "name": "Explicar benefícios da memoização",
                            "description": "Descrever como a memoização armazena resultados de subproblemas sobrepostos em uma tabela, reduzindo o tempo de exponencial para polinomial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Recursão Pura sem Memoização",
                                  "subSteps": [
                                    "Revise a definição de recursão em algoritmos de Programação Dinâmica.",
                                    "Analise um exemplo simples como Fibonacci recursivo.",
                                    "Calcule manualmente o número de chamadas para fib(5) e observe a duplicação.",
                                    "Meça o tempo de execução para valores maiores (ex: fib(40)) para ver o crescimento exponencial.",
                                    "Registre a complexidade temporal O(2^n)."
                                  ],
                                  "verification": "Construa uma árvore de recursão para fib(5) e confirme o número de chamadas (15 para fib(5)).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (Python ou JavaScript)",
                                    "Papel e caneta para diagrama",
                                    "Relógio para medir tempo"
                                  ],
                                  "tips": "Use print statements para contar chamadas recursivas.",
                                  "learningObjective": "Entender o custo computacional da recursão ingênua devido a recomputações.",
                                  "commonMistakes": [
                                    "Confundir recursão com iteração",
                                    "Ignorar o crescimento exponencial",
                                    "Não visualizar a árvore de chamadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Subproblemas Sobrepostos",
                                  "subSteps": [
                                    "Desenhe a árvore de recursão e destaque nós repetidos (ex: fib(3) chamado múltiplas vezes).",
                                    "Defina subproblema sobreposto como subproblemas resolvidos mais de uma vez.",
                                    "Compare com subproblemas ótimos (não repetidos).",
                                    "Liste subproblemas em uma tabela para Fibonacci: fib(0), fib(1), etc.",
                                    "Explique por que isso causa ineficiência."
                                  ],
                                  "verification": "Identifique pelo menos 3 subproblemas sobrepostos no diagrama de fib(6).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Diagrama de árvore impresso ou digital",
                                    "Planilha para tabela de subproblemas"
                                  ],
                                  "tips": "Use cores diferentes para destacar repetições na árvore.",
                                  "learningObjective": "Reconhecer padrões de sobreposição que justificam otimização.",
                                  "commonMistakes": [
                                    "Confundir sobrepostos com disjuntos",
                                    "Não quantificar repetições",
                                    "Aplicar a problemas sem sobreposição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar o Mecanismo da Memoização",
                                  "subSteps": [
                                    "Descreva memoização como cache de resultados em uma tabela/dicionário.",
                                    "Implemente uma tabela inicial vazia com chave = índice, valor = resultado.",
                                    "Modifique a recursão: antes de recursar, cheque se chave existe na tabela.",
                                    "Se existir, retorne o valor armazenado; senão, compute, armazene e retorne.",
                                    "Teste com fib(5) e observe que cada subproblema é computado apenas uma vez."
                                  ],
                                  "verification": "Implemente código memoizado e confirme que fib(40) executa em <1s vs. timeout sem memo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo de código base recursivo"
                                  ],
                                  "tips": "Use um dicionário com -1 como sentinel para não computados.",
                                  "learningObjective": "Dominar como memoização evita recomputações armazenando resultados.",
                                  "commonMistakes": [
                                    "Não inicializar tabela corretamente",
                                    "Chaves erradas no cache",
                                    "Esquecer de armazenar após computar"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Benefícios e Comparar Complexidades",
                                  "subSteps": [
                                    "Compare árvores: recursão pura (exponencial chamadas) vs. memoizada (linear chamadas).",
                                    "Calcule complexidades: sem memo O(2^n) → com memo O(n) tempo e O(n) espaço.",
                                    "Discuta benefícios: redução polinomial, escalabilidade para n grande.",
                                    "Meça empiricamente tempos para n=30,35,40.",
                                    "Resuma verbalmente: 'De exponencial para polinomial via reutilização.'"
                                  ],
                                  "verification": "Crie gráfico de tempo vs. n para ambas versões e explique a diferença.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca de plotagem (matplotlib ou similar)",
                                    "Dados de timing coletados"
                                  ],
                                  "tips": "Use @lru_cache em Python para teste rápido.",
                                  "learningObjective": "Quantificar ganhos da memoização em tempo e aplicabilidade.",
                                  "commonMistakes": [
                                    "Confundir tempo com espaço",
                                    "Ignorar overhead de cache",
                                    "Generalizar para todos problemas"
                                  ]
                                }
                              ],
                              "practicalExample": "Na sequência de Fibonacci, fib(5) sem memoização faz 15 chamadas; com memoização, apenas 5 chamadas únicas, armazenando fib(0)=0, fib(1)=1, fib(2)=1, fib(3)=2, fib(4)=3, fib(5)=5 em um dicionário, reduzindo tempo de minutos para milissegundos.",
                              "finalVerifications": [
                                "Explica corretamente subproblemas sobrepostos com exemplo.",
                                "Implementa memoização funcional em código.",
                                "Compara complexidades antes/depois com números precisos.",
                                "Identifica quando memoização é aplicável (sobrepostos presentes).",
                                "Descreve mecanismo de cache em palavras próprias.",
                                "Mediu empiricamente redução de tempo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de sobrepostos e complexidades.",
                                "Clareza na explicação verbal e visual (diagramas).",
                                "Correção no código implementado.",
                                "Quantificação de benefícios com evidências empíricas.",
                                "Distinção entre memoização top-down e bottom-up.",
                                "Generalização para outros problemas DP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e recorrências lineares.",
                                "Engenharia de Software: Técnicas de otimização e profiling.",
                                "Ciência de Dados: Caching em pipelines de ML para evitar recálculos.",
                                "Física Computacional: Simulações com subproblemas repetidos."
                              ],
                              "realWorldApplication": "Em servidores web como Netflix, memoização em APIs de recomendação evita recomputar similaridades de usuários; em browsers, caches de computação DOM reduzem latência; em finanças, otimiza cálculos de opções em árvores binomiais para trading em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.1.1",
                              "10.1.1.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.1.2.3.2",
                            "name": "Aplicar memoização em exemplo",
                            "description": "Implementar uma versão memoizada de um algoritmo recursivo com subproblemas sobrepostos, como Fibonacci, e comparar complexidades.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar Fibonacci Recursivo Puro",
                                  "subSteps": [
                                    "Escreva a função recursiva padrão para calcular o n-ésimo número de Fibonacci: fib(n) = fib(n-1) + fib(n-2), com casos base fib(0)=0 e fib(1)=1.",
                                    "Teste a função com valores pequenos (n=5, n=10) e observe os resultados.",
                                    "Meça o tempo de execução para n=30 e n=35 usando timeit ou similar.",
                                    "Desenhe a árvore de recursão manualmente para n=5 para visualizar chamadas repetidas.",
                                    "Registre o número de chamadas recursivas usando um contador global."
                                  ],
                                  "verification": "Função retorna valores corretos de Fibonacci e tempo de execução exponencial é observado (ex: >1s para n=35).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code), Python 3+, biblioteca timeit.",
                                  "tips": "Use print statements para contar chamadas recursivas inicialmente.",
                                  "learningObjective": "Compreender a ineficiência da recursão pura devido a subproblemas sobrepostos.",
                                  "commonMistakes": "Esquecer casos base levando a recursão infinita; não medir tempo corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Analisar Subproblemas Sobrepostos",
                                  "subSteps": [
                                    "Analise a árvore de recursão e destaque fib(k) calculado múltiplas vezes para o mesmo k.",
                                    "Calcule a complexidade temporal: O(2^n) para recursão pura.",
                                    "Liste todos os subproblemas únicos necessários para fib(n), que são apenas n+1 valores.",
                                    "Crie um diagrama mostrando sobreposições (use papel ou ferramenta como draw.io).",
                                    "Compare com complexidade ótima esperada: O(n) com memoização."
                                  ],
                                  "verification": "Diagrama completo com sobreposições marcadas e complexidades calculadas corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou draw.io, calculadora.",
                                  "tips": "Foque em fib(4) e fib(3) que são recalculados várias vezes.",
                                  "learningObjective": "Reconhecer padrões de subproblemas sobrepostos justificando memoização.",
                                  "commonMistakes": "Confundir sobreposições com subestruturas ótimas; errar contagem de subproblemas únicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Versão Memoizada",
                                  "subSteps": [
                                    "Crie um dicionário memo vazio como parâmetro ou global.",
                                    "Modifique a função: verifique se fib(n) está no memo; se sim, retorne; senão, calcule recursivamente e armazene.",
                                    "Teste com n=35 e compare tempo com versão pura.",
                                    "Otimize usando lru_cache do functools para validação.",
                                    "Adicione prints para mostrar acessos ao memo."
                                  ],
                                  "verification": "Código memoizado executa em <1ms para n=1000 e usa memo corretamente sem recalcular.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, Python 3+ com functools.",
                                  "tips": "Inicialize memo com {0:0, 1:1} para casos base.",
                                  "learningObjective": "Aplicar memoização para evitar recomputações desnecessárias.",
                                  "commonMistakes": "Não checar memo antes de recursão; chaves erradas no dicionário (use int como key)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Complexidades e Otimizações",
                                  "subSteps": [
                                    "Meça tempo e espaço para ambas versões com n=30,40,50 usando timeit e sys.getsizeof.",
                                    "Gere gráficos de tempo vs n usando matplotlib.",
                                    "Analise: recursivo O(2^n) tempo/espaço; memoizado O(n) tempo, O(n) espaço.",
                                    "Discuta trade-offs: memoização usa mais memória mas acelera drasticamente.",
                                    "Teste com input grande (n=1000) para demonstrar falha do recursivo."
                                  ],
                                  "verification": "Gráficos mostram speedup exponencial; análise escrita compara Big-O corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Python com matplotlib, timeit, sys.",
                                  "tips": "Rode testes em loop para médias precisas.",
                                  "learningObjective": "Quantificar ganhos da memoização em tempo e espaço.",
                                  "commonMistakes": "Ignorar overhead de recursão profunda (RecursionError); medir apenas um run."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Refatorar para Abordagem Bottom-Up (Opcional para Comparação)",
                                  "subSteps": [
                                    "Implemente DP bottom-up: array dp[0..n], preencha iterativamente.",
                                    "Compare tempo/espaço com top-down memoizado.",
                                    "Otimize espaço para O(1) usando duas variáveis.",
                                    "Teste equivalência de resultados.",
                                    "Documente quando usar cada abordagem."
                                  ],
                                  "verification": "Versão bottom-up matches memoizada e é mais eficiente em espaço.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código.",
                                  "tips": "Bottom-up evita recursão, bom para n muito grande.",
                                  "learningObjective": "Entender alternativas à memoização top-down.",
                                  "commonMistakes": "Erro em índices do array dp; não otimizar espaço."
                                }
                              ],
                              "practicalExample": "Em Python: def fib_memo(n, memo={}): if n in memo: return memo[n]; if n <= 1: return n; memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo); return memo[n]. Teste fib_memo(35) vs recursivo: speedup de segundos para microssegundos.",
                              "finalVerifications": [
                                "Código memoizado calcula fib(1000) instantaneamente sem erro.",
                                "Contador mostra zero recomputações de subproblemas memoizados.",
                                "Tempos medidos confirmam O(n) vs O(2^n).",
                                "Memo armazena exatamente n+1 entradas.",
                                "Gráficos de performance gerados e analisados.",
                                "Versão bottom-up implementada e comparada."
                              ],
                              "assessmentCriteria": [
                                "Correta identificação de subproblemas sobrepostos na árvore recursiva.",
                                "Implementação memoizada funcional sem vazamentos ou erros.",
                                "Análise quantitativa precisa de complexidades (Big-O).",
                                "Uso adequado de ferramentas de medição (timeit, profiling).",
                                "Documentação clara de comparações e trade-offs.",
                                "Código limpo, testado e com exemplos executáveis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências recursivas e análise assintótica.",
                                "Engenharia de Software: Otimização de performance e profiling.",
                                "Ciência de Dados: Caching em computação intensiva.",
                                "Física/Química: Simulações recursivas em modelagem molecular."
                              ],
                              "realWorldApplication": "Em aplicações web, memoização acelera APIs de cálculo (ex: rotas em mapas via Dijkstra memoizado); em finanças, otimiza cálculos de opções; em jogos, caching de estados em IA minimax; reduz tempo de computação em ML para feature engineering recursivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.2.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.3",
                    "name": "Subestrutura Ótima",
                    "description": "Princípio onde a solução ótima de um problema contém soluções ótimas de subproblemas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.3.1",
                        "name": "Definição de Subestrutura Ótima",
                        "description": "Princípio fundamental da programação dinâmica que estabelece que uma solução ótima para um problema global contém dentro dela soluções ótimas para subproblemas relevantes.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.1.1",
                            "name": "Enunciar a Definição Formal",
                            "description": "Articular com precisão a definição de subestrutura ótima, destacando que se uma solução ótima S para o problema P inclui soluções para subproblemas, então essas soluções devem ser ótimas para seus respectivos subproblemas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Subestrutura Ótima",
                                  "subSteps": [
                                    "Revise a definição básica de problema de otimização: um problema onde buscamos a melhor solução entre várias possíveis.",
                                    "Identifique o que significa 'solução ótima' para um problema P: a solução S que otimiza o critério (ex: mínimo custo, máximo valor).",
                                    "Diferencie problema principal P de subproblemas: subproblemas são instâncias menores de P derivadas de S.",
                                    "Leia exemplos clássicos como Fibonacci ou troca de moedas para visualizar subproblemas.",
                                    "Anote os elementos chave: solução ótima S, problema P, subproblemas e suas soluções ótimas."
                                  ],
                                  "verification": "Você pode listar 3 exemplos de problemas com subestrutura ótima e explicar por que eles se aplicam.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre Programação Dinâmica",
                                    "Exemplos de problemas: Fibonacci, Mochila 0/1"
                                  ],
                                  "tips": "Use diagramas para visualizar como S se decompõe em subproblemas.",
                                  "learningObjective": "Entender os blocos conceituais que compõem a definição formal.",
                                  "commonMistakes": "Confundir subestrutura ótima com sobreposição de subproblemas (que é para memoização)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dissecar a Definição Formal",
                                  "subSteps": [
                                    "Leia a definição exata: 'Uma solução ótima S para P contém soluções ótimas para subproblemas relevantes.'",
                                    "Destaque as palavras-chave: 'ótima', 'contém', 'subproblemas relevantes'.",
                                    "Explique cada parte: 'contém' significa que S inclui soluções para subproblemas; 'ótima para subproblemas' significa que não há melhor solução para eles.",
                                    "Compare com contraexemplos: problemas sem subestrutura ótima, como busca em grafo não-DAG.",
                                    "Reescreva a definição em suas próprias palavras, mantendo precisão."
                                  ],
                                  "verification": "Reescreva a definição sem consultar fontes e compare com a original (deve ter 90% de precisão).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Texto da definição formal de Cormen (CLRS) ou similar",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use cores para destacar termos obrigatórios na definição.",
                                  "learningObjective": "Identificar e explicar precisamente cada componente da definição.",
                                  "commonMistakes": "Omitir 'ótimas' para subproblemas, achando que qualquer solução serve."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar a Enunciação Verbal e Escrita",
                                  "subSteps": [
                                    "Enuncie a definição em voz alta 5 vezes, gravando áudio.",
                                    "Escreva a definição 3 vezes: uma formal, uma simplificada, uma com exemplo.",
                                    "Inclua o destaque obrigatório: 'se S é ótima para P, então soluções em S são ótimas para subproblemas'.",
                                    "Peça feedback a um par ou use autoavaliação com rubrica.",
                                    "Refine com base no feedback, ajustando clareza e precisão."
                                  ],
                                  "verification": "Gravação ou escrita mostra enunciação fluida e precisa sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gravador de voz ou app de notas",
                                    "Modelo de rubrica de avaliação"
                                  ],
                                  "tips": "Fale devagar, enfatizando 'ótimas para subproblemas' para fixar.",
                                  "learningObjective": "Articular a definição com fluência e precisão.",
                                  "commonMistakes": "Usar linguagem vaga como 'boa solução' em vez de 'ótima'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Reforçar com Exemplos",
                                  "subSteps": [
                                    "Aplique a definição a 2 problemas: prove subestrutura ótima enunciando formalmente.",
                                    "Identifique por que falha em um problema sem subestrutura ótima.",
                                    "Crie um fluxograma da definição: P → S ótima → subproblemas com soluções ótimas.",
                                    "Teste-se: cubra a definição e enuncie de memória.",
                                    "Discuta em fórum ou grupo para validar compreensão."
                                  ],
                                  "verification": "Prove corretamente subestrutura ótima em exemplos sem consultar notas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos: Coin Change, Longest Common Subsequence",
                                    "Ferramenta de fluxograma online (ex: Draw.io)"
                                  ],
                                  "tips": "Sempre volte à definição formal após exemplos para não desviar.",
                                  "learningObjective": "Aplicar e validar a enunciação em contextos reais.",
                                  "commonMistakes": "Generalizar demais, ignorando 'relevantes' subproblemas."
                                }
                              ],
                              "practicalExample": "No problema de troca de moedas ótima: a solução ótima S para trocar valor V usa moedas que formam soluções ótimas para valores menores (subproblemas V - c_i), pois qualquer troca subótima invalidaria S.",
                              "finalVerifications": [
                                "Enuncie a definição sem erros de memória.",
                                "Explique o porquê do destaque em 'soluções ótimas para subproblemas'.",
                                "Aplique a definição corretamente a um exemplo novo.",
                                "Diferencie de problemas sem subestrutura ótima.",
                                "Prove que sua enunciação é precisa comparando com fontes padrão."
                              ],
                              "assessmentCriteria": [
                                "Precisão lexical: usa termos exatos (ótima, contém, subproblemas).",
                                "Clareza: explicação lógica e sequencial.",
                                "Completude: inclui todos elementos da definição.",
                                "Fluência: enuncia sem hesitação ou pausas longas.",
                                "Aplicação: demonstra em exemplo concreto."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Otimização e Indução Matemática.",
                                "Lógica: Raciocínio Dedutivo e Provas por Contradição.",
                                "Filosofia: Definições Formais e Precisão Conceitual.",
                                "Economia: Otimização de Recursos e Custos Marginais."
                              ],
                              "realWorldApplication": "Em logística, otimizar rotas de entrega (problema do caixeiro-viajante aproximado) requer subestrutura ótima para sub-rotas, permitindo algoritmos dinâmicos eficientes em empresas como Amazon ou Uber."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.2",
                            "name": "Diferenciar de Outros Princípios",
                            "description": "Comparar subestrutura ótima com princípios de algoritmos gulosos e exaustivos, explicando por que ela é essencial para a viabilidade da programação dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceito de Subestrutura Ótima em Programação Dinâmica",
                                  "subSteps": [
                                    "Leia a definição formal de subestrutura ótima: soluções de subproblemas ótimos compõem a solução ótima global.",
                                    "Estude exemplos clássicos como Fibonacci e Knapsack 0/1.",
                                    "Anote as características chave: sobreposição de subproblemas e memoização.",
                                    "Identifique por que isso permite eficiência em PD vs. recursão pura.",
                                    "Desenhe um diagrama de dependências de subproblemas."
                                  ],
                                  "verification": "Crie um resumo de 1 parágrafo explicando subestrutura ótima com um exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre PD, pseudocódigo de Fibonacci PD, papel e caneta para diagramas.",
                                  "tips": "Use setas para mostrar como subproblemas se combinam na solução global.",
                                  "learningObjective": "Compreender a definição e exemplos de subestrutura ótima em PD.",
                                  "commonMistakes": "Confundir com optimalidade local como em greedy; sempre verificar composição global."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Princípios de Algoritmos Gulosos",
                                  "subSteps": [
                                    "Defina algoritmo guloso: escolha local ótima em cada passo esperando global ótima.",
                                    "Estude exemplos: seleção de atividades, fração ótima.",
                                    "Liste condições para corretude: propriedade gulosa e subestrutura ótima matroide.",
                                    "Compare superficialmente com PD: greedy não usa memoização.",
                                    "Teste um exemplo onde greedy falha (ex: Knapsack)."
                                  ],
                                  "verification": "Explique em voz alta por que greedy funciona em fração ótima mas falha em Knapsack.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Pseudocódigo de greedy para fração e Knapsack, timer para testes.",
                                  "tips": "Sempre pergunte: 'A escolha local garante global?'",
                                  "learningObjective": "Identificar quando e por quê algoritmos gulosos dependem de subestrutura específica.",
                                  "commonMistakes": "Assumir greedy sempre funciona; teste contra-exemplos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Algoritmos Exaustivos (Força Bruta)",
                                  "subSteps": [
                                    "Defina exaustivo: enumerar todas possibilidades e escolher a melhor.",
                                    "Examine complexidade: exponencial O(2^n) tipicamente.",
                                    "Compare com PD: PD otimiza reuso, exaustivo não.",
                                    "Use exemplo de Fibonacci recursivo puro como exaustivo.",
                                    "Calcule tempos para n=40 em ambos."
                                  ],
                                  "verification": "Calcule manualmente árvore de recursão para Fibonacci(5) e conte chamadas redundantes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora, tabela de Fibonacci, software para timing (opcional).",
                                  "tips": "Conte nós na árvore de recursão para visualizar explosão.",
                                  "learningObjective": "Reconhecer limitações de exaustivos e necessidade de otimização em PD.",
                                  "commonMistakes": "Subestimar redundâncias; sempre conte subproblemas repetidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Explicar Essencialidade da Subestrutura Ótima",
                                  "subSteps": [
                                    "Crie tabela comparativa: PD vs Greedy vs Exaustivo (subestrutura, complexidade, condições).",
                                    "Explique diferenças: PD requer subestrutura ótima + sobreposição; greedy requer matroide; exaustivo requer nada mas é lento.",
                                    "Discuta viabilidade PD: sem subestrutura ótima, PD colapsa para exaustivo ineficiente.",
                                    "Aplique a um problema: por que PD é viável para LCS mas não para TSP geral?",
                                    "Escreva parágrafo justificando essencialidade para eficiência polinomial."
                                  ],
                                  "verification": "Preencha tabela e explique oralmente uma diferença chave para cada par.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Planilha ou papel para tabela, exemplos de problemas (LCS, TSP).",
                                  "tips": "Use cores na tabela para destacar similaridades/diferenças.",
                                  "learningObjective": "Diferenciar princípios e argumentar por que subestrutura ótima habilita PD.",
                                  "commonMistakes": "Ignorar sobreposição; lembre que PD precisa de ambos optimal substructure e overlapping."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Diferenciação com Exercícios Integrados",
                                  "subSteps": [
                                    "Resolva quiz: classifique problemas como PD, greedy ou exaustivo justificado.",
                                    "Debata: 'PD é sempre melhor que greedy?' com contra-exemplos.",
                                    "Reescreva pseudocódigo greedy para PD onde falha.",
                                    "Autoavalie compreensão com flashcards de diferenças.",
                                    "Registre insights sobre viabilidade PD."
                                  ],
                                  "verification": "Acertar 90% em 10 perguntas de diferenciação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Quiz impresso ou online (Fibonacci, Knapsack, etc.), flashcards.",
                                  "tips": "Tempo limite por pergunta para simular exame.",
                                  "learningObjective": "Aplicar comparações em cenários variados.",
                                  "commonMistakes": "Forçar PD em problemas greedy; verifique condições primeiro."
                                }
                              ],
                              "practicalExample": "No problema de Knapsack 0/1, greedy (por peso ou valor) falha pois escolhas locais não compõem global ótima (sem subestrutura ótima para greedy). Exaustivo enumera 2^n subsets (lento). PD usa subestrutura ótima: dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i]), reaproveitando subproblemas para O(nW).",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave entre subestrutura ótima PD, greedy e exaustivo.",
                                "Classificar corretamente 5 problemas como PD-viável ou não, justificando.",
                                "Montar tabela comparativa precisa sem consulta.",
                                "Identificar por que falta de subestrutura ótima torna PD inviável em TSP.",
                                "Resolver Knapsack pequeno manualmente via PD vs tentativa greedy falha.",
                                "Discutir trade-offs de complexidade em exemplos reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de subestrutura ótima vs outros (90%+ acurácia).",
                                "Profundidade de exemplos e contra-exemplos fornecidos.",
                                "Clareza na explicação de essencialidade para viabilidade PD.",
                                "Uso correto de terminologia (sobreposição, matroide, exponencial).",
                                "Capacidade de tabela/diagrama comparativo lógico.",
                                "Aplicação prática em problemas padrão sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências e indução matemática para provar optimalidade.",
                                "Otimização: Teoria de programação linear/inteira e relaxações.",
                                "Ciência de Dados: Memoização em machine learning dinâmico (ex: Viterbi).",
                                "Economia: Otimização de recursos com restrições (Knapsack como alocação)."
                              ],
                              "realWorldApplication": "Em roteirização de veículos (VRP), subestrutura ótima permite PD para sub-rotas eficientes, evitando greedy (que ignora combinações globais) ou exaustivo (impraticável para frotas reais), economizando milhões em logística como Amazon ou UPS."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.3.1.3",
                            "name": "Ilustrar com Exemplo Simples",
                            "description": "Demonstrar o conceito usando o problema da sequência de Fibonacci, mostrando recursivamente como a solução ótima para Fib(n) depende das soluções ótimas para Fib(n-1) e Fib(n-2).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição Básica da Sequência de Fibonacci",
                                  "subSteps": [
                                    "Defina Fibonacci: F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) para n > 1.",
                                    "Calcule manualmente os primeiros termos: F(2), F(3), F(4), F(5).",
                                    "Escreva a fórmula recursiva em pseudocódigo.",
                                    "Discuta por que isso é um problema ótimo (menor soma de números naturais para representar n).",
                                    "Identifique que cada F(n) é a soma exata das soluções anteriores."
                                  ],
                                  "verification": "Liste corretamente F(0) a F(5) e recite a recursão sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto simples.",
                                  "tips": "Use uma tabela para visualizar os valores sequenciais.",
                                  "learningObjective": "Compreender a base recursiva da sequência de Fibonacci.",
                                  "commonMistakes": "Confundir F(0) com 1 ou inverter F(n-1) e F(n-2)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Representação Recursiva para Fib(n)",
                                  "subSteps": [
                                    "Escreva a função recursiva: fib(n) = fib(n-1) + fib(n-2).",
                                    "Escolha n=5 como exemplo e expanda: fib(5) = fib(4) + fib(3).",
                                    "Continue expandindo até as bases: fib(1) e fib(0).",
                                    "Desenhe uma árvore de chamadas recursivas mostrando todas as dependências.",
                                    "Conte os nós da árvore para ver computações redundantes."
                                  ],
                                  "verification": "Desenhe a árvore recursiva completa para fib(5) com valores corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado ou ferramenta de diagrama como Draw.io.",
                                  "tips": "Comece da raiz e ramifique para baixo, rotulando cada nó com o índice.",
                                  "learningObjective": "Visualizar a dependência recursiva de subproblemas.",
                                  "commonMistakes": "Esquecer ramificações ou calcular valores incorretos nas folhas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a Subestrutura Ótima na Recursão",
                                  "subSteps": [
                                    "Explique que a solução ótima para fib(5) usa soluções ótimas para fib(4) e fib(3).",
                                    "Mostre que fib(4) = fib(3) + fib(2), e assim por diante, formando uma cadeia.",
                                    "Destaque que soluções subótimas (erradas em fib(3)) invalidariam fib(5).",
                                    "Preencha os valores bottom-up na árvore para confirmar F(5)=5.",
                                    "Compare com uma abordagem não-ótima (ex: usar aproximações) para contrastar."
                                  ],
                                  "verification": "Explique em voz alta como fib(5) depende exclusivamente de sub-soluções corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Árvore do passo anterior e calculadora para verificação.",
                                  "tips": "Use setas para mostrar fluxo de dependência de baixo para cima.",
                                  "learningObjective": "Reconhecer que otimalidade é preservada recursivamente.",
                                  "commonMistakes": "Achar que subproblemas são independentes ou ignorar redundâncias."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e Ilustrar o Conceito de Subestrutura Ótima",
                                  "subSteps": [
                                    "Resuma: 'Solução ótima Fib(n) é composta unicamente de soluções ótimas Fib(n-1) e Fib(n-2)'.",
                                    "Crie um diagrama final destacando dependências ótimas.",
                                    "Teste com n=6 para generalizar: confirme F(6)=8.",
                                    "Discuta implicações para Programação Dinâmica (memoização resolve redundâncias).",
                                    "Escreva uma frase de definição personalizada do conceito."
                                  ],
                                  "verification": "Produza um diagrama anotado e recite a definição corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama do passo 3 e pseudocódigo.",
                                  "tips": "Use cores: verde para soluções ótimas, vermelho para potenciais erros.",
                                  "learningObjective": "Articular claramente a definição de subestrutura ótima via Fibonacci.",
                                  "commonMistakes": "Generalizar prematuramente sem verificar com múltiplos n."
                                }
                              ],
                              "practicalExample": "Para calcular o 6º número de Fibonacci (F(6)=8), note que ele depende de F(5)=5 e F(4)=3. F(5) por sua vez depende de F(4)=3 e F(3)=2, garantindo que se F(4) e F(3) forem ótimos, F(6) será ótimo. Desenhe: F(6) ← F(5) + F(4) ← (F(4)+F(3)) + F(4), destacando compartilhamento ótimo.",
                              "finalVerifications": [
                                "Desenha corretamente a árvore recursiva para Fib(5) com valores exatos.",
                                "Explica verbalmente a dependência ótima sem hesitação.",
                                "Calcula Fib(6) bottom-up usando sub-soluções.",
                                "Identifica pelo menos 3 redundâncias na árvore.",
                                "Define subestrutura ótima em próprias palavras.",
                                "Contrasta com um exemplo não-recursivo (soma direta)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos Fibonacci (100% correto).",
                                "Clareza visual na árvore/diagrama (rótulos legíveis).",
                                "Profundidade na explicação de dependências (cita recursão específica).",
                                "Generalização para n maior (testa Fib(6) ou Fib(7)).",
                                "Identificação de implicações para PD (menciona otimalidade preservada).",
                                "Criatividade no exemplo prático (usa diagrama ou analogia)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências recursivas e indução matemática.",
                                "Biologia: Modelagem de crescimento populacional (coelhos de Fibonacci).",
                                "Física: Ondas e padrões naturais recursivos.",
                                "Economia: Otimização de recursos em cadeias de dependência."
                              ],
                              "realWorldApplication": "Em otimização de rotas de entrega (problema do caixeiro-viajante), a rota ótima para n cidades depende de rotas ótimas para subconjuntos, similar a Fibonacci, permitindo soluções eficientes via Programação Dinâmica em logística real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.2",
                        "name": "Verificação de Subestrutura Ótima",
                        "description": "Processo de análise para determinar se um problema dado satisfaz o princípio de subestrutura ótima, incluindo provas e contraexemplos.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.2.1",
                            "name": "Identificar Características",
                            "description": "Reconhecer padrões em problemas que indicam subestrutura ótima, como recursões onde escolhas ótimas preservam otimalidade em subproblemas menores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição de Subestrutura Ótima",
                                  "subSteps": [
                                    "Leia a definição formal: uma solução ótima para o problema inclui soluções ótimas para subproblemas.",
                                    "Estude exemplos clássicos como Fibonacci e Mochila 0/1.",
                                    "Anote as propriedades chave: recursão e preservação de otimalidade.",
                                    "Compare com problemas sem subestrutura ótima, como busca exaustiva simples.",
                                    "Resuma em suas palavras o que significa 'preservar otimalidade'."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases explicando subestrutura ótima e cite 2 exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre PD, exemplos de Fibonacci e Mochila (impressos ou digitais)",
                                  "tips": "Use diagramas de árvore de recursão para visualizar a preservação.",
                                  "learningObjective": "Definir e exemplificar subestrutura ótima com precisão.",
                                  "commonMistakes": "Confundir com mera recursão sem otimalidade preservada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Padrões Característicos",
                                  "subSteps": [
                                    "Liste padrões: escolha ótima leva a subproblemas independentes e ótimos.",
                                    "Analise problemas conhecidos: verifique se o todo ótimo depende de partes ótimas.",
                                    "Crie uma checklist: (1) Divisível em subproblemas? (2) Escolha preserva otimalidade? (3) Sobreposição possível?",
                                    "Aplique checklist a 2-3 problemas simples.",
                                    "Destaque frases indicativas em descrições de problemas, como 'escolha ótima para o resto'."
                                  ],
                                  "verification": "Crie uma checklist pessoal e teste em um exemplo conhecido, justificando cada item.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Lista de problemas de PD (Fibonacci, Longest Common Subsequence), papel para checklist",
                                  "tips": "Procure por 'otimal' ou 'melhor' na descrição do problema.",
                                  "learningObjective": "Reconhecer 4-5 padrões verbais e estruturais de subestrutura ótima.",
                                  "commonMistakes": "Ignorar dependências entre subproblemas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar um Problema Desconhecido",
                                  "subSteps": [
                                    "Escolha um problema novo (ex: problema de corte de hastes).",
                                    "Divida em subproblemas potenciais.",
                                    "Teste se solução ótima do todo usa ótimas dos subs.",
                                    "Desenhe recursão e verifique preservação.",
                                    "Conclua se tem subestrutura ótima e justifique."
                                  ],
                                  "verification": "Produza um relatório curto (1 parágrafo) afirmando sim/não e razões.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Descrição de problema novo, software de desenho (opcional, como Draw.io)",
                                  "tips": "Comece assumindo subestrutura e tente refutar.",
                                  "learningObjective": "Aplicar análise sistemática a problemas inéditos.",
                                  "commonMistakes": "Assumir subestrutura sem testar preservação."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Refinar Identificação",
                                  "subSteps": [
                                    "Resolva 3-5 problemas variados usando sua checklist.",
                                    "Registre acertos/erros e padrões falsos positivos.",
                                    "Refine checklist com lições aprendidas.",
                                    "Discuta com pares ou simule explicação.",
                                    "Crie um problema próprio com subestrutura ótima."
                                  ],
                                  "verification": "Portfolio com análises de 3 problemas, incluindo 1 auto-criado.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Banco de problemas PD online (LeetCode, GeeksforGeeks), caderno de prática",
                                  "tips": "Tempo limite por problema para simular pressão.",
                                  "learningObjective": "Identificar com 80%+ de precisão em prática variada.",
                                  "commonMistakes": "Sobre-generalizar de poucos exemplos."
                                }
                              ],
                              "practicalExample": "No problema da Mochila 0/1: dada capacidade W e itens com pesos wi e valores vi, a solução ótima para W inclui solução ótima para W-wi se incluir item i, preservando otimalidade nos subproblemas menores.",
                              "finalVerifications": [
                                "Lista corretamente 4 padrões de subestrutura ótima.",
                                "Analisa com acerto um problema clássico como Fibonacci.",
                                "Identifica corretamente em 3/4 problemas de teste.",
                                "Justifica decisões com exemplos de recursão.",
                                "Cria checklist pessoal funcional.",
                                "Explica preservação de otimalidade sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação (90%+ em testes).",
                                "Justificativa detalhada com evidências recursivas.",
                                "Uso consistente de checklist ou padrões.",
                                "Capacidade de refutar falsos positivos.",
                                "Clareza na comunicação da análise.",
                                "Criatividade em exemplos auto-gerados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da recursão e indução matemática.",
                                "Otimização: Modelos lineares e inteiros em OR.",
                                "Ciência de Dados: Sobreposição em DP para ML pipelines.",
                                "Engenharia de Software: Design de algoritmos eficientes."
                              ],
                              "realWorldApplication": "Em logística, otimizar rotas de entrega onde escolha ótima de paradas preserva otimalidade em sub-rotas menores, reduzindo custos em empresas como Amazon ou Uber."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.2",
                            "name": "Provar Subestrutura Ótima",
                            "description": "Construir uma prova por contradição ou indução para um problema específico, assumindo uma solução ótima que usa subótimo e mostrando a contradição.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e a solução ótima",
                                  "subSteps": [
                                    "Escolha um problema específico de Programação Dinâmica com subestrutura ótima, como o problema da Mochila 0/1 ou Sequência Comum Mais Longa (LCS).",
                                    "Defina formalmente o que constitui uma solução ótima (OPT) para o problema inteiro.",
                                    "Descreva as subestruturas relevantes, como OPT para subproblemas menores.",
                                    "Escreva as recorrências ou equações que relacionam OPT com sub-OTPs.",
                                    "Verifique se o problema satisfaz as condições básicas de PD (sobreposição e subestrutura ótima)."
                                  ],
                                  "verification": "Confirme que a definição de OPT está clara e inclui condições de otimalidade mensuráveis (ex: soma máxima de valores).",
                                  "estimatedTime": "30-45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Pseudocódigo do problema",
                                    "Referência ao algoritmo PD do problema"
                                  ],
                                  "tips": "Comece com um problema familiar para evitar confusões na definição.",
                                  "learningObjective": "Compreender e formalizar o conceito de solução ótima e suas subestruturas.",
                                  "commonMistakes": [
                                    "Confundir solução ótima com solução factível.",
                                    "Ignorar as condições de fronteira do problema."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formular a hipótese de contradição",
                                  "subSteps": [
                                    "Assuma que existe uma solução ótima S* para o problema inteiro.",
                                    "Suponha que S* utiliza uma solução subótima S_sub para pelo menos um subproblema relevante.",
                                    "Defina quantitativamente o que significa 'subótima' (ex: valor de S_sub < OPT_sub).",
                                    "Especifique todas as premissas da suposição, incluindo o contexto do subproblema.",
                                    "Registre a hipótese em notação formal: 'Assuma ∃ S* ótima tal que usa S_sub subótima'."
                                  ],
                                  "verification": "A hipótese deve ser clara, negável e diretamente relacionada à subestrutura.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Definição do Step 1"
                                  ],
                                  "tips": "Use símbolos matemáticos para precisão: OPT(n) e subOPT(k).",
                                  "learningObjective": "Dominar a formulação precisa de uma hipótese por contradição.",
                                  "commonMistakes": [
                                    "Assumir contradição muito ampla.",
                                    "Esquecer de quantificar a subotimalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir uma solução alternativa usando subestruturas ótimas",
                                  "subSteps": [
                                    "Substitua a S_sub subótima na S* por uma OPT_sub conhecida.",
                                    "Calcule o valor/custo da nova solução S_alt.",
                                    "Mostre que S_alt satisfaz todas as restrições do problema.",
                                    "Prove que o valor de S_alt é estritamente melhor que S* ou pelo menos igual, mas preservando otimalidade.",
                                    "Verifique se S_alt é factível e compete com S*."
                                  ],
                                  "verification": "Demonstre matematicamente que valor(S_alt) > valor(S*) ou contradiz a otimalidade de S*.",
                                  "estimatedTime": "45-60 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Hipótese do Step 2",
                                    "Recorrências do problema"
                                  ],
                                  "tips": "Use desigualdades: valor(S_alt) = valor(S*) - (OPT_sub - S_sub) > valor(S*).",
                                  "learningObjective": "Construir argumentos construtivos que exploram a subestrutura ótima.",
                                  "commonMistakes": [
                                    "Violar restrições ao substituir.",
                                    "Erro em cálculos de valores comparativos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar a contradição e concluir a prova",
                                  "subSteps": [
                                    "Compare S_alt com S* para mostrar que S* não pode ser ótima (S_alt é melhor).",
                                    "Conclua que a hipótese é falsa: toda solução ótima deve usar apenas subestruturas ótimas.",
                                    "Discuta generalizações para indução, se aplicável (base + passo).",
                                    "Escreva a prova completa em parágrafos coesos.",
                                    "Teste a prova com um exemplo numérico pequeno."
                                  ],
                                  "verification": "A conclusão deve invalidar logicamente a hipótese inicial sem falácias.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "S_alt do Step 3"
                                  ],
                                  "tips": "Sempre termine com 'Portanto, por contradição...' para clareza.",
                                  "learningObjective": "Finalizar provas rigorosas e generalizáveis.",
                                  "commonMistakes": [
                                    "Pular a ligação explícita à contradição.",
                                    "Não testar com números."
                                  ]
                                }
                              ],
                              "practicalExample": "No problema da Mochila 0/1 com capacidade W e itens 1..n: Assuma OPT(W,n) usa OPT(W-w_i, i-1) subótima para algum i. Substitua por OPT verdadeira, mostrando que a nova solução tem valor maior, contradizendo a otimalidade. Exemplo numérico: W=5, itens [(2,3),(3,4),(4,5)]; prove para subproblema W=3.",
                              "finalVerifications": [
                                "A prova usa contradição ou indução corretamente sem falácias lógicas.",
                                "Todas as subestruturas são explicitamente definidas e quantificadas.",
                                "Exemplo numérico confirma a prova.",
                                "A conclusão afirma claramente que soluções ótimas usam subótimas.",
                                "A prova é concisa, mas completa (1-2 páginas).",
                                "Generalização para o algoritmo PD é mencionada."
                              ],
                              "assessmentCriteria": [
                                "Precisão lógica na hipótese e contradição (30%)",
                                "Correção matemática nas construções e comparações (25%)",
                                "Clareza e formalidade da redação (20%)",
                                "Uso efetivo de exemplo prático (15%)",
                                "Generalização e rigor (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por indução e contradição.",
                                "Lógica: Argumentação dedutiva e silogismos.",
                                "Física: Princípios de otimização em sistemas dinâmicos.",
                                "Economia: Otimização de recursos com restrições."
                              ],
                              "realWorldApplication": "Em design de algoritmos para roteamento de redes (ex: OSPF usa subestruturas ótimas), otimização de supply chain (mochila para alocação), ou machine learning (PD em HMMs para sequências ótimas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.1.3.2.3",
                            "name": "Analisar Contraexemplos",
                            "description": "Examinar problemas sem subestrutura ótima, como alguns algoritmos gulosos falhos, e explicar por que eles não se encaixam no princípio.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição de Subestrutura Ótima",
                                  "subSteps": [
                                    "Leia a definição formal de subestrutura ótima em programação dinâmica.",
                                    "Identifique os componentes chave: solução ótima do problema contém soluções ótimas dos subproblemas.",
                                    "Anote exemplos onde isso se aplica (ex: Knapsack 0/1)."
                                  ],
                                  "verification": "Escreva um resumo de 3-5 frases explicando subestrutura ótima e dê um exemplo positivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Algoritmos (ex: CLRS), caderno e caneta"
                                  ],
                                  "tips": "Use diagramas de recorrência para visualizar subproblemas.",
                                  "learningObjective": "Compreender precisamente o que constitui subestrutura ótima.",
                                  "commonMistakes": "Confundir com sobreposição de subproblemas; foque apenas em optimalidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar um Problema sem Subestrutura Ótima",
                                  "subSteps": [
                                    "Escolha um problema clássico onde algoritmos gulosos falham, como troco de moedas com denominações {1,4,6}.",
                                    "Defina o problema: minimizar número de moedas para valor alvo (ex: 8).",
                                    "Pesquise ou lembre por que guloso pode falhar aqui."
                                  ],
                                  "verification": "Descreva o problema e especifique as denominações e valor alvo em uma frase clara.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo de algoritmo guloso para troco, internet para exemplos"
                                  ],
                                  "tips": "Comece com problemas canônicos vs não-canônicos para contrastar.",
                                  "learningObjective": "Identificar candidatos a problemas sem subestrutura ótima.",
                                  "commonMistakes": "Escolher problemas que na verdade têm subestrutura ótima, como interval scheduling."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e Executar Contraexemplo com Algoritmo Guloso",
                                  "subSteps": [
                                    "Aplique o algoritmo guloso: sempre pegue a maior moeda possível.",
                                    "Para valor 8: guloso pega 6+1+1 (3 moedas).",
                                    "Encontre solução ótima manualmente: 4+4 (2 moedas)."
                                  ],
                                  "verification": "Registre as sequências de moedas gulosa e ótima, mostrando contagem diferente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou papel para simular execuções",
                                    "Tabela de troco"
                                  ],
                                  "tips": "Simule passo a passo, registrando escolhas em cada iteração.",
                                  "learningObjective": "Demonstrar falha prática do guloso via contraexemplo específico.",
                                  "commonMistakes": "Assumir guloso sempre falha; valide com múltiplos valores (ex: 6 ok, 8 falha)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a Violação de Subestrutura Ótima",
                                  "subSteps": [
                                    "Examine a solução gulosa: após pegar 6, subproblema de 2 é ótimo (1+1), mas global não.",
                                    "Na ótima (4+4), subproblema após primeiro 4 (4) é ótimo, mas guloso evitou isso.",
                                    "Explique: escolha gulosa local não preserva optimalidade global."
                                  ],
                                  "verification": "Escreva parágrafo explicando por que não há subestrutura ótima neste caso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama de árvore de decisões para escolhas de moedas"
                                  ],
                                  "tips": "Use setas para mostrar caminhos ótimos vs subótimos.",
                                  "learningObjective": "Explicar mecanicamente a violação usando o contraexemplo.",
                                  "commonMistakes": "Atribuir falha só a 'ganância'; foque na propriedade formal."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Generalizar e Comparar com Programação Dinâmica",
                                  "subSteps": [
                                    "Generalize: em problemas sem subestrutura ótima, PD ainda funciona mas é menos eficiente.",
                                    "Compare custo: guloso O(n), PD O(nV) para troco.",
                                    "Discuta quando testar essa propriedade."
                                  ],
                                  "verification": "Liste 2-3 problemas similares e prediga se têm subestrutura ótima.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de problemas de PD vs Guloso"
                                  ],
                                  "tips": "Relacione com condições de matroide para gulosos corretos.",
                                  "learningObjective": "Conectar análise a escolha de paradigma algorítmico.",
                                  "commonMistakes": "Ignorar que PD resolve mesmo sem essa propriedade, só é mais geral."
                                }
                              ],
                              "practicalExample": "No problema de troco com moedas {1,4,6} para valor 8: Algoritmo guloso pega 6+1+1 (3 moedas), mas ótimo é 4+4 (2 moedas). Isso viola subestrutura ótima porque a escolha gulosa de 6 leva a subproblema de 2 ótimo localmente, mas não globalmente.",
                              "finalVerifications": [
                                "Pode executar guloso e encontrar contraexemplo correto?",
                                "Explica violação em termos de subproblemas?",
                                "Identifica pelo menos 2 generalizações?",
                                "Compara com PD adequadamente?",
                                "Reproduz exemplo sem olhar notas?"
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa do contraexemplo (20%)",
                                "Análise da violação subestrutura ótima (30%)",
                                "Clareza na explicação escrita (20%)",
                                "Uso de diagramas/visuais (15%)",
                                "Generalizações e conexões (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização e teoria de grafos (árvores de decisão)",
                                "Lógica e Filosofia: Contraexemplos em provas matemáticas",
                                "Engenharia de Software: Validação de design de algoritmos",
                                "Economia: Problemas de otimização de recursos limitados"
                              ],
                              "realWorldApplication": "Em sistemas de pagamento ou finanças, analisar se um heurístico guloso (ex: maior nota primeiro) falha em cenários reais permite decidir por PD para garantia ótima, evitando perdas em automação de trocos ou alocação de recursos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.3.3",
                        "name": "Aplicação em Problemas Clássicos",
                        "description": "Exploração de como o princípio de subestrutura ótima se manifesta em problemas padrão de programação dinâmica, relacionando com grafos e cadeias.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.3.3.1",
                            "name": "Analisar em Cadeias de Caracteres",
                            "description": "Verificar subestrutura ótima no problema de subsequência comum mais longa (LCS), mostrando que a LCS ótima entre duas strings inclui LCS ótimas de prefixos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Problema LCS e a Solução por Programação Dinâmica",
                                  "subSteps": [
                                    "Defina o problema de Longest Common Subsequence (LCS) com exemplos simples.",
                                    "Construa a tabela DP básica para LCS de duas strings curtas (ex: 'AB' e 'AC').",
                                    "Explique a recorrência: se X[i]==Y[j], C[i][j] = C[i-1][j-1] + 1; senão max(C[i-1][j], C[i][j-1]).",
                                    "Preencha uma tabela 3x3 manualmente e trace a LCS.",
                                    "Identifique os subproblemas como prefixos das strings."
                                  ],
                                  "verification": "Construir corretamente a tabela DP para strings de tamanho 4 e recuperar a LCS.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Strings de exemplo impressas"
                                  ],
                                  "tips": "Sempre inicialize a primeira linha e coluna com 0 para prefixos vazios.",
                                  "learningObjective": "Dominar a construção da tabela DP para LCS e entender prefixos.",
                                  "commonMistakes": "Confundir subsequence com substring; esquecer de inicializar bordas da tabela."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Prefixos e LCS de Prefixos",
                                  "subSteps": [
                                    "Defina prefixo i de X como X[1..i] e similar para Y.",
                                    "Mostre que C[i][j] = comprimento da LCS ótima de prefixos i e j.",
                                    "Calcule LCS para todos os prefixos pares em uma tabela pequena.",
                                    "Verifique que valores em C[i][j] dependem apenas de valores menores (i-1,j-1 etc.).",
                                    "Discuta por que subproblemas são sobre prefixos menores."
                                  ],
                                  "verification": "Listar corretamente todos os LCS de prefixos para strings exemplo e seus comprimentos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para tabelas",
                                    "Strings exemplo"
                                  ],
                                  "tips": "Use notação C[i][j] consistentemente para evitar confusão com índices.",
                                  "learningObjective": "Entender que subproblemas são LCS de prefixos menores.",
                                  "commonMistakes": "Usar índices 0-based vs 1-based inconsistemente; ignorar casos vazios."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Recorrência para Propriedade de Subestrutura Ótima",
                                  "subSteps": [
                                    "Analise caso X[i]==Y[j]: prove que qualquer LCS ótima de prefixos i,j estende uma LCS ótima de i-1,j-1.",
                                    "Analise caso diferente: prove que LCS ótima usa max de LCS(i-1,j) ou LCS(i,j-1), que são ótimas por hipótese.",
                                    "Use indução: base (prefixos vazios), passo indutivo nos tamanhos.",
                                    "Escreva a prova formal para os dois casos.",
                                    "Verifique que não há LCS melhor que ignore sub-LCS ótimas."
                                  ],
                                  "verification": "Escrever prova curta (3-5 linhas por caso) mostrando subestrutura ótima.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha para anotações de prova",
                                    "Referência de indução matemática"
                                  ],
                                  "tips": "Pense em contraprova: suponha LCS melhor sem usar sub-ótima, derive contradição.",
                                  "learningObjective": "Provar que recorrência preserva otimalidade de subproblemas.",
                                  "commonMistakes": "Não tratar ambos os casos da recorrência; pular base da indução."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar com Exemplo e Generalizar",
                                  "subSteps": [
                                    "Aplique em exemplo: X='ABCBDAB', Y='BDCAB', construa tabela completa.",
                                    "Trace LCS='BCAB' e verifique sub-LCS em prefixos (ex: prefixo 4,3 tem LCS ótima 'BC').",
                                    "Confirme que todos subproblemas usados são ótimos.",
                                    "Generalize para qualquer strings: propriedade sempre vale pela recorrência.",
                                    "Teste com contraexemplo falho (ex: problema sem subestrutura ótima)."
                                  ],
                                  "verification": "Construir tabela para exemplo padrão e listar 3 sub-LCS ótimas usadas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Implementação Python opcional para LCS",
                                    "Exemplo impresso"
                                  ],
                                  "tips": "Backtrace da tabela para visualizar dependências de subproblemas.",
                                  "learningObjective": "Aplicar e validar propriedade em exemplo concreto.",
                                  "commonMistakes": "Erro no preenchimento da tabela; confundir LCS com alinhamento."
                                }
                              ],
                              "practicalExample": "Para X = 'ABCBDAB' (7 chars) e Y = 'BDCAB' (5 chars), a tabela DP tem C[7][5]=4 (LCS='BCAB'). Verifique: C[4][3] ('ABCB','BDC')=2 ('BC'), que é ótimo e usado na construção final, confirmando subestrutura ótima.",
                              "finalVerifications": [
                                "Constrói tabela DP correta para LCS de strings tamanho 10.",
                                "Explica e prova subestrutura ótima para casos iguais e diferentes.",
                                "Identifica sub-LCS ótimas em backtrace de exemplo complexo.",
                                "Aplica indução corretamente em prova escrita.",
                                "Distingue LCS de problemas sem subestrutura ótima (ex: 0-1 Knapsack variante).",
                                "Gera exemplo próprio validando propriedade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção e preenchimento da tabela DP (sem erros de recorrência).",
                                "Correção lógica da prova de subestrutura ótima (cobertura de casos e indução).",
                                "Profundidade na análise de exemplo (identificação explícita de subproblemas).",
                                "Clareza na explicação verbal ou escrita da propriedade.",
                                "Capacidade de generalizar para strings arbitrárias.",
                                "Detecção de erros comuns em implementações DP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Prova por indução em recorrências.",
                                "Biologia Computacional: Alinhamento de sequências genéticas via LCS.",
                                "Linguística Computacional: Similaridade semântica em textos.",
                                "Ciência da Computação: Otimização em edição de strings (Levenshtein)."
                              ],
                              "realWorldApplication": "Em bioinformática para comparar sequências de DNA/RNA identificando genes comuns; em controle de versão (Git diff) para detectar mudanças em código-fonte; em plágio detection comparando textos acadêmicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1",
                              "10.1.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.2",
                            "name": "Aplicar em Grafos",
                            "description": "Demonstrar subestrutura ótima em problemas como caminho mais curto (usando Bellman-Ford ou Floyd-Warshall), onde o caminho ótimo para um par de vértices inclui caminhos ótimos para subpares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Subestrutura Ótima em Grafos",
                                  "subSteps": [
                                    "Defina subestrutura ótima: o caminho ótimo entre u e v passa por caminhos ótimos entre pares intermediários.",
                                    "Estude grafos dirigidos ponderados e relaxação de arestas.",
                                    "Analise por que PD é ideal para problemas com sobreposições de subproblemas em grafos.",
                                    "Revise dependências: caminhos ótimos para distâncias menores constroem distâncias maiores.",
                                    "Desenhe um grafo simples com 4 vértices para visualizar."
                                  ],
                                  "verification": "Escreva uma definição clara e anote 3 exemplos onde subestrutura ótima se aplica em grafos.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Papel e caneta, Khan Academy vídeo sobre PD em grafos, pseudocódigo de Bellman-Ford.",
                                  "tips": "Use diagramas para visualizar recursão em grafos; comece com grafos acíclicos.",
                                  "learningObjective": "Identificar quando e por que subestrutura ótima permite PD em problemas de grafos.",
                                  "commonMistakes": "Confundir com estrutura ótima global; ignorar ciclos negativos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Bellman-Ford para Caminho Mais Curto",
                                  "subSteps": [
                                    "Inicialize distâncias: inf para todos exceto fonte (0).",
                                    "Execute |V|-1 iterações de relaxação em todas as arestas.",
                                    "Verifique ciclo negativo com iteração extra.",
                                    "Demonstre subestrutura: após k iterações, distâncias para caminhos de até k arestas são ótimas.",
                                    "Code em Python com grafo de exemplo (5 vértices, pesos mistos)."
                                  ],
                                  "verification": "Execute código em grafo com pesos negativos; confirme distâncias corretas sem ciclo negativo.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Editor de código (VS Code), Python, grafo exemplo em adjacência list.",
                                  "tips": "Use lista de arestas para relaxação simples; debugue imprimindo distâncias por iteração.",
                                  "learningObjective": "Implementar Bellman-Ford e provar sua subestrutura ótima iterativa.",
                                  "commonMistakes": "Esquecer inicialização ou limite de iterações; não tratar fonte corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Floyd-Warshall para Todos os Pares",
                                  "subSteps": [
                                    "Crie matriz de adjacência inicial (inf onde sem aresta).",
                                    "Para k de 1 a n: atualize dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]).",
                                    "Explique DP: dist[i][j] após k inclui vértice k como intermediário ótimo.",
                                    "Rastreie caminhos com matriz predecessora.",
                                    "Teste com grafo denso de 4x4 vértices."
                                  ],
                                  "verification": "Matriz final mostra todos caminhos ótimos; trace um caminho e confirme sub-otimalidade.",
                                  "estimatedTime": "2 horas",
                                  "materials": "Python ou C++, matriz 2D numpy, grafo exemplo com ciclos.",
                                  "tips": "O(n^3) é aceitável para n pequeno; visualize matriz evoluindo.",
                                  "learningObjective": "Dominar Floyd-Warshall e demonstrar subestrutura em todos pares via DP tabular.",
                                  "commonMistakes": "Índices off-by-one em loops; não inicializar diagonal como 0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Demonstrar e Aplicar Subestrutura Ótima",
                                  "subSteps": [
                                    "Escolha grafo exemplo: v1->v2(1), v2->v3(1), v1->v3(3).",
                                    "Aplique Bellman-Ford/Floyd: mostre caminho v1-v3 ótimo usa v1-v2 e v2-v3 ótimos.",
                                    "Generalize: prove por indução que relaxações constroem subestruturas.",
                                    "Resolva variante: grafo com pesos negativos sem ciclo.",
                                    "Documente em relatório com diagramas e código."
                                  ],
                                  "verification": "Relatório explica como ótimo global compõe sub-otimos; código roda corretamente.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": "Grafo desenhado, código dos steps anteriores, LaTeX ou Markdown para relatório.",
                                  "tips": "Use indução em comprimento de caminho; compare com greedy (Dijkstra falha em negativos).",
                                  "learningObjective": "Aplicar e provar subestrutura ótima em problemas clássicos de grafos.",
                                  "commonMistakes": "Não provar propriedade; usar algoritmo errado para pesos negativos."
                                }
                              ],
                              "practicalExample": "Considere grafo: v1->v2 (peso 2), v2->v3 (peso 3), v1->v3 (peso 6). Caminho ótimo v1-v3 é v1-v2-v3 (5), que usa sub-caminhos ótimos v1-v2 (2) e v2-v3 (3). Bellman-Ford itera: it1 relaxa v1-v2,v2-v3; it2 atualiza v1-v3 via v2.",
                              "finalVerifications": [
                                "Implementações de Bellman-Ford e Floyd-Warshall produzem distâncias corretas em grafos teste.",
                                "Relatório demonstra explicitamente subestrutura ótima com traçado de caminhos.",
                                "Código lida com pesos negativos sem ciclos detectados incorretamente.",
                                "Prova por indução ou tabela DP confirma composição de sub-otimos.",
                                "Testes com grafos variados (densos/esparsos) passam.",
                                "Tempo/espaço analisados corretamente (O(VE) Bellman, O(n^3) Floyd)."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: explica subestrutura ótima corretamente (30%).",
                                "Implementação funcional: códigos rodam sem erros (25%).",
                                "Demonstração prática: exemplo mostra composição de sub-caminhos (20%).",
                                "Análise de complexidade e limitações (15%).",
                                "Clareza do relatório/diagramas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Otimização Linear.",
                                "Ciência da Computação: Estruturas de Dados (matrizes, listas).",
                                "Engenharia: Otimização de Rotas em Redes (GPS, telecom).",
                                "Inteligência Artificial: Busca em Espaços de Estados com Heurísticas.",
                                "Economia: Problemas de Alocação Ótima em Redes."
                              ],
                              "realWorldApplication": "Em GPS (Google Maps), Bellman-Ford variações computam rotas ótimas considerando tráfego (pesos dinâmicos), onde rotas parciais ótimas compõem a rota global; em redes de computadores, Floyd-Warshall otimiza tabelas de roteamento para todos os pares de switches."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.1.3.3.3",
                            "name": "Relacionar com Sobreposição",
                            "description": "Explicar a interdependência com o princípio de sobreposição de subproblemas, preparando o terreno para a tabela de programação dinâmica completa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Conceito de Subestrutura Ótima",
                                  "subSteps": [
                                    "Defina subestrutura ótima como a propriedade onde a solução ótima de um problema pode ser construída a partir de soluções ótimas de seus subproblemas.",
                                    "Analise um exemplo simples, como o problema da mochila, identificando como a solução ótima total depende de subproblemas.",
                                    "Desenhe um diagrama recursivo mostrando a decomposição do problema em subproblemas.",
                                    "Compare com problemas sem subestrutura ótima, como busca linear.",
                                    "Liste as condições necessárias para que um problema exiba subestrutura ótima."
                                  ],
                                  "verification": "Crie um diagrama de decomposição para um problema clássico e explique verbalmente como ele demonstra subestrutura ótima.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io; notas de aula sobre PD.",
                                  "tips": "Use setas no diagrama para mostrar dependências entre subproblemas.",
                                  "learningObjective": "Compreender e visualizar a subestrutura ótima como base para PD.",
                                  "commonMistakes": "Confundir subestrutura ótima com mera recursão sem otimalidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar o Princípio de Sobreposição de Subproblemas",
                                  "subSteps": [
                                    "Defina sobreposição como a recorrência de subproblemas idênticos em diferentes ramos da recursão.",
                                    "Examine o problema de Fibonacci, contando quantas vezes cada subproblema Fib(n-1) é computado na recursão ingênua.",
                                    "Implemente uma recursão simples em pseudocódigo e trace as chamadas para visualizar sobreposições.",
                                    "Calcule o tempo exponencial causado pela sobreposição não memorizada.",
                                    "Discuta por que problemas lineares não exibem sobreposição significativa."
                                  ],
                                  "verification": "Trace a árvore de recursão de Fib(5) e destaque subproblemas repetidos em uma tabela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Pseudocódigo ou editor de código simples; calculadora para contagem de chamadas.",
                                  "tips": "Marque subproblemas repetidos com a mesma cor para facilitar a visualização.",
                                  "learningObjective": "Identificar e quantificar sobreposições em recursões.",
                                  "commonMistakes": "Ignorar que sobreposição requer subproblemas idênticos, não apenas semelhantes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Interdependência entre Subestrutura Ótima e Sobreposição",
                                  "subSteps": [
                                    "Explique que subestrutura ótima permite decompor, mas sem sobreposição, memoização não é eficiente.",
                                    "Use uma tabela comparativa: coluna para subestrutura ótima, sobreposição, e impacto na PD.",
                                    "Discuta como ambos são necessários para justificar o preenchimento bottom-up de uma tabela DP.",
                                    "Analise um problema clássico como LCS (Longest Common Subsequence) destacando ambos os princípios.",
                                    "Crie um fluxograma mostrando o ciclo: decomposição (subestrutura) → repetição (sobreposição) → tabela DP."
                                  ],
                                  "verification": "Preencha uma tabela comparativa para dois problemas (um com ambos, um sem) e justifique.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou papel para tabelas; exemplos de problemas PD como LCS ou Fib.",
                                  "tips": "Sempre pergunte: 'Os subproblemas se repetem?' e 'A solução ótima se constrói deles?'",
                                  "learningObjective": "Articular como os dois princípios se complementam para viabilizar PD.",
                                  "commonMistakes": "Tratar os princípios como independentes, ignorando que PD requer ambos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preparar o Terreno para Construção da Tabela de Programação Dinâmica",
                                  "subSteps": [
                                    "Desenhe uma tabela DP vazia para um problema clássico, identificando dimensões baseadas em subproblemas.",
                                    "Preencha células iniciais usando casos base, ligando à subestrutura ótima.",
                                    "Simule preenchimento, reutilizando células para demonstrar eficiência da sobreposição.",
                                    "Compare tempo/recursão ingênua vs. tabela DP.",
                                    "Discuta transição para implementação bottom-up ou top-down com memoização."
                                  ],
                                  "verification": "Construa e preencha uma tabela DP 4x4 para LCS e calcule o tempo salvo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Papel quadriculado ou Excel para tabela; pseudocódigo de PD.",
                                  "tips": "Comece sempre pelos casos base para evitar erros de dependência.",
                                  "learningObjective": "Conectar os princípios à estrutura prática da tabela DP.",
                                  "commonMistakes": "Preencher tabela sem verificar dependências de subproblemas menores."
                                }
                              ],
                              "practicalExample": "No problema de Fibonacci, a subestrutura ótima permite Fib(n) = Fib(n-1) + Fib(n-2), mas a sobreposição faz Fib(3) ser computado múltiplas vezes. Com PD, criamos uma tabela [Fib(0)=0, Fib(1)=1, ..., Fib(n)], preenchendo sequencialmente para evitar recomputações.",
                              "finalVerifications": [
                                "Explique verbalmente a interdependência dos dois princípios em um problema clássico.",
                                "Desenhe uma tabela DP parcial e identifique onde sobreposição é explorada.",
                                "Compare um problema com PD vs. sem, justificando a escolha.",
                                "Trace recursão e mostre reduções de tempo com tabela.",
                                "Crie um fluxograma ligando subestrutura, sobreposição e tabela DP.",
                                "Responda a perguntas como: 'Por que PD falha sem um dos princípios?'"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e distinção dos princípios (80% acerto).",
                                "Clareza na explicação da interdependência com exemplos visuais.",
                                "Capacidade de construir tabela DP correta para problema dado.",
                                "Identificação correta de sobreposições em árvores recursivas.",
                                "Justificativa quantitativa de eficiência (ex: O(2^n) vs O(n^2)).",
                                "Uso apropriado de diagramas e tabelas para suporte."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações de recorrência e análise assintótica.",
                                "Lógica e Filosofia: Estruturas hierárquicas e dependências causais.",
                                "Economia: Otimização de recursos em problemas de alocação.",
                                "Engenharia de Software: Memoização e caching em design de algoritmos."
                              ],
                              "realWorldApplication": "Em planejamento de rotas de entrega (como TSP aproximado), subestrutura ótima decompõe rotas em sub-rotas, enquanto sobreposição reutiliza cálculos de distâncias parciais via tabela DP, otimizando logística em empresas como Amazon ou Uber."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.4",
                    "name": "Princípio da Otimalidade de Bellman",
                    "description": "Formalização matemática que garante a validade da combinação de soluções ótimas de subproblemas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.4.1",
                        "name": "Definição Intuitiva do Princípio de Otimalidade de Bellman",
                        "description": "Compreensão conceitual básica do princípio que afirma que uma solução ótima para o problema global contém soluções ótimas para subproblemas associados.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.1.1",
                            "name": "Descrever o princípio de Bellman em termos simples",
                            "description": "Explicar verbalmente que, em problemas que satisfazem o princípio, toda solução ótima do problema principal inclui soluções ótimas de seus subproblemas, permitindo a construção bottom-up de soluções.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender problemas de otimização e suas soluções ótimas",
                                  "subSteps": [
                                    "Defina o que é um problema de otimização: encontrar a melhor solução entre muitas opções possíveis.",
                                    "Explique 'solução ótima': a melhor possível, como o caminho mais curto ou o maior lucro.",
                                    "Identifique exemplos cotidianos, como planejar a rota mais rápida para casa.",
                                    "Discuta por que soluções parciais ruins levam a resultados ruins no todo.",
                                    "Anote definições em suas próprias palavras."
                                  ],
                                  "verification": "Escreva uma definição clara de otimização e solução ótima; revise se faz sentido para um amigo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Vídeo introdutório sobre otimização (ex: Khan Academy)"
                                  ],
                                  "tips": "Use analogias simples como 'escolher o melhor sanduíche' para fixar conceitos.",
                                  "learningObjective": "Compreender os fundamentos de problemas de otimização e o conceito de solução ótima.",
                                  "commonMistakes": [
                                    "Confundir otimização com qualquer cálculo; foque em 'melhor' solução."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar subproblemas em um problema maior",
                                  "subSteps": [
                                    "Divida um problema grande em partes menores (subproblemas), como dividir uma viagem longa em etapas.",
                                    "Descreva como cada subproblema tem sua própria solução ótima.",
                                    "Ilustre com um exemplo: em uma viagem de A a C via B, o melhor A-B e B-C formam o melhor A-C.",
                                    "Questione: 'O que acontece se um subproblema for ruim?'",
                                    "Crie um diagrama simples de um problema dividido."
                                  ],
                                  "verification": "Desenhe um diagrama de um problema com 3 subproblemas e marque soluções ótimas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para diagrama",
                                    "Exemplo de viagem impresso ou digital"
                                  ],
                                  "tips": "Comece com problemas lineares como caminhos sequenciais para simplicidade.",
                                  "learningObjective": "Identificar e descrever subproblemas e suas soluções ótimas independentemente.",
                                  "commonMistakes": [
                                    "Ignorar dependências entre subproblemas; lembre que eles se conectam sequencialmente."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular o princípio de Bellman em termos simples",
                                  "subSteps": [
                                    "Enuncie: 'Em certos problemas, a melhor solução total usa as melhores soluções das partes menores.'",
                                    "Explique a condição: problemas que 'satisfazem o princípio' (ótimo total inclui ótimos subótimos).",
                                    "Compare com casos que não satisfazem, como um jogo onde sacrifício em subetapa beneficia o todo.",
                                    "Reescreva a descrição oficial em palavras simples: 'Construa de baixo para cima usando melhores pedaços.'",
                                    "Pratique verbalizando para si mesmo ou gravando áudio."
                                  ],
                                  "verification": "Grave uma explicação de 1 minuto e ouça se está clara e sem jargões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gravador de voz no celular",
                                    "Folha com descrição oficial do princípio"
                                  ],
                                  "tips": "Evite termos técnicos; mire em explicação para uma criança de 12 anos.",
                                  "learningObjective": "Articular o princípio de Bellman de forma intuitiva e verbal.",
                                  "commonMistakes": [
                                    "Usar linguagem técnica como 'bottom-up' sem simplificar; traduza tudo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e refinar a descrição com exemplos",
                                  "subSteps": [
                                    "Aplique a um exemplo simples: problema de Fibonacci (melhor forma de somar até N usa melhores sub-somas).",
                                    "Descreva verbalmente: 'A melhor soma até 5 usa a melhor até 4 e 3, e assim por diante.'",
                                    "Teste com variações: rotas de viagem ou planejamento de mochila.",
                                    "Peça feedback simulando uma conversa com um colega.",
                                    "Revise e simplifique sua descrição final."
                                  ],
                                  "verification": "Explique para outra pessoa (ou espelho) e confirme compreensão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de Fibonacci anotado",
                                    "Parceiro para feedback opcional"
                                  ],
                                  "tips": "Use histórias: 'Imagine um ladrão roubando casas em sequência, escolhendo sempre o melhor até ali.'",
                                  "learningObjective": "Descrever o princípio fluentemente com exemplos concretos.",
                                  "commonMistakes": [
                                    "Exemplos muito complexos; fique com 1-2 simples e relatable."
                                  ]
                                }
                              ],
                              "practicalExample": "Imagine planejar a viagem mais curta de casa ao trabalho passando por 3 pontos: A->B->C->D. Pelo princípio de Bellman, o melhor caminho total usa o melhor A->B, melhor B->C e melhor C->D, construindo a solução ótima de baixo para cima.",
                              "finalVerifications": [
                                "Pode explicar o princípio em 30 segundos sem jargões técnicos.",
                                "Identifica corretamente se um problema satisfaz o princípio (ex: viagem sim, jogo de xadrez nem sempre).",
                                "Descreve a construção bottom-up com um exemplo simples.",
                                "Diferencia solução ótima de subótima em um cenário dado.",
                                "Reescreve a definição oficial em termos pessoais claros.",
                                "Responde perguntas como 'Por que isso permite programação dinâmica?'"
                              ],
                              "assessmentCriteria": [
                                "Clareza: Explicação simples, sem termos avançados.",
                                "Precisão: Captura essência (ótimo total inclui ótimos subótimos).",
                                "Simplicidade: Usa analogias cotidianas efetivas.",
                                "Completude: Menciona condição de satisfação e construção bottom-up.",
                                "Fluência verbal: Descreve naturalmente em conversa.",
                                "Exemplificação: Inclui pelo menos um exemplo concreto."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recursão e indução matemática.",
                                "Economia: Otimização de recursos e decisões sequenciais.",
                                "Física: Princípios de minimalidade em trajetórias (ex: princípio de Fermat).",
                                "Gestão: Planejamento de projetos com milestones ótimos.",
                                "Informática: Base para algoritmos recursivos e DP."
                              ],
                              "realWorldApplication": "No GPS como Waze, o melhor trajeto total é construído usando melhores sub-rotas entre interseções, otimizando tempo em tempo real e evitando tráfego."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.2",
                            "name": "Diferenciar o princípio de otimalidade de abordagens gulosas",
                            "description": "Comparar com algoritmos gulosos, destacando que o princípio de Bellman garante otimalidade via subproblemas sobrepostos, enquanto gulosos tomam decisões locais irreversíveis sem essa garantia.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as Abordagens Gulosas",
                                  "subSteps": [
                                    "Defina abordagem gulosa: algoritmo que toma a escolha localmente ótima em cada etapa, esperando que resulte em solução global ótima.",
                                    "Identifique características principais: decisões irreversíveis, sem backtracking, eficiência computacional alta.",
                                    "Estude exemplo clássico: Problema de Seleção de Atividades, onde ordenar por tempo de término funciona.",
                                    "Analise quando falha: Problema da Mochila Fracionária com itens de densidades variadas.",
                                    "Pratique implementando um algoritmo guloso simples em pseudocódigo."
                                  ],
                                  "verification": "Escreva uma definição precisa e um exemplo onde o guloso succeeds, confirmando com execução manual.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Notebook e lápis",
                                    "Pseudocódigo de exemplo de seleção de atividades",
                                    "Artigo introdutório sobre algoritmos gulosos"
                                  ],
                                  "tips": "Sempre pergunte: 'Essa escolha local leva à global?' Visualize com diagramas de decisão.",
                                  "learningObjective": "Dominar definição, características e exemplos de sucesso/falha de algoritmos gulosos.",
                                  "commonMistakes": [
                                    "Confundir com PD achando que toda otimização local é global.",
                                    "Ignorar casos de falha, assumindo sempre ótimo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Princípio de Otimalidade de Bellman",
                                  "subSteps": [
                                    "Defina o princípio: Uma solução ótima para um problema contém soluções ótimas para subproblemas.",
                                    "Explique subproblemas sobrepostos e dependência mútua.",
                                    "Discuta recursão e memoização para eficiência.",
                                    "Estude prova intuitiva via indução matemática.",
                                    "Compare com definição formal: Para todo prefixo ótimo, todo prefixo é ótimo."
                                  ],
                                  "verification": "Reescreva o princípio em suas palavras e aplique a um subproblema simples como Fibonacci.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Diagrama de subproblemas sobrepostos",
                                    "Exemplo de PD para sequência de Fibonacci",
                                    "Video curto sobre Bellman"
                                  ],
                                  "tips": "Desenhe árvores de recursão para visualizar sobreposições e economias de recomputação.",
                                  "learningObjective": "Internalizar como Bellman garante otimalidade via decomposição em subproblemas.",
                                  "commonMistakes": [
                                    "Confundir com mera recursão sem otimalidade.",
                                    "Subestimar necessidade de sobreposições para PD."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Fundamentais",
                                  "subSteps": [
                                    "Compare garantias: Guloso sem garantia global; Bellman com prova de otimalidade.",
                                    "Analise decisões: Guloso irreversível/local; PD explora todas vias via tabela/DP.",
                                    "Discuta complexidade: Guloso O(n log n); PD O(n^2) ou pior, mas exato.",
                                    "Liste critérios de falha guloso: Ausência de propriedade greedy-choice ou matroid.",
                                    "Crie tabela comparativa com colunas: Decisão, Garantia, Exemplos."
                                  ],
                                  "verification": "Preencha tabela comparativa corretamente e justifique cada entrada.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela comparativa",
                                    "Lista de propriedades matemáticas (greedy-choice, optimal substructure)"
                                  ],
                                  "tips": "Use setas para mostrar 'decisão local → possível falha global' vs 'subestrutura ótima → global ótima'.",
                                  "learningObjective": "Discernir precisamente mecanismos e limitações de cada abordagem.",
                                  "commonMistakes": [
                                    "Achar gulosos sempre mais rápidos sem contexto.",
                                    "Ignorar que PD requer optimal substructure, similar mas mais rigoroso que greedy."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em Exemplos Comparativos",
                                  "subSteps": [
                                    "Escolha problema: Mochila 0/1 – Guloso por peso/valor falha; PD resolve exatamente.",
                                    "Simule guloso: Ordene itens por densidade, tome até caber – calcule subótimo.",
                                    "Simule PD: Construa tabela dp[i][w] para subproblemas.",
                                    "Compare soluções numéricas e explique por quê PD é ótimo.",
                                    "Discuta trade-offs: Tempo vs precisão."
                                  ],
                                  "verification": "Resolva manualmente ambos para instância pequena e confirme PD ≥ Guloso.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Exemplo numérico: Capacidade 10, itens (peso,valor): (6,30),(3,14),(4,16),(2,9)",
                                    "Calculadora ou planilha"
                                  ],
                                  "tips": "Comece com instâncias pequenas (n=3) para ver falhas claramente.",
                                  "learningObjective": "Demonstrar diferenças práticas através de análise hands-on.",
                                  "commonMistakes": [
                                    "Erro em cálculos DP confundindo índices.",
                                    "Assumir guloso funciona se densidades iguais."
                                  ]
                                }
                              ],
                              "practicalExample": "No problema da Mochila 0/1 com capacidade 10 e itens [(6,30), (3,14), (4,16), (2,9)]: Guloso por densidade pega (6,30) e (3,14) total 44; PD pega (3,14),(4,16),(2,9) total 39? Espera, corrija: Na verdade guloso (dens:5, 4.66,4,4.5) pega 6-30, então 4-16 total46; PD pode 3-14+4-16+2-9=39? Exemplo clássico onde guloso falha: itens (5,6),(5,5),(5,5),(3,6) cap10 – guloso 5-6+5-5=11; PD 3-6+5-5+2? Ajuste: Padrão mochila onde guloso subótimo.",
                              "finalVerifications": [
                                "Explique em 1 parágrafo a diferença chave entre Bellman e guloso.",
                                "Identifique problema onde guloso falha e por quê PD succeeds.",
                                "Descreva propriedade matemática ausente em gulosos genéricos.",
                                "Compare complexidades em notação Big-O para problema comum.",
                                "Dê contraexemplo onde guloso é ótimo e PD desnecessário."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ambos conceitos (90%+ acurácia).",
                                "Capacidade de gerar exemplos corretos de falha/sucesso.",
                                "Clareza na tabela ou diagrama comparativo.",
                                "Compreensão de garantias matemáticas (optimal substructure vs greedy choice).",
                                "Análise qualitativa/quantitativa de trade-offs.",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução matemática na prova de Bellman.",
                                "Economia: Decisões sequenciais ótimas vs heurísticas em alocação de recursos.",
                                "Inteligência Artificial: Heurísticas gulosas em busca A* vs PD em planejamento.",
                                "Gestão de Projetos: Escolha local (guloso) vs planejamento holístico (PD)."
                              ],
                              "realWorldApplication": "Em logística de rotas (guloso para aproximado rápido como Dijkstra greedy-like; PD para exato em redes pequenas), planejamento financeiro (PD para portfólios ótimos considerando subperíodos), ou compiladores (guloso para registro alocação aproximada vs PD exato)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.1.3",
                            "name": "Identificar a necessidade do princípio em programação dinâmica",
                            "description": "Reconhecer que o princípio é fundamental para justificar o uso de tabelas de programação dinâmica em vez de métodos exaustivos puros.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar problemas candidatos a Programação Dinâmica",
                                  "subSteps": [
                                    "Estude exemplos clássicos como Fibonacci, Knapsack 0/1 e Sequência de Longest Increasing Subsequence (LIS).",
                                    "Identifique características comuns: problemas de otimização com decisões sequenciais e sobreposições de subproblemas.",
                                    "Anote problemas que envolvem escolhas exaustivas em árvores de decisão.",
                                    "Compare com problemas que não se encaixam, como buscas simples sem recorrência.",
                                    "Liste 3-5 problemas reais que parecem exaustivos inicialmente."
                                  ],
                                  "verification": "Crie uma tabela comparando 3 problemas DP vs. não-DP, justificando por quê cada um é candidato.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notebook, exemplos de código em Python (Fibonacci recursivo), diagramas de árvores de recursão.",
                                  "tips": "Use diagramas visuais para mapear chamadas recursivas e visualizar sobreposições.",
                                  "learningObjective": "Reconhecer padrões de problemas que demandam otimização além de exaustão pura.",
                                  "commonMistakes": "Confundir todos os problemas recursivos com DP; ignorar ausência de sobreposições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar limitações de métodos exaustivos puros",
                                  "subSteps": [
                                    "Implemente uma solução recursiva exaustiva para Fibonacci(n=40) e meça o tempo de execução.",
                                    "Calcule a complexidade temporal (ex: O(2^n) para Fibonacci) e observe timeouts ou estouro de pilha.",
                                    "Conte o número de chamadas redundantes usando contadores em código.",
                                    "Simule para Knapsack com n=20 itens e capacidade pequena, notando explosão combinatória.",
                                    "Registre métricas: tempo, memória e escalabilidade para n crescente."
                                  ],
                                  "verification": "Gere um relatório com tempos de execução e gráficos de complexidade exponencial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Ambiente Python/Jupyter, cronômetro de performance (timeit), papel para cálculos de recorrência.",
                                  "tips": "Use memoização temporária desabilitada para forçar exaustão e destacar o problema.",
                                  "learningObjective": "Quantificar ineficiências de abordagens ingênuas em problemas com subproblemas sobrepostos.",
                                  "commonMistakes": "Subestimar impactos para n pequeno; confundir recursão com iteração."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender o Princípio da Otimalidade de Bellman",
                                  "subSteps": [
                                    "Leia a definição: 'Uma política ótima tem a propriedade de que, independentemente da decisão inicial, as decisões restantes devem constituir uma política ótima para o subproblema restante.'",
                                    "Traduza para DP: Soluções ótimas de subproblemas compõem a solução ótima global.",
                                    "Aplique a Fibonacci: fib(n) = fib(n-1) + fib(n-2), onde fib(k) é ótimo para todo k < n.",
                                    "Verifique em Knapsack: Valor ótimo para subcapacidade é independente e reutilizável.",
                                    "Escreva em suas palavras: por quê isso justifica computar subproblemas uma vez só."
                                  ],
                                  "verification": "Explique o princípio em 1 parágrafo e aplique a 2 exemplos, sem consultar fontes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Artigo original de Bellman (resumo online), exemplos anotados de DP.",
                                  "tips": "Pense em 'divide e conquiste' mas com reutilização: sem Bellman, não há garantia de composição ótima.",
                                  "learningObjective": "Internalizar como o princípio valida a quebra em subproblemas independentes.",
                                  "commonMistakes": "Confundir com 'ganância' (greedy); achar que aplica a todo problema recursivo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar tabelas DP via Princípio de Bellman",
                                  "subSteps": [
                                    "Construa tabela bottom-up para Fibonacci, preenchendo de baixo para cima.",
                                    "Compare código: recursivo exaustivo vs. tabela DP, medindo speedup.",
                                    "Para Knapsack, crie matriz dp[i][w] e trace dependências (apenas subproblemas menores).",
                                    "Argumente: 'Sem Bellman, tabela poderia conter inconsistências; com ele, é correto e eficiente.'",
                                    "Teste com input grande: confirme O(n^2) vs. exponencial."
                                  ],
                                  "verification": "Implemente ambos e produza tabela de performance + justificativa escrita.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Código Python para DP tabelas, planilha para tabelas manuais.",
                                  "tips": "Sempre pergunte: 'Essa sub-solução é ótima sozinha?' para validar Bellman.",
                                  "learningObjective": "Conectar princípio teórico à prática de tabelas, provando superioridade sobre exaustivo.",
                                  "commonMistakes": "Implementar top-down como bottom-up; ignorar prova de correção via Bellman."
                                }
                              ],
                              "practicalExample": "No problema de Fibonacci, recursão pura faz ~2^n chamadas redundantes. Com Bellman, fib(5) usa fib(4) e fib(3), que são ótimos independentemente, permitindo tabela [0,1,1,2,3,5,...] computada uma vez em O(n), evitando recomputações.",
                              "finalVerifications": [
                                "Explica por quê recursão pura falha em escala e como Bellman resolve.",
                                "Identifica sobreposições e optimalidade em novos problemas como LIS ou Coin Change.",
                                "Constrói tabela DP manual para n=10 sem erros.",
                                "Justifica verbalmente: 'Tabelas DP são corretas porque subproblemas são ótimos por Bellman.'",
                                "Compara complexidades corretamente (exponencial vs. polinomial).",
                                "Aplica a exemplo real sem hesitação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e aplicação do Princípio de Bellman (peso 30%).",
                                "Análise quantitativa de eficiência (tempos/complexidades) (peso 25%).",
                                "Clareza na justificativa de tabelas vs. exaustivo (peso 20%).",
                                "Uso correto de exemplos com diagramas/código (peso 15%).",
                                "Identificação de erros comuns e prevenções (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências lineares e indução matemática para provar optimalidade.",
                                "Economia: Otimização dinâmica em modelos de decisão sequencial (ex: consumo intertemporal).",
                                "Gestão: Planejamento de projetos com dependências e alocação ótima de recursos.",
                                "Física: Problemas de caminho mínimo em redes (ex: refração de luz via princípio de Fermat)."
                              ],
                              "realWorldApplication": "Em logística, otimizar rotas de entrega (como TSP variante) usando DP com Bellman para sub-rotas ótimas, reduzindo combustível em 30% vs. buscas exaustivas, escalável para frotas reais como Amazon ou Uber Eats."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.2",
                        "name": "Formalização Matemática do Princípio",
                        "description": "Representação precisa e matemática do princípio, incluindo equações de recorrência que expressam a otimalidade em termos de subproblemas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.2.1",
                            "name": "Enunciar a definição formal do princípio de Bellman",
                            "description": "Escrever e interpretar a formalização: 'Uma solução ótima a um problema de n etapas contém uma solução ótima ao problema associado às primeiras k etapas, para qualquer k < n', adaptada a contextos discretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto de problemas de otimização multi-etapa",
                                  "subSteps": [
                                    "Revise o conceito de problema de otimização: minimizar ou maximizar uma função objetivo sob restrições.",
                                    "Identifique problemas multi-etapa: sequências de decisões onde cada etapa afeta as subsequentes.",
                                    "Diferencie problemas discretos de contínuos, focando em estados finitos e ações discretas.",
                                    "Examine exemplos iniciais como o problema do caixeiro viajante ou alocação de recursos.",
                                    "Anote as características comuns desses problemas: sobreposição de subproblemas e otimalidade das subestruturas."
                                  ],
                                  "verification": "Explique em suas palavras o que é um problema multi-etapa discreto e dê um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre programação dinâmica",
                                    "Livro de Algoritmos Avançados (capítulo de PD)",
                                    "Vídeo introdutório sobre otimização"
                                  ],
                                  "tips": "Use diagramas de árvore de decisões para visualizar etapas sequenciais.",
                                  "learningObjective": "Entender o ambiente onde o princípio de Bellman é aplicável.",
                                  "commonMistakes": [
                                    "Confundir multi-etapa com problemas estáticos",
                                    "Ignorar a natureza discreta dos estados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a declaração informal do princípio de Bellman",
                                  "subSteps": [
                                    "Leia a declaração: 'Uma solução ótima a um problema de n etapas contém uma solução ótima ao problema associado às primeiras k etapas, para qualquer k < n'.",
                                    "Decomponha a frase: identifique 'solução ótima', 'problema de n etapas' e 'primeiras k etapas'.",
                                    "Discuta implicações: subproblemas prefixados devem ser ótimos independentemente.",
                                    "Compare com contraexemplos onde isso não vale, como problemas sem sobreposição.",
                                    "Reescreva a declaração em suas palavras para fixar o entendimento intuitivo."
                                  ],
                                  "verification": "Parafraseie corretamente a declaração informal sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigo ou slide sobre Princípio da Otimalidade de Bellman",
                                    "Exemplos de problemas de PD"
                                  ],
                                  "tips": "Pense em termos de 'herança ótima': o ótimo total herda otimalidade parcial.",
                                  "learningObjective": "Internalizar a intuição por trás da formalização.",
                                  "commonMistakes": [
                                    "Interpretar como solução ótima para qualquer subproblema, não só prefixos",
                                    "Confundir com recursividade simples"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a formalização matemática do princípio",
                                  "subSteps": [
                                    "Defina notação: seja S_k o subproblema das primeiras k etapas, OPT(S_n) a solução ótima para n etapas.",
                                    "Escreva a formalização: OPT(S_n) restringida às primeiras k etapas = OPT(S_k), ∀ k < n.",
                                    "Adapte a contextos discretos: introduza estados s_k e políticas ótimas π*.",
                                    "Formalize com equações: V*(s) = max_a [R(s,a) + γ ∑_{s'} P(s'|s,a) V*(s')], implicando otimalidade subestrutural.",
                                    "Verifique consistência com definição de Bellman para valor ótimo."
                                  ],
                                  "verification": "Escreva a formalização matemática exata em um papel e confira com a referência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Referência matemática do princípio (wikipedia ou livro)",
                                    "Editor de LaTeX online para prática"
                                  ],
                                  "tips": "Use subscritos para etapas (S_k) e símbolos padrão como OPT ou V*.",
                                  "learningObjective": "Dominar a escrita precisa da definição formal.",
                                  "commonMistakes": [
                                    "Omitir 'para qualquer k < n'",
                                    "Usar notação errada para estados discretos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar a interpretação e aplicação da definição formal",
                                  "subSteps": [
                                    "Aplique a formalização a um exemplo simples: problema de n passos em grade.",
                                    "Interprete: explique por que a restrição de OPT(S_n) a k etapas é OPT(S_k).",
                                    "Gere variações: adapte para minimização e contextos estocásticos discretos.",
                                    "Crie um contraexemplo onde o princípio falha e justifique.",
                                    "Escreva um parágrafo interpretando a formalização em palavras."
                                  ],
                                  "verification": "Resolva um exercício: enuncie e interprete para um problema dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exercícios de PD",
                                    "Simulador online de problemas discretos"
                                  ],
                                  "tips": "Sempre volte à declaração original para validar sua interpretação.",
                                  "learningObjective": "Capacitar-se a usar a definição em contextos reais de PD.",
                                  "commonMistakes": [
                                    "Generalizar excessivamente sem respeitar prefixos sequenciais",
                                    "Ignorar adaptações discretas"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema clássico de escalada de montanha com n etapas, onde cada etapa tem custo, a política ótima total π* para as primeiras k etapas coincide com π*_k, permitindo decomposição recursiva via equação de Bellman: V_k(s) = min_a [c(s,a) + V_{k-1}(s')].",
                              "finalVerifications": [
                                "Escrever a definição formal sem erros de notação.",
                                "Interpretar corretamente em um exemplo discreto.",
                                "Identificar quando o princípio se aplica ou não.",
                                "Explicar a implicação para programação dinâmica.",
                                "Adaptar a formalização para um contexto específico dado.",
                                "Diferenciar de princípios semelhantes como 'no free lunch'."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude da formalização matemática (100% match com padrão).",
                                "Clareza na interpretação verbal ou escrita.",
                                "Correta identificação de contextos discretos.",
                                "Uso apropriado de notação (estados, políticas ótimas).",
                                "Capacidade de aplicar em exemplos simples.",
                                "Ausência de erros comuns como omissão de 'qualquer k < n'."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Princípio da Indução Matemática para provas de otimalidade.",
                                "Economia: Modelos de Otimização Dinâmica em decisões sequenciais.",
                                "Física: Problemas de Caminho Ótimo em Mecânica Clássica discreta.",
                                "Ciência da Computação: Fundamento para Algoritmos Recursivos e Memoização.",
                                "Gestão: Planejamento Estratégico com Decisões Multi-etapas."
                              ],
                              "realWorldApplication": "O princípio de Bellman é a base para algoritmos de roteamento em GPS (como Dijkstra adaptado), otimização de portfólios financeiros em trading algorítmico e planejamento de produção em cadeias de suprimentos, permitindo soluções eficientes para problemas de decisões sequenciais discretas no mundo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.2.2",
                            "name": "Escrever equações de recorrência baseadas no princípio",
                            "description": "Construir expressões como C[i][j] = min_k { C[i][k] + C[k+1][j] + custo(i,j,k) } para problemas de cadeia de matrizes, justificando pela otimalidade de Bellman.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio da Otimalidade de Bellman",
                                  "subSteps": [
                                    "Leia a definição formal: uma solução ótima para um problema contém soluções ótimas para subproblemas.",
                                    "Analise exemplos simples, como o problema da mochila ou Fibonacci.",
                                    "Identifique por que problemas de PD satisfazem Bellman: sobreposição e otimalidade das subestruturas.",
                                    "Anote as condições necessárias: subproblemas sobrepostos e estrutura ótima.",
                                    "Compare com problemas que não satisfazem Bellman, como busca exaustiva."
                                  ],
                                  "verification": "Escreva um resumo de 3 frases explicando Bellman e dê um exemplo válido/inválido.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre PD, pseudocódigo de Bellman, vídeo introdutório (5 min).",
                                  "tips": "Use analogias como 'caminho mais curto em grafos' para fixar o conceito.",
                                  "learningObjective": "Explicar verbalmente o princípio e identificar problemas aplicáveis.",
                                  "commonMistakes": "Confundir com divide-and-conquer; ignorar a necessidade de subestruturas ótimas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Estrutura do Problema Específico",
                                  "subSteps": [
                                    "Defina o problema: ex., multiplicação em cadeia de matrizes com dimensões A1(n1xn2), ..., Am(nm x n{m+1}).",
                                    "Identifique subproblemas: custo ótimo de multiplicar de i a j.",
                                    "Desenhe a tabela de recorrência C[i][j] representando subproblemas.",
                                    "Liste dependências: C[i][j] depende de C[i][k] e C[k+1][j] para k entre i e j-1.",
                                    "Calcule o custo de combinar: custo(i,j,k) = ni * nk+1 * nj+1."
                                  ],
                                  "verification": "Desenhe diagrama da cadeia e rotule subproblemas com dependências corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel quadriculado, exemplo de matrizes (ex.: dimensões [10,20,30,40]), calculadora.",
                                  "tips": "Comece com 3 matrizes para visualizar splits possíveis.",
                                  "learningObjective": "Mapear subproblemas e suas interdependências no problema.",
                                  "commonMistakes": "Esquecer índices corretos em custo; confundir i,j com dimensões."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Equação de Recorrência",
                                  "subSteps": [
                                    "Escreva a forma geral: C[i][j] = min sobre k (C[i][k] + C[k+1][j] + custo(i,j,k)).",
                                    "Defina condições base: C[i][i] = 0 (uma matriz não custa).",
                                    "Expanda para j = i+1: C[i][i+1] = 0 ou custo trivial.",
                                    "Teste com pequena instância: 3 matrizes, compute manualmente.",
                                    "Generalize para n matrizes, verificando recursão."
                                  ],
                                  "verification": "Escreva a equação completa com bases e compute C[1][3] para exemplo.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Folha de exercícios com cadeia de 4 matrizes, software como Python para verificação opcional.",
                                  "tips": "Use laços for mentais: para len=2 a n, para i=1 a n-len+1, j=i+len-1, min_k.",
                                  "learningObjective": "Formular a recorrência exata derivada da estrutura.",
                                  "commonMistakes": "Índices errados em k+1; min ao invés de +; omitir custo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar pela Otimalidade de Bellman",
                                  "subSteps": [
                                    "Explique: se C[i][j] ótima divide em i-k e k+1-j ótimas.",
                                    "Prove supondo contradição: se subótima, então total não ótima.",
                                    "Verifique sobreposição: subproblemas C[p][q] computados múltiplas vezes.",
                                    "Discuta ordem de computação: bottom-up por tamanho de cadeia.",
                                    "Aplique a outro problema similar para reforço (ex.: all-pairs shortest paths)."
                                  ],
                                  "verification": "Escreva parágrafo de justificativa + prova esboçada para cadeia de matrizes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Livro de Algoritmos (CLRS cap. PD), quadro branco para prova.",
                                  "tips": "Use notação: OTIMA(i,j) implica OTIMA(i,k) e OTIMA(k+1,j) para algum k.",
                                  "learningObjective": "Justificar matematicamente por que a recorrência é válida via Bellman.",
                                  "commonMistakes": "Ignorar prova de otimalidade; confundir com memoização apenas."
                                }
                              ],
                              "practicalExample": "Para multiplicar 4 matrizes A(10x20), B(20x30), C(30x40), D(40x50): C[1][4] = min_k=1..3 { C[1][k] + C[k+1][4] + custo(1,4,k) }, onde custo(1,4,2)=10*30*50=15000, etc. Compute valor ótimo 30000 via ((AB)C)D.",
                              "finalVerifications": [
                                "Escreve corretamente C[i][j] = min_k {C[i][k] + C[k+1][j] + custo(i,j,k)} com bases.",
                                "Justifica otimalidade citando Bellman explicitamente.",
                                "Computa exemplo pequeno (3 matrizes) manualmente sem erros.",
                                "Identifica dependências e ordem de preenchimento da tabela.",
                                "Adapta equação para variação similar (ex.: com custo diferente).",
                                "Explica por que não é busca exaustiva."
                              ],
                              "assessmentCriteria": [
                                "Precisão na formulação da recorrência (índices, min, custo correto): 30%",
                                "Justificativa clara e correta via Bellman (prova esboçada): 25%",
                                "Exemplo prático resolvido com cálculos numéricos: 20%",
                                "Identificação de subproblemas e dependências: 15%",
                                "Generalização e discussão de limitações: 10%"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização combinatória e minimização.",
                                "Algoritmos: Extensão para Floyd-Warshall em grafos.",
                                "Economia: Problemas de alocação ótima de recursos.",
                                "Engenharia de Software: Otimização de expressões em compiladores."
                              ],
                              "realWorldApplication": "Em compiladores, otimiza ordem de multiplicação de matrizes em loops aninhados para reduzir tempo de execução; em logística, minimiza custos de encadeamento de operações em supply chain."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.4.3",
                        "name": "Aplicação e Validação do Princípio",
                        "description": "Verificação de problemas que satisfazem o princípio e exemplos clássicos em grafos e cadeias de caracteres.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.4.3.1",
                            "name": "Verificar se um problema satisfaz o princípio de Bellman",
                            "description": "Analisar um problema dado (ex: caminho mais curto em grafos) para confirmar se soluções ótimas de subgrafos levam à solução global ótima, citando referências como Cormen et al.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio de Optimalidade de Bellman",
                                  "subSteps": [
                                    "Leia a definição formal do princípio: uma solução ótima para o problema todo inclui soluções ótimas para subproblemas.",
                                    "Estude exemplos clássicos como o problema da mochila ou sequência de Fibonacci.",
                                    "Anote os dois requisitos chave: subproblemas sobrepostos e estrutura ótima (optimal substructure).",
                                    "Revise referências iniciais como Cormen et al., Capítulo 15.",
                                    "Resuma em suas palavras os critérios para um problema satisfazer o princípio."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando o princípio e seus requisitos; verifique se menciona optimal substructure.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Algorithms' de Cormen et al. (PDF ou físico)",
                                    "Notas em branco",
                                    "Acesso a Khan Academy ou Wikipedia para Programação Dinâmica"
                                  ],
                                  "tips": "Use analogias como 'escadaria': o melhor caminho ao topo passa pelos melhores degraus intermediários.",
                                  "learningObjective": "Dominar a definição e requisitos do Princípio de Bellman para análise posterior.",
                                  "commonMistakes": [
                                    "Confundir com divide-and-conquer (sem sobreposição)",
                                    "Ignorar a necessidade de subproblemas sobrepostos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente o Problema a Ser Analisado",
                                  "subSteps": [
                                    "Descreva o problema em termos precisos: entradas, saídas e objetivo (ex: encontrar caminho mais curto em grafo).",
                                    "Especifique restrições, como grafos sem ciclos negativos.",
                                    "Modele o problema matematicamente, definindo função objetivo e variáveis.",
                                    "Identifique possíveis soluções não-óptimas para contrastar.",
                                    "Documente suposições iniciais sobre a estrutura do problema."
                                  ],
                                  "verification": "Crie uma definição formal escrita que inclua notação matemática; um colega deve entender sem ambiguidades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel ou editor de texto (Google Docs)",
                                    "Exemplo de grafo (desenhe um com 4-5 nós)"
                                  ],
                                  "tips": "Use notação padrão: G(V,E) para grafos, δ(u,v) para distância mais curta.",
                                  "learningObjective": "Formalizar o problema para permitir análise estrutural precisa.",
                                  "commonMistakes": [
                                    "Definições vagas sem matemática",
                                    "Omitir restrições que afetam optimalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Subproblemas e Verificar Estrutura Ótima",
                                  "subSteps": [
                                    "Liste subproblemas potenciais (ex: distância mais curta de s a v para todo v).",
                                    "Verifique se soluções ótimas de subproblemas compõem a solução global: prove que δ(s,x) + δ(x,t) = δ(s,t) para caminhos ótimos.",
                                    "Confirme sobreposição: subproblemas se repetem em recursão.",
                                    "Teste propriedade: assuma solução ótima global e mostre que sub-soluções são ótimas.",
                                    "Desenhe um grafo pequeno e trace recursão."
                                  ],
                                  "verification": "Prove matematicamente que a concatenação de sub-otimalidades leva à global; valide com diagrama.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de desenho de grafos (Draw.io ou papel)",
                                    "Calculadora para distâncias"
                                  ],
                                  "tips": "Comece com indução: base e passo indutivo para optimal substructure.",
                                  "learningObjective": "Analisar se o problema exibe optimal substructure e subproblemas sobrepostos.",
                                  "commonMistakes": [
                                    "Assumir sem prova",
                                    "Confundir com problemas NP-completos sem PD"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar com Exemplos, Contra-Exemplos e Referências",
                                  "subSteps": [
                                    "Aplique a um exemplo concreto: grafo com nós A-B-C, calcule caminhos.",
                                    "Teste um contra-exemplo: problema que não satisfaz (ex: viagem do vendedor).",
                                    "Cite Cormen et al. para confirmação em caminhos mais curtos.",
                                    "Conclua se satisfaz: sim/não com justificativa.",
                                    "Registre lições aprendidas para problemas similares."
                                  ],
                                  "verification": "Gere relatório de 1 página com prova, exemplo e citação; auto-avalia se convincente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Referência Cormen et al.",
                                    "Ferramenta NetworkX (Python) para simulação opcional"
                                  ],
                                  "tips": "Use contra-exemplos para fortalecer argumento negativo.",
                                  "learningObjective": "Confirmar aplicação do princípio com evidências empíricas e teóricas.",
                                  "commonMistakes": [
                                    "Ignorar contra-exemplos",
                                    "Citar sem ler contexto"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de caminho mais curto em grafo direcionado com pesos não-negativos (ex: nós S->A(2)->T(3), S->B(5)->T(1)): subproblema δ(S,A)=2 é ótimo e compõe δ(S,T)=5; recursão sobreposta confirma Bellman.",
                              "finalVerifications": [
                                "Pode definir precisamente o Princípio de Bellman?",
                                "Identifica corretamente subproblemas no exemplo de grafo?",
                                "Prova que optimal substructure holds com indução?",
                                "Distingue problemas que satisfazem vs. não (ex: TSP)?",
                                "Cita referências apropriadas como Cormen?",
                                "Aplica a um novo problema similar?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na formalização do problema (20%)",
                                "Correta identificação de subproblemas e sobreposição (25%)",
                                "Prova rigorosa de optimal substructure (30%)",
                                "Uso de exemplos/contra-exemplos relevantes (15%)",
                                "Referências e clareza na conclusão (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria da Otimização e Indução Matemática",
                                "Economia: Programação Linear e Alocação de Recursos Ótimos",
                                "Engenharia de Software: Design de Algoritmos Eficientes",
                                "Física: Otimização de Trajetórias em Sistemas Dinâmicos"
                              ],
                              "realWorldApplication": "Em roteamento de redes (ex: Google Maps ou protocolos BGP), verifica-se Bellman para usar Dijkstra/PD, garantindo caminhos ótimos globais via sub-rotas ótimas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.2",
                            "name": "Aplicar o princípio em exemplos de grafos e árvores",
                            "description": "Demonstrar o princípio no algoritmo de Floyd-Warshall para caminhos mais curtos ou em problemas de emparelhamento, mostrando combinação de subproblemas ótimos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Princípio da Otimalidade de Bellman e selecionar exemplo em grafos",
                                  "subSteps": [
                                    "Relembre a definição: uma solução ótima para um problema contém soluções ótimas para subproblemas sobrepostos.",
                                    "Escolha o algoritmo Floyd-Warshall para caminhos mais curtos em grafos ponderados.",
                                    "Desenhe um grafo pequeno de exemplo com 3-4 vértices e pesos nas arestas.",
                                    "Identifique subproblemas: distância mais curta entre i e j usando apenas os primeiros k vértices intermediários.",
                                    "Anote como subproblemas se combinam via recorrência: d[k][i][j] = min(d[k-1][i][j], d[k-1][i][k] + d[k-1][k][j])."
                                  ],
                                  "verification": "Crie um diagrama do grafo com anotações dos subproblemas e recorrência escrita corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, acesso a pseudocódigo de Floyd-Warshall online ou livro-texto de algoritmos.",
                                  "tips": "Comece com grafos sem ciclos negativos para simplicidade inicial.",
                                  "learningObjective": "Compreender como o princípio se aplica a problemas de caminhos em grafos.",
                                  "commonMistakes": "Confundir com Dijkstra (guloso) em vez de PD; ignorar vértices intermediários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e inicializar a tabela de Programação Dinâmica para Floyd-Warshall",
                                  "subSteps": [
                                    "Crie uma matriz de distâncias inicial (n x n), onde d[0][i][j] = peso da aresta i-j se existir, 0 se i=j, infinito caso contrário.",
                                    "Preencha a matriz para k=0 (sem intermediários).",
                                    "Explique por que isso satisfaz optimalidade: caminhos diretos são ótimos sem intermediários.",
                                    "Teste com seu grafo exemplo: compute distâncias iniciais manualmente.",
                                    "Verifique simetria e diagonal zero."
                                  ],
                                  "verification": "Matriz inicial preenchida corretamente para o grafo exemplo, com valores infinitos onde não há aresta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Planilha Excel ou papel quadriculado para matriz, calculadora.",
                                  "tips": "Use ∞ representado como um número grande como 99999 em implementações.",
                                  "learningObjective": "Estabelecer base ótima para subproblemas iniciais.",
                                  "commonMistakes": "Esquecer de setar diagonal como 0; colocar peso zero em arestas inexistentes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher a tabela DP iterativamente e demonstrar combinação de subproblemas",
                                  "subSteps": [
                                    "Para cada k de 1 a n: atualize d[k][i][j] para todos i,j usando a recorrência.",
                                    "Execute passo a passo para k=1 no seu grafo exemplo, mostrando como caminhos via k melhoram.",
                                    "Continue para k=2, etc., até completar a tabela.",
                                    "Destaque uma célula onde a atualização ocorre, provando uso de dois subproblemas ótimos.",
                                    "Compare d[n][][] com distâncias iniciais para mostrar melhorias."
                                  ],
                                  "verification": "Tabela DP final completa, com pelo menos uma atualização explicada mostrando optimalidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Mesma matriz do step anterior, pseudocódigo impresso.",
                                  "tips": "Implemente em Python ou pseudocódigo para automação após manual.",
                                  "learningObjective": "Demonstrar recursão e combinação de soluções ótimas.",
                                  "commonMistakes": "Atualizar na mesma matriz sem cópia (causa uso de valores atualizados prematuramente); ignorar ordem de k."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar em árvores e estender a emparelhamento, analisando resultados",
                                  "subSteps": [
                                    "Aplique similarmente em uma árvore: ex. caminhos mais curtos em árvore genealógica ou binária.",
                                    "Para emparelhamento: revise Hungarian ou PD para matching máximo, definindo subproblemas por subgrafos.",
                                    "No exemplo de grafo, trace caminhos ótimos reconstruindo predecessores.",
                                    "Verifique ausência de ciclos negativos afetando optimalidade.",
                                    "Discuta generalização: como Bellman se aplica além de Floyd-Warshall."
                                  ],
                                  "verification": "Relatório curto com tabela final, caminhos traçados e nota sobre optimalidade em pelo menos dois contextos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Código fonte opcional (Python com NetworkX), exemplos de árvores impressos.",
                                  "tips": "Use bibliotecas como NetworkX para visualização de grafos.",
                                  "learningObjective": "Validar princípio em múltiplos cenários e analisar soluções.",
                                  "commonMistakes": "Não reconstruir caminhos; confundir emparelhamento com caminhos."
                                }
                              ],
                              "practicalExample": "Em um grafo com vértices A, B, C onde A-B=3, A-C=8, B-C=2: Inicial d[0] = [[0,3,8],[inf,0,2],[inf,inf,0]]. Após k=1 (B): d[1][A][C] = min(8, 3+2)=5, mostrando combinação ótima A-B-C.",
                              "finalVerifications": [
                                "Tabela DP final corresponde a distâncias mais curtas verificadas por exaustão.",
                                "Recorrência escrita corretamente com justificativa de optimalidade.",
                                "Pelo menos um caminho ótimo reconstruído da tabela.",
                                "Exemplo em árvore ou emparelhamento com subproblemas identificados.",
                                "Ausência de erros em inicialização ou atualizações.",
                                "Explicação clara de como subproblemas se combinam."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e preenchimento da tabela DP (40%).",
                                "Demonstração clara da optimalidade de Bellman com exemplos (30%).",
                                "Correção na reconstrução de caminhos e verificações (15%).",
                                "Extensão a outros cenários como árvores (10%).",
                                "Clareza na documentação e avoidance de erros comuns (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Otimização Linear.",
                                "Ciência da Computação: Estruturas de Dados (Matrizes, Grafos).",
                                "Engenharia: Roteamento em Redes e Otimização de Rotas.",
                                "Física: Modelagem de Sistemas em Grafos (ex. partículas)."
                              ],
                              "realWorldApplication": "No GPS e roteamento de tráfego (Google Maps usa variantes PD para caminhos ótimos); em telecomunicações para minimizar latência em redes; em logística para entregas eficientes combinando sub-rotas ótimas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.4.3.3",
                            "name": "Relacionar com ordenação topológica em PD",
                            "description": "Explicar como o princípio facilita a ordenação topológica de subproblemas em grafos acíclicos para computação eficiente de soluções ótimas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Princípio da Otimalidade de Bellman",
                                  "subSteps": [
                                    "Defina o Princípio de Bellman: uma solução ótima para o problema contém soluções ótimas para subproblemas.",
                                    "Identifique condições: subestrutura ótima e sobreposição de subproblemas.",
                                    "Explique por que isso permite computação bottom-up em PD.",
                                    "Discuta dependências entre subproblemas como pré-requisitos.",
                                    "Esboce um grafo conceitual onde nós são subproblemas e arestas indicam dependências."
                                  ],
                                  "verification": "Resuma o princípio em suas próprias palavras e liste 2 exemplos de dependências em PD.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Notas de aula sobre PD, quadro branco ou papel para esboçar grafo.",
                                  "tips": "Use analogia de 'blocos de construção' para soluções ótimas.",
                                  "learningObjective": "Compreender como o princípio cria dependências hierárquicas entre subproblemas.",
                                  "commonMistakes": "Confundir com recursão simples sem memoização; ignorar sobreposição."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Grafos Acíclicos Direcionados (DAGs) e Ordenação Topológica",
                                  "subSteps": [
                                    "Defina DAG: grafo direcionado sem ciclos.",
                                    "Explique ordenação topológica: linearização de nós onde para toda aresta u→v, u vem antes de v.",
                                    "Liste algoritmos: Kahn's (fila com graus de entrada) ou DFS-based.",
                                    "Implemente topological sort manualmente em um DAG pequeno.",
                                    "Verifique aciclicidade detectando ciclos."
                                  ],
                                  "verification": "Aplique topological sort em um DAG de 5 nós e liste a ordem resultante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de texto ou ferramenta como Graphviz para visualizar DAGs.",
                                  "tips": "Comece com nós sem entradas (grau 0) no algoritmo de Kahn.",
                                  "learningObjective": "Dominar topological sort como método para resolver dependências.",
                                  "commonMistakes": "Processar nós com dependências pendentes; confundir com BFS/DFS padrão."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar Subproblemas de PD como um DAG",
                                  "subSteps": [
                                    "Identifique subproblemas em um problema PD (ex: dp[i] depende de dp[j] para j < i).",
                                    "Crie nós para cada subproblema.",
                                    "Adicione arestas: de subproblema dependente para o que ele usa.",
                                    "Confirme que o grafo é acíclico devido à definição de subproblemas.",
                                    "Rotule nós com estados PD (ex: tamanho da submochila)."
                                  ],
                                  "verification": "Construa DAG para subproblemas de 'maior caminho em DAG' e valide aciclicidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplo de problema PD (mochila ou LCS), software de grafos.",
                                  "tips": "Pense em 'dp[i]' como nó que requer todos dp[j] para j<i.",
                                  "learningObjective": "Mapear dependências de PD para estrutura de grafo DAG.",
                                  "commonMistakes": "Criar ciclos ao modelar dependências bidirecionais erradas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Ordenação Topológica para Computação Eficiente em PD",
                                  "subSteps": [
                                    "Obtenha ordem topológica do DAG de subproblemas.",
                                    "Inicialize tabela DP com casos base (nós sem entradas).",
                                    "Preencha tabela seguindo a ordem: compute cada subproblema após dependências.",
                                    "Compare com abordagem memoizada recursiva.",
                                    "Meça eficiência: O(n) vs recursão exponencial."
                                  ],
                                  "verification": "Implemente PD bottom-up usando topo sort e verifique resultados contra brute force.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Linguagem de programação (Python), exemplo código de PD.",
                                  "tips": "Use lista de adjacência para representar DAG.",
                                  "learningObjective": "Executar PD tabular via topological sort para eficiência.",
                                  "commonMistakes": "Computar subproblema antes de dependências; ignorar casos base."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e Analisar o Relacionamento",
                                  "subSteps": [
                                    "Explique como Bellman garante aciclicidade (subótimos levam a ótimo).",
                                    "Discuta por que topo sort evita recomputações desnecessárias.",
                                    "Analise complexidade: O(V+E) para topo sort + O(1) por estado.",
                                    "Teste com problema que viola Bellman (tem ciclos).",
                                    "Resuma benefícios para PD geral."
                                  ],
                                  "verification": "Escreva parágrafo explicando o elo e dê contraexemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Resumo escrito, debugger para código PD.",
                                  "tips": "Lembre: Bellman implica DAG natural em subproblemas.",
                                  "learningObjective": "Articular precisamente como Bellman habilita topo sort em PD.",
                                  "commonMistakes": "Assumir todos PD usam grafos explícitos; ignorar problemas com ciclos."
                                }
                              ],
                              "practicalExample": "No problema de 'maior caminho em DAG', subproblemas dp[v] = max(dp[u] + w(u,v) para u predecessores de v). Modelamos como DAG dos vértices originais, topo sort define ordem de computação: inicialize dp[fontes]=0, preencha seguindo ordem, obtendo solução ótima em O(V+E).",
                              "finalVerifications": [
                                "Construa DAG corretamente para um problema PD dado.",
                                "Execute topological sort e preencha tabela DP sem erros.",
                                "Explique verbalmente o papel de Bellman na aciclicidade.",
                                "Compare eficiência com recursão memoizada.",
                                "Identifique e corrija modelagem errada em um exemplo.",
                                "Implemente código funcional em Python."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de dependências como DAG (80% correto).",
                                "Correção da ordem topológica e preenchimento DP.",
                                "Clareza na explicação do princípio de Bellman.",
                                "Eficiência demonstrada em análise de complexidade.",
                                "Criatividade em exemplos e contraexemplos.",
                                "Profundidade em verificações e tips personalizados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Ordenação Linear.",
                                "Ciência da Computação: Algoritmos de Busca e Otimização.",
                                "Engenharia de Software: Gerenciamento de Dependências em Builds.",
                                "Economia: Modelagem de Decisões Sequenciais em Otimização."
                              ],
                              "realWorldApplication": "Em compiladores, topological sort em DAG de dependências de módulos garante ordem de linkage correta; em planejamento de projetos (PERT/CPM), PD com topo sort otimiza cronogramas críticos sem recomputações."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.5",
                    "name": "Memoização (Top-Down)",
                    "description": "Abordagem recursiva com tabela para armazenar e reutilizar soluções de subproblemas.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.5.1",
                        "name": "Recursão com Sobreposição de Subproblemas",
                        "description": "Compreensão da recursão pura e identificação de subproblemas sobrepostos que levam a computações redundantes, justificando a necessidade de memoização na abordagem top-down.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.1.1",
                            "name": "Identificar subproblemas sobrepostos em problemas recursivos",
                            "description": "Analisar uma função recursiva para detectar chamadas recursivas idênticas que são resolvidas múltiplas vezes, como no problema de Fibonacci clássico.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Recursão",
                                  "subSteps": [
                                    "Defina recursão como uma função que chama a si mesma para resolver subproblemas menores.",
                                    "Identifique os componentes essenciais: caso base e chamada recursiva.",
                                    "Estude um exemplo simples sem sobreposição, como fatorial (fact(n) = n * fact(n-1)).",
                                    "Desenhe manualmente a árvore de chamadas para fatorial(4) para visualizar o fluxo.",
                                    "Explique verbalmente por que o fatorial não tem sobreposições."
                                  ],
                                  "verification": "Desenhe corretamente a árvore de chamadas para fatorial(4) sem erros e explique os componentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de código simples (ex: Python IDLE)"
                                  ],
                                  "tips": "Sempre comece pelo caso base para evitar confusão no fluxo.",
                                  "learningObjective": "Compreender os fundamentos da recursão para preparar análise de sobreposições.",
                                  "commonMistakes": [
                                    "Confundir recursão com iteração",
                                    "Esquecer o caso base na árvore"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Problema Clássico de Fibonacci",
                                  "subSteps": [
                                    "Escreva a função recursiva padrão para Fibonacci: fib(n) = fib(n-1) + fib(n-2), com fib(0)=0, fib(1)=1.",
                                    "Execute fib(5) manualmente, listando todas as chamadas recursivas em uma tabela.",
                                    "Desenhe a árvore de recursão completa para fib(5), marcando cada nó com o valor de n.",
                                    "Conte o número total de chamadas para cada subproblema único (ex: quantas fib(3)?).",
                                    "Observe visualmente os ramos idênticos na árvore."
                                  ],
                                  "verification": "A árvore de fib(5) mostra corretamente 8 chamadas para fib(3) e total de 15 chamadas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Ferramenta online de visualização de recursão (ex: recursion-visualizer.com)"
                                  ],
                                  "tips": "Use cores diferentes para destacar chamadas idênticas na árvore.",
                                  "learningObjective": "Visualizar o custo computacional da recursão ingênua em Fibonacci.",
                                  "commonMistakes": [
                                    "Erros no desenho da árvore (ramos errados)",
                                    "Subestimar o número exponencial de chamadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar e Marcar Subproblemas Sobrepostos",
                                  "subSteps": [
                                    "Na árvore de Fibonacci, circule todos os nós com o mesmo valor de n (ex: todos fib(3)).",
                                    "Classifique subproblemas como 'sobrepostos' se o mesmo n aparece mais de uma vez em chamadas independentes.",
                                    "Calcule a frequência de cada subproblema e o tempo total de computação sem memoização.",
                                    "Compare com uma versão sem sobreposição, como soma simples recursiva.",
                                    "Documente o padrão: sobreposições ocorrem quando subproblemas idênticos são resolvidos em ramos diferentes."
                                  ],
                                  "verification": "Liste corretamente 5 subproblemas sobrepostos em fib(5) com suas frequências.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para contar frequências",
                                    "Código Python para simular chamadas"
                                  ],
                                  "tips": "Numere as ocorrências de cada subproblema para rastrear independência.",
                                  "learningObjective": "Desenvolver habilidade para detectar sobreposições por inspeção visual e contagem.",
                                  "commonMistakes": [
                                    "Confundir sobreposição com subproblemas ótimos",
                                    "Ignorar chamadas em ramos irmãos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar para Outros Problemas Recursivos",
                                  "subSteps": [
                                    "Escolha outro problema, como 'sequência de Hanoi' ou 'caminhos em grade', e desenhe sua árvore.",
                                    "Aplique o método: liste chamadas, desenhe árvore, marque sobreposições.",
                                    "Compare Fibonacci com um problema sem sobreposição (ex: potência recursiva).",
                                    "Crie um checklist: 'Mesmos argumentos? Chamadas independentes? Mais de uma ocorrência?'",
                                    "Teste com código: implemente uma função que conta chamadas recursivas."
                                  ],
                                  "verification": "Analise corretamente 2 problemas adicionais, identificando presença/ausência de sobreposições.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python com contador de chamadas",
                                    "Lista de problemas recursivos clássicos"
                                  ],
                                  "tips": "Implemente um decorador para contar chamadas automaticamente no código.",
                                  "learningObjective": "Aplicar o reconhecimento de sobreposições de forma independente em novos problemas.",
                                  "commonMistakes": [
                                    "Generalizar incorretamente de Fibonacci",
                                    "Não considerar argumentos múltiplos"
                                  ]
                                }
                              ],
                              "practicalExample": "No cálculo recursivo de Fibonacci(5), fib(3) é chamado 5 vezes independentemente: fib(5) -> fib(4) -> fib(3), fib(2)->fib(1); e fib(4)->fib(3), etc. Desenhe a árvore para ver fib(3) resolvido repetidamente, desperdiçando computação.",
                              "finalVerifications": [
                                "Desenha árvores de recursão precisas para problemas dados.",
                                "Identifica corretamente todos os subproblemas sobrepostos com frequências.",
                                "Explica por que sobreposições levam a ineficiência exponencial.",
                                "Distingue sobreposições de subproblemas ótimos.",
                                "Aplica checklist em novos problemas recursivos.",
                                "Implementa contador de chamadas em código para validar."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da árvore de recursão (100% dos nós corretos).",
                                "Correta contagem de frequências de subproblemas (erro <5%).",
                                "Explicação clara e concisa das sobreposições detectadas.",
                                "Uso consistente do checklist para generalização.",
                                "Identificação de ausência de sobreposições em controles.",
                                "Eficiência na análise (tempo dentro do estimado)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de árvores e grafos para complexidade.",
                                "Física: Modelagem de sistemas caóticos com recursão (ex: fractais).",
                                "Economia: Otimização de recursos em problemas de alocação dinâmica.",
                                "Biologia: Modelos recursivos em filogenia e árvores evolutivas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, identificar sobreposições permite aplicar memoização para otimizar algoritmos em IA (ex: busca em grafos), jogos (caminhos ótimos) e machine learning (árvores de decisão), reduzindo tempo de execução de horas para segundos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.2",
                            "name": "Comparar recursão pura e recursão memoizada",
                            "description": "Calcular o número de chamadas recursivas em uma recursão pura versus memoizada, demonstrando a redução exponencial para polinomial no tempo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar recursão pura para Fibonacci com contador de chamadas",
                                  "subSteps": [
                                    "Defina a função recursiva fib_pura(n) com casos base: fib(0)=0, fib(1)=1, fib(n)=fib(n-1)+fib(n-2).",
                                    "Adicione um contador global ou parâmetro para registrar cada chamada recursiva.",
                                    "Teste com n=5 e n=10, executando a função e anotando o total de chamadas.",
                                    "Verifique o resultado Fibonacci manualmente para confirmar correção.",
                                    "Registre o tempo de execução aproximado usando timeit ou console."
                                  ],
                                  "verification": "Função retorna Fibonacci correto e contador mostra chamadas exponenciais (ex: 21 para n=5).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (Python ou JavaScript)",
                                    "Documentação de Fibonacci",
                                    "Relógio ou módulo timeit"
                                  ],
                                  "tips": "Use uma variável global para contador para simplicidade; imprima chamadas para depuração.",
                                  "learningObjective": "Implementar recursão pura e quantificar o overhead de chamadas repetidas.",
                                  "commonMistakes": [
                                    "Esquecer casos base levando a loop infinito",
                                    "Não contar chamadas em ambas as ramificações recursivas",
                                    "Confundir chamadas com resultados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar complexidade da recursão pura",
                                  "subSteps": [
                                    "Desenhe a árvore de chamadas recursivas para n=5, contando nós (chamadas).",
                                    "Calcule o número de chamadas: observe padrão 2*fib(n+1)-1.",
                                    "Identifique subproblemas sobrepostos na árvore (ex: fib(3) chamado múltiplas vezes).",
                                    "Estime complexidade temporal como O(φ^n) onde φ≈1.618 (exponencial).",
                                    "Compare tempos de execução para n=20 vs n=30 para demonstrar explosão."
                                  ],
                                  "verification": "Árvore desenhada corretamente e fórmula de chamadas aplicada com precisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para árvore",
                                    "Calculadora",
                                    "Gráfico de complexidade (opcional)"
                                  ],
                                  "tips": "Comece com n pequeno para visualizar árvore; use ferramenta online como recursion-visualizer.",
                                  "learningObjective": "Reconhecer ineficiência exponencial devido a recomputação de subproblemas.",
                                  "commonMistakes": [
                                    "Contar apenas folhas da árvore",
                                    "Ignorar chamadas em fib(n-2)",
                                    "Confundir complexidade espacial com temporal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar recursão memoizada com contador de chamadas",
                                  "subSteps": [
                                    "Crie um dicionário memo vazio para armazenar resultados computados.",
                                    "Modifique fib_memo(n): se n em memo, retorne memo[n]; senão compute recursivamente e armazene.",
                                    "Adicione contador similar ao passo 1 para registrar chamadas.",
                                    "Teste com n=10 e n=30, anotando chamadas e tempo.",
                                    "Confirme que todos subproblemas são resolvidos linearmente."
                                  ],
                                  "verification": "Chamadas lineares (≈2n+1) e tempo muito menor para n grande.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Dicionário Python ou Map JS"
                                  ],
                                  "tips": "Inicialize memo com casos base para eficiência; teste vazamento de memória em n grande.",
                                  "learningObjective": "Aplicar memoização para evitar recomputação, transformando recursão em linear.",
                                  "commonMistakes": [
                                    "Não verificar memo antes de recursão",
                                    "Chaves erradas no dicionário",
                                    "Contador não resetado entre testes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar recursão pura e memoizada quantitativamente",
                                  "subSteps": [
                                    "Execute ambas funções para n=5,10,15,20 e tabule chamadas/tempos.",
                                    "Calcule razão: chamadas_pura / chamadas_memo, mostrando redução exponencial para linear.",
                                    "Plote gráfico de chamadas vs n para visualização.",
                                    "Explique redução de O(2^n) para O(n) em termos de sobreposição.",
                                    "Discuta trade-offs: memo usa O(n) espaço extra."
                                  ],
                                  "verification": "Tabela/gráfico mostra memo << pura para n>10; explicação coerente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel/Google Sheets",
                                    "Biblioteca matplotlib (opcional)"
                                  ],
                                  "tips": "Use loop para múltiplos n; normalize tempos em máquina mesma.",
                                  "learningObjective": "Demonstrar ganho polinomial via memoização em problemas com sobreposição.",
                                  "commonMistakes": [
                                    "Testar n muito pequeno sem diferença visível",
                                    "Ignorar custo espacial da memo",
                                    "Gráfico em escala log errada"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Fibonacci(10): Recursão pura faz 177 chamadas (tempo ~0.1s), memoizada faz 21 chamadas (tempo ~0.001s). Para n=30, pura é inviável (>1M chamadas), memo instantânea.",
                              "finalVerifications": [
                                "Contar corretamente chamadas para fib_pura(6)=13 chamadas.",
                                "Implementar fib_memo(20) com <50 chamadas.",
                                "Explicar árvore de chamadas memoizada como linear.",
                                "Calcular razão de chamadas para n=15: ~89x redução.",
                                "Medir tempo real mostrando speedup >100x para n=25.",
                                "Identificar subproblemas sobrepostos em pelo menos 3 exemplos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de chamadas recursivas em ambas implementações.",
                                "Análise correta de complexidade: exponencial vs linear.",
                                "Implementação funcional sem bugs em memoização.",
                                "Visualização clara (tabela/gráfico) da comparação.",
                                "Explicação verbal da redução exponencial para polinomial.",
                                "Consideração de trade-offs (espaço/tempo)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e sequências Fibonacci.",
                                "Engenharia de Software: Otimização de performance e profiling.",
                                "Física/Química: Modelagem recursiva em simulações dinâmicas.",
                                "Economia: Otimização de recursos computacionais em big data."
                              ],
                              "realWorldApplication": "Em algoritmos de grafos (ex: caminhos mais curtos com memo em Dijkstra top-down), processamento de linguagem natural (parsing recursivo memoizado), jogos (busca minimax com cache), e machine learning (caching em reinforcement learning para evitar recomputações custosas)."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.1.3",
                            "name": "Definir estados para subproblemas",
                            "description": "Mapear parâmetros de entrada da recursão para estados únicos que representem subproblemas, garantindo unicidade na memoização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Função Recursiva Original",
                                  "subSteps": [
                                    "Examine a assinatura da função recursiva e liste todos os parâmetros de entrada.",
                                    "Descreva o que cada parâmetro representa no contexto do problema (ex: índice de moeda, valor restante).",
                                    "Trace 2-3 chamadas recursivas manuais para identificar padrões de subproblemas.",
                                    "Anote dependências entre chamadas recursivas.",
                                    "Registre o problema principal e como ele se divide em subproblemas."
                                  ],
                                  "verification": "Lista completa de parâmetros com descrições e diagrama de chamadas recursivas desenhado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou quadro branco",
                                    "Código fonte da função recursiva",
                                    "Editor de texto"
                                  ],
                                  "tips": "Comece pelo caso base para entender o fluxo ascendente dos subproblemas.",
                                  "learningObjective": "Compreender como os parâmetros da recursão definem o escopo de cada subproblema.",
                                  "commonMistakes": "Ignorar parâmetros auxiliares que afetam a solução única."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Parâmetros que Definem Estados Únicos",
                                  "subSteps": [
                                    "Classifique parâmetros como variáveis (mudam por subproblema) ou fixos (constantes do problema).",
                                    "Teste se combinações diferentes de parâmetros levam a soluções independentes.",
                                    "Elimine parâmetros redundantes que podem ser derivados de outros.",
                                    "Verifique sobreposição: encontre subproblemas idênticos em diferentes ramos da recursão.",
                                    "Documente por que cada parâmetro selecionado é essencial para unicidade."
                                  ],
                                  "verification": "Tabela ou lista priorizando parâmetros com justificativas e exemplos de sobreposição.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela em editor de texto",
                                    "Exemplos de chamadas recursivas do Step 1"
                                  ],
                                  "tips": "Use o critério: 'Dois subproblemas têm o mesmo estado se geram a mesma solução independente do caminho'.",
                                  "learningObjective": "Selecionar parâmetros que capturam a essência única de cada subproblema.",
                                  "commonMistakes": "Incluir parâmetros desnecessários, levando a estados inchados e ineficientes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a Chave de Estado para Memoização",
                                  "subSteps": [
                                    "Combine parâmetros selecionados em uma tupla ou estrutura hashável (ex: (index, remaining)).",
                                    "Defina o formato do estado: array, string ou objeto, garantindo hash único.",
                                    "Implemente um protótipo de mapa/memo com 3-5 entradas de teste.",
                                    "Ajuste para cobrir todos os casos de borda (ex: valores zero ou máximos).",
                                    "Escreva pseudocódigo da função memoizada usando o novo estado."
                                  ],
                                  "verification": "Pseudocódigo funcional com chave de estado e pelo menos 3 testes manuais de lookup.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código ou IDE",
                                    "Dicionário ou mapa para simular memo"
                                  ],
                                  "tips": "Garanta imutabilidade da chave para evitar erros de hash em linguagens como Python.",
                                  "learningObjective": "Criar uma representação compacta e única do estado para armazenamento eficiente.",
                                  "commonMistakes": "Criar chaves não-hasháveis ou que colidem (ex: usar listas mutáveis como chaves)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Refinar a Definição de Estados",
                                  "subSteps": [
                                    "Simule a execução recursiva completa usando o memo e conte hits de cache.",
                                    "Identifique subproblemas não cobertos ou duplicados incorretamente.",
                                    "Meça redução de chamadas recursivas (comparar com versão sem memo).",
                                    "Teste com inputs variados para confirmar unicidade em todos os ramos.",
                                    "Refine a definição se necessário e documente mudanças."
                                  ],
                                  "verification": "Relatório com contagem de chamadas antes/depois e testes passando sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código de teste unitário",
                                    "Debugger ou print statements"
                                  ],
                                  "tips": "Use contadores de chamadas para quantificar a sobreposição resolvida.",
                                  "learningObjective": "Garantir que os estados capturem toda a sobreposição sem redundâncias.",
                                  "commonMistakes": "Sobrestimar unicidade, levando a recomputações desnecessárias."
                                }
                              ],
                              "practicalExample": "No problema de 'Número Mínimo de Moedas' (minCoins(coins, amount)), a recursão usa parâmetros index (posição na lista de moedas) e remaining (valor restante). O estado é definido como (index, remaining), permitindo memoizar soluções como dp[3][15] = 2, evitando recomputar subproblemas como fazer 15 com moedas a partir da 3ª.",
                              "finalVerifications": [
                                "Todos os parâmetros relevantes da recursão são mapeados para o estado.",
                                "Chave de estado gera hashes únicos para subproblemas distintos.",
                                "Simulação mostra hits de memo > 30% das chamadas recursivas.",
                                "Casos de borda (ex: amount=0, index=max) são tratados corretamente.",
                                "Pseudocódigo memoizado resolve o problema original sem alterações lógicas.",
                                "Nenhum colisão de estado detectada em testes com 5+ inputs variados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de parâmetros essenciais (sem omissões ou extras).",
                                "Unicidade comprovada da chave de estado via testes de simulação.",
                                "Eficiência demonstrada por redução mensurável de chamadas recursivas.",
                                "Documentação clara com justificativas e exemplos.",
                                "Tratamento completo de casos de borda e sobreposições.",
                                "Pseudocódigo executável e livre de erros comuns de memoização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estados como funções compostas de variáveis independentes (semelhante a coordenadas cartesianas).",
                                "Banco de Dados: Chaves primárias compostas garantindo unicidade em tabelas.",
                                "Engenharia de Software: Design de caches com chaves hasháveis para otimização de performance.",
                                "Lógica e Filosofia: Representação canônica de problemas para evitar ambiguidades."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação como Netflix, estados (user_id, watch_history_slice) memoizam predições de conteúdo, reduzindo tempo de computação em milhões de consultas diárias e escalando para big data."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.2",
                        "name": "Estrutura da Tabela de Memoização",
                        "description": "Projeto e inicialização de uma tabela auxiliar para armazenar resultados de subproblemas já computados, utilizando estruturas de dados adequadas como arrays ou dicionários.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.2.1",
                            "name": "Escolher estrutura de dados para memoização",
                            "description": "Selecionar array para índices discretos ou dicionário (map/hash) para estados multidimensionais, considerando espaço e tempo de acesso O(1).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a definição e dimensionalidade do estado na memoização",
                                  "subSteps": [
                                    "Defina o estado recursivo claramente, identificando todos os parâmetros que variam (ex: índice único ou múltiplos índices)",
                                    "Determine se os valores dos parâmetros são discretos e contínuos (ex: 0 a n) ou esparsos/arbitrários",
                                    "Classifique a dimensionalidade: unidimensional (1 param), bidimensional (2 params), etc.",
                                    "Liste os bounds conhecidos para cada dimensão (mínimo e máximo esperados)",
                                    "Registre o tamanho estimado do espaço de estados (produto dos bounds)"
                                  ],
                                  "verification": "Descreva o estado em uma frase e liste sua dimensionalidade e bounds em uma tabela simples",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook com Python ou pseudocódigo",
                                    "Descrição do problema DP",
                                    "Papel e caneta para esboços"
                                  ],
                                  "tips": [
                                    "Comece sempre pelo estado mais simples possível antes de expandir",
                                    "Use diagramas de recursão para visualizar chamadas"
                                  ],
                                  "learningObjective": "Identificar precisamente a dimensionalidade e bounds do estado para guiar a escolha da estrutura",
                                  "commonMistakes": [
                                    "Confundir parâmetros de entrada com estado memoizado",
                                    "Ignorar valores negativos ou fracionários nos bounds",
                                    "Subestimar o tamanho total do espaço de estados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Avaliar trade-offs de array versus dicionário (hashmap)",
                                  "subSteps": [
                                    "Para estados discretos com bounds pequenos e conhecidos: prefira array (acesso O(1), menor overhead de memória)",
                                    "Para estados multidimensionais ou esparsos: use hashmap (flexível, só armazena estados visitados)",
                                    "Calcule espaço: array = produto(bounds) * sizeof(valor); hashmap ≈ num_estados_visitados * (chave + valor)",
                                    "Compare tempo: ambos O(1) médio, mas array é mais rápido e previsível sem colisões",
                                    "Considere linguagens: arrays multidim em Python (listas aninhadas), maps nativos (dict)"
                                  ],
                                  "verification": "Crie uma tabela comparativa com colunas: Estrutura, Espaço, Tempo, Prós, Contras para o seu estado",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python para simular tamanhos",
                                    "Documentação de dict em Python/JS",
                                    "Exemplos de problemas DP clássicos"
                                  ],
                                  "tips": [
                                    "Teste com n=1000 para bounds grandes: array pode explodir em memória",
                                    "Hashmaps são ideais se <10% dos estados forem visitados"
                                  ],
                                  "learningObjective": "Comparar quantitativamente array e hashmap considerando O(1) acesso e otimização de espaço/tempo",
                                  "commonMistakes": [
                                    "Assumir array sempre melhor sem checar bounds",
                                    "Usar hashmap para estados densos (overhead desnecessário)",
                                    "Esquecer hashing de tuplas multidim como chave"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar e justificar a estrutura de dados ideal",
                                  "subSteps": [
                                    "Escolha array se: 1D ou 2D baixa dim, bounds <=10^4 por dim, denso",
                                    "Escolha hashmap se: >2D, bounds altos/esparsos, estados dinâmicos",
                                    "Justifique com métricas: espaço estimado <1GB? Tempo aceitável?",
                                    "Defina assinatura: array[estado1][estado2]... ou memo[state_tuple] = valor",
                                    "Planeje tratamento de valores inválidos (ex: -1 para não computado)"
                                  ],
                                  "verification": "Escreva um parágrafo justificando a escolha com números de espaço/tempo para um caso teste",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo do esqueleto recursivo+memo",
                                    "Ferramentas de profiling como timeit em Python"
                                  ],
                                  "tips": [
                                    "Para 2D, teste array vs map em um mini-exemplo",
                                    "Prefira array em competições por velocidade"
                                  ],
                                  "learningObjective": "Tomar decisão informada baseada em análise quantitativa e qualitativa",
                                  "commonMistakes": [
                                    "Escolher array para multidimensional sem bounds",
                                    "Não inicializar memo adequadamente",
                                    "Ignorar custo de serialização de chaves complexas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar, testar e otimizar a estrutura escolhida",
                                  "subSteps": [
                                    "Implemente a função recursiva com memo usando a estrutura selecionada",
                                    "Teste com inputs pequenos: verifique corretude e ausência de recomputação",
                                    "Meça performance: tempo e memória para input grande",
                                    "Otimize se necessário: mude para hashmap se array OOM, ou vice-versa",
                                    "Documente lições: quando a escolha falhou e por quê"
                                  ],
                                  "verification": "Execute testes unitários mostrando O(1) acesso e corretude; compare com versão sem memo",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente Python/JS com profiler (cProfile, memory_profiler)",
                                    "Casos de teste variados (pequeno/grande/esparso)"
                                  ],
                                  "tips": [
                                    "Use @lru_cache como baseline para validação",
                                    "Monitore colisões em hashmap com logging"
                                  ],
                                  "learningObjective": "Validar empiricamente a escolha e iterar para otimização",
                                  "commonMistakes": [
                                    "Não testar casos extremos (bounds max)",
                                    "Vazar memória com chaves não hasháveis",
                                    "Comparar só tempo, ignorando espaço"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema Fibonacci(n): estado = índice i (0 a n, discreto), use array memo = [-1]*(n+1). No Knapsack 0/1 com weights/pesos multidim: estado=(i,w) esparso se w grande, use dict com chave (i,w): memo[(i,w)] = -1.",
                              "finalVerifications": [
                                "Explica corretamente quando usar array vs hashmap com exemplo pessoal",
                                "Calcula espaço para um estado dado com precisão",
                                "Implementa memoização funcional em código para problema teste",
                                "Identifica e corrige erro comum como estado mal definido",
                                "Compara performance de array vs map em benchmark simples",
                                "Justifica escolha considerando constraints de tempo/espaço"
                              ],
                              "assessmentCriteria": [
                                "Análise de estado precisa e completa (30%)",
                                "Comparação quantitativa de trade-offs (25%)",
                                "Justificativa fundamentada e correta (20%)",
                                "Implementação funcional com testes (15%)",
                                "Otimização e lições aprendidas (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de recorrências e complexidade assintótica O(1)",
                                "Estruturas de Dados: Trade-offs hash tables vs arrays fixos",
                                "Algoritmos: Otimização bottom-up vs top-down",
                                "Engenharia de Software: Profiling e benchmarking de performance"
                              ],
                              "realWorldApplication": "Em sistemas de cache como Redis (hashmaps para chaves arbitrárias) ou navegadores web (arrays para histórico indexado), otimizando consultas O(1) em apps de ML para memoizar computações caras em grids multidim."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.2",
                            "name": "Inicializar tabela com valores sentinelas",
                            "description": "Preencher a tabela com -1 ou valores nulos para indicar subproblemas não resolvidos, evitando redefinições desnecessárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o propósito dos valores sentinelas na memoização top-down",
                                  "subSteps": [
                                    "Estude o problema de redefinição desnecessária em recursão pura, onde subproblemas são resolvidos múltiplas vezes.",
                                    "Aprenda que valores sentinelas (ex: -1) marcam estados 'não computados' na tabela de memoização.",
                                    "Compare com inicialização bottom-up, destacando a preguiça da abordagem top-down.",
                                    "Identifique cenários onde sentinelas evitam loops infinitos ou computações redundantes.",
                                    "Revise exemplos simples como Fibonacci recursivo sem memoização vs. com sentinelas."
                                  ],
                                  "verification": "Explique em suas palavras por que usar -1 em vez de 0 ou null, e liste 2 vantagens.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação de Programação Dinâmica",
                                    "Exemplos de código Python para Fibonacci"
                                  ],
                                  "tips": "Sempre pense no valor sentinela como um 'flag' de 'pendente', não como um resultado válido.",
                                  "learningObjective": "Entender o papel conceitual dos sentinelas para evitar recomputações.",
                                  "commonMistakes": [
                                    "Confundir sentinela com valor inicial zero",
                                    "Usar valores válidos do problema como sentinelas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Determinar dimensões e estrutura da tabela de memoização",
                                  "subSteps": [
                                    "Analise os parâmetros do problema recursivo (ex: índices i e j para 2D).",
                                    "Defina o tamanho da tabela: para 1D, [n+1]; para 2D, [[n+1] * (m+1)].",
                                    "Considere o tipo de dados: lista de listas em Python para multidimensional.",
                                    "Planeje o índice base: geralmente memo[0] ou memo[i][0] para casos base.",
                                    "Teste dimensões com um problema pequeno, como Fibonacci(n=5)."
                                  ],
                                  "verification": "Crie uma tabela vazia com dimensões corretas e imprima para confirmar shape.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Referência de problemas DP como Knapsack ou LCS"
                                  ],
                                  "tips": "Use len(problem_size) + 1 para cobrir todos os subproblemas possíveis.",
                                  "learningObjective": "Dimensionar corretamente a tabela para mapear todos os subproblemas.",
                                  "commonMistakes": [
                                    "Índices off-by-one",
                                    "Tabelas muito pequenas que causam IndexError"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a inicialização com valores sentinelas",
                                  "subSteps": [
                                    "Crie a tabela usando list comprehension: memo = [[-1 for _ in range(m+1)] for _ in range(n+1)].",
                                    "Preencha todos os elementos com o valor sentinela escolhido (-1 ou float('-inf')).",
                                    "Defina casos base explicitamente se necessário (ex: memo[0][0] = 0).",
                                    "Integre a tabela como parâmetro global ou passado por referência na função recursiva.",
                                    "Execute uma chamada inicial para testar: print(memo) deve mostrar só -1s."
                                  ],
                                  "verification": "Inspecione a tabela impressa: todos elementos devem ser -1 exceto casos base definidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python interpreter",
                                    "Código template de memoização top-down"
                                  ],
                                  "tips": "Evite loops aninhados desnecessários; use comprehensions para eficiência.",
                                  "learningObjective": "Codificar a inicialização de forma limpa e escalável.",
                                  "commonMistakes": [
                                    "Inicializar com [[]] * size (shallow copy)",
                                    "Esquecer de atualizar casos base"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e integrar na função recursiva completa",
                                  "subSteps": [
                                    "Na função recursiva, cheque if memo[i][j] != -1: return memo[i][j].",
                                    "Calcule o subproblema e armazene: memo[i][j] = resultado.",
                                    "Teste com input pequeno: rode fib(5) e verifique se memo preenche corretamente.",
                                    "Meça performance: compare tempo com/sem memoização.",
                                    "Debugue: use breakpoints para rastrear acessos à tabela."
                                  ],
                                  "verification": "Execute o código completo; tabela deve ter valores computados sem duplicatas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código completo de exemplo (Fibonacci ou Knapsack)",
                                    "Timer para performance"
                                  ],
                                  "tips": "Sempre retorne o valor memoizado ANTES de computar para evitar recursão desnecessária.",
                                  "learningObjective": "Integrar inicialização em um fluxo recursivo funcional.",
                                  "commonMistakes": [
                                    "Checar == -1 em vez de != -1",
                                    "Não armazenar após calcular"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Fibonacci memoizado: def fib(n, memo=[-1] * 51): if n <= 1: return n; if memo[n] != -1: return memo[n]; memo[n] = fib(n-1, memo) + fib(n-2, memo); return memo[n]. Inicialize memo com 51 slots de -1 para n até 50.",
                              "finalVerifications": [
                                "Tabela inicial impressa mostra exclusivamente -1s (exceto casos base).",
                                "Função recursiva acessa memo corretamente sem recomputações.",
                                "Performance melhora: tempo para fib(40) < 1ms vs. recursão pura.",
                                "Nenhum IndexError ou recursão infinita ocorre.",
                                "Valores finais na memo correspondem à solução ótima.",
                                "Teste com múltiplas chamadas: usa cache corretamente."
                              ],
                              "assessmentCriteria": [
                                "Uso correto de valor sentinela não-conflictante (-1 ou None).",
                                "Dimensões da tabela cobrem todos subproblemas sem overflow.",
                                "Inicialização eficiente (O(1) ou O(n) via comprehension).",
                                "Integração perfeita na recursão: check antes de compute.",
                                "Código limpo, legível com comentários.",
                                "Testes unitários passam para casos edge (n=0,1)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de dados discretas e teoria de grafos (DAGs em DP).",
                                "Ciência da Computação: Otimização e análise de complexidade (O(n) space).",
                                "Engenharia de Software: Padrões de caching e lazy evaluation.",
                                "Estatística: Memoização similar a tabelas de lookup em simulações Monte Carlo."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), memoização com tabelas sentinelas acelera cálculos de similaridade entre usuários; em jogos (xadrez AI), armazena estados de tabuleiro para poda alfa-beta eficiente."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.2.3",
                            "name": "Verificar e atualizar tabela durante recursão",
                            "description": "Implementar verificação if (memo[estado] != -1) return memo[estado]; antes da recursão e memo[estado] = resultado; após computar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar a verificação de cache hit no início da função recursiva",
                                  "subSteps": [
                                    "Identifique o parâmetro 'estado' que representa o estado atual da recursão (ex: índice n em Fibonacci).",
                                    "No topo da função recursiva, adicione a condição: if (memo[estado] != -1) { return memo[estado]; }",
                                    "Inicialize a tabela memo com -1 em todos os índices relevantes antes da primeira chamada recursiva.",
                                    "Compile e execute o código para verificar sintaxe sem erros.",
                                    "Adicione um console.log para depurar: 'Cache hit para estado X'."
                                  ],
                                  "verification": "Execute a função com um valor pequeno; verifique se retorna imediatamente se o estado já foi computado em chamadas anteriores.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code), linguagem JavaScript ou Python, exemplo de função recursiva sem memo.",
                                  "tips": "Use -1 como sentinel value para indicar 'não computado'; evite 0 se 0 for um resultado válido.",
                                  "learningObjective": "Compreender e implementar a checagem de valor pré-computado para evitar recomputações desnecessárias.",
                                  "commonMistakes": "Esquecer de inicializar memo com -1; usar == em vez de !=; colocar a checagem após a recursão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estruturar o cálculo recursivo após a verificação",
                                  "subSteps": [
                                    "Após o if de cache hit, inicie o bloco de cálculo: defina resultado = recursão para sub-estados.",
                                    "Exemplo em Fibonacci: resultado = fib(n-1) + fib(n-2);",
                                    "Garanta que as chamadas recursivas usem o mesmo memo compartilhado.",
                                    "Adicione logs para rastrear: 'Calculando estado X recursivamente'.",
                                    "Teste com n=3 para observar chamadas aninhadas."
                                  ],
                                  "verification": "Use debugger ou logs para confirmar que o cálculo só ocorre se memo[estado] == -1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo editor, debugger do navegador ou IDE, papel para desenhar árvore de recursão.",
                                  "tips": "Desenhe a árvore de chamadas em papel para visualizar onde o cache será hit.",
                                  "learningObjective": "Integrar recursão condicional à memoização, garantindo progressão apenas quando necessário.",
                                  "commonMistakes": "Chamar recursão antes da checagem; não passar memo corretamente nas chamadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atualizar a tabela de memoização com o resultado computado",
                                  "subSteps": [
                                    "Após calcular o resultado, adicione: memo[estado] = resultado;",
                                    "Posicione esta linha imediatamente antes do return resultado;",
                                    "Verifique se o tipo do resultado é compatível com memo (inteiro, etc.).",
                                    "Execute com n=5 e inspecione o array memo após execução.",
                                    "Confirme que todos os estados visitados foram preenchidos."
                                  ],
                                  "verification": "Após execução completa, console.log(memo) deve mostrar valores != -1 nos estados computados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código, console do navegador para inspecionar arrays.",
                                  "tips": "Coloque a atualização logo após o cálculo para evitar perda de dados em erros.",
                                  "learningObjective": "Garantir persistência do resultado computado para futuras consultas.",
                                  "commonMistakes": "Atualizar memo antes do cálculo (causa valores errados); esquecer o return após update."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar a implementação completa de memoização",
                                  "subSteps": [
                                    "Execute a função para n=10 e n=20; compare tempo com versão sem memo.",
                                    "Verifique se evita explosão de chamadas (ex: fib(40) sem memo trava, com memo é rápido).",
                                    "Teste casos base (n=0, n=1) para garantir que memo não sobrescreva incorretamente.",
                                    "Remova logs e otimize se necessário.",
                                    "Documente a função com comentários explicando as linhas de memo."
                                  ],
                                  "verification": "Medir tempo de execução: deve ser O(n) em vez de exponencial; todos estados de 0 a n preenchidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Cronômetro ou performance.now() em JS, casos de teste pré-definidos.",
                                  "tips": "Use performance metrics para quantificar ganho; teste com estados repetidos.",
                                  "learningObjective": "Validar que a memoização top-down otimiza corretamente a recursão.",
                                  "commonMistakes": "Índice fora de bounds em memo; não tratar casos base antes de memo."
                                }
                              ],
                              "practicalExample": "No cálculo de Fibonacci com memoização: função fib(n) { if (memo[n] != -1) return memo[n]; if (n <= 1) return n; let res = fib(n-1) + fib(n-2); memo[n] = res; return res; }. Para fib(5), memo[5]==-1 → calcula fib(4)+fib(3) → armazena 5; na próxima fib(3), retorna direto do memo.",
                              "finalVerifications": [
                                "A função sempre checa memo[estado] != -1 antes de recursão.",
                                "Resultado é armazenado em memo apenas após cálculo completo.",
                                "Execução para n=30 completa em <1s, sem stack overflow.",
                                "Todos estados de 0 a n têm valores corretos em memo.",
                                "Sem chamadas recursivas redundantes (ver logs ou contador).",
                                "Casos base são respeitados independentemente de memo."
                              ],
                              "assessmentCriteria": [
                                "Código contém if (memo[estado] != -1) return; no topo.",
                                "Atualização memo[estado] = resultado; antes do return final.",
                                "Memo inicializada com -1 e tamanho adequado.",
                                "Função recursiva evita recomputações (teste empírico).",
                                "Comentários explicam lógica de memoização.",
                                "Sem erros de índice ou tipo em memo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Compreensão de recursões e árvores de chamadas.",
                                "Estruturas de Dados: Uso de arrays/objetos como cache.",
                                "Análise de Algoritmos: Complexidade temporal O(n) vs exponencial.",
                                "Debugging e Testing: Logs e verificações unitárias."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), cache de subproblemas em grafos de usuários para evitar recomputações caras; em jogos, memoização de estados de tabuleiro para IA eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.5.3",
                        "name": "Implementação Top-Down Completa",
                        "description": "Desenvolvimento de uma solução memoizada top-down para problemas clássicos, integrando recursão, tabela e condições base.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.5.3.1",
                            "name": "Implementar memoização em Fibonacci",
                            "description": "Codificar função fib(n) com memoização top-down em pseudocódigo ou C++/Python, verificando tempo de execução para n=40+.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar Fibonacci Recursivo Simples",
                                  "subSteps": [
                                    "Escreva uma função recursiva básica fib(n) que retorna o n-ésimo número de Fibonacci.",
                                    "Defina casos base: fib(0) = 0, fib(1) = 1.",
                                    "Implemente a recursão: fib(n) = fib(n-1) + fib(n-2).",
                                    "Teste com valores pequenos (n=5, n=10) para validar resultados.",
                                    "Meça o tempo de execução para n=30 usando timeit ou similar."
                                  ],
                                  "verification": "Execute fib(10) e confirme que retorna 55; observe lentidão crescente para n>30.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Python instalado",
                                    "Biblioteca timeit"
                                  ],
                                  "tips": "Use print statements para visualizar chamadas recursivas e entender a árvore de recursão.",
                                  "learningObjective": "Compreender o problema exponencial da recursão ingênua em Fibonacci.",
                                  "commonMistakes": [
                                    "Esquecer casos base levando a recursão infinita",
                                    "Confundir índices (fib(0)=0, fib(1)=1)",
                                    "Não medir tempo corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Sobreposição de Subproblemas",
                                  "subSteps": [
                                    "Adicione contadores globais para rastrear chamadas de fib(n-1) e fib(n-2).",
                                    "Execute para n=30 e anote quantas vezes cada subproblema é computado.",
                                    "Desenhe a árvore de recursão em papel para n=5, destacando subproblemas repetidos.",
                                    "Calcule complexidade temporal: confirme O(2^n) chamadas.",
                                    "Discuta por que memoização resolve isso (armazenar resultados já computados)."
                                  ],
                                  "verification": "Relatório mostrando >1 chamadas para o mesmo subproblema (ex: fib(5) chamado múltiplas vezes).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para diagrama",
                                    "Código Python com contadores"
                                  ],
                                  "tips": "Use um dicionário temporário para contar chamadas únicas vs totais.",
                                  "learningObjective": "Reconhecer padrões de sobreposição que justificam memoização top-down.",
                                  "commonMistakes": [
                                    "Ignorar contadores e subestimar redundância",
                                    "Confundir sobreposição com optimal substructure"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Memoização Top-Down",
                                  "subSteps": [
                                    "Crie um dicionário memo vazio como parâmetro ou global.",
                                    "No início de fib(n), verifique se n está em memo; se sim, retorne memo[n].",
                                    "Se não, compute recursivamente, armazene em memo[n] e retorne.",
                                    "Atualize a função para passar memo recursivamente.",
                                    "Teste com n=10, confirmando que cache é populado corretamente."
                                  ],
                                  "verification": "Inspecione memo após execução: deve conter todos subproblemas de 0 a n.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com dicionário",
                                    "Exemplos de código online para referência (não copiar)"
                                  ],
                                  "tips": "Use @lru_cache(None) do functools para protótipo rápido, mas implemente manualmente depois.",
                                  "learningObjective": "Codificar memoização top-down, garantindo preenchimento lazy do cache.",
                                  "commonMistakes": [
                                    "Não passar memo recursivamente",
                                    "Chaves erradas no dicionário (use int n)",
                                    "Cache não atualizado antes do return"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar Performance para n=40+",
                                  "subSteps": [
                                    "Meça tempo de execução recursivo vs memoizado para n=40 usando time.perf_counter().",
                                    "Execute 10 vezes e calcule média para precisão.",
                                    "Compare: recursivo deve falhar/ser lento (>1s), memoizado <1ms.",
                                    "Verifique resultado correto: fib(40) = 102334155.",
                                    "Analise cache: deve ter exatamente 41 entradas (0 a 40)."
                                  ],
                                  "verification": "Tempo memoizado < 1ms para n=40; resultado exato; cache size=41.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "time.perf_counter()",
                                    "Conhecido fib(40)=102334155 para validação"
                                  ],
                                  "tips": "Aumente recursão limit se necessário com sys.setrecursionlimit(1000).",
                                  "learningObjective": "Validar ganhos de performance da memoização empiricamente.",
                                  "commonMistakes": [
                                    "Medir tempo sem aquecimento/warmup",
                                    "Usar n pequeno onde diferença é imperceptível",
                                    "Erro em comparação de tempos"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente fib_memo(40) em Python: deve retornar 102334155 em milissegundos, enquanto fib_recursivo(40) leva minutos ou trava. Exemplo de código: def fib(n, memo={}): if n in memo: return memo[n]; if n<=1: return n; memo[n] = fib(n-1,memo) + fib(n-2,memo); return memo[n]. Tempo: ~0.1ms vs >60s.",
                              "finalVerifications": [
                                "Função retorna fib(40) = 102334155 corretamente.",
                                "Cache contém 41 entradas únicas após execução.",
                                "Tempo de execução para n=40 < 10ms em máquina padrão.",
                                "Nenhuma recursão infinita ou stack overflow.",
                                "Contadores mostram redução de chamadas de O(2^n) para O(n).",
                                "Código funciona em pseudocódigo, Python e C++ equivalentes."
                              ],
                              "assessmentCriteria": [
                                "Correção: Resultados idênticos à sequência Fibonacci padrão.",
                                "Eficiência: Complexidade temporal O(n) via cache hits.",
                                "Estrutura: Memoização top-down com verificação pré-computação.",
                                "Robustez: Lida com n=0,1 e n>40 sem erros.",
                                "Clareza: Código legível com comentários em pontos chave.",
                                "Performance mensurável: Relatório de tempos antes/depois."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Sequências recursivas e propriedades de Fibonacci (proporção áurea).",
                                "Engenharia de Software: Otimização de algoritmos e profiling de performance.",
                                "Ciência da Computação: Análise de complexidade Big-O em recursão vs DP.",
                                "Física: Modelagem de crescimento populacional (coelhos de Fibonacci).",
                                "Economia: Otimização em problemas de alocação dinâmica."
                              ],
                              "realWorldApplication": "Em machine learning, memoização otimiza cálculos recursivos em árvores de decisão ou pathfinding em jogos (ex: A* com heurísticas); em finanças, acelera simulações de opções binomiais; em compiladores, caches resultados de parsing recursivo descendente."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.2",
                            "name": "Aplicar memoização em problema de mochila 0/1",
                            "description": "Desenvolver recursão top-down para knapsack com estados (indice, peso_atual), usando tabela 2D para memoizar decisões ótimas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Problema da Mochila 0/1 e Definir Estados",
                                  "subSteps": [
                                    "Analise o problema: dado itens com pesos e valores, e capacidade W, maximize valor sem exceder W, cada item 0 ou 1 vez.",
                                    "Defina parâmetros: array weights[], values[], capacidade W, n itens.",
                                    "Identifique estados recursivos: dp(index, peso_atual) = max valor de index ao fim com peso_atual restante.",
                                    "Esboce árvore de recursão manual para pequeno exemplo (n=3, W=5).",
                                    "Liste casos base: index == n (0), peso_atual == 0 (0), peso_atual < 0 (inviável)."
                                  ],
                                  "verification": "Escreva pseudocódigo da recursão base e valide com exemplo manual.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de código (VS Code ou similar)",
                                    "Documentação Knapsack Wikipedia"
                                  ],
                                  "tips": "Comece com exemplo pequeno para visualizar explosão de chamadas recursivas.",
                                  "learningObjective": "Compreender estados e recursão pura para Knapsack.",
                                  "commonMistakes": [
                                    "Confundir peso restante com peso usado",
                                    "Ignorar caso peso_atual < weights[index]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Recursão Top-Down Sem Memoização",
                                  "subSteps": [
                                    "Crie função recursiva knapsack(index, peso_atual) retornando max valor.",
                                    "Implemente: se index == n ou peso_atual == 0, retorne 0.",
                                    "Caso 1: não pegar item: knapsack(index+1, peso_atual).",
                                    "Caso 2: se peso_atual >= weights[index], max( caso1, values[index] + knapsack(index+1, peso_atual - weights[index]) ).",
                                    "Teste com input pequeno: weights=[1,3,4], values=[1,4,5], W=7; espere 9."
                                  ],
                                  "verification": "Execute e observe tempo/recursões para n=20; deve ser lento (~2^n chamadas).",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Linguagem Python ou JavaScript",
                                    "Ferramenta de profiling recursão (print contador)"
                                  ],
                                  "tips": "Adicione contador global de chamadas para medir ineficiência.",
                                  "learningObjective": "Codificar recursão base e observar problema exponencial.",
                                  "commonMistakes": [
                                    "Retornar min em vez de max",
                                    "Índice off-by-one",
                                    "Não tratar peso negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Memoização com Tabela 2D",
                                  "subStates": [
                                    "Crie tabela memo[n+1][W+1], inicializada com -1 (não computado).",
                                    "Modifique função: se memo[index][peso_atual] != -1, retorne valor.",
                                    "Após computar, armazene em memo[index][peso_atual] antes de retornar.",
                                    "Chame recursão: knapsack(0, W).",
                                    "Implemente inicialização: memo = [[-1]*(W+1) for _ in range(n+1)] em Python."
                                  ],
                                  "verification": "Reexecute exemplo anterior; contador de chamadas deve cair para O(n*W). Imprima tabela final.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Código do Step 2",
                                    "Debugger para inspecionar memo"
                                  ],
                                  "tips": "Use tuplas como chaves se dicionário, mas prefira 2D array para eficiência.",
                                  "learningObjective": "Integrar memoização top-down para evitar recomputações.",
                                  "commonMistakes": [
                                    "Não inicializar corretamente (-1 ou None)",
                                    "Índices invertidos na tabela",
                                    "Atualizar memo após recursão errada"
                                  ],
                                  "subSteps": [
                                    {
                                      "id": 1,
                                      "title": "Inicializar a tabela de memoização",
                                      "description": "Crie uma tabela 2D memo de dimensões (n+1) x (W+1), inicializada com -1 para indicar valores não computados.",
                                      "codeSnippet": "memo = [[-1] * (W + 1) for _ in range(n + 1)]",
                                      "hint": "Garanta que seja uma lista de listas para evitar referências compartilhadas."
                                    },
                                    {
                                      "id": 2,
                                      "title": "Verificar cache na função recursiva",
                                      "description": "No início da função knapsack(index, peso_atual), adicione uma verificação: se memo[index][peso_atual] != -1, retorne esse valor imediatamente.",
                                      "codeSnippet": "if memo[index][peso_atual] != -1:\n    return memo[index][peso_atual]",
                                      "hint": "Coloque isso logo após os parâmetros da função."
                                    },
                                    {
                                      "id": 3,
                                      "title": "Armazenar resultado no memo",
                                      "description": "Após calcular o valor máximo (considerando take ou not_take), armazene-o em memo[index][peso_atual] antes de retornar.",
                                      "codeSnippet": "max_val = max(take, not_take)\nmemo[index][peso_atual] = max_val\nreturn max_val",
                                      "hint": "Atualize o memo apenas com o resultado final da computação."
                                    },
                                    {
                                      "id": 4,
                                      "title": "Ajustar chamada inicial",
                                      "description": "Na função principal, inicialize a memo e chame knapsack(0, W) para iniciar a recursão com memoização.",
                                      "codeSnippet": "return knapsack(0, W)",
                                      "hint": "Passe a memo como parâmetro global ou use nonlocal/closure se necessário."
                                    },
                                    {
                                      "id": 5,
                                      "title": "Testar e verificar",
                                      "description": "Reexecute o exemplo do Step anterior e confirme que o número de chamadas recursivas reduz para O(n*W). Imprima a tabela memo final.",
                                      "codeSnippet": "print(memo)",
                                      "hint": "Use um contador de chamadas para medir eficiência."
                                    }
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Otimizar e Reconstruir Solução",
                                  "subSteps": [
                                    "Teste com múltiplos casos: W=0, n=0, item peso > W.",
                                    "Adicione função para reconstruir itens selecionados rastreando escolhas.",
                                    "Otimize: detecte padrões na tabela (preencha linhas de baixo para cima se bottom-up híbrido).",
                                    "Meça tempo: compare recursão pura vs memoizada para n=100, W=1000.",
                                    "Documente complexidade: tempo O(n*W), espaço O(n*W) -> otimize para O(W) com 1D."
                                  ],
                                  "verification": "Solução correta em 5+ testes; tabela preenche sem sobreposições.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Suite de testes unitários (pytest ou similar)",
                                    "Exemplos Knapsack LeetCode"
                                  ],
                                  "tips": "Para reconstrução, passe lista de escolhas ou backtrack da tabela.",
                                  "learningObjective": "Validar implementação e estender para solução completa.",
                                  "commonMistakes": [
                                    "Overflow em linguagens com int pequeno",
                                    "Não limpar memo entre testes",
                                    "Confundir max com sum"
                                  ]
                                }
                              ],
                              "practicalExample": "Itens: [(peso=2,valor=3), (3,4), (4,5), (5,6)], W=8. Solução memoizada: selecione itens 4(p=3,v=4)+5(p=5,v=6)=10, tabela[0][8]=10.",
                              "finalVerifications": [
                                "Função retorna valor ótimo correto para 5+ exemplos variados.",
                                "Número de chamadas recursivas <= n*W +1.",
                                "Tabela memo preenchida apenas uma vez por estado.",
                                "Reconstrói lista exata de itens selecionados.",
                                "Funciona com W=0, n=0, itens inviáveis.",
                                "Tempo <1s para n=100, W=1000."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% acertos em testes edge/corner.",
                                "Eficiência: Chamadas O(n*W), sem TLE.",
                                "Clareza: Código comentado, variáveis intuitivas.",
                                "Robustez: Trata todos casos base sem crashes.",
                                "Extensibilidade: Fácil adaptar para fractional knapsack.",
                                "Documentação: Explica estados e memo no código."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização combinatória e recursão.",
                                "Economia: Alocação ótima de recursos limitados (investimentos).",
                                "Logística: Planejamento de cargas em veículos.",
                                "IA: Estados em busca heurística (A*).",
                                "Finanças: Portfolio otimização com restrições."
                              ],
                              "realWorldApplication": "Otimizar seleção de projetos em startup com orçamento fixo (max valor/profit sem exceder custo), ou packing de contêineres em supply chain."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.3",
                            "name": "Analisar complexidade com memoização",
                            "description": "Derivar tempo O(n*W) e espaço O(n*W) para knapsack memoizado, contrastando com recursão pura exponencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Complexidade da Recursão Pura no Knapsack",
                                  "subSteps": [
                                    "Identifique a estrutura recursiva do problema 0/1 Knapsack: parâmetros (índice do item atual, peso restante).",
                                    "Conte o número de chamadas recursivas possíveis: para n itens e peso W, há 2^n chamadas na pior caso.",
                                    "Calcule o tempo: cada chamada faz trabalho O(1) + duas chamadas recursivas, resultando em T(n,W) ≈ 2^n.",
                                    "Discuta o espaço: pilha de recursão atinge profundidade O(n), mas total é exponencial devido a ramificações.",
                                    "Anote a complexidade tempo O(2^n) e espaço O(n)."
                                  ],
                                  "verification": "Escreva uma equação de recorrência e justifique por que é exponencial com um exemplo pequeno (n=3, W=5).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código recursivo do Knapsack, papel e caneta para árvore de chamadas.",
                                  "tips": "Desenhe a árvore de recursão para visualizar explosão de chamadas.",
                                  "learningObjective": "Entender por que a abordagem bottom-up recursiva é impraticável para n>30.",
                                  "commonMistakes": "Confundir profundidade da pilha com total de chamadas; ignorar que cada subproblema é resolvido múltiplas vezes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Estados Únicos na Memoização Top-Down",
                                  "subSteps": [
                                    "Revise o código memoizado: usa um mapa ou array 2D com chaves (índice i, peso w atual).",
                                    "Determine o número de estados possíveis: i de 0 a n, w de 0 a W, total (n+1)*(W+1) estados.",
                                    "Explique que memoização armazena resultados para cada (i,w), evitando recomputações.",
                                    "Trace um exemplo: para n=3, W=5, liste todos os 4*6=24 estados possíveis.",
                                    "Confirme que cada estado é visitado exatamente uma vez na top-down."
                                  ],
                                  "verification": "Liste todos os estados para um knapsack pequeno e marque quais são computados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código memoizado, tabela 2D vazia para preencher manualmente.",
                                  "tips": "Pense em estados como 'subproblema: considerando itens de i em diante com peso w'.",
                                  "learningObjective": "Mapear parâmetros recursivos para dimensões da tabela de memo.",
                                  "commonMistakes": "Contar  n*W em vez de (n+1)*(W+1); esquecer estado base (i=0 ou w=0)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar Complexidade de Tempo na Memoização",
                                  "subSteps": [
                                    "Analise trabalho por estado: para cada (i,w), faz O(1) trabalho + duas chamadas (memoizadas).",
                                    "Multiplique: número de estados *(n+1)*(W+1) * O(1) por estado = O(n*W).",
                                    "Inclua inicialização da tabela: O(n*W) para array 2D ou mapa vazio inicialmente.",
                                    "Verifique com trace: em exemplo n=3,W=5, conte visitas exatas a cada célula.",
                                    "Compare: vs recursão pura, onde estados são recomputados exponencialmente."
                                  ],
                                  "verification": "Escreva T(n,W) = O((n+1)*(W+1)) e prove por indução simples ou contagem.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Pseudocódigo memoizado, calculadora para n=10,W=100.",
                                  "tips": "Foque em 'cada célula preenchida uma vez'; ignore constantes.",
                                  "learningObjective": "Quantificar ganho da memoização via contagem de estados únicos.",
                                  "commonMistakes": "Incluir custo das chamadas recursivas como extra; confundir com bottom-up."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Complexidade de Espaço e Contrastar Abordagens",
                                  "subSteps": [
                                    "Para espaço: tabela memo 2D de tamanho (n+1)*(W+1), cada entrada O(1) ou valor inteiro = O(n*W).",
                                    "Adicione pilha recursiva: pior caso O(n) profundidade, negligible vs O(n*W).",
                                    "Contrastar: recursão pura espaço O(n) pilha mas tempo exponencial; memo tempo O(n*W) mas espaço O(n*W).",
                                    "Discuta trade-offs: para W grande (ex: 10^4), espaço pode ser issue; otimizações como 1D array.",
                                    "Resuma: memoização transforma exponencial em polinomial pseudo-linear."
                                  ],
                                  "verification": "Calcule espaço para n=100,W=1000 (~100KB ok); compare tempos empíricos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código fonte, profiler ou timer para medir empiricamente.",
                                  "tips": "Use array 2D[-1] para não computado; meça com debugger.",
                                  "learningObjective": "Balancear tempo/espaço e justificar memoização para knapsack.",
                                  "commonMistakes": "Ignorar overhead do mapa (hash); superestimar pilha como O(n*W)."
                                }
                              ],
                              "practicalExample": "Para Knapsack com n=4 itens (pesos [1,3,4,5], valores [1,4,5,7], W=7): recursão pura faz ~16 chamadas; memo top-down preenche exatamente 5*8=40 estados, tempo ~40 ops vs 16. Implemente ambos e profile: recursão 2^4=16 mas cresce rápido; memo O(1) por estado.",
                              "finalVerifications": [
                                "Deriva corretamente tempo O(n*W) contando estados únicos.",
                                "Explica espaço O(n*W) incluindo tabela e pilha.",
                                "Contrasta com recursão pura: exponencial vs polinomial.",
                                "Fornece prova ou contagem para exemplo concreto.",
                                "Identifica quando memoização falha (W muito grande).",
                                "Sugere otimizações como memo 1D."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de complexidades tempo/espaço.",
                                "Clareza no contraste recursão vs memoização.",
                                "Uso correto de notação Big-O com justificativa.",
                                "Análise de trade-offs práticos (espaço vs tempo).",
                                "Exemplos numéricos ou diagramas de suporte.",
                                "Identificação de erros comuns na análise."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e recorrências (Cálculo III).",
                                "Algoritmos: Comparação com bottom-up DP e greedy.",
                                "Estruturas de Dados: Hash maps vs arrays para memo.",
                                "Otimização: Aplicações em OR (Pesquisa Operacional)."
                              ],
                              "realWorldApplication": "Em logística, otimizar mochila de entregas (itens=produtos, W=capacidade van) com milhares de itens; memoização permite soluções em segundos vs horas na recursão pura, usado em roteirizadores como Google OR-Tools."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.5.3.4",
                            "name": "Debugar falhas comuns em memoização",
                            "description": "Identificar e corrigir erros como falta de condições base, índices fora de bounds ou chaves duplicadas em dicionários.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Reproduzir e Analisar Sintomas do Erro",
                                  "subSteps": [
                                    "Execute o código memoizado com entradas problemáticas (ex: n grande para Fibonacci).",
                                    "Observe sintomas como stack overflow, resultados incorretos ou lentidão excessiva.",
                                    "Registre o traceback ou logs de erro para identificar o ponto de falha.",
                                    "Compare com versão sem memoização para isolar o problema.",
                                    "Anote métricas: tempo de execução e uso de memória."
                                  ],
                                  "verification": "Confirme que o erro é reproduzível e sintomas documentados em um log ou notebook.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Exemplo de código com memoização defeituosa"
                                  ],
                                  "tips": "Use print statements ou debugger para rastrear chamadas recursivas.",
                                  "learningObjective": "Identificar sintomas característicos de falhas em memoização top-down.",
                                  "commonMistakes": [
                                    "Ignorar erros silenciosos que não crasham o programa",
                                    "Não comparar com implementação bottom-up"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar e Corrigir Condições Base",
                                  "subSteps": [
                                    "Inspecione o código para condições base ausentes ou incorretas (ex: if n <= 1: return n).",
                                    "Teste isoladamente as condições base com entradas pequenas.",
                                    "Adicione validação explícita para casos base no memo (ex: memo[0] = 0).",
                                    "Simule recursão manualmente para 2-3 níveis.",
                                    "Atualize o código e re-teste."
                                  ],
                                  "verification": "Condições base retornam valores corretos sem recursão.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Código fonte",
                                    "Calculadora ou papel para simulação manual"
                                  ],
                                  "tips": "Sempre teste n=0 e n=1 primeiro em problemas de recorrência.",
                                  "learningObjective": "Garantir que memoização não entre em recursão infinita por falta de base.",
                                  "commonMistakes": [
                                    "Condições base que não cobrem todos os casos edge",
                                    "Retorno de None em vez de valor padrão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar e Corrigir Chaves do Memo",
                                  "subSteps": [
                                    "Examine como as chaves são geradas (ex: tuple para multi-param).",
                                    "Verifique bounds: chave negativa ou além do range esperado.",
                                    "Detecte duplicatas: imprima memo.keys() antes e após chamadas.",
                                    "Corrija hashing inválido ou tipos inconsistentes nas chaves.",
                                    "Limpe memo e re-teste com prints de chave acessada."
                                  ],
                                  "verification": "Memo contém chaves únicas e dentro dos bounds esperados após execução.",
                                  "estimatedTime": "25-30 minutos",
                                  "materials": [
                                    "Debugger (pdb ou IDE breakpoints)",
                                    "Dicionário de log para chaves"
                                  ],
                                  "tips": "Use frozenset ou tuple para chaves compostas imutáveis.",
                                  "learningObjective": "Evitar erros de indexação e colisões em estruturas de memoização.",
                                  "commonMistakes": [
                                    "Usar listas mutáveis como chaves",
                                    "Índices off-by-one em arrays"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Recursão, Hits e Performance",
                                  "subSteps": [
                                    "Adicione contadores para recursões totais vs. memo hits.",
                                    "Execute com profiler para medir chamadas e tempo.",
                                    "Teste casos edge: n=0, n=1, n grande, entradas inválidas.",
                                    "Compare output com solução conhecida (ex: math.comb para binomial).",
                                    "Otimize se necessário (ex: memo pré-preenchido)."
                                  ],
                                  "verification": "Memo hits > 80% em inputs grandes; resultados exatos.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Profiler (cProfile)",
                                    "Casos de teste unitários"
                                  ],
                                  "tips": "Implemente @lru_cache como baseline para comparação.",
                                  "learningObjective": "Confirmar eficiência e corretude pós-correções.",
                                  "commonMistakes": [
                                    "Não limpar memo entre testes",
                                    "Ignorar overflow em valores grandes"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Generalizar Lições",
                                  "subSteps": [
                                    "Escreva um checklist de debug para memoização futura.",
                                    "Crie testes unitários automatizados para o código corrigido.",
                                    "Aplique o debug em outro problema DP (ex: knapsack).",
                                    "Registre métricas before/after em um relatório.",
                                    "Compartilhe em repo ou forum para feedback."
                                  ],
                                  "verification": "Checklist completo e testes passando 100%.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Ferramenta de testes (pytest)",
                                    "Notebook Markdown"
                                  ],
                                  "tips": "Versione código com Git para rastrear mudanças.",
                                  "learningObjective": "Sistematizar processo de debug para reutilização.",
                                  "commonMistakes": [
                                    "Pular testes edge",
                                    "Não documentar para problemas semelhantes"
                                  ]
                                }
                              ],
                              "practicalExample": "No Fibonacci top-down: def fib(n, memo={}): if n in memo: return memo[n]; if n <= 1: return n; memo[n] = fib(n-1, memo) + fib(n-2, memo); return memo[n]. Erro: falta memo.clear() para novos calls, causando cache poluição. Correção: memo = {} por default e validação de n >= 0. Teste: fib(5) deve ser 5, sem stack overflow em fib(1000).",
                              "finalVerifications": [
                                "Código executa sem erros para n até 1000.",
                                "Memo contém apenas chaves válidas e únicas.",
                                "Condições base ativadas corretamente em 100% dos casos.",
                                "Performance melhora >90% vs recursão pura.",
                                "Testes unitários cobrem 5+ casos edge.",
                                "Checklist de debug é acionável e completo."
                              ],
                              "assessmentCriteria": [
                                "Identificação precisa de pelo menos 2 falhas comuns.",
                                "Correções implementadas com código limpo e comentado.",
                                "Uso efetivo de debugger/print para diagnóstico.",
                                "Métricas de performance documentadas.",
                                "Generalização para outros problemas DP.",
                                "Checklist cobre condições base, chaves e recursão."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de recorrências e complexidade O(n).",
                                "Lógica: Verificação de pré-condições e pós-condições.",
                                "Engenharia de Software: Testes unitários e profiling.",
                                "Ciência de Dados: Otimização de computação em ML recursivo.",
                                "Pensamento Computacional: Decomposição de problemas em subproblemas."
                              ],
                              "realWorldApplication": "Em sistemas de recomendação (Netflix), debug de memoização em tree traversals evita lentidão em queries grandes; em jogos (pathfinding), corrige stack overflows para mapas dinâmicos; em finanças, otimiza cálculos de opções com DP memoizado para trading em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.1.6",
                    "name": "Abordagem Bottom-Up (Tabulação)",
                    "description": "Construção iterativa da tabela de soluções preenchendo de subproblemas menores para maiores.",
                    "individualConcepts": [
                      {
                        "id": "10.1.1.6.1",
                        "name": "Princípios da Abordagem Bottom-Up",
                        "description": "Compreensão dos fundamentos da abordagem bottom-up em programação dinâmica, que constrói soluções de forma iterativa partindo de subproblemas menores e progredindo para maiores, utilizando uma tabela para armazenar resultados intermediários e evitando chamadas recursivas desnecessárias.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.1.1",
                            "name": "Diferenciar Bottom-Up de Top-Down",
                            "description": "Comparar a abordagem bottom-up (tabulação iterativa) com top-down (memoização recursiva), identificando vantagens como eliminação da sobrecarga de recursão, melhor controle de memória e adequação para problemas com dependências lineares.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Top-Down e Bottom-Up",
                                  "subSteps": [
                                    "Estude a definição de Top-Down: abordagem recursiva que começa do problema principal e divide em subproblemas, usando memoização para armazenar resultados.",
                                    "Estude a definição de Bottom-Up: abordagem iterativa que constrói soluções de subproblemas menores até o problema principal, usando tabulação em uma tabela.",
                                    "Identifique as diferenças chave: Top-Down explora recursivamente com cache; Bottom-Up preenche tabela de forma sequencial.",
                                    "Revise exemplos clássicos como Fibonacci para visualizar cada método.",
                                    "Anote as estruturas de dados usadas: array/tabela em ambos, mas preenchimento difere."
                                  ],
                                  "verification": "Crie um diagrama comparativo resumindo definições e fluxos de cada abordagem.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de Programação Dinâmica (ex: GeeksforGeeks DP section)",
                                    "Vídeo introdutório sobre DP (Khan Academy ou YouTube)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Use analogias: Top-Down como 'resolver de cima para baixo como uma árvore'; Bottom-Up como 'construir de baixo para cima como tijolos'.",
                                  "learningObjective": "Definir precisamente Top-Down (memoização recursiva) e Bottom-Up (tabulação iterativa).",
                                  "commonMistakes": [
                                    "Confundir memoização com tabulação",
                                    "Achar que ambos são puramente recursivos",
                                    "Ignorar o papel da recursão em Top-Down"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Ambas as Abordagens em um Problema Simples (Fibonacci)",
                                  "subSteps": [
                                    "Implemente Fibonacci Top-Down: escreva função recursiva com memoização usando um mapa ou array.",
                                    "Teste a implementação Top-Down com n=10, medindo chamadas recursivas antes/depois da memoização.",
                                    "Implemente Fibonacci Bottom-Up: crie array dp[0..n], preencha iterativamente de baixo para cima.",
                                    "Compare tempos de execução e uso de memória entre as duas implementações.",
                                    "Debugue qualquer erro, como índices incorretos na tabulação."
                                  ],
                                  "verification": "Execute ambos os códigos e capture saídas/tempos; confirme que resultados são idênticos.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Linguagem Python ou JavaScript",
                                    "Ferramenta de profiling básica (timeit em Python)"
                                  ],
                                  "tips": "Inicialize memo como dicionário vazio; para Bottom-Up, defina dp[0]=0, dp[1]=1 explicitamente.",
                                  "learningObjective": "Codificar funcionalmente ambas as abordagens para um problema de DP padrão.",
                                  "commonMistakes": [
                                    "Stack overflow em recursão sem memo",
                                    "Preenchimento incorreto da tabela Bottom-Up",
                                    "Não limpar memo entre testes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Vantagens, Desvantagens e Casos de Uso",
                                  "subSteps": [
                                    "Liste vantagens do Bottom-Up: sem sobrecarga recursiva, controle total de memória, ideal para dependências lineares.",
                                    "Liste vantagens do Top-Down: só computa subproblemas necessários, mais intuitivo para problemas complexos.",
                                    "Identifique desvantagens: Bottom-Up pode desperdiçar espaço se nem todos subproblemas forem usados; Top-Down tem overhead recursivo.",
                                    "Discuta adequação: Bottom-Up para problemas lineares (ex: sequências); Top-Down para árvores de dependências esparsas.",
                                    "Crie tabela comparativa com métricas: tempo, espaço, simplicidade."
                                  ],
                                  "verification": "Preencha e valide uma tabela de prós/contras com pelo menos 5 itens por abordagem.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Google Sheets ou papel para tabela",
                                    "Exemplos de problemas DP (Knapsack, LCS)"
                                  ],
                                  "tips": "Pense em Big O: ambos O(n) para Fibonacci, mas constante difere devido a recursão.",
                                  "learningObjective": "Identificar cenários onde uma abordagem supera a outra.",
                                  "commonMistakes": [
                                    "Superestimar overhead recursivo moderno (tail recursion)",
                                    "Ignorar que Bottom-Up sempre usa O(n) espaço",
                                    "Não considerar otimizações como espaço reduzido"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Diferenciação em um Problema Mais Complexo",
                                  "subSteps": [
                                    "Escolha problema como Longest Common Subsequence (LCS); implemente Top-Down com memo 2D.",
                                    "Converta para Bottom-Up: crie tabela 2D e preencha com loops duplos.",
                                    "Meça diferenças: número de células preenchidas vs. computadas.",
                                    "Explique por que Bottom-Up é preferível aqui (todas células necessárias).",
                                    "Refatore código para alternar entre abordagens facilmente."
                                  ],
                                  "verification": "Implementações produzem mesmo resultado para strings de teste; anote diferenças observadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código base de LCS",
                                    "Strings de teste: 'ABCDGH' e 'AEDFHR'"
                                  ],
                                  "tips": "Use tuplas como chaves em memo para 2D; loops for i in range(m+1), for j in range(n+1) em Bottom-Up.",
                                  "learningObjective": "Diferenciar abordagens em problemas multidimensionais.",
                                  "commonMistakes": [
                                    "Índices off-by-one em tabelas 2D",
                                    "Memo não lidando com dimensões múltiplas",
                                    "Confundir ordem de preenchimento"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema Fibonacci(n=40): Top-Down faz ~40 chamadas recursivas com memo (evita exponencial); Bottom-Up preenche array de 0 a 40 iterativamente, sem recursão, usando exatamente O(n) espaço e tempo.",
                              "finalVerifications": [
                                "Explicar verbalmente diferenças sem consultar notas.",
                                "Codificar ambas abordagens para Fibonacci sem erros.",
                                "Identificar 3 vantagens específicas do Bottom-Up.",
                                "Escolher abordagem correta para um problema dado (ex: linear vs. esparso).",
                                "Comparar traces de execução (chamadas vs. iterações).",
                                "Converter código Top-Down para Bottom-Up em <5 min."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (100% correto).",
                                "Códigos funcionais e eficientes (sem TLE ou erros).",
                                "Análise de prós/contras balanceada e contextualizada.",
                                "Uso correto de terminologia (memoização, tabulação).",
                                "Capacidade de generalizar para novos problemas.",
                                "Clareza em diagramas/tabelas comparativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de recorrências lineares.",
                                "Engenharia de Software: Otimização de performance e trade-offs memória/tempo.",
                                "Análise de Dados: Computação eficiente em grandes datasets.",
                                "Lógica e Raciocínio: Pensamento bottom-up vs. top-down em resolução de problemas."
                              ],
                              "realWorldApplication": "Em roteamento de entregas (DP para caminhos ótimos), Bottom-Up otimiza memória em problemas lineares como sequências de cidades; em jogos como xadrez (minimax com memo), Top-Down evita computar estados irrelevantes, economizando CPU em cenários ramificados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.2",
                            "name": "Identificar Dependências de Subproblemas",
                            "description": "Analisar a estrutura de um problema de programação dinâmica para determinar a ordem de resolução dos subproblemas, garantindo que soluções menores sejam computadas antes das maiores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir os Subproblemas e Suas Recorrências",
                                  "subSteps": [
                                    "Leia a definição do problema e identifique o estado principal (ex: tamanho da subseqüência ou índice).",
                                    "Escreva a recorrência básica, listando quais subproblemas menores cada subproblema maior depende.",
                                    "Anote os casos base (subproblemas triviais que não dependem de outros).",
                                    "Crie uma tabela ou lista numerada dos subproblemas possíveis (ex: dp[0..n]).",
                                    "Marque dependências iniciais com setas ou referências (ex: dp[i] -> dp[i-1], dp[i-2])."
                                  ],
                                  "verification": "Verifique se todos os subproblemas estão listados e suas dependências explícitas estão anotadas sem ambiguidades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto/diagrama (ex: Draw.io, Notion).",
                                  "tips": "Comece pelos casos base para ancorar a análise.",
                                  "learningObjective": "Compreender como mapear o problema em subproblemas hierárquicos com dependências claras.",
                                  "commonMistakes": "Ignorar casos base ou assumir dependências lineares sem verificar a recorrência real."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o Grafo de Dependências",
                                  "subSteps": [
                                    "Represente cada subproblema como um nó em um grafo direcionado.",
                                    "Desenhe arestas de um subproblema para os que ele depende (ex: nó i aponta para i-1 e i-2).",
                                    "Identifique ciclos potenciais e confirme ausência (DP requer DAG).",
                                    "Agrupe nós por 'níveis' de dependência (ex: tamanho 0, tamanho 1, etc.).",
                                    "Valide o grafo comparando com a recorrência original."
                                  ],
                                  "verification": "O grafo deve ser acíclico e todas as arestas corresponderem às dependências da recorrência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de diagramação (ex: Graphviz online, papel quadriculado).",
                                  "tips": "Use cores para diferenciar casos base (verde) e subproblemas dependentes (azul).",
                                  "learningObjective": "Visualizar dependências como grafo para facilitar ordenação.",
                                  "commonMistakes": "Desenhar arestas na direção errada (de dependente para dependência). Criar ciclos acidentais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Determinar a Ordem de Resolução (Ordenação Topológica)",
                                  "subSteps": [
                                    "Liste subproblemas sem dependências entrantes (grau de entrada 0, geralmente casos base).",
                                    "Resolva-os primeiro e remova suas arestas, atualizando graus de entrada.",
                                    "Repita: pegue próximos com grau 0, até esgotar todos os nós.",
                                    "Anote a sequência linear de computação (ordem bottom-up).",
                                    "Confirme que a ordem respeita todas as dependências originais."
                                  ],
                                  "verification": "A sequência deve permitir computar cada dp[i] após todos os seus dependentes estarem resolvidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou lista numerada no editor de código.",
                                  "tips": "Use algoritmo de Kahn para simular (fila de nós com grau 0).",
                                  "learningObjective": "Aplicar ordenação topológica para definir ordem de tabulação em DP.",
                                  "commonMistakes": "Pular nós com dependências pendentes ou ordenar de cima para baixo (top-down)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar com Tabulação Inicial e Teste",
                                  "subSteps": [
                                    "Implemente uma tabela DP parcial seguindo a ordem determinada.",
                                    "Preencha os primeiros subproblemas e verifique valores contra recorrência.",
                                    "Simule preenchimento completo para um input pequeno.",
                                    "Compare com solução recursiva ou conhecida para validar ordem.",
                                    "Ajuste se houver erros de dependência não resolvida."
                                  ],
                                  "verification": "Tabela preenchida sem referenciar células não computadas; resultados coincidem com expectativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (Python/Jupyter) com exemplo de problema.",
                                  "tips": "Use print statements para rastrear ordem de preenchimento.",
                                  "learningObjective": "Confirmar que a ordem identificada suporta computação bottom-up eficiente.",
                                  "commonMistakes": "Preencher tabela em ordem errada, causando uso de valores indefinidos (NaN ou zero incorreto)."
                                }
                              ],
                              "practicalExample": "No problema Fibonacci (fib(n)): subproblemas dp[i] = fib(i). Dependências: dp[i] depende de dp[i-1] e dp[i-2]. Ordem: dp[0]=0, dp[1]=1, dp[2]=dp[1]+dp[0], ..., dp[n]. Grafo: setas i->i-1 e i->i-2. Tabule de 0 a n.",
                              "finalVerifications": [
                                "Grafo de dependências é acíclico e captura todas as recorrências.",
                                "Ordem de resolução permite computar cada subproblema após seus dependentes.",
                                "Tabulação parcial em um exemplo pequeno produz valores corretos.",
                                "Nenhuma dependência é violada na sequência final.",
                                "Casos base são computados primeiro.",
                                "Escalabilidade para n maior é intuitiva pela ordem."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todas as dependências da recorrência (100% cobertas).",
                                "Correção da ordenação topológica (sem violações).",
                                "Clareza na representação visual do grafo.",
                                "Validação bem-sucedida com implementação tabular.",
                                "Eficiência: ordem linear O(n) sem redundâncias.",
                                "Explicação concisa da lógica usada."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Ordenação topológica e detecção de ciclos.",
                                "Matemática Discreta: Relações de dependência e indução.",
                                "Ciência da Computação: Análise de complexidade em algoritmos iterativos.",
                                "Engenharia de Software: Modelagem de pré-requisitos em pipelines de build."
                              ],
                              "realWorldApplication": "Em otimização de rotas de entrega (problema do caixeiro-viajante aproximado), identificar dependências garante que rotas parciais menores sejam calculadas antes das completas, otimizando logística em empresas como Amazon ou Uber Eats."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.1.3",
                            "name": "Reconhecer Aplicabilidade da Tabulação",
                            "description": "Avaliar quando a abordagem bottom-up é preferível, como em problemas com subproblemas sobrepostos e estrutura ótima, citando exemplos clássicos como Fibonacci ou Knapsack.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais da Programação Dinâmica",
                                  "subSteps": [
                                    "Estudar a definição de subproblemas sobrepostos, identificando chamadas recursivas repetidas em soluções ingênuas.",
                                    "Analisar exemplos iniciais como sequências recursivas simples para visualizar overlaps.",
                                    "Definir estrutura ótima subestrutural, explicando como soluções de subproblemas compõem a solução ótima global.",
                                    "Revisar pré-requisitos de PD: overlap e optimalidade.",
                                    "Mapear diferenças entre PD e abordagens recursivas puras."
                                  ],
                                  "verification": "Escrever um resumo de 100 palavras explicando subproblemas sobrepostos e estrutura ótima, com um diagrama simples.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Slides ou notas sobre Programação Dinâmica",
                                    "Vídeo introdutório de PD (ex: Khan Academy ou YouTube)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Desenhe árvores de recursão para visualizar overlaps visualmente.",
                                  "learningObjective": "Dominar os dois pilares da PD: subproblemas sobrepostos e estrutura ótima subestrutural.",
                                  "commonMistakes": "Confundir subproblemas sobrepostos com meras subdivisões, ignorando repetições."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Quando Bottom-Up (Tabulação) é Preferível",
                                  "subSteps": [
                                    "Comparar bottom-up vs top-down (memoization): bottom-up evita pilha de recursão e é mais eficiente em memória para grandes n.",
                                    "Listar cenários ideais para tabulação: problemas com overlaps intensos e tamanhos previsíveis de subproblemas.",
                                    "Avaliar trade-offs: bottom-up sempre computa todos subproblemas, útil quando todos são necessários.",
                                    "Praticar distinção: preferir bottom-up em problemas com estrutura tabular clara.",
                                    "Simular fluxograma de decisão para escolha de abordagem."
                                  ],
                                  "verification": "Criar uma tabela comparativa bottom-up vs top-down com 3 critérios (memória, tempo, simplicidade).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha ou editor de texto para tabela",
                                    "Exemplos de código em Python/C++ de ambas abordagens"
                                  ],
                                  "tips": "Pense em bottom-up como 'preenchendo uma tabela do menor para o maior problema'.",
                                  "learningObjective": "Saber avaliar preferência por tabulação baseada em características do problema.",
                                  "commonMistakes": "Escolher bottom-up sem verificar se todos subproblemas são computados desnecessariamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Clássicos de Aplicabilidade",
                                  "subSteps": [
                                    "Dissecar Fibonacci: mostrar overlaps na recursão e como tabulação resolve com tabela dp[0..n].",
                                    "Estudar Knapsack 0/1: identificar subproblemas dp[i][w] com overlaps e optimalidade.",
                                    "Comparar com problemas sem overlap (ex: Euclides) para contrastar.",
                                    "Implementar pseudocódigo bottom-up para ambos exemplos.",
                                    "Avaliar por que tabulação é ideal nesses casos."
                                  ],
                                  "verification": "Explicar em parágrafos curtos por que Fibonacci e Knapsack usam tabulação, com contagem de computações economizadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Códigos de exemplo em Python para Fibonacci e Knapsack",
                                    "Calculadora ou simulador online de PD"
                                  ],
                                  "tips": "Conte o número de chamadas recursivas vs iterações na tabela para quantificar ganhos.",
                                  "learningObjective": "Reconhecer padrões clássicos onde tabulação brilha.",
                                  "commonMistakes": "Ignorar que Knapsack tem múltiplas dimensões, assumindo apenas 1D."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Avaliação em Problemas Novos",
                                  "subSteps": [
                                    "Selecionar 3 problemas aleatórios (ex: Longest Common Subsequence, Matrix Chain Multiplication).",
                                    "Avaliar presença de overlaps e optimalidade para cada um.",
                                    "Decidir abordagem preferida e justificar com bottom-up.",
                                    "Esboçar tabela DP para um deles.",
                                    "Refletir sobre generalização para problemas reais."
                                  ],
                                  "verification": "Produzir relatório curto avaliando 3 problemas, justificando tabulação onde aplicável.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de problemas PD clássicos (LeetCode ou GeeksforGeeks)",
                                    "Editor de texto para relatórios"
                                  ],
                                  "tips": "Use checklist: 'Há overlaps? Há optimalidade? Tabela é viável?'.",
                                  "learningObjective": "Aplicar critérios de aplicabilidade de forma independente.",
                                  "commonMistakes": "Forçar PD em problemas sem overlaps, como buscas lineares."
                                }
                              ],
                              "practicalExample": "No problema Fibonacci(n), recursão pura faz ~2^n chamadas com overlaps extremos (fib(3) chamado múltiplas vezes). Bottom-up cria tabela dp[i] = dp[i-1] + dp[i-2] para i=0 a n, computando cada subproblema exatamente uma vez em O(n) tempo e espaço, ideal para grandes n onde recursão falha por stack overflow.",
                              "finalVerifications": [
                                "Citar corretamente 3 exemplos clássicos onde tabulação é preferível (ex: Fibonacci, Knapsack, LCS).",
                                "Explicar diferenças chave entre bottom-up e top-down sem erros.",
                                "Identificar overlaps e optimalidade em um problema dado em <2 minutos.",
                                "Justificar escolha de tabulação vs recursão pura em cenários específicos.",
                                "Desenhar tabela DP básica para Fibonacci ou Knapsack.",
                                "Comparar complexidades temporal/espacial corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de subproblemas sobrepostos (0-2 pontos).",
                                "Compreensão de estrutura ótima subestrutural (0-2 pontos).",
                                "Correta preferência por bottom-up em casos ideais (0-2 pontos).",
                                "Uso de exemplos clássicos com justificativa (0-2 pontos).",
                                "Capacidade de generalizar para novos problemas (0-2 pontos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de recorrências e sequências lineares.",
                                "Otimização: Problemas de maximização/minimização com restrições.",
                                "Ciência da Computação: Análise de complexidade e estruturas de dados (arrays/tabelas).",
                                "Engenharia de Software: Design de algoritmos eficientes para escalabilidade."
                              ],
                              "realWorldApplication": "Em logística para otimização de rotas de entrega (como Knapsack para capacidade de veículos), onde sub-rotas se sobrepõem; ou em finanças para portfólios ótimos, calculando combinações de ativos com restrições de risco via tabulação para eficiência em grandes datasets."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.2",
                        "name": "Construção e Preenchimento da Tabela",
                        "description": "Processo prático de definir, inicializar e preencher iterativamente a tabela de soluções em programação dinâmica bottom-up, seguindo a ordem de subproblemas.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.2.1",
                            "name": "Definir e Inicializar a Tabela DP",
                            "description": "Determinar as dimensões da tabela baseada nos parâmetros do problema, inicializando casos base com valores conhecidos (ex.: dp[0] = 0 ou dp[i][0] = valor inicial).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o Problema para Determinar Dimensões da Tabela DP",
                                  "subSteps": [
                                    "Ler cuidadosamente a declaração do problema e identificar parâmetros de entrada (ex.: comprimento da string n, número de itens m).",
                                    "Mapear os estados do subproblema (ex.: dp[i][j] representa solução ótima para prefixos i e j).",
                                    "Determinar dimensões incluindo casos base (ex.: dp[n+1][m+1] para cobrir i=0 a n e j=0 a m).",
                                    "Verificar constraints do problema para garantir que dimensões não excedam limites de memória.",
                                    "Anotar dimensões em pseudocódigo ou comentário."
                                  ],
                                  "verification": "Escrever as dimensões exatas (ex.: 'dp[n+1][m+1]') em um papel ou comentário de código e justificar brevemente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Declaração do problema",
                                    "Papel e caneta",
                                    "Editor de texto"
                                  ],
                                  "tips": "Sempre adicione +1 às dimensões para acomodar casos base como i=0 ou j=0.",
                                  "learningObjective": "Mapear parâmetros do problema para dimensões precisas da tabela DP, evitando erros de indexação.",
                                  "commonMistakes": [
                                    "Esquecer o +1, causando IndexOutOfBounds.",
                                    "Confundir 1D (dp[n+1]) com 2D (dp[n+1][m+1]).",
                                    "Ignorar constraints, levando a TLE ou MLE."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar e Alocar a Tabela DP",
                                  "subSteps": [
                                    "Escolher tipo de dado adequado (int para valores pequenos, long para grandes ou negativos).",
                                    "Declarar array 1D ou 2D com dimensões calculadas (ex.: Java: int[][] dp = new int[n+1][m+1];).",
                                    "Em Python: dp = [[0] * (m+1) for _ in range(n+1)] para evitar referência rasa.",
                                    "Inicializar com valor neutro se aplicável (0 para somas, INF para minimização).",
                                    "Compilar ou testar declaração isoladamente."
                                  ],
                                  "verification": "Executar código de declaração e imprimir dimensões (ex.: System.out.println(dp.length);) sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Compilador/Interpretador (javac, python)"
                                  ],
                                  "tips": "Use constantes para dimensões (ex.: final int N = n+1;) para legibilidade.",
                                  "learningObjective": "Declarar estruturas de dados multidimensionais otimizadas para Programação Dinâmica.",
                                  "commonMistakes": [
                                    "Tipo errado causando overflow (int vs long).",
                                    "Lista rasa em Python duplicando referências.",
                                    "Dimensões invertidas (dp[m+1][n+1] em vez de dp[n+1][m+1])."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar os Casos Base do Problema",
                                  "subSteps": [
                                    "Analisar a recorrência da DP para encontrar subproblemas triviais (ex.: dp[0][j] = 0 para strings vazias).",
                                    "Listar bordas da tabela: linhas i=0, colunas j=0, e casos especiais como dp[0][0].",
                                    "Determinar valores exatos baseados na definição (ex.: dp[i][0] = i para climbing stairs).",
                                    "Verificar consistência com recorrência (ex.: dp[1][0] deve satisfazer fórmula).",
                                    "Documentar casos base em comentários."
                                  ],
                                  "verification": "Criar uma lista numerada de casos base com valores esperados e checar manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para esboçar tabela",
                                    "Exemplo pequeno do problema"
                                  ],
                                  "tips": "Pense em 'o que acontece com entrada zero ou unitária?' para revelar casos base.",
                                  "learningObjective": "Reconhecer subproblemas base que ancoram o preenchimento da tabela DP.",
                                  "commonMistakes": [
                                    "Omitir dp[0][0].",
                                    "Atribuir valor errado (ex.: dp[0]=1 em vez de 0 para Fibonacci).",
                                    "Confundir com memoização top-down."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inicializar a Tabela com Valores dos Casos Base",
                                  "subSteps": [
                                    "Escrever loops para preencher bordas (ex.: for(int i=0; i<=n; i++) dp[i][0] = valor_inicial;).",
                                    "Cobrir todas as bordas identificadas, incluindo diagonais se necessário.",
                                    "Usar condições especiais para interseções (ex.: if(i==0 && j==0) dp[0][0]=0;).",
                                    "Imprimir ou debugar tabela após inicialização para visualização.",
                                    "Testar com input mínimo (n=0, n=1) para validar."
                                  ],
                                  "verification": "Executar código, imprimir tabela inicial e confirmar que bordas têm valores corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Ferramenta de debug (print statements)"
                                  ],
                                  "tips": "Inicialize apenas casos base; o resto será preenchido iterativamente depois.",
                                  "learningObjective": "Implementar código robusto para setup inicial da tabela DP.",
                                  "commonMistakes": [
                                    "Loops off-by-one (i<=n vs i<n).",
                                    "Sobrescrever casos base durante inicialização.",
                                    "Esquecer inicialização de uma borda inteira."
                                  ]
                                }
                              ],
                              "practicalExample": "Problema: Fibonacci Bottom-Up (n=5). Parâmetros: n=5. Dimensões: dp[6] (índices 0-5). Casos base: dp[0]=0, dp[1]=1. Código Python: dp = [0] * (n+1); dp[0] = 0; dp[1] = 1. Resultado inicial: [0,1,0,0,0,0]. Pronto para loop for i in range(2, n+1): dp[i] = dp[i-1] + dp[i-2].",
                              "finalVerifications": [
                                "Dimensões da tabela correspondem exatamente aos parâmetros + casos base.",
                                "Todos os casos base identificados estão listados e corretos.",
                                "Código de inicialização roda sem erros e produz tabela com bordas preenchidas.",
                                "Teste com n=0 e n=1 retorna solução conhecida do problema.",
                                "Memória alocada é O(n*m), sem desperdício excessivo.",
                                "Comentários explicam escolhas de dimensões e valores base."
                              ],
                              "assessmentCriteria": [
                                "Justifica dimensões com base na recorrência e parâmetros (nota máxima se inclui +1).",
                                "Lista completa e precisa de casos base, com exemplos.",
                                "Código de declaração e inicialização é limpo, eficiente e multilinguagem.",
                                "Demonstra teste unitário com input pequeno, mostrando tabela inicial.",
                                "Explica impacto de erros comuns em performance ou corretude.",
                                "Integra inicialização em solução DP completa funcional."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Condições iniciais em equações de recorrência linear.",
                                "Estruturas de Dados: Arrays e matrizes para armazenamento tabular.",
                                "Algoritmos: Pré-requisito para preenchimento iterativo bottom-up.",
                                "Programação: Gerenciamento de memória e inicialização de variáveis.",
                                "Lógica Computacional: Decomposição de problemas em subproblemas base."
                              ],
                              "realWorldApplication": "Em otimização de cadeias de suprimentos, definir dimensões de tabela DP baseadas no número de produtos (n) e armazéns (m), inicializando casos base com custos zero para zero itens, permitindo calcular alocações ótimas eficientes em logística real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.2",
                            "name": "Implementar Loops Iterativos de Preenchimento",
                            "description": "Escrever loops for aninhados ou iterativos para calcular cada célula da tabela usando fórmulas de recorrência, como dp[i] = max(dp[i-1], dp[i-w] + val) em Knapsack.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e Inicializar a Tabela DP",
                                  "subSteps": [
                                    "Analise o problema de Knapsack: identifique n itens com pesos w[i] e valores val[i], e capacidade W.",
                                    "Crie uma matriz 2D dp[n+1][W+1] ou otimize para 1D dp[W+1] se aplicável.",
                                    "Inicialize a primeira linha/coluna com 0s (dp[0][j] = 0 e dp[i][0] = 0).",
                                    "Defina variáveis auxiliares como maxWeight = W.",
                                    "Escreva o código inicial da tabela em Python ou linguagem escolhida."
                                  ],
                                  "verification": "Verifique se todas as células iniciais são zero e dimensões estão corretas imprimindo a tabela inicial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Documentação de listas/matrices em Python",
                                    "Exemplo de problema Knapsack com n=3, W=5"
                                  ],
                                  "tips": "Use numpy para matrizes grandes para facilitar depuração visual.",
                                  "learningObjective": "Compreender a estrutura da tabela DP bottom-up e sua inicialização para evitar erros de índice.",
                                  "commonMistakes": [
                                    "Índices off-by-one (esquecer +1 nas dimensões)",
                                    "Inicializar com valores errados como -1",
                                    "Confundir dimensões (itens vs peso)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Loops Iterativos Aninhados",
                                  "subSteps": [
                                    "Defina loop externo for i in range(1, n+1): para iterar sobre itens.",
                                    "Defina loop interno for j in range(1, W+1): para iterar sobre capacidades de peso.",
                                    "Garanta ordem bottom-up: preencha de baixo para cima, evitando uso de valores futuros.",
                                    "Adicione prints opcionais para depuração: print(f'Preenchendo dp[{i}][{j}]')",
                                    "Teste loops vazios com print(len(dp)) para confirmar iterações."
                                  ],
                                  "verification": "Execute loops sem lógica interna e confirme que todas as células (exceto bordas) são visitadas via debug prints.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de código skeleton com loops vazios",
                                    "Debugger do IDE",
                                    "Papel e caneta para simular iterações manuais"
                                  ],
                                  "tips": "Comece com W pequeno (ex: 5) para visualizar iterações facilmente.",
                                  "learningObjective": "Dominar a estrutura de loops for aninhados para percorrer a tabela DP de forma iterativa e eficiente.",
                                  "commonMistakes": [
                                    "Loop de j começando em 0 causando divisão por zero ou erros",
                                    "Ordem invertida dos loops levando a dependências erradas",
                                    "Range sem +1 incluindo/excluindo índices errados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Lógica de Recorrência nos Loops",
                                  "subSteps": [
                                    "Dentro do loop interno: if w[i-1] > j: dp[i][j] = dp[i-1][j]",
                                    "Else: dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i-1]] + val[i-1])",
                                    "Use índices corrigidos (i-1, j-w[i-1]) para acessar valores anteriores.",
                                    "Otimize para 1D se possível: for j in range(W, w[i-1]-1, -1): dp[j] = max(dp[j], dp[j - w[i-1]] + val[i-1])",
                                    "Salve o código e execute com input de teste."
                                  ],
                                  "verification": "Compare valores preenchidos manualmente com o output do código para um caso pequeno.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Problema teste: itens=[(2,3),(3,4),(4,5)], W=5",
                                    "Calculadora para recorrência manual",
                                    "Ferramenta de linting para syntax"
                                  ],
                                  "tips": "Escreva a fórmula em comentário acima do if para referência rápida.",
                                  "learningObjective": "Aplicar corretamente a recorrência de Knapsack em loops bottom-up, garantindo optimalidade.",
                                  "commonMistakes": [
                                    "Não subtrair w[i-1] corretamente no segundo termo",
                                    "Usar dp[i][j-w] em vez de dp[i-1][j-w] causando overlap",
                                    "Esquecer conversão de índices 0-based"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Verificar a Solução Completa",
                                  "subSteps": [
                                    "Execute com múltiplos casos teste: ótimo conhecido vs dp[n][W].",
                                    "Adicione asserts: assert dp[n][W] == expected_value.",
                                    "Meça complexidade: confirme O(nW) com timing para W grande.",
                                    "Otimize memória se necessário (de 2D para 1D).",
                                    "Documente o código com comentários sobre cada loop."
                                  ],
                                  "verification": "Todos testes passam e tabela final matches solução ótima manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Suite de testes: 3-5 casos edge (W=0, n=0, etc.)",
                                    "Profiler de performance (timeit em Python)",
                                    "Git para versionar mudanças"
                                  ],
                                  "tips": "Use breakpoints no debugger para inspecionar dp durante preenchimento.",
                                  "learningObjective": "Garantir robustez da implementação através de testes e depuração sistemática.",
                                  "commonMistakes": [
                                    "Ignorar casos edge como item peso > W",
                                    "Sobrecarga de memória com W grande sem otimização",
                                    "Confundir valor ótimo com peso usado"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Knapsack 0/1 com itens pesos=[1,3,4], valores=[1,4,5], W=7: Inicialize dp[4][8]. Loops: for i=1 to 3, for j=1 to 7. Ex: i=2 (peso3,val4), j=4: max(dp[1][4]=1, dp[1][1]+4=5) -> dp[2][4]=5. Resultado final dp[3][7]=9.",
                              "finalVerifications": [
                                "Tabela DP preenchida sem erros de índice ou overflow.",
                                "dp[n][W] equals o valor ótimo conhecido para casos teste.",
                                "Todos loops executam O(nW) iterações sem timeouts.",
                                "Otimização 1D funciona se implementada, usando metade da memória.",
                                "Código roda com inputs edge (n=0, W=0, todos pesos > W).",
                                "Visualização da tabela mostra preenchimento progressivo correto."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Solução ótima obtida em todos testes.",
                                "Eficiência: Tempo O(nW) e espaço O(nW) ou otimizado O(W).",
                                "Clareza: Código comentado com lógica de loops explicada.",
                                "Robustez: Trata casos edge sem crashes.",
                                "Otimização: Uso correto de 1D quando aplicável.",
                                "Depuração: Verificações inline ou asserts presentes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências lineares e maximização discreta.",
                                "Algoritmos: Comparação com top-down memoization.",
                                "Estruturas de Dados: Arrays multidimensionais e otimização espacial.",
                                "Programação: Boas práticas de loops e condicionais.",
                                "Otimização: Problemas de programação linear inteira."
                              ],
                              "realWorldApplication": "Em logística para otimizar carregamento de caminhões (max valor com limite peso); em finanças para seleção de portfólio investimentos (max retorno com risco limitado); em manufatura para alocação de recursos limitados em produção."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.2.3",
                            "name": "Validar Ordem de Preenchimento",
                            "description": "Verificar que cada subproblema é resolvido apenas após seus dependentes, evitando erros de referência a células não preenchidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Dependências entre Subproblemas",
                                  "subSteps": [
                                    "Analise a recorrência da DP para mapear quais células dependem de quais (ex: dp[i][j] depende de dp[i-1][j] e dp[i][j-1]).",
                                    "Desenhe um grafo de dependências onde nós são células da tabela e arestas indicam dependência.",
                                    "Liste todas as dependências diretas para cada célula, priorizando as de menor dimensão.",
                                    "Marque células base (sem dependências) como ponto de partida.",
                                    "Verifique se há ciclos no grafo (deve ser DAG para bottom-up viável)."
                                  ],
                                  "verification": "Grafo de dependências completo sem ciclos e lista de dependentes por célula.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, pseudocódigo da recorrência, ferramenta de grafos como Draw.io.",
                                  "tips": "Comece pelas células de borda (i=0 ou j=0) que geralmente são cases base.",
                                  "learningObjective": "Mapear precisamente as dependências na recorrência DP.",
                                  "commonMistakes": "Ignorar dependências indiretas ou assumir ordem linear sem análise."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Ordem de Preenchimento Linear",
                                  "subSteps": [
                                    "Ordene as células em uma sequência linear respeitando as dependências (topological order).",
                                    "Use loops aninhados: for i from 0 to n, for j from 0 to m, garantindo que dependentes venham depois.",
                                    "Confirme que para cada célula, todas as suas dependências aparecem antes na sequência.",
                                    "Ajuste limites de loops para cobrir todas as células sem saltos.",
                                    "Documente a ordem como pseudocódigo de loops."
                                  ],
                                  "verification": "Pseudocódigo de loops onde cada referência é a uma célula anterior na execução.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Pseudocódigo inicial, editor de texto, tabela DP vazia.",
                                  "tips": "Em 2D, itere dimensões menores primeiro; teste com n=m=2.",
                                  "learningObjective": "Construir ordem de iteração que garanta preenchimento bottom-up.",
                                  "commonMistakes": "Inverter ordem de loops, causando referência a células não inicializadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular Preenchimento e Detectar Violações",
                                  "subSteps": [
                                    "Preencha a tabela manualmente seguindo a ordem proposta, marcando ordem de execução.",
                                    "Para cada célula, cheque se todas as referenciadas já foram preenchidas.",
                                    "Registre qualquer erro de referência (NaN ou undefined).",
                                    "Repita simulação com valores de entrada reais do problema.",
                                    "Corrija ordem se violações forem encontradas e revalide."
                                  ],
                                  "verification": "Tabela preenchida sem erros de referência e log de ordem de execução.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha Excel/Google Sheets para tabela, exemplo de problema DP.",
                                  "tips": "Use cores para marcar ordem: verde para preenchido, vermelho para violação.",
                                  "learningObjective": "Detectar e diagnosticar erros de ordem via simulação.",
                                  "commonMistakes": "Simular apenas uma vez sem valores edge-case."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Documentar e Testar Validação Automatizada",
                                  "subSteps": [
                                    "Crie uma checklist de validação para futuras tabelas DP.",
                                    "Implemente asserts no código para checar ordem em runtime.",
                                    "Teste com variação do problema (ex: dimensões maiores).",
                                    "Compare resultado com solução top-down para confirmação.",
                                    "Resuma lições aprendidas em notas."
                                  ],
                                  "verification": "Checklist completa, código com asserts passando testes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (Python/JS), testes unitários.",
                                  "tips": "Use print statements ou debugger para rastrear ordem real.",
                                  "learningObjective": "Automatizar validação para escalabilidade.",
                                  "commonMistakes": "Pular testes com tamanhos maiores que revelam problemas."
                                }
                              ],
                              "practicalExample": "No problema de Longest Common Subsequence (LCS) para strings 'ABCBDAB' e 'BDCAB', a tabela dp[i][j] depende de dp[i-1][j], dp[i][j-1] e dp[i-1][j-1]. Ordem: for i=0 to 7, for j=0 to 5. Simule preenchimento: dp[1][1] ('A','B') refere dp[0][1]='0', dp[1][0]='0', dp[0][0]='0' — todos preenchidos antes.",
                              "finalVerifications": [
                                "Todas as células referenciadas em uma fórmula estão antes na ordem de preenchimento.",
                                "Simulação completa sem erros de referência ou valores indefinidos.",
                                "Grafo de dependências é acíclico e coberto pela ordem linear.",
                                "Resultados coincidem com solução memoizada top-down.",
                                "Loops iteram dimensões em ordem crescente de complexidade.",
                                "Cases base (bordas da tabela) são preenchidos primeiro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 100% das dependências (rubrica: 25%).",
                                "Ordem de preenchimento correta e eficiente (sem redundâncias, 25%).",
                                "Simulação livre de erros com explicação detalhada (25%).",
                                "Checklist e automação robustas para reutilização (15%).",
                                "Documentação clara com exemplos e lições (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Ordenação topológica para dependências.",
                                "Programação: Controle de fluxo em loops aninhados e debugging.",
                                "Lógica Matemática: Relações de precedência e indução.",
                                "Ciência da Computação: Análise de complexidade em preenchimento O(n*m)."
                              ],
                              "realWorldApplication": "Em sistemas de otimização como roteirização de veículos (VRP), validação garante que rotas parciais sejam computadas antes de extensões, evitando soluções inválidas em software de logística como OR-Tools."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.1.6.3",
                        "name": "Reconstrução da Solução e Otimizações",
                        "description": "Extração da solução completa a partir da tabela preenchida e técnicas para otimizar o uso de tempo e espaço na implementação bottom-up.",
                        "specificSkills": [
                          {
                            "id": "10.1.1.6.3.1",
                            "name": "Reconstruir a Solução Ótima",
                            "description": "Percorrer a tabela de volta (backtracking) para recuperar as escolhas ótimas que levam ao valor final, armazenando caminhos ou decisões auxiliares se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a Posição Final e Revisar a Tabela DP",
                                  "subSteps": [
                                    "Localize a célula final da tabela DP, tipicamente dp[n][m] onde n é o número de itens/estados e m é o limite (ex: capacidade W).",
                                    "Confirme o valor ótimo armazenado nessa célula comparando com o esperado.",
                                    "Revise a fórmula de recorrência usada para preencher a tabela (ex: max(dp[i-1][w], dp[i-1][w-peso[i]] + valor[i]) para Knapsack).",
                                    "Anote os índices iniciais para backtrack: i = n, w = m.",
                                    "Marque auxiliarmente células relevantes próximas à final para referência rápida."
                                  ],
                                  "verification": "Posição final identificada corretamente e valor ótimo confirmado com anotações claras.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela DP preenchida (papel ou código)",
                                    "Folha de rascunho",
                                    "Caneta"
                                  ],
                                  "tips": "Use setas ou destaques visuais na tabela para facilitar a navegação futura.",
                                  "learningObjective": "Compreender a estrutura da tabela bottom-up e o ponto de partida para reconstrução.",
                                  "commonMistakes": [
                                    "Confundir dimensões da tabela (itens vs capacidade)",
                                    "Ignorar o valor ótimo e partir de célula errada"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iniciar o Backtracking Aplicando a Recorrência Invertida",
                                  "subSteps": [
                                    "Da célula atual (i, w), compare dp[i][w] com dp[i-1][w] (não pegar item).",
                                    "Se dp[i][w] == dp[i-1][w], mova para (i-1, w) sem pegar o item i.",
                                    "Caso contrário, se dp[i][w] == dp[i-1][w - peso[i]] + valor[i], pegue o item i e mova para (i-1, w - peso[i]).",
                                    "Registre a decisão (pegar/não pegar) para o item i.",
                                    "Repita até i=0 ou w=0."
                                  ],
                                  "verification": "Cada movimento segue exatamente a recorrência invertida, com decisões registradas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela DP",
                                    "Lista de itens/estados",
                                    "Rascunho para registrar caminho"
                                  ],
                                  "tips": "Priorize comparações exatas de valores para evitar ambiguidades em casos de empates.",
                                  "learningObjective": "Dominar a lógica invertida da recorrência para navegar pela tabela.",
                                  "commonMistakes": [
                                    "Escolher decisão errada em empates (sempre verificar ambas opções)",
                                    "Pular índices incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Registrar e Armazenar o Caminho Ótimo Completo",
                                  "subSteps": [
                                    "Mantenha uma lista ou pilha de decisões (ex: itens selecionados: [item2, item4]).",
                                    "Ao chegar na base (i=0 ou w=0), pare e reverta a lista se necessário para ordem cronológica.",
                                    "Calcule o valor total do caminho para confirmação intermediária.",
                                    "Anote restrições atendidas (ex: soma pesos <= W).",
                                    "Opcionalmente, armazene em estrutura auxiliar como array durante o preenchimento DP para eficiência."
                                  ],
                                  "verification": "Lista de decisões completa, com soma de valores igual ao ótimo e constraints válidos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de decisões (array ou papel)",
                                    "Calculadora simples"
                                  ],
                                  "tips": "Use uma pilha para push/pop decisões, facilitando reversão.",
                                  "learningObjective": "Aprender a coletar e estruturar o caminho ótimo de forma eficiente.",
                                  "commonMistakes": [
                                    "Perder itens no registro",
                                    "Erro em soma cumulativa"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Otimizar a Solução Reconstruída",
                                  "subSteps": [
                                    "Simule a solução forward: aplique itens selecionados e verifique se atinge o valor ótimo.",
                                    "Compare com solução conhecida ou brute-force para problemas pequenos.",
                                    "Identifique otimizações: armazene prev[i][w] durante DP para backtrack direto.",
                                    "Teste com variação: altere um item e re-backtrack para verificar robustez.",
                                    "Documente a solução final em formato legível (ex: 'Itens: 2 e 4, valor: 9')."
                                  ],
                                  "verification": "Solução validada forward, matches ótimo, e otimizações sugeridas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Solução reconstruída",
                                    "Código ou simulador opcional"
                                  ],
                                  "tips": "Sempre valide forward para catch erros de backtrack.",
                                  "learningObjective": "Garantir correção e eficiência na reconstrução.",
                                  "commonMistakes": [
                                    "Assumir backtrack correto sem validação",
                                    "Ignorar casos de fronteira como w=0"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema 0/1 Knapsack: itens peso=[2,3,4], valor=[3,4,5], W=5. Tabela dp[3][5]=8 (itens 2 e 3: 3+4=7<=5? Ajuste: peso=[1,3,4], valor=[1,4,5], W=5. dp[3][5]=9 (itens 2 e 3: 3+4=7>5 inválido. Correto: peso=[2,3,5], valor=[6,10,12], W=8 -> dp[3][8]=16 (itens 1 e 2). Backtrack: dp[3][8]=max(dp[2][8]=13, dp[2][3]+12=10+12=22? Exemplo padrão: de dp[3][8], assume pegou item1 e2. Caminho: pegue item2 (w=8-3=5, i=1), pegue item1 (w=5-2=3>0 mas dp[0][3]=0).",
                              "finalVerifications": [
                                "O caminho reconstruído resulta exatamente no valor ótimo da dp final.",
                                "Todas as decisões respeitam a recorrência e constraints do problema.",
                                "Soma cumulativa de recursos (ex: peso) não excede o limite.",
                                "Solução é completa desde o estado inicial até final.",
                                "Validação forward reproduz o valor ótimo.",
                                "Casos de fronteira (w=0, i=0) tratados corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% nas decisões de backtrack sem erros.",
                                "Tempo de backtrack eficiente (linear na tabela).",
                                "Explicação clara da lógica invertida da recorrência.",
                                "Validação forward realizada e documentada.",
                                "Sugestões de otimizações (ex: tabela auxiliar) incluídas.",
                                "Aplicação correta em exemplo prático fornecido."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução de sistemas recursivos e indução.",
                                "Lógica e Raciocínio: Dedução reversa em árvores de decisão.",
                                "Programação: Implementação de algoritmos de otimização e debugging.",
                                "Ciência de Dados: Reconstrução de caminhos em modelos preditivos."
                              ],
                              "realWorldApplication": "Em gerenciamento de projetos com recursos limitados (ex: alocação de budget), reconstruir quais tarefas ou investimentos foram selecionados no plano ótimo de programação dinâmica, permitindo auditoria, relatórios e ajustes dinâmicos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.2",
                            "name": "Analisar Complexidade da Implementação",
                            "description": "Calcular a complexidade temporal O(n*m) e espacial O(n*m) da tabulação bottom-up, identificando otimizações como redução de espaço para O(n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a Estrutura da Tabulação Bottom-Up",
                                  "subSteps": [
                                    "Revise o pseudocódigo da tabulação bottom-up para um problema DP padrão, como LCS ou Knapsack.",
                                    "Identifique os loops aninhados: externo sobre i (1 a n), interno sobre j (1 a m).",
                                    "Anote as dimensões da tabela DP: tipicamente dp[n+1][m+1].",
                                    "Desenhe um diagrama da tabela preenchida sequencialmente de baixo para cima.",
                                    "Registre dependências entre células: dp[i][j] depende de dp[i-1][j], dp[i][j-1], etc."
                                  ],
                                  "verification": "Crie um diagrama da tabela DP com loops anotados e confirme que captura todas as iterações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo de exemplo (LCS ou Knapsack)",
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Comece com um exemplo pequeno (n=3, m=4) para visualizar o preenchimento.",
                                  "learningObjective": "Compreender a dependência espacial e temporal na construção da tabela DP.",
                                  "commonMistakes": [
                                    "Ignorar índices base (i=0 ou j=0)",
                                    "Confundir ordem de preenchimento top-down com bottom-up"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Complexidade Temporal",
                                  "subSteps": [
                                    "Conte o número de operações dentro do loop interno: adições, comparações, atribuições (tipicamente O(1)).",
                                    "Multiplique pelas iterações: loop externo O(n), interno O(m), total O(n*m).",
                                    "Inclua inicializações da tabela: O(n*m) para zeros ou valores base.",
                                    "Some reconstrução da solução: O(n+m) no pior caso, negligible comparado a O(n*m).",
                                    "Expresse em notação Big O, justificando por que termos inferiores são ignorados."
                                  ],
                                  "verification": "Escreva a análise formal: T(n,m) = n*m * O(1) + O(n*m) = O(n*m).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo anotado",
                                    "Calculadora ou planilha para simular contagens"
                                  ],
                                  "tips": "Use contadores de execução em código para validar em um exemplo pequeno.",
                                  "learningObjective": "Dominar o cálculo de complexidade temporal baseado em loops aninhados.",
                                  "commonMistakes": [
                                    "Contar apenas loops sem operações internas",
                                    "Incluir I/O como parte do tempo DP"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Complexidade Espacial",
                                  "subSteps": [
                                    "Meça o tamanho da tabela DP: (n+1) * (m+1) * sizeof(int) ≈ O(n*m).",
                                    "Identifique variáveis auxiliares: O(1) ou O(n+m), negligible.",
                                    "Considere armazenamento da solução ótima: O(n+m) para caminho.",
                                    "Some overhead de recursão ou pilha: ausente em bottom-up puro.",
                                    "Expresse total como O(n*m), destacando dominância da tabela."
                                  ],
                                  "verification": "Calcule espaço para n=100, m=100: confirme ~40KB para int.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo com alocações de memória destacadas",
                                    "Ferramenta de profiling como Valgrind (opcional)"
                                  ],
                                  "tips": "Pense em termos de células da matriz, não linhas de código.",
                                  "learningObjective": "Avaliar uso de memória na tabulação completa.",
                                  "commonMistakes": [
                                    "Esquecer +1 nos índices",
                                    "Confundir espaço com tempo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar e Analisar Otimizações de Espaço",
                                  "subSteps": [
                                    "Observe dependências: para dp[i][j], só precisa de linha anterior dp[i-1].",
                                    "Implemente duas linhas: atual e anterior, reduzindo para O(2*m) = O(m).",
                                    "Para problemas 1D efetivos, use array rolante ou até O(1) em casos especiais.",
                                    "Compare: original O(n*m) vs otimizado O(m), trade-off zero em funcionalidade.",
                                    "Teste com código: rode versões e meça memória usada."
                                  ],
                                  "verification": "Modifique código para usar O(m) espaço e confirme saída idêntica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código-fonte em Python/C++ de LCS bottom-up",
                                    "Ferramenta de medição de memória (memory_profiler)"
                                  ],
                                  "tips": "Comece otimizando para O(min(n,m)) assumindo n >= m.",
                                  "learningObjective": "Reconhecer padrões de otimização de espaço em DP bottom-up.",
                                  "commonMistakes": [
                                    "Perder track da linha anterior",
                                    "Aplicar otimização inválida para problemas não-lineares"
                                  ]
                                }
                              ],
                              "practicalExample": "No algoritmo bottom-up para Longest Common Subsequence (LCS) de strings X (len n) e Y (len m): loops for i=1 to n, for j=1 to m preenchem dp[i][j]. Tempo: O(n*m) por n*m iterações. Espaço: O(n*m) para tabela. Otimização: use duas arrays de tamanho m+1, reduzindo para O(m). Para n=1000, m=1000, espaço cai de ~4MB para ~4KB.",
                              "finalVerifications": [
                                "Calcular corretamente O(n*m) para tempo e espaço em um exemplo dado.",
                                "Implementar versão otimizada de espaço O(min(n,m)) com saída correta.",
                                "Explicar por que otimização preserva corretude via dependências.",
                                "Comparar tempos/memória em execução real para n=m=500.",
                                "Identificar quando otimização não aplica (ex: reconstrução precisa tabela cheia)."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo Big O (temporal e espacial).",
                                "Correta identificação de dependências para otimização.",
                                "Implementação funcional da otimização com testes.",
                                "Análise qualitativa de trade-offs (tempo vs espaço).",
                                "Clareza na documentação da análise.",
                                "Tratamento de casos edge (n=0, m=0)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Assintótica e Notação Big O.",
                                "Engenharia de Software: Otimização de Recursos e Profiling.",
                                "Ciência de Dados: Processamento Eficiente de Sequências em Bioinformática.",
                                "Algoritmos Gerais: Paralelos com Divide-and-Conquer."
                              ],
                              "realWorldApplication": "Em bioinformática para alinhamento de sequências genéticas (LCS-like), onde n/m são milhões: otimização de espaço permite rodar em dispositivos limitados como sequenciadores portáteis, reduzindo custos em pesquisa médica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.1.6.3.3",
                            "name": "Converter Memoização para Tabulação",
                            "description": "Transformar uma solução top-down recursiva com memoização em equivalente bottom-up iterativo, preservando a lógica da recorrência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar a Solução Recursiva com Memoização",
                                  "subSteps": [
                                    "Identifique os parâmetros da função recursiva que representam o estado (ex: índices i, j em uma matriz).",
                                    "Extraia a lógica da recorrência principal (ex: dp[i][j] = dp[i-1][j] + dp[i][j-1]).",
                                    "Anote os casos base onde a recursão para (ex: dp[0][j] = 1).",
                                    "Registre como o memo é indexado e atualizado.",
                                    "Desenhe um grafo de dependências para visualizar a ordem top-down."
                                  ],
                                  "verification": "Escreva a recorrência em pseudocódigo sem memo e liste 3 estados dependentes.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Código fonte com memoização",
                                    "Papel e caneta para diagrama",
                                    "Editor de código"
                                  ],
                                  "tips": "Comece pelos casos pequenos para mapear dependências manualmente.",
                                  "learningObjective": "Compreender o estado e dependências da recursão para mapear para bottom-up.",
                                  "commonMistakes": [
                                    "Ignorar múltiplos parâmetros de estado",
                                    "Confundir memo com cache global",
                                    "Esquecer casos base não-triviais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar e Inicializar a Tabela DP",
                                  "subSteps": [
                                    "Defina as dimensões da tabela DP baseadas nos estados (ex: dp[n+1][w+1] para knapsack).",
                                    "Escolha o tipo de dados e inicialize com valores sentinelas (ex: -1 ou infinito).",
                                    "Preencha os casos base diretamente na tabela seguindo a lógica memoizada.",
                                    "Valide inicializações com 2-3 exemplos manuais.",
                                    "Decida sobre rastreamento de caminhos se necessário (ex: tabela auxiliar prev)."
                                  ],
                                  "verification": "Tabela inicializada corretamente para n=2 e n=3, combinando com execução memoizada.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Código do step 1",
                                    "Planilha ou array 2D no editor",
                                    "Casos de teste pequenos"
                                  ],
                                  "tips": "Use dimensões exatas para evitar desperdício de espaço; priorize O(n) se possível.",
                                  "learningObjective": "Criar uma representação tabular fiel à memoização.",
                                  "commonMistakes": [
                                    "Dimensões erradas (off-by-one)",
                                    "Inicializar tudo com 0 quando deve ser infinito",
                                    "Esquecer inicializações de bordas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o Preenchimento Bottom-Up Iterativo",
                                  "subSteps": [
                                    "Determine a ordem de iteração reversa à recursão (ex: for i=0 to n; for j=0 to w).",
                                    "Para cada estado (i,j), aplique a recorrência usando células já preenchidas.",
                                    "Atualize a tabela DP com o resultado computado.",
                                    "Inclua condições para escolhas ótimas se aplicável (ex: max ou min).",
                                    "Teste incrementalmente com valores parciais da tabela."
                                  ],
                                  "verification": "Execute para input pequeno e compare dp[n][w] com resultado memoizado.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Unit tests para sub-estados",
                                    "Debugger"
                                  ],
                                  "tips": "Itere sempre das dependências para o estado alvo; use prints para depurar ordem.",
                                  "learningObjective": "Converter recorrência em loops aninhados preservando lógica.",
                                  "commonMistakes": [
                                    "Ordem de loop invertida causando uso de valores não computados",
                                    "Índices off-by-one nos loops",
                                    "Não tratar max/min corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair Solução Final e Verificar Equivalência",
                                  "subSteps": [
                                    "Acesse o valor final na tabela (ex: dp[n][w]).",
                                    "Se requer reconstrução, rastreie backwards ou use prev table.",
                                    "Compare tempo/espaço e output com a versão memoizada em múltiplos testes.",
                                    "Otimize espaço se possível (ex: variáveis scrolling para 1D).",
                                    "Documente diferenças e similaridades entre as abordagens."
                                  ],
                                  "verification": "Soluções idênticas em 5 casos de teste variados, sem stack overflow.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Ambas implementações",
                                    "Suite de testes",
                                    "Profiler de tempo/espaço"
                                  ],
                                  "tips": "Sempre compare com asserts; reconstrua caminho manualmente primeiro.",
                                  "learningObjective": "Garantir equivalência e preparar para otimizações avançadas.",
                                  "commonMistakes": [
                                    "Acessar índice errado para resultado final",
                                    "Reconstrução falha sem prev",
                                    "Otimizar prematuramente sem validar"
                                  ]
                                }
                              ],
                              "practicalExample": "Para Fibonacci(n): Memo top-down: memo = {}, fib(n) { if n in memo return; if n<=1 return n; memo[n]=fib(n-1)+fib(n-2); }. Bottom-up: dp[0]=0, dp[1]=1; for i=2 to n: dp[i]=dp[i-1]+dp[i-2]; return dp[n]. Ambas O(n) tempo/espaço.",
                              "finalVerifications": [
                                "Implementação bottom-up produz output idêntico à memoizada em 5+ casos.",
                                "Não há chamadas recursivas; usa apenas loops.",
                                "Complexidade temporal/espaço preservada (ex: O(n) para linear).",
                                "Tabela DP preenchida corretamente para sub-estados intermediários.",
                                "Reconstrução de caminho (se aplicável) matches a recursiva.",
                                "Executa sem erros em edge cases (n=0, n=1)."
                              ],
                              "assessmentCriteria": [
                                "Correção: Solução equivalente em todos testes.",
                                "Eficiência: Tempo/espaço otimizado e matching memo.",
                                "Legibilidade: Código comentado com recorrência explícita.",
                                "Robustez: Trata edge cases e validações.",
                                "Modularidade: Funções separadas para init, fill, extract.",
                                "Documentação: Explica mapeamento de memo para tabulação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Resolução analítica de recorrências lineares.",
                                "Engenharia de Software: Refatoração para performance iterativa.",
                                "Análise de Algoritmos: Prova de corretude bottom-up por indução.",
                                "Inteligência Artificial: Viterbi algorithm em HMMs.",
                                "Otimização: Aplicações em problemas de mochila em logística."
                              ],
                              "realWorldApplication": "Em sistemas de roteamento GPS (otimizar caminhos com DP bottom-up para evitar recursão profunda em grandes grafos), machine learning (sequências em NLP como parsing probabilístico), e finanças (otimização de portfólios com restrições dinâmicas)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.2",
                "name": "Métodos Exaustivos",
                "description": "Abordagens que exploram todas as combinações possíveis de soluções para garantir a optimalidade em problemas de tamanho limitado.",
                "totalSkills": 42,
                "atomicTopics": [
                  {
                    "id": "10.1.2.1",
                    "name": "Definição de Métodos Exaustivos",
                    "description": "Abordagens que enumeram todas as combinações possíveis de soluções para assegurar a optimalidade em problemas pequenos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.1.1",
                        "name": "Definição Fundamental de Métodos Exaustivos",
                        "description": "Métodos exaustivos são abordagens algorítmicas que sistematicamente enumeram todas as combinações possíveis de soluções candidatas para um problema de otimização, garantindo a exaustividade na busca.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.1.1",
                            "name": "Identificar a definição de métodos exaustivos",
                            "description": "Reconhecer e reproduzir a definição precisa de métodos exaustivos como algoritmos que exploram o espaço de soluções completo para assegurar a melhor solução possível.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Busca Exaustiva",
                                  "subSteps": [
                                    "Ler definições padrão de métodos exaustivos em fontes confiáveis.",
                                    "Identificar termos chave como 'espaço de soluções completo' e 'exploração total'.",
                                    "Explicar verbalmente ou por escrito o que significa 'exaustivo' no contexto algorítmico.",
                                    "Associar o conceito a exemplos cotidianos, como verificar todas as chaves de um chaveiro.",
                                    "Anotar sinônimos como 'força bruta' ou 'enumeração completa'."
                                  ],
                                  "verification": "Escrever uma paráfrase da definição em no máximo 50 palavras e compará-la com a original.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Texto introdutório de Algoritmos Avançados (PDF ou livro)",
                                    "Caderno para anotações"
                                  ],
                                  "tips": "Visualize o algoritmo como um explorador que não deixa nenhuma pedra sobre outra.",
                                  "learningObjective": "Graspar o significado fundamental de métodos exaustivos como exploração total do espaço de soluções.",
                                  "commonMistakes": [
                                    "Confundir com métodos aproximados que param após poucas tentativas.",
                                    "Ignorar o aspecto de garantia de otimalidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Características Chave dos Métodos Exaustivos",
                                  "subSteps": [
                                    "Listar pelo menos 4 características: exploração completa, garantia de solução ótima, independência de heurísticas, alto custo computacional.",
                                    "Explicar cada característica com uma frase curta.",
                                    "Classificar cenários onde essas características são vantajosas (espaços pequenos).",
                                    "Discutir limitações, como explosão combinatória.",
                                    "Criar um mapa mental conectando características à definição."
                                  ],
                                  "verification": "Produzir uma lista numerada de 4-5 características com explicações breves.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de mapa mental (ex: MindMeister ou papel)",
                                    "Referência sobre complexidade algorítmica"
                                  ],
                                  "tips": "Use mnemônicos: 'Tudo ou Nada' para lembrar exploração completa e otimalidade.",
                                  "learningObjective": "Reconhecer elementos essenciais que definem métodos exaustivos.",
                                  "commonMistakes": [
                                    "Omitir o custo computacional como traço definidor.",
                                    "Confundir com backtracking, que é uma variante otimizada."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar Métodos Exaustivos de Alternativas",
                                  "subSteps": [
                                    "Comparar com heurísticas, branch-and-bound e algoritmos greedy em uma tabela.",
                                    "Identificar diferenças chave: exaustivos não usam podas ou aproximações.",
                                    "Analisar um exemplo simples onde exaustivo é único por garantir o ótimo.",
                                    "Discutir trade-offs: precisão vs. eficiência.",
                                    "Preencher lacunas: quando exaustivo é impraticável."
                                  ],
                                  "verification": "Completar uma tabela de comparação com pelo menos 3 métodos alternativos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou tabela em documento (Google Sheets)",
                                    "Exemplos de algoritmos de referência"
                                  ],
                                  "tips": "Pense em exaustivo como 'certificado', enquanto outros são 'provável'.",
                                  "learningObjective": "Distinguir métodos exaustivos para reforçar sua definição única.",
                                  "commonMistakes": [
                                    "Achar que todos os exaustivos usam poda, confundindo com variantes."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reproduzir e Memorizar a Definição Precisa",
                                  "subSteps": [
                                    "Escrever a definição oficial de memória 3 vezes, variando as palavras.",
                                    "Recitar em voz alta para um parceiro ou gravar e autoavaliar.",
                                    "Testar com flashcards: frente 'Definição de métodos exaustivos?', verso resposta.",
                                    "Aplicar a definição a um problema fictício.",
                                    "Revisar erros das tentativas anteriores."
                                  ],
                                  "verification": "Reproduzir a definição corretamente em um teste escrito sem consulta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Flashcards (Anki ou papel)",
                                    "Gravador de áudio no celular"
                                  ],
                                  "tips": "Use técnica de Feynman: explique como se ensinasse a uma criança.",
                                  "learningObjective": "Reproduzir com precisão a definição de métodos exaustivos.",
                                  "commonMistakes": [
                                    "Usar termos vagos como 'tenta tudo' em vez de 'espaço de soluções completo'."
                                  ]
                                }
                              ],
                              "practicalExample": "Para resolver o problema de encontrar a permutação ótima de 3 itens (A,B,C) que minimiza uma função custo, um método exaustivo gera todas as 6 permutações (ABC, ACB, BAC, BCA, CAB, CBA), avalia cada uma e seleciona a de menor custo, garantindo a solução ótima sem suposições.",
                              "finalVerifications": [
                                "Reproduzir a definição completa sem erros ou omissões.",
                                "Explicar em 1 minuto o que diferencia métodos exaustivos de heurísticos.",
                                "Identificar corretamente 4 características chave em uma lista.",
                                "Aplicar a definição a um exemplo simples sem hesitação.",
                                "Listar 2 cenários reais onde métodos exaustivos são apropriados.",
                                "Passar em um quiz de 5 perguntas sobre a definição."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Inclui 'espaço de soluções completo' e 'garantia de melhor solução'.",
                                "Completude: Cobre exploração total, otimalidade e limitações implícitas.",
                                "Clareza: Explicação concisa e sem ambiguidades.",
                                "Aplicação: Demonstra entendimento via exemplos ou comparações.",
                                "Memorização: Reproduz sem consulta com 100% de acurácia.",
                                "Diferenciação: Distingue corretamente de métodos não-exaustivos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e teoria de conjuntos para espaços de soluções.",
                                "Física: Simulações exaustivas em otimização de trajetórias quânticas.",
                                "Economia: Modelos de otimização em alocação de recursos limitados.",
                                "Engenharia: Verificação exaustiva em testes de software e hardware."
                              ],
                              "realWorldApplication": "Em cibersegurança, métodos exaustivos são usados em ataques de força bruta para senhas curtas (ex: 4 dígitos), enumerando todas as 10.000 combinações possíveis para garantir descoberta da senha correta, quando o espaço é pequeno o suficiente para viabilidade computacional."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.2",
                            "name": "Explicar o propósito principal dos métodos exaustivos",
                            "description": "Descrever verbalmente ou por escrito o objetivo de enumerar todas as possibilidades para problemas onde a optimalidade absoluta é requerida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição Básica de Métodos Exaustivos",
                                  "subSteps": [
                                    "Leia a definição: métodos exaustivos enumeram todas as soluções possíveis de um problema.",
                                    "Identifique palavras-chave: 'exaustivo' significa completo e sem omissões.",
                                    "Anote sinônimos: busca exaustiva, força bruta.",
                                    "Compare com busca parcial: exaustivo cobre 100% das possibilidades.",
                                    "Resuma em uma frase própria."
                                  ],
                                  "verification": "Escreva uma definição de 1-2 frases e compare com fontes confiáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Algoritmos Avançados (capítulo Métodos Exaustivos)",
                                    "Notas em papel ou editor de texto"
                                  ],
                                  "tips": "Use analogia: como verificar todas as portas em uma casa para encontrar a saída.",
                                  "learningObjective": "Definir precisamente o que são métodos exaustivos.",
                                  "commonMistakes": [
                                    "Confundir com heurísticas (que são aproximadas)",
                                    "Achar que é sempre ineficiente sem contexto"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar o Propósito Principal: Garantia de Optimalidade",
                                  "subSteps": [
                                    "Explique o objetivo: encontrar a solução ótima absoluta, sem exceções.",
                                    "Discuta trade-offs: tempo computacional alto em troca de certeza 100%.",
                                    "Liste cenários: problemas NP-difíceis onde aproximações não bastam.",
                                    "Crie um fluxograma: Problema → Enumerar tudo → Selecionar melhor.",
                                    "Registre exemplos iniciais de problemas que precisam disso."
                                  ],
                                  "verification": "Crie um diagrama simples mostrando entrada, enumeração e saída ótima.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho como Draw.io ou papel",
                                    "Artigos sobre complexidade computacional"
                                  ],
                                  "tips": "Pense em 'prova de exaustão': você provou que verificou tudo.",
                                  "learningObjective": "Articular por que enumerar tudo garante optimalidade.",
                                  "commonMistakes": [
                                    "Ignorar o custo computacional",
                                    "Aplicar a problemas lineares simples"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar com Alternativas e Contextualizar Uso",
                                  "subSteps": [
                                    "Compare com heurísticas: rápidas mas não garantem ótimo.",
                                    "Compare com programação dinâmica: otimiza enumeração mas ainda exaustiva em essência.",
                                    "Identifique quando usar: instâncias pequenas, prova de corretude necessária.",
                                    "Analise limitações: escalabilidade para n grande.",
                                    "Escreva prós e contras em tabela."
                                  ],
                                  "verification": "Preencha uma tabela de comparação com 3 alternativas e valide com exemplos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets",
                                    "Pseudocódigos de algoritmos alternativos"
                                  ],
                                  "tips": "Use a regra: 'Se errar custa caro (ex: finanças), use exaustivo'.",
                                  "learningObjective": "Explicar quando e por que métodos exaustivos são preferíveis.",
                                  "commonMistakes": [
                                    "Generalizar como 'sempre ruins' devido a tempo",
                                    "Confundir com randomização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar a Explicação Verbal e Escrita",
                                  "subSteps": [
                                    "Escreva um parágrafo explicando o propósito em linguagem simples.",
                                    "Grave-se explicando para um 'aluno imaginário' em 2 minutos.",
                                    "Peça feedback a um par ou use autoavaliação com rubrica.",
                                    "Refine com base em erros: adicione analogias ou exemplos.",
                                    "Teste em contexto: aplique a um problema real como Caixeiro Viajante."
                                  ],
                                  "verification": "Gravação ou texto revisado atende a critérios de clareza e precisão.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Gravador de voz/celular",
                                    "Modelo de problema: Caixeiro Viajante com 4 cidades"
                                  ],
                                  "tips": "Comece com 'O propósito é...' e termine com 'por exemplo...'",
                                  "learningObjective": "Explicar fluidamente o propósito principal de forma convincente.",
                                  "commonMistakes": [
                                    "Usar jargão excessivo",
                                    "Não enfatizar a garantia de optimalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema do Caixeiro Viajante com 4 cidades, um método exaustivo gera todas as 6 rotas possíveis (3! = 6), calcula distâncias e seleciona a menor, garantindo a rota ótima absoluta, ao contrário de uma heurística que pode pular algumas e errar.",
                              "finalVerifications": [
                                "Pode definir métodos exaustivos sem erros.",
                                "Explica corretamente a garantia de optimalidade.",
                                "Identifica pelo menos 2 cenários de uso apropriado.",
                                "Compara adequadamente com heurísticas.",
                                "Fornece um exemplo concreto sem falhas.",
                                "Verbaliza explicação em menos de 3 minutos com clareza."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual (definição e propósito: 30%)",
                                "Clareza na explicação verbal/escrita (25%)",
                                "Uso de exemplos relevantes (20%)",
                                "Compreensão de limitações e trade-offs (15%)",
                                "Capacidade de analogias para leigos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e teoria de grafos para contagem de possibilidades.",
                                "Filosofia: Lógica dedutiva e prova exaustiva em raciocínio.",
                                "Engenharia de Software: Testes exaustivos de cobertura total.",
                                "Economia: Otimização em alocação de recursos com garantia ótima."
                              ],
                              "realWorldApplication": "Em segurança cibernética, métodos exaustivos testam todas as chaves possíveis em criptoanálise para quebrar códigos fracos; em logística, garantem rotas ótimas para frotas pequenas onde o custo de subótimo é alto."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.1.1.3",
                            "name": "Diferenciar métodos exaustivos de heurísticas",
                            "description": "Comparar métodos exaustivos, que garantem optimalidade via enumeração completa, com heurísticas que priorizam velocidade mas podem não encontrar a solução ótima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais de Métodos Exaustivos",
                                  "subSteps": [
                                    "Leia a definição: métodos exaustivos enumeram todas as soluções possíveis para garantir a ótima.",
                                    "Identifique características chave: garantem optimalidade, mas são computacionalmente caros (tempo exponencial).",
                                    "Analise complexidade: O(n!) para problemas como permutações.",
                                    "Estude um exemplo simples: encontrar o maior número em uma lista via verificação completa.",
                                    "Anote prós (sempre ótimo) e contras (lento para n grande)."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e liste 3 características com exemplos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notebook e caneta",
                                    "Artigo sobre brute-force algorithms (ex: Wikipedia 'Brute-force search')"
                                  ],
                                  "tips": "Use analogia: como testar todas as chaves em uma fechadura até achar a certa.",
                                  "learningObjective": "Definir precisamente métodos exaustivos e suas propriedades.",
                                  "commonMistakes": [
                                    "Confundir com busca binária (que é eficiente)",
                                    "Ignorar impacto da escala no tempo de execução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Heurísticas e Suas Características",
                                  "subSteps": [
                                    "Defina heurística: método aproximado que usa regras práticas para soluções rápidas.",
                                    "Liste traços: prioriza velocidade, boa solução mas não necessariamente ótima, guiada por experiência.",
                                    "Examine tipos: greedy, simulated annealing, genetic algorithms.",
                                    "Calcule complexidade: geralmente polinomial, O(n log n) ou melhor.",
                                    "Exemplo básico: ordenar lista aproximando com heurística de inserção rápida."
                                  ],
                                  "verification": "Crie um fluxograma simples de uma heurística básica e compare tempo com exaustivo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para fluxograma",
                                    "Vídeo curto sobre heurísticas (ex: Khan Academy ou YouTube 'Heuristic Algorithms')"
                                  ],
                                  "tips": "Pense em GPS: não testa todas as rotas, usa atalhos baseados em tráfego médio.",
                                  "learningObjective": "Identificar heurísticas como alternativas práticas a métodos exaustivos.",
                                  "commonMistakes": [
                                    "Achar que heurísticas nunca são ótimas",
                                    "Confundir com métodos randômicos sem orientação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Métodos Exaustivos e Heurísticas Diretamente",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: colunas para optimalidade, tempo, uso ideal.",
                                    "Discuta trade-offs: exaustivo para n pequeno (<10), heurística para n grande.",
                                    "Analise cenários: quando precisão > velocidade vs. velocidade > precisão perfeita.",
                                    "Simule com números: para n=5, exaustivo viável; n=20, impraticável.",
                                    "Debata hibridizações: exaustivo + heurística para pruning."
                                  ],
                                  "verification": "Preencha tabela comparativa e justifique 2 cenários de escolha.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel quadriculado",
                                    "Pseudocódigo de exemplos simples"
                                  ],
                                  "tips": "Use métricas: tempo vs. qualidade da solução em gráfico mental.",
                                  "learningObjective": "Diferenciar claramente prós, contras e contextos de aplicação.",
                                  "commonMistakes": [
                                    "Generalizar exaustivo como sempre ruim",
                                    "Subestimar casos onde heurística falha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Diferenciação em um Problema Prático",
                                  "subSteps": [
                                    "Escolha problema: Caixeiro Viajante (TSP) com 4 cidades.",
                                    "Implemente exaustivo: gere todas permutações e ache menor custo.",
                                    "Aplique heurística: nearest neighbor para rota aproximada.",
                                    "Compare resultados: custo ótimo vs. aproximado e tempos.",
                                    "Reflita: escale para 10 cidades e discuta viabilidade."
                                  ],
                                  "verification": "Registre soluções, tempos e conclusão sobre qual usar por quê.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python ou pseudocódigo",
                                    "Ferramenta online como Repl.it para TSP"
                                  ],
                                  "tips": "Comece com distâncias pequenas para cálculo manual.",
                                  "learningObjective": "Demonstrar diferenciação prática através de implementação.",
                                  "commonMistakes": [
                                    "Esquecer de medir tempo real",
                                    "Não notar gaps na qualidade heurística"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema do Caixeiro Viajante (TSP) com 5 cidades: método exaustivo testa 24 rotas para achar a de 100km ótima (2s em PC); heurística nearest neighbor acha 120km em 0.1s. Diferença clara em escala e qualidade.",
                              "finalVerifications": [
                                "Explique em 1 parágrafo a diferença chave sem consultar notas.",
                                "Classifique 3 algoritmos dados como exaustivo ou heurístico corretamente.",
                                "Dê exemplo onde heurística supera exaustivo em tempo sem perda aceitável.",
                                "Identifique limiar de n onde exaustivo vira impraticável.",
                                "Compare trade-offs em tabela verbal."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (90% match com conceitos padrão).",
                                "Profundidade na comparação de trade-offs (prós/contras balanceados).",
                                "Uso correto de exemplos práticos e escalabilidade.",
                                "Clareza na justificativa de escolhas contextuais.",
                                "Ausência de confusões comuns (ex: heurística como randômica).",
                                "Completude da tabela comparativa e verificações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e teoria de grafos para enumeração.",
                                "Inteligência Artificial: Heurísticas em busca A* e aprendizado de máquina.",
                                "Economia/Gestão: Otimização em logística e supply chain.",
                                "Física: Simulações aproximadas em modelagem complexa."
                              ],
                              "realWorldApplication": "Em apps de roteirização como Google Maps: heurísticas para rotas rápidas em milhões de opções; exaustivos só para pequenos clusters. Em finanças, otimização de portfólios usa heurísticas para velocidade em mercados dinâmicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.2",
                        "name": "Princípios de Enumeração Completa",
                        "description": "Princípios que regem a geração e avaliação exaustiva de todas as combinações viáveis no espaço de busca, incluindo backtracking e força bruta.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.2.1",
                            "name": "Descrever o processo de enumeração completa",
                            "description": "Explicar passo a passo como os métodos exaustivos geram todas as permutações, combinações ou subconjuntos possíveis de uma instância de problema.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o problema e definir o tipo de enumeração",
                                  "subSteps": [
                                    "Analise a instância do problema e identifique o conjunto de elementos envolvidos (ex: n itens).",
                                    "Determine o tipo de enumeração necessária: permutações (todas as ordens), combinações (seleções sem ordem) ou subconjuntos (potência do conjunto).",
                                    "Calcule o tamanho total da enumeração (ex: n! para permutações, 2^n para subconjuntos).",
                                    "Esboce um exemplo pequeno manualmente para validar o entendimento.",
                                    "Defina os critérios de validade para cada candidato gerado."
                                  ],
                                  "verification": "Pode listar manualmente todas as possibilidades para um conjunto pequeno (ex: 3 elementos) sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para fatoriais e potências"
                                  ],
                                  "tips": "Sempre comece com n=2 ou n=3 para testar intuitivamente.",
                                  "learningObjective": "Compreender o escopo e o volume da enumeração completa.",
                                  "commonMistakes": "Confundir permutações (com ordem) com combinações (sem ordem) ou ignorar o conjunto vazio em subconjuntos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a estratégia de geração sistemática",
                                  "subSteps": [
                                    "Escolha o método de geração: recursivo (backtracking), iterativo ou usando bibliotecas.",
                                    "Para recursivo: defina a função que constrói soluções parciais adicionando um elemento por vez.",
                                    "Estabeleça o ponto de decisão: incluir/não incluir um elemento (subconjuntos), ou escolher próximo (permutações).",
                                    "Implemente controle de profundidade para evitar loops infinitos.",
                                    "Planeje o backtrack: remover o elemento e tentar a próxima opção."
                                  ],
                                  "verification": "Desenhe um diagrama de árvore de recursão para um exemplo pequeno mostrando todas as ramificações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado para diagrama de árvore",
                                    "Exemplos de pseudocódigo"
                                  ],
                                  "tips": "Use uma árvore de decisão para visualizar o processo antes de codificar.",
                                  "learningObjective": "Dominar a estrutura base para geração exaustiva sem duplicatas.",
                                  "commonMistakes": "Gerar duplicatas por não marcar elementos usados ou não ordenar adequadamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o processo de geração passo a passo",
                                  "subSteps": [
                                    "Inicie com solução vazia ou parcial.",
                                    "Em cada iteração, gere o próximo candidato adicionando elementos válidos.",
                                    "Verifique se é uma solução completa (tamanho total atingido).",
                                    "Se sim, registre-a; senão, avance recursivamente.",
                                    "Ao esgotar opções, faça backtrack e retorne.",
                                    "Continue até esgotar todas as ramificações da árvore."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o fluxo para gerar 3 permutações iniciais de [A,B,C].",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo template para backtracking",
                                    "Marcadores para anotar passos"
                                  ],
                                  "tips": "Simule o processo à mão para 4 elementos antes de generalizar.",
                                  "learningObjective": "Explicar com precisão o ciclo de construção, verificação e backtrack.",
                                  "commonMistakes": "Esquecer de processar o caso base (solução vazia) ou não tratar terminação corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Garantir completude, corretude e eficiência relativa",
                                  "subSteps": [
                                    "Prove completude: toda possibilidade é explorada pela árvore exaustiva.",
                                    "Verifique ausência de duplicatas: usando marcação de usados ou ordenação.",
                                    "Discuta corretude: cada folha da árvore é uma solução válida e única.",
                                    "Analise complexidade: O(n!) ou O(2^n), inevitável para exaustivo.",
                                    "Sugira podas (pruning) para otimização, mas sem perder completude.",
                                    "Teste com código simples ou simulação para validar."
                                  ],
                                  "verification": "Gere todas as soluções para um exemplo e confirme contagem exata (ex: 6 permutações para 3 itens).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Tabela de complexidades"
                                  ],
                                  "tips": "Conte as folhas da árvore para provar completude.",
                                  "learningObjective": "Avaliar propriedades fundamentais dos métodos exaustivos.",
                                  "commonMistakes": "Afirmar eficiência polinomial ou ignorar crescimento exponencial."
                                }
                              ],
                              "practicalExample": "Para gerar todas as permutações de [1,2,3] usando backtracking: Inicie com []. Adicione 1 → [1], então 2 → [1,2], então 3 → [1,2,3] (registre). Backtrack, troque por [1,3,2] (registre). Continue até [3,2,1], totalizando 6 permutações únicas.",
                              "finalVerifications": [
                                "Lista corretamente todas as permutações/combinações/subconjuntos de um conjunto pequeno.",
                                "Desenha árvore de recursão completa sem ramificações faltantes.",
                                "Explica backtrack com exemplo concreto.",
                                "Calcula tamanho exato da enumeração.",
                                "Identifica e evita duplicatas na descrição.",
                                "Prova completude verbalmente."
                              ],
                              "assessmentCriteria": [
                                "Clareza na distinção entre tipos de enumeração (permutações vs. combinações).",
                                "Detalhamento preciso do ciclo recursivo (construir-verificar-backtrack).",
                                "Uso de exemplos concretos em todos os passos.",
                                "Correta análise de completude e ausência de duplicatas.",
                                "Inclusão de complexidade temporal.",
                                "Estrutura lógica e sequencial da explicação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e Teoria dos Conjuntos.",
                                "Programação: Recursão e Estruturas de Dados (árvores).",
                                "Otimização: Introdução a Branch and Bound.",
                                "Lógica: Provas de exaustividade."
                              ],
                              "realWorldApplication": "Em criptoanálise, métodos exaustivos testam todas as chaves possíveis em ataques de força bruta para descriptografar mensagens curtas, ou em verificação de software para cobrir todos os cenários de teste possíveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.2",
                            "name": "Reconhecer exemplos de enumeração em problemas pequenos",
                            "description": "Identificar cenários como o problema do caixeiro viajante com n=4 ou subconjunto soma em conjuntos pequenos onde a enumeração é factível.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Fundamentos da Enumeração Completa",
                                  "subSteps": [
                                    "Defina enumeração completa como a geração e verificação de todas as soluções possíveis em um espaço de busca.",
                                    "Explique por que ela é usada em métodos exaustivos: garante otimalidade em problemas decidíveis.",
                                    "Discuta limitações: viável apenas para espaços de busca pequenos (ex: 2^n ou n! baixo).",
                                    "Identifique métricas de tamanho: n ≤ 10 para permutações, |S| ≤ 20 para subconjuntos.",
                                    "Revise exemplos iniciais: contagem de soluções vs. problemas NP-completos."
                                  ],
                                  "verification": "Resuma em 3 frases os princípios da enumeração e liste 2 limitações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook e caneta",
                                    "Artigo sobre métodos exaustivos (PDF ou wiki)"
                                  ],
                                  "tips": "Use analogias como 'provar todos os caminhos em um labirinto pequeno'.",
                                  "learningObjective": "Compreender o conceito base de enumeração para reconhecimento posterior.",
                                  "commonMistakes": [
                                    "Confundir com heurísticas",
                                    "Ignorar o custo exponencial",
                                    "Achar que funciona para n grande"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Características de Problemas 'Pequenos' para Enumeração",
                                  "subSteps": [
                                    "Liste critérios: tamanho do input pequeno (n≤5 para TSP, soma alvo com |S|≤15).",
                                    "Calcule tamanhos de espaço: n! para permutações, 2^|S| para subconjuntos.",
                                    "Compare com problemas grandes: TSP n=20 tem 2.43e18 rotas (inviável).",
                                    "Pratique cálculo: para n=4, 24 permutações; para |S|=4, 16 subconjuntos.",
                                    "Crie tabela comparativa: problema, n, espaço de busca, factível?"
                                  ],
                                  "verification": "Crie tabela com 3 problemas e seus espaços de busca, marcando factibilidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora ou Python para fatorial/2^n",
                                    "Planilha Excel"
                                  ],
                                  "tips": "Lembre: factível se <10^6 soluções tipicamente.",
                                  "learningObjective": "Reconhecer quando enumeração é computacionalmente viável.",
                                  "commonMistakes": [
                                    "Subestimar crescimento exponencial",
                                    "Confundir com aproximações",
                                    "Usar n grande como exemplo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Exemplos Clássicos de Enumeração em Problemas Pequenos",
                                  "subSteps": [
                                    "Estude TSP n=4: 4 cidades, enumerar (4-1)!/2 = 12 rotas únicas (direcionado: 24).",
                                    "Detalhe Subconjunto Soma: |S|=5, alvo=10, enumerar 32 subconjuntos.",
                                    "Desenhe grafos para TSP e liste todas permutações.",
                                    "Simule execução: verifique cada solução contra restrições.",
                                    "Compare com variantes: TSP n=5 (120 rotas, ainda ok)."
                                  ],
                                  "verification": "Liste todas soluções para TSP n=3 e SubSoma |S|=3, alvo=5.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para desenhar grafos",
                                    "Ferramenta online como TSP solver demo"
                                  ],
                                  "tips": "Comece com n=3 para visualizar antes de n=4.",
                                  "learningObjective": "Reconhecer e descrever exemplos padrão onde enumeração funciona.",
                                  "commonMistakes": [
                                    "Esquecer simetria em TSP",
                                    "Não considerar vazios em subconjuntos",
                                    "Pular verificação de viabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Reconhecimento em Novos Problemas",
                                  "subSteps": [
                                    "Receba 5 problemas aleatórios e classifique: enumeração factível? Por quê?",
                                    "Exemplos: agendamento 4 tarefas, knapsack 0/1 com 5 itens.",
                                    "Justifique: calcule espaço e compare com limites.",
                                    "Discuta borderline: n=6 TSP (720 rotas, marginal).",
                                    "Crie seu próprio problema pequeno e resolva por enumeração."
                                  ],
                                  "verification": "Classifique corretamente 4/5 problemas dados como 'enumeração viável'.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de problemas NP-completos (online)",
                                    "Timer para prática"
                                  ],
                                  "tips": "Sempre calcule o tamanho exato do espaço primeiro.",
                                  "learningObjective": "Aplicar reconhecimento independentemente em cenários variados.",
                                  "commonMistakes": [
                                    "Classificar grande como pequeno",
                                    "Ignorar constraints que reduzem espaço",
                                    "Não justificar com números"
                                  ]
                                }
                              ],
                              "practicalExample": "Para TSP com 4 cidades A,B,C,D e distâncias d(A,B)=1, d(A,C)=2, etc., enumere todas 24 permutações de rotas A->X->Y->Z->A, calcule custos e encontre mínimo (ex: A-B-C-D-A custo 10).",
                              "finalVerifications": [
                                "Lista todas permutações para TSP n=4.",
                                "Calcula corretamente 2^5=32 para subconjunto soma.",
                                "Identifica 3 problemas onde enumeração é factível e 2 onde não.",
                                "Explica por que TSP n=4 é ok mas n=10 não.",
                                "Cria tabela comparativa de 4 problemas.",
                                "Resolve SubSoma |S|=4 por enumeração manual."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de espaços de busca (100% correto).",
                                "Correta identificação de factibilidade em 90% dos casos.",
                                "Explicações claras com exemplos numéricos.",
                                "Uso de critérios quantitativos (n!, 2^n) em todas respostas.",
                                "Capacidade de criar exemplos próprios viáveis.",
                                "Ausência de confusão com métodos não-exaustivos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e teoria de grafos para modelagem.",
                                "Programação: Implementar loops aninhados para enumeração em Python.",
                                "Lógica: Raciocínio dedutivo em verificação de soluções.",
                                "Otimização: Introdução a problemas NP-completos em IA."
                              ],
                              "realWorldApplication": "Em cenários limitados como roteirização de entregas para 4-5 pontos (logística pequena), configuração ótima de 4 máquinas ou testes exaustivos em software com poucas variáveis."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.2.3",
                            "name": "Analisar o custo computacional da exaustividade",
                            "description": "Calcular e discutir a complexidade exponencial típica (O(2^n) ou similar) decorrente da enumeração de todas as soluções possíveis.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Enumeração Exaustiva",
                                  "subSteps": [
                                    "Defina enumeração exaustiva como a geração e verificação de todas as soluções possíveis em um espaço de busca.",
                                    "Identifique problemas clássicos que usam exaustividade, como o problema do caixeiro-viajante ou subconjuntos de um conjunto.",
                                    "Explique por que a exaustividade garante otimalidade, mas ao custo de completude.",
                                    "Diferencie exaustividade de heurísticas ou aproximadas.",
                                    "Liste exemplos de espaços de busca discretos e finitos."
                                  ],
                                  "verification": "Escreva uma definição clara e liste 3 exemplos de problemas exaustivos com justificativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Artigo introdutório sobre algoritmos exaustivos (ex: Wikipedia - Brute-force search)"
                                  ],
                                  "tips": "Comece com problemas pequenos para visualizar o crescimento do espaço de busca.",
                                  "learningObjective": "Entender o conceito base da exaustividade e seus trade-offs iniciais.",
                                  "commonMistakes": [
                                    "Confundir exaustividade com busca aleatória",
                                    "Ignorar que nem todos os problemas têm espaço finito"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o Tamanho do Espaço de Busca",
                                  "subSteps": [
                                    "Para um problema dado, identifique os parâmetros que definem o espaço (ex: n itens → 2^n subconjuntos).",
                                    "Use combinatória para contar possibilidades: permutações (n!), combinações (C(n,k)), etc.",
                                    "Construa uma árvore de decisão ou tabela para visualizar o número de folhas (soluções candidatas).",
                                    "Calcule explicitamente para n=1 até n=10 para observar o crescimento.",
                                    "Registre fórmulas como |S| = 2^n para subconjuntos ou n! para permutações."
                                  ],
                                  "verification": "Para um conjunto de 5 elementos, calcule e liste o número exato de subconjuntos (32) e explique o padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora ou Python para potências e fatoriais",
                                    "Papel e lápis para tabelas"
                                  ],
                                  "tips": "Use logaritmos para estimar grandes n sem calcular números exatos.",
                                  "learningObjective": "Dominar o cálculo preciso do tamanho do espaço de enumeração.",
                                  "commonMistakes": [
                                    "Esquecer de contar apenas soluções válidas vs. todas candidatas",
                                    "Confundir combinações com permutações"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Expressar e Analisar a Complexidade em Notação Big O",
                                  "subSteps": [
                                    "Traduza o tamanho do espaço |S| para notação assintótica: O(2^n), O(n!), etc.",
                                    "Discuta tempo por operação: assuma O(1) por candidato, então T(n) = Θ(|S|).",
                                    "Compare com polinomiais: exponencial vs. O(n^k) para qualquer k.",
                                    "Plote ou descreva curvas de crescimento em gráfico logarítmico.",
                                    "Calcule tempo real: assuma 10^9 ops/seg, quanto tempo para n=40 em O(2^n)?"
                                  ],
                                  "verification": "Derive O(2^n) para subconjuntos e estime tempo para n=30 (bilhões de anos).",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha Excel ou Python para plots",
                                    "Tabela de tempos de execução (ex: 2^10=1s, 2^20=1min)"
                                  ],
                                  "tips": "Lembre: Big O foca no pior caso, comum em exaustivos.",
                                  "learningObjective": "Analisar formalmente a complexidade exponencial da exaustividade.",
                                  "commonMistakes": [
                                    "Omitir constantes ou custos de verificação por candidato",
                                    "Confundir O(2^n) com linear"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Implicações Práticas e Limites Computacionais",
                                  "subSteps": [
                                    "Avalie viabilidade: para quais n é factível (ex: n<30 para 2^n)?",
                                    "Considere otimizações como poda (branch-and-bound) que reduzem mas mantêm pior caso exponencial.",
                                    "Debata trade-offs: exaustivo para corretude vs. heurísticas para escala.",
                                    "Relacione com Lei de Moore: hardware dobra a cada 18 meses, mas 2^n cresce mais rápido.",
                                    "Conclua quando usar exaustivos (problemas pequenos, provas de lower bound)."
                                  ],
                                  "verification": "Escreva um parágrafo discutindo por que exaustivos são 'inviáveis' para n grande, com exemplo numérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Leitura: 'The Traveling Salesman Problem' seção sobre brute force",
                                    "Vídeo curto sobre complexidade (ex: 3Blue1Brown)"
                                  ],
                                  "tips": "Pense em aplicações reais como criptoanálise para motivar.",
                                  "learningObjective": "Avaliar criticamente o custo da exaustividade no contexto prático.",
                                  "commonMistakes": [
                                    "Superestimar viabilidade ignorando overheads",
                                    "Ignorar podas que mascaram o custo exponencial"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de Subconjunto Soma (dado array [1,3,4,5] soma=9), enumere todos 16 subconjuntos (2^4), verifique cada um: custo O(2^n * n) devido à soma por subconjunto. Para n=40, inviável (1 trilhão ops).",
                              "finalVerifications": [
                                "Calcule corretamente |S| para 3 problemas diferentes (subconjuntos, permutações, N-rainhas).",
                                "Classifique complexidades como exponenciais vs. polinomiais com justificativa.",
                                "Estime tempo de execução para n=25 em O(2^n) assumindo 1GHz máquina.",
                                "Explique por que exaustivos provam lower bounds em otimização.",
                                "Identifique 2 cenários onde exaustivo é prático apesar de exponencial.",
                                "Discuta impacto de poda em um exemplo concreto."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de |S| e Big O (exata ou assintótica correta).",
                                "Profundidade na análise de crescimento exponencial vs. polinomial.",
                                "Uso correto de exemplos reais com números concretos.",
                                "Clareza na discussão de viabilidade prática e trade-offs.",
                                "Identificação de erros comuns e como evitá-los.",
                                "Conexão com implicações além do teórico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e análise assintótica (funções exponenciais).",
                                "Física: Simulações exaustivas em mecânica quântica (espaços de Hilbert).",
                                "Economia: Otimização combinatorial em alocação de recursos.",
                                "Criptografia: Ataques brute-force em chaves (2^128 espaço).",
                                "IA: Busca exaustiva em árvores de jogo como xadrez minimax."
                              ],
                              "realWorldApplication": "Em cibersegurança, analisar custo de brute-force em senhas (O(95^l) para comprimento l), guiando políticas de força mínima; ou em logística, avaliar se enumerar rotas para 15 cidades é viável antes de recorrer a heurísticas como genetícos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.1.3",
                        "name": "Garantia de Optimalidade e Limitações",
                        "description": "Como a exaustividade assegura a solução ótima em problemas pequenos, contrastando com limitações em instâncias maiores.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.1.3.1",
                            "name": "Explicar a garantia de optimalidade",
                            "description": "Argumentar por que a enumeração completa garante encontrar a solução ótima, pois todas as possibilidades são verificadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Enumeração Completa em Métodos Exaustivos",
                                  "subSteps": [
                                    "Defina enumeração completa como a geração e verificação de todas as soluções possíveis em um espaço de busca finito.",
                                    "Identifique o espaço de soluções: liste todos os elementos possíveis sem duplicatas ou omissões.",
                                    "Explique que métodos exaustivos não usam podas prematuras, garantindo cobertura total.",
                                    "Diferencie de métodos parciais que amostram apenas subconjuntos.",
                                    "Crie um diagrama simples do espaço de busca total."
                                  ],
                                  "verification": "Liste todas as soluções possíveis para um problema pequeno (ex: 3 itens) sem faltas ou sobras.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou diagrama online como Draw.io"
                                  ],
                                  "tips": "Comece com espaços pequenos para visualizar a completude antes de escalar.",
                                  "learningObjective": "Compreender a base da exhaustividade como cobertura total do espaço de soluções.",
                                  "commonMistakes": [
                                    "Confundir com busca aleatória",
                                    "Ignorar restrições do problema que definem o espaço"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Optimalidade em Problemas de Otimização",
                                  "subSteps": [
                                    "Defina solução ótima como aquela que minimiza/maximiza a função objetivo entre todas as viáveis.",
                                    "Esclareça viabilidade: soluções que satisfazem todas as restrições.",
                                    "Discuta funções objetivo: custo, tempo, lucro, etc.",
                                    "Classifique problemas: minimização (ex: menor caminho) vs. maximização (ex: maior cobertura).",
                                    "Escreva formalmente: argmax/argmin f(x) para x em S (espaço de soluções)."
                                  ],
                                  "verification": "Forneça definição precisa e classifique 2 exemplos de problemas como min/max.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Livro de algoritmos ou PDF sobre otimização",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use notação matemática para precisão, mas explique em linguagem natural.",
                                  "learningObjective": "Dominar a noção de optimalidade como extremum global no espaço completo.",
                                  "commonMistakes": [
                                    "Confundir ótima global com local",
                                    "Esquecer restrições de viabilidade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir o Argumento Lógico da Garantia de Optimalidade",
                                  "subSteps": [
                                    "Afirme: Como todas as soluções viáveis são enumeradas, a melhor é inevitavelmente incluída e comparada.",
                                    "Estruture prova: 1) Espaço finito e enumerado completamente; 2) Avaliação imparcial de todos; 3) Seleção do melhor por comparação direta.",
                                    "Use lógica: Por exaustão, ∀ soluções x ∈ S, f(x) é computado, logo argopt é encontrado.",
                                    "Aborde completude: Sem omissões, não há solução melhor 'escondida'.",
                                    "Compare com heurísticas: Elas podem perder a ótima por amostragem incompleta."
                                  ],
                                  "verification": "Escreva um parágrafo argumentando a garantia e refute uma contra-argumento comum.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de algoritmo exaustivo",
                                    "Ferramenta de escrita como Google Docs"
                                  ],
                                  "tips": "Use silogismos: Premissa1 (completude), Premissa2 (comparação), Conclusão (otimalidade).",
                                  "learningObjective": "Formular argumento lógico irrefutável da garantia via exhaustividade.",
                                  "commonMistakes": [
                                    "Assumir infinitude do espaço",
                                    "Ignorar custo computacional na garantia"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Verificar o Conceito com um Exemplo Simples",
                                  "subSteps": [
                                    "Escolha problema: Subconjunto ótimo para soma exata (ex: números 1,2,3,4 somar 6).",
                                    "Enumere todas as combinações viáveis: {2,4}, {1,2,3}, etc.",
                                    "Avalie função objetivo (soma ==6, maximizar tamanho).",
                                    "Identifique ótima e prove por exhaustividade.",
                                    "Discuta escalabilidade: Funciona para pequeno N, mas exponencial."
                                  ],
                                  "verification": "Resolva o exemplo manualmente e explique por que é ótima.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou Python REPL para enumeração pequena"
                                  ],
                                  "tips": "Implemente em código simples para validar enumeração.",
                                  "learningObjective": "Internalizar garantia através de aplicação prática.",
                                  "commonMistakes": [
                                    "Erros de enumeração manual",
                                    "Selecionar heurística em vez de exaustiva"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema do Caixeiro Viajante com 4 cidades (A,B,C,D), enumere todas as 6 rotas possíveis (permutações): A-B-C-D, A-B-D-C, etc. Calcule distâncias totais para cada e selecione a menor (ex: 100km). Como todas foram verificadas, é garantidamente ótima.",
                              "finalVerifications": [
                                "Explicar em 1 minuto por que exhaustividade garante optimalidade sem ambiguidades.",
                                "Provar logicamente para um problema dado que nenhuma solução melhor foi omitida.",
                                "Identificar ótima em enumeração manual de 5 soluções.",
                                "Diferenciar garantia exaustiva vs. probabilística de heurísticas.",
                                "Resumir limitações (tempo) sem invalidar a garantia teórica.",
                                "Aplicar argumento a novo contexto de otimização."
                              ],
                              "assessmentCriteria": [
                                "Precisão lógica: Argumento cobre completude, avaliação e seleção sem falhas.",
                                "Clareza: Explicação acessível, com termos definidos e sem jargão desnecessário.",
                                "Completude: Inclui formalização e contra-exemplos de métodos incompletos.",
                                "Exemplificação: Usa caso concreto para ilustrar garantia.",
                                "Profundidade: Discute implicações teóricas e práticas.",
                                "Originalidade: Reformula em palavras próprias, não copia definições."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos conjuntos (espaços finitos) e lógica proposicional (provas exaustivas).",
                                "Filosofia: Exhaustividade em silogismos aristotélicos e método cartesiano.",
                                "Ciência da Computação: Complexidade (NP-completo) e verificação formal.",
                                "Estatística: Comparação com amostragem completa vs. Monte Carlo.",
                                "Engenharia: Testes exaustivos em software para cobertura 100%."
                              ],
                              "realWorldApplication": "Em criptoanálise, enumeração exaustiva de chaves curtas garante quebra ótima; em planejamento de rotas logísticas pequenas, assegura menor custo sem surpresas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.1.3.2",
                            "name": "Identificar limitações para problemas pequenos",
                            "description": "Discutir por que métodos exaustivos são viáveis apenas para tamanhos de entrada pequenos (ex: n ≤ 20), devido ao tempo exponencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a natureza exponencial dos métodos exaustivos",
                                  "subSteps": [
                                    "Definir métodos exaustivos como algoritmos que testam todas as combinações possíveis de soluções.",
                                    "Explicar complexidades comuns: O(n!) para permutações ou O(2^n) para subconjuntos.",
                                    "Calcular exemplos simples: para n=5, 5! = 120; para n=10, 3.628.800 operações.",
                                    "Discutir que o tempo cresce exponencialmente com n."
                                  ],
                                  "verification": "Escrever a definição e calcular 4! e 5! corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Tabela de fatoriais impressa",
                                    "Calculadora"
                                  ],
                                  "tips": "Use fatoriais para visualizar o crescimento rápido; memorize valores até 10!",
                                  "learningObjective": "Identificar e quantificar a complexidade temporal exponencial.",
                                  "commonMistakes": [
                                    "Confundir complexidade exponencial com linear ou quadrática.",
                                    "Ignorar o impacto do hardware real."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o impacto prático do tempo de execução",
                                  "subSteps": [
                                    "Estimar tempo de execução assumindo 10^9 operações por segundo (computador moderno).",
                                    "Calcular para n=20: 20! ≈ 2.43 × 10^18 operações → tempo em anos.",
                                    "Comparar n≤20 (viável em segundos/minutos) vs n>20 (impraticável).",
                                    "Plotar gráfico simples de tempo vs n para visualização.",
                                    "Testar código simples de enumeração para n=10 e medir tempo."
                                  ],
                                  "verification": "Calcular tempo para n=15 e concluir se é viável (resposta: não).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou pseudocódigo",
                                    "Cronômetro",
                                    "Gráfico em papel ou Excel"
                                  ],
                                  "tips": "Assuma 1 bilhão de ops/segundo; multiplique fatoriais por isso.",
                                  "learningObjective": "Quantificar por que n≤20 é o limite prático.",
                                  "commonMistakes": [
                                    "Subestimar fatoriais grandes ou ignorar overhead real."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar limites computacionais reais",
                                  "subSteps": [
                                    "Discutir limitações de hardware: CPU, memória e paralelismo.",
                                    "Explicar por que paralelismo (ex: 1000 cores) não resolve exponencial puro.",
                                    "Comparar com problemas NP-completos onde exaustivo falha para n médio.",
                                    "Analisar trade-offs: precisão vs tempo em cenários reais."
                                  ],
                                  "verification": "Explicar em 2 frases por que n=30 é impossível mesmo com supercomputador.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Artigos sobre complexidade NP",
                                    "Vídeo curto sobre tempo exponencial"
                                  ],
                                  "tips": "Pense em termos de universo: tempo do Big Bang não basta para n=100!",
                                  "learningObjective": "Reconhecer barreiras físicas e teóricas além da teoria.",
                                  "commonMistakes": [
                                    "Acreditar que mais hardware resolve tudo exponencial."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o conceito a um exemplo concreto",
                                  "subSteps": [
                                    "Escolher problema: Caixeiro Viajante (TSP) com n cidades.",
                                    "Implementar exaustivo simples para n=8 (viável) e tentar n=12 (lento).",
                                    "Medir e discutir: para n=20, inviável.",
                                    "Concluir limitações e sugerir heurísticas para n maior.",
                                    "Documentar lições aprendidas."
                                  ],
                                  "verification": "Executar código para n=10 e relatar tempo <1min, n=12 >10min.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ambiente Python com itertools",
                                    "Dataset pequeno de TSP"
                                  ],
                                  "tips": "Use permutations() no Python para protótipo rápido.",
                                  "learningObjective": "Demonstrar limitações na prática com medições reais.",
                                  "commonMistakes": [
                                    "Não medir tempo real ou usar n muito pequeno."
                                  ]
                                }
                              ],
                              "practicalExample": "No problema do Caixeiro Viajante (TSP) com 10 cidades, um método exaustivo testa 9! ≈ 362k rotas em segundos; para 20 cidades, 19! ≈ 1.2×10^17 rotas levam bilhões de anos em um PC comum.",
                              "finalVerifications": [
                                "Explicar corretamente por que n≤20 é limite para exaustivo.",
                                "Calcular tempo para n=15 com precisão (milênios).",
                                "Identificar 3 problemas onde exaustivo só funciona para n pequeno.",
                                "Comparar exaustivo vs heurística em exemplo prático.",
                                "Discutir impacto de hardware moderno no limite.",
                                "Listar 2 erros comuns em análise de complexidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação de crescimento exponencial (nota 1-5).",
                                "Cálculos corretos de fatoriais e tempos estimados.",
                                "Uso de exemplos concretos com medições reais.",
                                "Identificação clara de limites práticos (n≤20).",
                                "Conexão com conceitos de NP-completude.",
                                "Clareza na discussão de alternativas (heurísticas)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de funções exponenciais e fatoriais.",
                                "Física: Limites termodinâmicos da computação (Landauer).",
                                "Economia: Custo-benefício de tempo computacional em projetos.",
                                "Estatística: Probabilidade em amostragem vs enumeração total."
                              ],
                              "realWorldApplication": "Em otimização logística (ex: rotas de entrega), métodos exaustivos são usados só para frotas pequenas (n≤15); para grandes, heurísticas como Google Maps economizam tempo exponencial, priorizando soluções 'boas o suficiente'."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.1.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.2",
                    "name": "Algoritmo de Força Bruta",
                    "description": "Enumeração direta e completa de todas as possibilidades sem podas ou otimizações.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.2.1",
                        "name": "Definição e Características do Algoritmo de Força Bruta",
                        "description": "Compreensão dos princípios fundamentais do algoritmo de força bruta, que consiste na enumeração direta e completa de todas as possibilidades sem podas ou otimizações, garantindo a exaustividade da busca.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.1.1",
                            "name": "Identificar cenários adequados para força bruta",
                            "description": "Reconhecer problemas onde a enumeração completa é viável, como problemas de tamanho pequeno ou com restrições limitadas, diferenciando de métodos heurísticos ou otimizados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos da força bruta",
                                  "subSteps": [
                                    "Estude a definição de força bruta: enumeração exaustiva de todas as soluções possíveis.",
                                    "Analise as limitações: viável apenas para espaços de busca pequenos (ex: n ≤ 10-15).",
                                    "Revise a complexidade temporal: O(n!) ou similar para problemas combinatórios.",
                                    "Identifique pré-requisitos: conhecimento básico de complexidade algorítmica.",
                                    "Registre exemplos clássicos como busca exaustiva em grafos pequenos."
                                  ],
                                  "verification": "Explique em suas palavras o que é força bruta e cite uma limitação chave.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notebook para anotações",
                                    "Artigo ou vídeo sobre força bruta (ex: Wikipedia ou Khan Academy)"
                                  ],
                                  "tips": "Use analogias cotidianas, como tentar todas as chaves em uma fechadura.",
                                  "learningObjective": "Dominar a definição e limitações da força bruta para basear identificações futuras.",
                                  "commonMistakes": [
                                    "Confundir com backtracking (que poda buscas)",
                                    "Ignorar impacto da escala no tempo de execução"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar características de problemas adequados",
                                  "subSteps": [
                                    "Liste critérios: tamanho de entrada pequeno, restrições limitadas (ex: n<20).",
                                    "Avalie restrições: problemas com simetrias ou independência de ordem favorecem FB.",
                                    "Classifique tipos: permutações curtas, subconjuntos pequenos, combinações limitadas.",
                                    "Pratique filtrando: marque problemas com n grande como inadequados.",
                                    "Crie uma checklist: 'Entrada pequena? Sem otimização necessária?'"
                                  ],
                                  "verification": "Crie uma tabela com 5 problemas hipotéticos e classifique-os como adequados ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Lista de problemas algorítmicos clássicos"
                                  ],
                                  "tips": "Comece com problemas conhecidos como N-Reinas para n=4.",
                                  "learningObjective": "Reconhecer padrões em problemas onde enumeração é factível.",
                                  "commonMistakes": [
                                    "Superestimar viabilidade para n médio",
                                    "Ignorar overhead de implementação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Diferenciar de métodos heurísticos e otimizados",
                                  "subSteps": [
                                    "Compare com heurísticas: FB garante otimalidade, heurísticas são aproximadas e rápidas.",
                                    "Analise branch-and-bound: poda FB, mas requer estrutura adicional.",
                                    "Estude DP vs FB: DP para sobreposições, FB para independentes.",
                                    "Monte uma matriz comparativa: tempo, garantia, aplicabilidade.",
                                    "Teste em um problema: escolha FB só se outros forem ineficazes."
                                  ],
                                  "verification": "Para 3 problemas, justifique por que FB é ou não melhor que alternativas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro branco ou ferramenta digital como Draw.io para matriz"
                                  ],
                                  "tips": "Lembre: FB é baseline; use quando protótipo rápido é prioridade.",
                                  "learningObjective": "Discernir contextos onde FB é preferível sobre abordagens avançadas.",
                                  "commonMistakes": [
                                    "Assumir FB sempre incorreta para n pequeno",
                                    "Confundir exaustivo com greedy"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar identificação em cenários reais",
                                  "subSteps": [
                                    "Selecione 5 problemas reais: senha curta (4 dígitos), TSP com 5 cidades.",
                                    "Aplique checklist do step 2 e diferenciação do step 3.",
                                    "Implemente um em código simples para validar tempo.",
                                    "Registre decisões: 'Adequado por n=5, tempo <1s'.",
                                    "Revise com pares ou autoavaliação."
                                  ],
                                  "verification": "Apresente portfólio com 5 análises justificadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código (Python/IDEs)",
                                    "Datasets pequenos de problemas"
                                  ],
                                  "tips": "Meça tempo real de execução para validar intuição.",
                                  "learningObjective": "Aplicar critérios para decidir uso de FB em prática.",
                                  "commonMistakes": [
                                    "Não testar empiricamente",
                                    "Escolher FB por preguiça em otimizar"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema do Caixeiro Viajante (TSP) com 5 cidades: enumere todas as 24 permutações (5!-1), calcule distâncias e encontre o menor caminho. Viável em segundos, ideal para protótipo ou verificação exata.",
                              "finalVerifications": [
                                "Classifica corretamente 80% de 10 cenários mistos como adequados para FB.",
                                "Justifica decisões com critérios de tamanho e restrições.",
                                "Diferencia FB de heurísticas em exemplos concretos.",
                                "Implementa FB simples sem erros para n pequeno.",
                                "Identifica quando FB serve como baseline para métodos avançados.",
                                "Cria checklist pessoal reutilizável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação: ≥90% acertos em testes.",
                                "Justificativas claras e baseadas em complexidade.",
                                "Uso correto de comparações com alternativas.",
                                "Exemplos práticos relevantes e testados.",
                                "Checklist abrangente com ≥5 critérios.",
                                "Demonstração empírica (tempos de execução)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e teoria de grafos para espaços de busca.",
                                "Física: Simulações exaustivas em sistemas pequenos (ex: partículas).",
                                "Engenharia de Software: Prototipagem rápida e testes de baseline.",
                                "Estatística: Enumeração em amostras pequenas para validação exata."
                              ],
                              "realWorldApplication": "Em cibersegurança, testar senhas curtas por força bruta; em jogos, IA para tabuleiros pequenos como damas 3x3; em otimização logística para rotas com poucas paradas, garantindo solução ótima exata."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.2.1.2",
                            "name": "Descrever o processo de enumeração exaustiva",
                            "description": "Explicar passo a passo como gerar todas as combinações possíveis de entradas, incluindo o uso de loops aninhados para percorrer o espaço de busca.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Enumeração Exaustiva",
                                  "subSteps": [
                                    "Defina enumeração exaustiva como o processo sistemático de gerar e testar todas as combinações possíveis de entradas em um espaço de busca finito.",
                                    "Identifique cenários ideais: espaços de busca pequenos onde a exaustividade garante a solução ótima.",
                                    "Compare com métodos aproximados, destacando a garantia de completude versus alto custo computacional.",
                                    "Analise a complexidade temporal: O(|D1| × |D2| × ... × |Dk|) para k variáveis com domínios Di.",
                                    "Discuta limitações: inviável para espaços grandes devido à explosão combinatória."
                                  ],
                                  "verification": "Escreva uma definição clara em 50 palavras e liste três exemplos reais de aplicação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para anotações",
                                    "Acesso a um editor de texto simples"
                                  ],
                                  "tips": "Use analogias cotidianas como tentar todas as chaves em um chaveiro para visualizar a exaustividade.",
                                  "learningObjective": "Dominar a definição, propósitos e limitações da enumeração exaustiva.",
                                  "commonMistakes": [
                                    "Confundir com busca randômica (não garante completude)",
                                    "Subestimar o crescimento exponencial do espaço de busca"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Espaço de Busca",
                                  "subSteps": [
                                    "Identifique todas as variáveis de entrada e seus domínios discretos (ex: dígitos 0-9 para senhas).",
                                    "Calcule o tamanho total do espaço de busca como o produto cartesiano dos tamanhos dos domínios.",
                                    "Represente graficamente o espaço usando diagramas de árvore para 2-3 variáveis.",
                                    "Verifique se o problema é adequadamente modelável como enumeração (domínios finitos e enumeráveis).",
                                    "Documente restrições iniciais que reduzem o espaço, se aplicável."
                                  ],
                                  "verification": "Crie uma tabela ou diagrama mostrando o espaço de busca para um exemplo com 2 variáveis (ex: 2 moedas: C/C, C/K, K/C, K/K).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de papel quadriculado",
                                    "Marcadores ou lápis"
                                  ],
                                  "tips": "Comece com domínios pequenos (tamanho 2-3) para visualizar facilmente.",
                                  "learningObjective": "Saber modelar problemas como espaços de busca enumeráveis.",
                                  "commonMistakes": [
                                    "Ignorar domínios infinitos ou contínuos",
                                    "Calcular incorretamente o produto cartesiano"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Projetar e Implementar Loops Aninhados",
                                  "subSteps": [
                                    "Estruture loops aninhados correspondendo à ordem das variáveis (externo para primeira, interno para última).",
                                    "Escreva pseudocódigo: for v1 in D1: for v2 in D2: ... for vk in Dk: processar(v1,...,vk).",
                                    "Implemente em uma linguagem de programação simples (ex: Python) para gerar todas as combinações.",
                                    "Adicione lógica de teste/função objetivo dentro do loop mais interno.",
                                    "Otimize iterações desnecessárias com quebras condicionais precoces, se possível."
                                  ],
                                  "verification": "Execute o código e confirme que gera exatamente o número esperado de combinações (ex: 100 para 2 dígitos 0-9).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Replit)",
                                    "Internet para referências de sintaxe de loops"
                                  ],
                                  "tips": "Teste com k=2 primeiro antes de expandir para mais variáveis.",
                                  "learningObjective": "Projetar estruturas de loops que percorram exaustivamente o espaço de busca.",
                                  "commonMistakes": [
                                    "Ordem errada de aninhamento levando a duplicatas",
                                    "Loops off-by-one (ex: range(10) em vez de range(9))"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar Completude e Eficiência da Enumeração",
                                  "subSteps": [
                                    "Conte o número de iterações executadas e compare com o tamanho teórico do espaço.",
                                    "Teste casos extremos: combinações mínimas e máximas nos domínios.",
                                    "Meça tempo de execução e discuta escalabilidade para espaços maiores.",
                                    "Registre resultados em uma tabela para análise.",
                                    "Reflita sobre melhorias: paralelização ou poda de branches."
                                  ],
                                  "verification": "Gere um relatório com contagem de combinações, tempo gasto e uma amostra de 5 combinações iniciais/finais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Cronômetro ou timer no código",
                                    "Planilha para registrar métricas"
                                  ],
                                  "tips": "Use print() ou logging para rastrear progressão durante execução.",
                                  "learningObjective": "Verificar se a enumeração cobre todo o espaço sem omissões ou duplicatas.",
                                  "commonMistakes": [
                                    "Não validar contra tamanho esperado",
                                    "Confundir eficiência com otimalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Para quebrar uma senha de 3 dígitos (0-9), use loops aninhados: for i in 0..9: for j in 0..9: for k in 0..9: teste_senha(i,j,k). Isso gera 1.000 combinações, testando exaustivamente até encontrar a correta (ex: 4-2-7).",
                              "finalVerifications": [
                                "Lista corretamente todas as 16 combinações para 2 variáveis booleanas (True/False).",
                                "Implementa código que itera exatamente 100 vezes para 2 dígitos decimais.",
                                "Explica verbalmente o papel dos loops aninhados no percorrer do produto cartesiano.",
                                "Calcula complexidade O(10^3) = 1.000 para senha de 3 dígitos.",
                                "Identifica quando enumeração exaustiva falha (ex: senhas longas >10 caracteres)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e modelagem do espaço de busca (30%)",
                                "Corretude da implementação de loops aninhados sem erros lógicos (30%)",
                                "Validação completa com métricas quantitativas (20%)",
                                "Clareza na explicação passo a passo (10%)",
                                "Análise de limitações e complexidade (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Produto cartesiano e combinatória",
                                "Programação: Estruturas de repetição e controle de fluxo",
                                "Ciência da Computação: Análise de complexidade algorítmica",
                                "Lógica e Filosofia: Raciocínio exaustivo versus heurístico"
                              ],
                              "realWorldApplication": "Em cibersegurança, ataques de força bruta testam todas as senhas possíveis para contas fracas; em otimização de hardware, enumera configurações de circuitos lógicos para encontrar a melhor; em jogos como Sudoku, gera todas as preenchidas possíveis para validação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.1.3",
                            "name": "Comparar força bruta com métodos exaustivos otimizados",
                            "description": "Analisar diferenças entre força bruta pura e variantes com podas, destacando a ausência de heurísticas ou branch-and-bound na versão básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Força Bruta Pura",
                                  "subSteps": [
                                    "Defina força bruta como o método que testa todas as combinações possíveis sem otimização prévia.",
                                    "Liste características principais: exaustividade total, ausência de podas ou heurísticas.",
                                    "Identifique problemas típicos: caixeiro viajante, subconjunto soma, N-rainhas.",
                                    "Calcule complexidade temporal: geralmente O(n!) ou O(2^n).",
                                    "Anote limitações: inviável para instâncias grandes devido a explosão combinatória."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras definindo força bruta e liste 3 exemplos de problemas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de algoritmos exaustivos",
                                    "Exemplos de problemas NP-completos"
                                  ],
                                  "tips": "Use diagramas de árvore de decisão para visualizar a exploração completa.",
                                  "learningObjective": "Compreender as bases e limitações da força bruta pura.",
                                  "commonMistakes": [
                                    "Confundir com busca exaustiva otimizada",
                                    "Ignorar a ausência total de pruning",
                                    "Subestimar a complexidade exponencial"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Métodos Exaustivos Otimizados",
                                  "subSteps": [
                                    "Descreva variantes como backtracking com poda (pruning) e branch-and-bound.",
                                    "Explique poda: eliminar ramos inviáveis usando critérios como limite superior/inferior.",
                                    "Diferencie de heurísticas: otimizações são exaustivas, mas reduzem espaço de busca.",
                                    "Estude exemplos: backtracking no N-rainhas com poda por colunas, branch-and-bound no caixeiro.",
                                    "Compare complexidade: ainda exponencial no pior caso, mas polinomial em prática para muitos casos."
                                  ],
                                  "verification": "Crie um fluxograma comparando força bruta vs. backtracking com poda.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigos de backtracking e branch-and-bound",
                                    "Ferramentas de visualização como VisuAlgo"
                                  ],
                                  "tips": "Foque em como a poda reduz nós visitados sem perder otimalidade.",
                                  "learningObjective": "Identificar mecanismos de otimização em métodos exaustivos.",
                                  "commonMistakes": [
                                    "Confundir poda com heurísticas aproximadas",
                                    "Achar que otimizações eliminam exaustividade",
                                    "Não notar pior caso idêntico"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Diferenças Chave Entre Força Bruta e Otimizados",
                                  "subSteps": [
                                    "Compare exaustividade: ambos garantem solução ótima, mas otimizados cortam ramos.",
                                    "Avalie ausência de heurísticas/branch-and-bound na força bruta básica.",
                                    "Meça eficiência: conte nós explorados em árvore de decisão para instâncias pequenas.",
                                    "Discuta trade-offs: força bruta simples de implementar, otimizados requerem bounding functions.",
                                    "Registre métricas: tempo de execução, memória, escalabilidade."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com 5 critérios (tempo, memória, implementação, garantias, casos práticos).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou tabela Markdown para comparação",
                                    "Implementações em Python simples"
                                  ],
                                  "tips": "Use contadores de nós para quantificar reduções na prática.",
                                  "learningObjective": "Destacar diferenças qualitativas e quantitativas.",
                                  "commonMistakes": [
                                    "Ignorar que força bruta é caso degenerado sem poda",
                                    "Superestimar ganhos em todos cenários",
                                    "Confundir com algoritmos greedy"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação em um Problema Prático",
                                  "subSteps": [
                                    "Escolha problema: caixeiro viajante com 5 cidades.",
                                    "Implemente força bruta pura: gere todas permutações.",
                                    "Adapte para backtracking com poda por limite inferior.",
                                    "Execute e compare tempos/nós visitados.",
                                    "Conclua lições: quando usar cada abordagem."
                                  ],
                                  "verification": "Gere relatório com tempos de execução e gráficos de comparação.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python com itertools.permutations",
                                    "Biblioteca timeit para medição"
                                  ],
                                  "tips": "Comece com n pequeno para validar, escale para observar diferenças.",
                                  "learningObjective": "Praticar comparação através de implementação empírica.",
                                  "commonMistakes": [
                                    "Bugs em geração de permutações",
                                    "Poda incorreta que perde otimalidade",
                                    "Não medir corretamente overhead de poda"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema do Caixeiro Viajante com 5 cidades, força bruta gera 120 permutações (5!), testando todas. Com backtracking otimizado, poda ramos onde custo parcial excede melhor atual, visitando ~40 nós, reduzindo tempo de 0.1s para 0.01s.",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças principais sem consultar notas.",
                                "Implementar tabela comparativa precisa para novo problema.",
                                "Identificar quando força bruta falha em escalabilidade vs. otimizados.",
                                "Calcular complexidade de ambos para TSP(n=10).",
                                "Discutir ausência de heurísticas na força bruta básica.",
                                "Comparar em código funcional com métricas reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e distinção de conceitos (30%)",
                                "Profundidade da análise comparativa quantitativa/qualitativa (25%)",
                                "Correta identificação de podas vs. heurísticas (20%)",
                                "Qualidade de exemplos práticos e implementações (15%)",
                                "Clareza em trade-offs e limitações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e teoria de grafos para complexidade.",
                                "Programação: Implementação de recursão e otimização de código.",
                                "Estatística: Análise empírica de performance com benchmarks.",
                                "Física: Otimização em simulações de partículas ou trajetórias."
                              ],
                              "realWorldApplication": "Em logística (otimização de rotas de entrega com OR-Tools usando branch-and-bound vs. brute-force para frotas pequenas), criptoanálise (ataques exaustivos em chaves curtas) e jogos (resolução exata de puzzles como Sudoku)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.2",
                        "name": "Implementação Prática do Algoritmo de Força Bruta",
                        "description": "Desenvolvimento de códigos para aplicar força bruta em problemas clássicos, focando em estruturas de dados simples e verificação exaustiva.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.2.1",
                            "name": "Implementar força bruta para problema de subconjunto",
                            "description": "Codificar uma solução que testa todos os subconjuntos possíveis de um conjunto para encontrar soma alvo, usando bitmasks ou recursão para gerar combinações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema e configurar a função base",
                                  "subSteps": [
                                    "Analise o problema Subset Sum: dado um array de inteiros e um target, verificar se existe um subconjunto que soma exatamente ao target.",
                                    "Defina a assinatura da função, ex: def subsetSumBruteForce(nums, target): em Python.",
                                    "Inicialize variáveis: n = len(nums), total_subsets = 2**n.",
                                    "Prepare uma lista para armazenar subconjuntos ou apenas flags de resultado.",
                                    "Escreva comentários explicando a abordagem de força bruta (O(2^n * n))."
                                  ],
                                  "verification": "Função é definida corretamente e roda sem erros em um array vazio ou target=0.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VSCode ou Jupyter)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Sempre teste casos edge primeiro: array vazio, target=0 (true), todos zeros.",
                                  "learningObjective": "Entender a formulação do problema e estrutura básica da solução exaustiva.",
                                  "commonMistakes": [
                                    "Confundir soma total com subconjunto",
                                    "Esquecer casos negativos ou zero",
                                    "Não calcular 2^n corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de subconjuntos com bitmasks",
                                  "subSteps": [
                                    "Use um loop de 0 a (1<<n) - 1 para representar cada bitmask.",
                                    "Para cada mask, extraia bits para formar o subconjunto: for i in range(n): if mask & (1<<i): incluir nums[i].",
                                    "Colete os elementos do subconjunto em uma lista temporária.",
                                    "Implemente uma função auxiliar para extrair subconjunto de um mask.",
                                    "Teste com n=3 para visualizar todos os 8 subconjuntos manualmente."
                                  ],
                                  "verification": "Imprima todos os subconjuntos gerados e confirme que são 2^n únicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora binária ou papel para desenhar bitmasks",
                                    "Exemplos de arrays pequenos"
                                  ],
                                  "tips": "Pense em bitmasks como contadores binários onde 1=incluir, 0=excluir.",
                                  "learningObjective": "Dominar representação de subconjuntos via manipulação de bits.",
                                  "commonMistakes": [
                                    "Loop errado: usar range(n) ao invés de range(1<<n)",
                                    "Shift de bits incorreto (1<<i vs i<<1)",
                                    "Duplicar elementos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular somas e verificar o target",
                                  "subSteps": [
                                    "Para cada subconjunto gerado, compute a soma dos elementos.",
                                    "Se soma == target, retorne True imediatamente (otimização precoce).",
                                    "Caso contrário, continue até o final e retorne False.",
                                    "Adicione logging para mostrar subconjuntos testados e suas somas.",
                                    "Implemente tratamento para overflow em linguagens como C++ (use long long)."
                                  ],
                                  "verification": "Execute com exemplo conhecido e confirme detecção correta do subconjunto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Array de teste: [3,34,4,12,5,2], target=9"
                                  ],
                                  "tips": "Pare ao encontrar o primeiro match para eficiência, mas comente a versão completa.",
                                  "learningObjective": "Aplicar verificação exaustiva e otimização básica em loops.",
                                  "commonMistakes": [
                                    "Somar índice ao invés de valor",
                                    "Não resetar soma por iteração",
                                    "Retornar índice ao invés de booleano"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, debugar e analisar a solução",
                                  "subSteps": [
                                    "Crie testes unitários: casos true/false, grandes n (até 20 para ver lentidão).",
                                    "Meça tempo de execução com timeit ou similar.",
                                    "Analise complexidade: tempo O(2^n * n), espaço O(1) ou O(n).",
                                    "Compare com recursão alternativa (backtracking).",
                                    "Documente limitações: viável só para n <= 30."
                                  ],
                                  "verification": "Todos testes passam e tempo é exponencial em n.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Biblioteca unittest ou pytest",
                                    "Relógio para medir performance"
                                  ],
                                  "tips": "Use n=25+ para demonstrar por que força bruta é impraticável em escala.",
                                  "learningObjective": "Avaliar corretude, performance e quando usar força bruta.",
                                  "commonMistakes": [
                                    "Testes insuficientes (só casos felizes)",
                                    "Ignorar overflow em somas",
                                    "Confundir com DP otimizado"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado nums = [3, 34, 4, 12, 5, 2] e target = 9, a função gera todos os 64 subconjuntos (2^6), calcula somas e encontra [4,5] que soma 9, retornando true. Para target=1, retorna false após checar todos.",
                              "finalVerifications": [
                                "Função retorna true/false corretamente para exemplos padrão.",
                                "Gera exatamente 2^n subconjuntos sem duplicatas.",
                                "Detecta subconjuntos vazios (soma=0).",
                                "Funciona com números negativos e zeros.",
                                "Performance degrada exponencialmente com n crescente.",
                                "Código é legível com comentários sobre bitmasks."
                              ],
                              "assessmentCriteria": [
                                "Corretude: passa em 100% dos testes unitários.",
                                "Eficiência da geração de subconjuntos via bitmasks.",
                                "Tratamento de edge cases (vazio, zero, overflow).",
                                "Clareza do código e documentação.",
                                "Análise de complexidade temporal e espacial.",
                                "Otimização precoce (early return)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória (2^n subconjuntos), operações binárias.",
                                "Programação Básica: Manipulação de bits, loops aninhados.",
                                "Algoritmos: Introdução a problemas NP-completos e exaustivos.",
                                "Otimização: Trade-offs entre simplicidade e performance."
                              ],
                              "realWorldApplication": "Aplicado em verificação de senhas curtas (subconjuntos de caracteres), planejamento de recursos limitados (knapsack pequeno), testes de cobertura em software ou simulações combinatórias onde n é baixo (ex: circuitos lógicos simples)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.2",
                            "name": "Aplicar força bruta em permutações",
                            "description": "Gerar e testar todas as permutações de uma sequência para resolver problemas como o caixeiro-viajante em instâncias pequenas, utilizando std::next_permutation ou recursão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos de permutações e força bruta",
                                  "subSteps": [
                                    "Defina permutação como rearranjo de elementos de uma sequência.",
                                    "Calcule o número de permutações: n! para n elementos.",
                                    "Explique força bruta: testar todas as permutações possíveis.",
                                    "Discuta limitações: viável apenas para n pequeno (n ≤ 10).",
                                    "Exemplo manual: permutações de {1,2,3}."
                                  ],
                                  "verification": "Responda um quiz com 5 perguntas sobre conceitos e calcule 5! manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora",
                                    "Documentação C++ sobre <algorithm>"
                                  ],
                                  "tips": "Visualize permutações com árvores de recursão para melhor compreensão.",
                                  "learningObjective": "Entender o que são permutações e quando usar força bruta.",
                                  "commonMistakes": [
                                    "Confundir permutação com combinação.",
                                    "Subestimar complexidade exponencial n!."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de permutações com std::next_permutation",
                                  "subSteps": [
                                    "Inclua <algorithm> e <vector>.",
                                    "Crie um vetor ordenado com elementos da sequência.",
                                    "Use do-while com next_permutation para gerar todas.",
                                    "Imprima cada permutação em uma função main.",
                                    "Teste com n=3 e verifique saída completa."
                                  ],
                                  "verification": "Programa gera exatamente 6 permutações para {1,2,3} sem duplicatas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C++ (g++)",
                                    "IDE como VS Code ou Code::Blocks"
                                  ],
                                  "tips": "Sempre ordene o vetor antes: std::sort(v.begin(), v.end()).",
                                  "learningObjective": "Gerar todas as permutações iterativamente de forma eficiente.",
                                  "commonMistakes": [
                                    "Esquecer de ordenar o vetor inicial.",
                                    "Usar loop while incorreto, pulando a primeira permutação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar geração recursiva de permutações",
                                  "subSteps": [
                                    "Crie função recursiva que troca elementos e chama a si mesma.",
                                    "Use swap para gerar variantes e backtrack.",
                                    "Passe vetor por referência e índice atual.",
                                    "Implemente base case: quando índice == tamanho.",
                                    "Teste e compare com next_permutation."
                                  ],
                                  "verification": "Função recursiva produz as mesmas permutações que a iterativa para n=4.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Compilador C++",
                                    "Debugger para rastrear recursão"
                                  ],
                                  "tips": "Desenhe pilha de chamadas recursivas no papel antes de codificar.",
                                  "learningObjective": "Dominar recursão para geração de permutações.",
                                  "commonMistakes": [
                                    "Não fazer backtrack (swap de volta).",
                                    "Índice off-by-one em recursão."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a permutações no problema do Caixeiro-Viajante (TSP)",
                                  "subSteps": [
                                    "Defina matriz de distâncias entre cidades (ex: 4x4).",
                                    "Gere permutações das cidades (excluindo cidade inicial).",
                                    "Para cada permutação, calcule custo total da rota.",
                                    "Registre a permutação com menor custo.",
                                    "Implemente usando next_permutation ou recursão."
                                  ],
                                  "verification": "Programa encontra rota ótima para instância de 4 cidades com custo mínimo correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Compilador C++",
                                    "Matriz de distâncias exemplo em código"
                                  ],
                                  "tips": "Fixe cidade 0 como partida para evitar rotações desnecessárias.",
                                  "learningObjective": "Resolver TSP exaustivamente com permutações.",
                                  "commonMistakes": [
                                    "Calcular distância errada (não fechar ciclo).",
                                    "Incluir cidade inicial nas permutações."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, otimizar e documentar a solução",
                                  "subSteps": [
                                    "Teste com n=5 cidades e meça tempo de execução.",
                                    "Adicione pruning se custo parcial > mínimo atual (otimização simples).",
                                    "Comente código e escreva relatório de resultados.",
                                    "Compare tempos: iterativo vs recursivo.",
                                    "Execute para n=10 e observe lentidão."
                                  ],
                                  "verification": "Código roda corretamente para n=5 em <1s e relatório explica limitações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Cronômetro ou std::chrono",
                                    "Editor de texto para relatório"
                                  ],
                                  "tips": "Use std::chrono para medir performance precisamente.",
                                  "learningObjective": "Avaliar viabilidade prática da força bruta.",
                                  "commonMistakes": [
                                    "Ignorar overhead de recursão profunda.",
                                    "Não testar casos extremos como todas distâncias iguais."
                                  ]
                                }
                              ],
                              "practicalExample": "Resolva TSP para 4 cidades A,B,C,D com distâncias: A-B=10, A-C=15, A-D=20, B-C=35, B-D=25, C-D=30. Gere todas 6 permutações de B,C,D partindo de A, calcule custos (incluindo retorno a A) e encontre rota A-B-D-C-A com custo 10+25+30+15=80.",
                              "finalVerifications": [
                                "Programa gera exatamente n! permutações únicas.",
                                "Cálculo de custo da rota é correto, incluindo ciclo fechado.",
                                "Encontra solução ótima para instâncias n≤6.",
                                "Código compila sem warnings e executa em tempo razoável.",
                                "Saída inclui permutação ótima e seu custo.",
                                "Testes unitários passam para exemplos manuais."
                              ],
                              "assessmentCriteria": [
                                "Corretude: todas permutações geradas e TSP resolvido precisamente.",
                                "Eficiência: viável para n≤10, com otimizações opcionais.",
                                "Código limpo: bem estruturado, comentado e modular.",
                                "Compreensão: explicação clara de força bruta vs heurísticas.",
                                "Testes: casos variados incluindo degenerados.",
                                "Documentação: relatório com análise de complexidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e cálculo de fatoriais.",
                                "Otimização Operacional: Problemas de roteamento.",
                                "Programação Competitiva: Backtracking em contests.",
                                "Inteligência Artificial: Busca exaustiva em espaços de estados.",
                                "Análise de Algoritmos: Estudo de complexidade O(n!)."
                              ],
                              "realWorldApplication": "Otimização de rotas de entrega para frotas pequenas em logística (ex: entregas locais de e-commerce), sequenciamento de tarefas em manufatura com poucas máquinas, ou geração de senhas por força bruta em testes de segurança para conjuntos pequenos de caracteres."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.1",
                              "10.1.2.2.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.2.2.3",
                            "name": "Verificar corretude da solução exaustiva",
                            "description": "Desenvolver testes unitários para validar que todas as possibilidades foram enumeradas e a solução ótima foi encontrada, comparando com casos conhecidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Solução Exaustiva e Identificar Casos de Teste Conhecidos",
                                  "subSteps": [
                                    "Analise o algoritmo de força bruta para identificar o espaço de busca (ex: 2^n possibilidades para subconjuntos).",
                                    "Liste soluções ótimas conhecidas para instâncias pequenas do problema (ex: Subset Sum com n<=5).",
                                    "Identifique casos edge: vazio, todos elementos, sem solução possível.",
                                    "Documente o número esperado de enumerações e o resultado ótimo para cada caso."
                                  ],
                                  "verification": "Lista de 5-10 casos de teste conhecidos criada e validada manualmente contra expectativa.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código fonte do algoritmo",
                                    "Papel e caneta ou planilha para enumerar manualmente",
                                    "Documentação do problema"
                                  ],
                                  "tips": "Comece com n=0 a n=3 para validação manual rápida.",
                                  "learningObjective": "Entender o espaço de soluções exaustivas e soluções ótimas de referência.",
                                  "commonMistakes": "Ignorar casos onde não há solução ótima ou subestimar o tamanho do espaço de busca."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Framework de Testes Unitários",
                                  "subSteps": [
                                    "Instale e configure biblioteca de testes (ex: JUnit para Java, pytest para Python).",
                                    "Crie classe/função de teste dedicada para o algoritmo.",
                                    "Defina asserts para saída esperada vs. obtida.",
                                    "Integre logging para rastrear número de enumerações durante execução."
                                  ],
                                  "verification": "Teste dummy roda sem erros e framework está funcional.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE com suporte a testes (VS Code, IntelliJ)",
                                    "Biblioteca de testes instalada"
                                  ],
                                  "tips": "Use mocks se o algoritmo depender de I/O externo.",
                                  "learningObjective": "Configurar ambiente para testes automatizados e reproduzíveis.",
                                  "commonMistakes": "Não capturar contadores de enumeração ou usar asserts fracos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Testes para Verificação de Enumeração Completa",
                                  "subSteps": [
                                    "Adicione contador global no algoritmo para contar iterações/explorações.",
                                    "Crie testes que assertam contagem exata de enumerações (ex: 2^n para Subset Sum).",
                                    "Teste com inputs pequenos e compare logs de execução.",
                                    "Inclua testes para ramificações parciais em buscas recursivas."
                                  ],
                                  "verification": "Testes passam e logs mostram contagem exata de enumerações para n=1 a 5.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código do algoritmo modificado com contadores",
                                    "Casos de teste do step 1"
                                  ],
                                  "tips": "Desabilite otimizações prematuras no algoritmo durante testes.",
                                  "learningObjective": "Validar exaustividade através de contagem quantitativa de explorações.",
                                  "commonMistakes": "Confundir enumerações com soluções válidas ou esquecer recursão profunda."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Testes para Otimalidade da Solução",
                                  "subSteps": [
                                    "Para cada caso conhecido, assert solução retornada == ótima conhecida.",
                                    "Teste múltiplas soluções ótimas se existirem (ex: várias partições).",
                                    "Adicione testes de performance indireta: tempo ≈ O(2^n).",
                                    "Verifique ausência de falsos positivos com asserts em saídas inválidas."
                                  ],
                                  "verification": "100% dos casos conhecidos passam com solução ótima correta.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Lista de soluções ótimas do step 1",
                                    "Ferramenta de profiling opcional"
                                  ],
                                  "tips": "Use dados de benchmark públicos para mais casos conhecidos.",
                                  "learningObjective": "Confirmar que a solução exaustiva encontra o ótimo global.",
                                  "commonMistakes": "Comparar apenas com soluções subótimas ou ignorar múltiplos ótimos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Executar Testes Completos e Analisar Cobertura",
                                  "subSteps": [
                                    "Rode suíte completa de testes em batch.",
                                    "Gere relatório de cobertura de código focado em loops de enumeração.",
                                    "Analise falhas: debug e ajuste algoritmo/testes.",
                                    "Documente relatório final com métricas (pass rate, cobertura)."
                                  ],
                                  "verification": "Relatório mostra 100% pass rate e cobertura >95% nas partes críticas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de coverage (ex: JaCoCo, coverage.py)",
                                    "Relatórios gerados"
                                  ],
                                  "tips": "Automatize com CI se possível para regressões futuras.",
                                  "learningObjective": "Garantir robustez através de execução e análise sistemática.",
                                  "commonMistakes": "Aceitar cobertura baixa ou ignorar warnings de timeout em casos grandes."
                                }
                              ],
                              "practicalExample": "No problema Subset Sum com conjunto [1,3,4,5] e target=9: Solução ótima [4,5]. Implemente testes que contam 16 enumerações e assertam que [4,5] é retornado, não [1,3,5] (soma 9 mas não máxima se contexto permitir).",
                              "finalVerifications": [
                                "Contagem de enumerações matches 2^n para n<=10.",
                                "Soluções ótimas corretas em todos casos conhecidos.",
                                "Cobertura de código >95% nas loops de força bruta.",
                                "Sem falsos positivos em 20+ casos edge.",
                                "Tempo de execução alinhado com complexidade esperada."
                              ],
                              "assessmentCriteria": [
                                "Testes cobrem exaustividade quantitativamente (contadores).",
                                "Validação qualitativa contra benchmarks conhecidos.",
                                "Inclusão de edge cases (n=0, impossíveis).",
                                "Relatórios claros e reproduzíveis.",
                                "Capacidade de debug falhas em enumeração."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e teoria de conjuntos para espaços de busca.",
                                "Engenharia de Software: Test-Driven Development (TDD) e cobertura.",
                                "Estatística: Análise de cobertura e métricas de teste.",
                                "Lógica: Verificação formal de completude."
                              ],
                              "realWorldApplication": "Em otimização logística (ex: roteirização exaustiva para frotas pequenas), validação de software crítico (segurança cibernética) e pesquisa em IA para confirmar baselines exaustivos antes de heurísticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.2.3",
                        "name": "Análise de Complexidade e Limitações",
                        "description": "Avaliação do custo computacional da força bruta e identificação de quando ela é impraticável, relacionando com o tamanho do espaço de busca.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.2.3.1",
                            "name": "Calcular complexidade temporal e espacial",
                            "description": "Derivar notação Big-O para força bruta em problemas como n! para permutações ou 2^n para subconjuntos, analisando dependência do tamanho da entrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a estrutura do algoritmo de força bruta",
                                  "subSteps": [
                                    "Analise o pseudocódigo do algoritmo para identificar loops aninhados, recursões ou gerações exaustivas.",
                                    "Mapeie as operações principais: comparações, atribuições e chamadas de função em termos do tamanho da entrada n.",
                                    "Destaque padrões comuns como backtracking para permutações ou geração de subconjuntos.",
                                    "Registre dependências explícitas e implícitas do tamanho n.",
                                    "Crie um diagrama de fluxo simples mostrando iterações."
                                  ],
                                  "verification": "Pseudocódigo anotado com identificação clara de estruturas repetitivas e dependências de n.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Pseudocódigo do algoritmo, papel e lápis ou editor de texto para diagramas.",
                                  "tips": "Comece pelo caso mais simples (n=1 ou n=2) para validar a estrutura.",
                                  "learningObjective": "Compreender como a estrutura do algoritmo dita o crescimento da complexidade.",
                                  "commonMistakes": "Ignorar recursões implícitas ou confundir iterações com operações constantes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contar e somar operações temporais básicas",
                                  "subSteps": [
                                    "Conte o número de execuções de cada operação básica dentro dos loops mais internos.",
                                    "Multiplique pelas iterações dos loops externos para obter T(n).",
                                    "Inclua operações fora de loops como O(1) ou iniciais.",
                                    "Expresse T(n) como soma de termos exponenciais, fatoriais ou polinomiais.",
                                    "Teste com valores pequenos de n para validar a contagem."
                                  ],
                                  "verification": "Fórmula explícita de T(n), como T(n) = n! para permutações, validada com n=3.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Calculadora, planilha para simulações numéricas, exemplos de código.",
                                  "tips": "Use tabelas para rastrear execuções por nível de loop.",
                                  "learningObjective": "Quantificar precisamente o número de operações em função de n.",
                                  "commonMistakes": "Contar apenas iterações de loop sem incluir operações internas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar a notação Big-O temporal e simplificar",
                                  "subSteps": [
                                    "Identifique o termo dominante em T(n) (ex: n! domina sobre termos menores).",
                                    "Aplique regras de Big-O: ignore constantes e termos inferiores.",
                                    "Para padrões como permutações, reconheça O(n!); para subconjuntos, O(2^n).",
                                    "Escreva a notação assintótica final: O(f(n)).",
                                    "Compare com limites práticos (ex: n=10 para 2^n é viável?)."
                                  ],
                                  "verification": "Notação Big-O derivada corretamente, com justificativa do termo dominante.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Tabelas de crescimento assintótico (Big-O cheat sheet), exemplos resolvidos.",
                                  "tips": "Lembre-se: Big-O foca no pior caso e crescimento superior.",
                                  "learningObjective": "Simplificar contagens exatas para análise assintótica.",
                                  "commonMistakes": "Confundir contagem exata com Big-O ou ignorar termo dominante."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar complexidade espacial e validar integralmente",
                                  "subSteps": [
                                    "Identifique estruturas de dados: arrays, pilhas de recursão, tabelas auxiliares.",
                                    "Calcule espaço por iteração e multiplique pelo número máximo de iterações simultâneas.",
                                    "Para força bruta, derive O(n) ou O(2^n) espacial tipicamente.",
                                    "Valide com exemplos: recursão para permutações usa O(n) pilha.",
                                    "Compare temporal vs. espacial e discuta limitações."
                                  ],
                                  "verification": "Análise espacial completa com notação Big-O e comparação com temporal.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramentas de profiling (opcional), diagramas de memória.",
                                  "tips": "Espaço recursivo é profundidade da recursão, não largura.",
                                  "learningObjective": "Avaliar trade-offs entre tempo e espaço em força bruta.",
                                  "commonMistakes": "Atribuir espaço total como produto de todas as estruturas sem considerar pico."
                                }
                              ],
                              "practicalExample": "Para o problema de permutações de n elementos via backtracking: Step 1 identifica recursão de profundidade n; Step 2 conta n! folhas; Step 3 deriva O(n!); Step 4 nota O(n) espacial na pilha. Para n=5, ~120 operações, viável; n=10 inviável.",
                              "finalVerifications": [
                                "Deriva corretamente O(n!) para algoritmo de permutações por força bruta.",
                                "Calcula O(2^n * n) para geração de subconjuntos com verificação.",
                                "Identifica pico de memória espacial corretamente para recursão.",
                                "Justifica termo dominante em T(n) com exemplo numérico.",
                                "Discute limitações práticas para n=20 em 2^n.",
                                "Compara complexidades de dois algoritmos de força bruta diferentes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de operações e derivação Big-O (40%).",
                                "Justificativa clara e lógica passo a passo (20%).",
                                "Tratamento correto de casos exponenciais/fatoriais (20%).",
                                "Análise espacial integrada e precisa (10%).",
                                "Validação com exemplos numéricos e diagramas (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e análise assintótica (funções exponenciais).",
                                "Física: Modelagem de simulações exaustivas em sistemas complexos.",
                                "Engenharia: Avaliação de viabilidade em design de sistemas embarcados.",
                                "Economia: Análise de custo-benefício em otimização de recursos computacionais."
                              ],
                              "realWorldApplication": "Em criptoanálise (quebra de senhas por força bruta, O(2^bits)), otimização de roteiros TSP para entregas pequenas (O(n!)), ou baseline para problemas NP-completos em IA, determinando quando heurísticas são necessárias devido a explosão exponencial."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.2",
                            "name": "Identificar limitações práticas",
                            "description": "Discutir thresholds de viabilidade, como n <= 20 para 2^n, e comparar tempos de execução empíricos em diferentes linguagens de programação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Complexidade Teórica e Calcular Thresholds de Viabilidade",
                                  "subSteps": [
                                    "Estude a notação Big O para complexidade exponencial, focando em O(2^n).",
                                    "Calcule manualmente o número de operações para n=10, 15, 20, 25 usando 2^n.",
                                    "Defina thresholds práticos: n≤20 para ~1 milhão de operações (viável em segundos).",
                                    "Considere fatores como constantes ocultas e hardware (ex: 10^9 ops/segundo).",
                                    "Registre thresholds em uma tabela: n vs. tempo estimado."
                                  ],
                                  "verification": "Tabela completa com cálculos corretos para n=10-25 e thresholds definidos (ex: n≤20).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Calculadora, planilha (Google Sheets/Excel), documentação Big O.",
                                  "tips": "Use log2 para estimar: 2^20 ≈ 1M, divida por velocidade da máquina (~10^8-10^9 ops/s).",
                                  "learningObjective": "Calcular e interpretar thresholds teóricos de viabilidade para algoritmos exponenciais.",
                                  "commonMistakes": "Ignorar constantes ocultas ou confundir 2^n com n^2; sempre valide com logaritmos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Medir Tempo Empírico em Python",
                                  "subSteps": [
                                    "Escolha um problema de força bruta: soma de subconjuntos (2^n subconjuntos).",
                                    "Implemente função recursiva ou iterativa gerando todos subconjuntos.",
                                    "Meça tempo de execução para n=10,15,18,20,22 usando timeit ou time.perf_counter().",
                                    "Registre tempos médios de 5 execuções por n em uma tabela.",
                                    "Plote gráfico tempo vs. n usando matplotlib."
                                  ],
                                  "verification": "Código funcional com tabela de tempos e gráfico mostrando explosão em n>20.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Python 3, Jupyter Notebook, bibliotecas timeit e matplotlib.",
                                  "tips": "Execute em máquina limpa; use %timeit no Jupyter para precisão.",
                                  "learningObjective": "Medir empiricamente limitações de força bruta em uma linguagem interpretada.",
                                  "commonMistakes": "Não fazer múltiplas execuções (variância); esquecer de limpar cache."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Tempos Empíricos em C++",
                                  "subSteps": [
                                    "Traduza o código Python para C++ otimizado (STL vectors, recursão com memo se aplicável).",
                                    "Meça tempos para mesmos n=10-22 usando std::chrono::high_resolution_clock.",
                                    "Compile com -O3 e execute 5 vezes, registrando médias.",
                                    "Compare tabelas Python vs. C++: calcule speedup (ex: C++ 10-100x mais rápido).",
                                    "Atualize thresholds: n≤25 viável em C++."
                                  ],
                                  "verification": "Código C++ com tabela comparativa e speedup calculado corretamente.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Compilador g++ (VS Code/Code::Blocks), std::chrono.",
                                  "tips": "Use -O3 para otimizações; evite I/O dentro do loop de medição.",
                                  "learningObjective": "Comparar impactos linguísticos em performance de algoritmos exaustivos.",
                                  "commonMistakes": "Compilação sem flags de otimização; confundir wall-clock com CPU time."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Resultados e Discutir Limitações Práticas",
                                  "subSteps": [
                                    "Compare thresholds teóricos vs. empíricos em ambas linguagens.",
                                    "Discuta fatores: overhead Python, otimizações C++, hardware variability.",
                                    "Identifique viabilidade geral: n≤20 Python, n≤25 C++ para problemas 2^n.",
                                    "Escreva relatório resumindo limitações e quando evitar força bruta.",
                                    "Proponha alternativas (branch-and-bound, DP) para n maiores."
                                  ],
                                  "verification": "Relatório de 1 página com tabelas, gráficos e conclusões claras.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Document editor (Google Docs/Word), gráficos do Step 2-3.",
                                  "tips": "Use speedup = tempo_Python / tempo_C++ para quantificar diferenças.",
                                  "learningObjective": "Sintetizar análise teórica-empírica para decisões práticas em algoritmos.",
                                  "commonMistakes": "Generalizar sem considerar problema específico; ignorar escalabilidade de input."
                                }
                              ],
                              "practicalExample": "Para o problema de Subconjunto Soma (dado array de 20 números, encontre subconjunto somando target): força bruta testa 2^20=1M subconjuntos. Em Python: ~5s para n=20; em C++: ~0.05s. Para n=25: Python >1h, C++ ~5s – threshold prático n≤20 Python.",
                              "finalVerifications": [
                                "Thresholds calculados corretamente (ex: 2^20 ≈1M ops viável).",
                                "Tabelas de tempos empíricos para Python e C++ com n=10-25.",
                                "Gráficos exponenciais tempo vs. n validados.",
                                "Speedup entre linguagens quantificado (>10x C++).",
                                "Relatório discute viabilidade prática e fatores influentes.",
                                "Identifica quando força bruta é inviável (n>20-25)."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos teóricos de 2^n e thresholds (90%+ correto).",
                                "Códigos funcionais e tempos medidos com <5% variância entre runs.",
                                "Comparação linguística com speedup evidenciado e explicado.",
                                "Análise inclui hardware, overhead e generalizações.",
                                "Relatório claro, com gráficos e conclusões acionáveis.",
                                "Identifica limitações além de tempo (memória para 2^n)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de exponenciais e logaritmos para estimativas.",
                                "Física: Modelagem de simulações computacionais intensivas (ex: N-body).",
                                "Engenharia de Software: Benchmarking e profiling de performance.",
                                "Estatística: Análise de variância em medições empíricas."
                              ],
                              "realWorldApplication": "Em otimização de rotas logísticas (TSP força bruta inviável >15 cidades), criptoanálise (chaves 2^128), ou machine learning (busca exaustiva hiperparâmetros) – define quando usar heurísticas em vez de exaustivo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3.1",
                              "10.1.2.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.2.3.3",
                            "name": "Relacionar com paradigmas alternativos",
                            "description": "Mapear quando migrar de força bruta para programação dinâmica ou guloso, usando referências bibliográficas como Cormen para justificativa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender limitações da força bruta",
                                  "subSteps": [
                                    "Analise a complexidade temporal e espacial de algoritmos de força bruta em problemas clássicos como Fibonacci ou subconjunto soma.",
                                    "Identifique padrões de sobreposição de subproblemas e escolhas ótimas em soluções de força bruta.",
                                    "Calcule thresholds de performance onde força bruta se torna impraticável (ex: n > 30 para O(2^n)).",
                                    "Registre exemplos onde força bruta falha em escala real.",
                                    "Compare com métricas de Big O para quantificar ineficiências."
                                  ],
                                  "verification": "Lista de 3 problemas com análise de complexidade e thresholds documentados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Livro 'Introduction to Algorithms' (Cormen, Capítulo 15), calculadora ou Python para testes.",
                                  "tips": "Use grafos de recorrência para visualizar explosão computacional.",
                                  "learningObjective": "Identificar precisamente quando força bruta é ineficiente devido a sobreposições ou otimizações perdidas.",
                                  "commonMistakes": "Ignorar espaço auxiliar ou confundir tempo com espaço em análises."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar paradigmas alternativos: DP e Guloso",
                                  "subSteps": [
                                    "Revise definição e condições para Programação Dinâmica (DP): sobreposição de subproblemas e estrutura ótima.",
                                    "Estude Algoritmos Guloso: propriedade de escolha gulosa e subestrutura ótima.",
                                    "Leia capítulos relevantes em Cormen: DP (Cap. 15), Guloso (Cap. 16).",
                                    "Compare pseudocódigos de força bruta vs DP/guloso para problemas como Knapsack e MST.",
                                    "Anote pré-condições matemáticas para cada paradigma."
                                  ],
                                  "verification": "Resumo de 1 página com definições, condições e citações de Cormen.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Cormen et al. (Capítulos 15-16), anotações em Notion ou papel.",
                                  "tips": "Crie tabelas comparativas para fixar diferenças chave.",
                                  "learningObjective": "Diferenciar conceitualmente DP e guloso de força bruta com base em propriedades algorítmicas.",
                                  "commonMistakes": "Confundir guloso com DP; guloso não memoíza sempre."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Mapear cenários de migração",
                                  "subSteps": [
                                    "Para cada problema de força bruta, mapeie: 'Quando migrar para DP?' (ex: sobreposição detectada).",
                                    "Mapeie para guloso: 'Quando propriedade gulosa segura?' (ex: matroids).",
                                    "Crie fluxograma de decisão: inputs (complexidade, estrutura problema) -> output (paradigma).",
                                    "Teste fluxograma em 3 problemas: Fibonacci (DP), Dijkstra (guloso), TSP (nem sempre).",
                                    "Justifique com teoremas de Cormen (ex: Teorema 15.1 para DP)."
                                  ],
                                  "verification": "Fluxograma funcional testado em exemplos com justificativas citadas.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ferramenta de diagrama (Draw.io), Cormen para referências.",
                                  "tips": "Comece com problemas familiares para validar o mapa.",
                                  "learningObjective": "Criar um framework decision-making para escolher paradigmas baseado em características do problema.",
                                  "commonMistakes": "Aplicar DP sem sobreposição, levando a overhead desnecessário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e justificar com referências",
                                  "subSteps": [
                                    "Implemente força bruta e otimização em código para 2 problemas.",
                                    "Documente migração com métricas de performance e citações de Cormen.",
                                    "Debata trade-offs: exatidão vs aproximação em guloso.",
                                    "Crie relatório com mapa de migração e bibliografia.",
                                    "Autoavalie usando critérios de Cormen para validade."
                                  ],
                                  "verification": "Código funcional + relatório de 500 palavras com refs.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Python/Jupyter, Cormen (físico/digital), GitHub para versionamento.",
                                  "tips": "Meça tempos reais com timeit para evidências empíricas.",
                                  "learningObjective": "Aplicar e justificar migrações paradigmas com evidências teóricas e empíricas.",
                                  "commonMistakes": "Citar refs sem ler contexto; use índices de Cormen."
                                }
                              ],
                              "practicalExample": "No problema de Fibonacci: Força bruta (O(2^n)) recalcula subproblemas; migre para DP (memoização ou bottom-up, O(n)) quando n>40, justificado por Cormen Cap.15 (sobreposição de subproblemas). Código: def fib_brute(n): if n<=1: return n; return fib_brute(n-1)+fib_brute(n-2). Otimizado: dp[0]=0; dp[1]=1; for i in 2 to n: dp[i]=dp[i-1]+dp[i-2].",
                              "finalVerifications": [
                                "Explica corretamente condições para DP vs guloso em 3 problemas.",
                                "Cita capítulos específicos de Cormen com justificativas precisas.",
                                "Fluxograma de decisão cobre 80% dos casos comuns sem erros.",
                                "Implementações mostram speedup >10x em benchmarks.",
                                "Relatório identifica limitações (ex: guloso falha em TSP).",
                                "Discute quando força bruta ainda é preferível (n pequeno)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de sobreposição/subestrutura ótima (30%).",
                                "Uso correto de referências bibliográficas (25%).",
                                "Qualidade do fluxograma de migração (20%).",
                                "Evidências empíricas via código/performance (15%).",
                                "Clareza e completude do relatório (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências e indução matemática (para DP).",
                                "Economia: Otimização de recursos e escolhas marginais (guloso).",
                                "Física: Simulações numéricas onde brute force falha em escalas quânticas.",
                                "Gestão: Tomada de decisão sob restrições (migração de estratégias)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, engenheiros migram força bruta para DP em caches de rotas (Google Maps usa Dijkstra guloso); em finanças, otimização de portfólios evita brute force com DP para milhões de ativos, economizando horas de CPU e habilitando apps em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.3",
                    "name": "Técnica de Backtracking",
                    "description": "Busca recursiva sistemática com poda de subárvores inviáveis para explorar o espaço de soluções.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.3.1",
                        "name": "Espaço de Soluções e Representação Parcial",
                        "description": "Compreender o espaço de soluções como uma árvore de decisões, onde cada nó representa uma solução parcial viável ou inviável.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.1.1",
                            "name": "Identificar o espaço de soluções de um problema",
                            "description": "Analisar um problema combinatorial para definir o conjunto total de soluções possíveis e representá-lo como uma estrutura hierárquica de escolhas sequenciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema para identificar as decisões principais",
                                  "subSteps": [
                                    "Leia atentamente o enunciado do problema combinatorial.",
                                    "Identifique o objetivo principal (ex: encontrar todas as combinações válidas).",
                                    "Liste as restrições e componentes discretos envolvidos.",
                                    "Reformule o problema em termos de escolhas sequenciais que levam a soluções.",
                                    "Defina as variáveis de decisão (ex: posição da próxima peça)."
                                  ],
                                  "verification": "Crie um resumo escrito com as variáveis de decisão identificadas e sua ordem sequencial.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta ou editor de texto; enunciado do problema.",
                                  "tips": "Pense em termos de 'escolhas em etapas' como em um jogo de decisão.",
                                  "learningObjective": "Compreender a estrutura sequencial de um problema combinatorial.",
                                  "commonMistakes": [
                                    "Ignorar restrições iniciais.",
                                    "Confundir variáveis com soluções finais.",
                                    "Não definir ordem sequencial clara."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o domínio de escolhas para cada variável de decisão",
                                  "subSteps": [
                                    "Para cada variável sequencial, liste todos os valores possíveis (sem pruning ainda).",
                                    "Considere o tamanho do domínio (ex: 1 a N para linhas).",
                                    "Registre dependências entre escolhas anteriores e atuais.",
                                    "Calcule o tamanho teórico do espaço (produto dos domínios).",
                                    "Documente em tabela: nível x domínio."
                                  ],
                                  "verification": "Tabela completa de domínios por nível, com cálculo do número total de folhas.",
                                  "estimatedTime": "1 hora",
                                  "materials": "Planilha ou papel quadriculado; calculadora.",
                                  "tips": "Use domínios iniciais amplos; pruning vem depois no backtracking.",
                                  "learningObjective": "Mapear precisamente os ramos possíveis em cada nível.",
                                  "commonMistakes": [
                                    "Restringir domínios prematuramente.",
                                    "Esquecer dependências parciais.",
                                    "Erro no cálculo do tamanho total."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a representação hierárquica do espaço de soluções",
                                  "subSteps": [
                                    "Desenhe a árvore raiz com o primeiro nível de escolhas.",
                                    "Expanda ramos sequencialmente para níveis subsequentes.",
                                    "Marque nós internos como soluções parciais e folhas como soluções completas.",
                                    "Inclua anotações para restrições globais se aplicável.",
                                    "Valide conectividade: cada caminho da raiz à folha é uma solução potencial."
                                  ],
                                  "verification": "Diagrama da árvore completo, com pelo menos 2 níveis expandidos.",
                                  "estimatedTime": "1 hora e 30 minutos",
                                  "materials": "Software de diagramação (Draw.io, papel grande); lápis coloridos.",
                                  "tips": "Comece pequeno (N pequeno) para visualizar; use abreviações para nós.",
                                  "learningObjective": "Visualizar o espaço como árvore de escolhas binárias ou multi-ramos.",
                                  "commonMistakes": [
                                    "Árvore assimétrica sem justificativa.",
                                    "Omitir ramos inválidos no espaço total.",
                                    "Confundir profundidade com largura."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar a representação do espaço",
                                  "subSteps": [
                                    "Conte o número de folhas e compare com fórmula teórica.",
                                    "Simule 3 caminhos completos da raiz às folhas.",
                                    "Identifique padrões ou simetrias no espaço.",
                                    "Ajuste a representação para clareza (ex: compactar subárvores idênticas).",
                                    "Escreva uma descrição formal do espaço."
                                  ],
                                  "verification": "Relatório de validação com contagem exata e 3 exemplos de caminhos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Diagrama anterior; contador ou script simples.",
                                  "tips": "Use enumeração manual para pequenos espaços para confirmar.",
                                  "learningObjective": "Garantir exaustividade e precisão na modelagem.",
                                  "commonMistakes": [
                                    "Subestimar o tamanho exponencial.",
                                    "Não validar caminhos completos.",
                                    "Ignorar simetrias que reduzem representação."
                                  ]
                                }
                              ],
                              "practicalExample": "No problema das 4-Rainhas: Níveis representam colunas 1 a 4; em cada nível, escolhas são linhas 1-4 (inicialmente), formando árvore com 4^4=256 folhas potenciais. Nós internos são posicionamentos parciais sem ataques.",
                              "finalVerifications": [
                                "O número de folhas corresponde ao produto dos tamanhos de domínio.",
                                "Todos os caminhos raiz-folha representam soluções candidatas únicas.",
                                "Restrições iniciais estão refletidas nos domínios.",
                                "Diagrama cobre todo o espaço sem lacunas ou duplicatas.",
                                "Descrição formal explica hierarquia sequencial.",
                                "Simulação de 3 caminhos confirma validade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de variáveis e domínios (30%).",
                                "Clareza e completude da árvore hierárquica (25%).",
                                "Correção no cálculo do tamanho do espaço (20%).",
                                "Validação com exemplos concretos (15%).",
                                "Descrição formal acionável (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e árvores de decisão.",
                                "Programação: Estruturas de dados (árvores recursivas).",
                                "Lógica: Análise de problemas em grafos.",
                                "Física: Modelagem de estados em sistemas discretos."
                              ],
                              "realWorldApplication": "Em otimização de rotas logísticas (espaço de permutações de entregas), desenvolvimento de jogos (exploração de movimentos), ou criptografia (geração de chaves exaustiva)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.2",
                            "name": "Representar soluções parciais em estruturas de dados",
                            "description": "Utilizar arrays, listas ou strings para manter o estado atual da solução parcial durante a exploração recursiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Solução Parcial em Backtracking",
                                  "subSteps": [
                                    "Analise o problema de backtracking, identificando onde as soluções são construídas incrementalmente.",
                                    "Defina o que constitui uma 'solução parcial': um prefixo válido da solução final.",
                                    "Estude exemplos como N-Queens ou permutações para visualizar estados parciais.",
                                    "Desenhe um diagrama do espaço de soluções, destacando caminhos parciais.",
                                    "Explique verbalmente ou por escrito como a recursão explora esses estados."
                                  ],
                                  "verification": "Crie um diagrama manual do espaço de soluções para um problema simples (ex: permutações de 3 elementos) mostrando estados parciais.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                  "tips": "Comece com problemas pequenos (n=3) para visualizar claramente os estados.",
                                  "learningObjective": "Entender o papel das soluções parciais na exploração recursiva do backtracking.",
                                  "commonMistakes": "Confundir solução parcial com solução completa; ignorar restrições parciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e Inicializar a Estrutura de Dados Adequada",
                                  "subSteps": [
                                    "Avalie opções: array para sequências indexadas, lista encadeada para inserções dinâmicas, string para caracteres.",
                                    "Escolha baseada no problema: array para N-Queens (posições), string para anagramas.",
                                    "Inicialize a estrutura vazia ou com valores padrão no escopo da função recursiva.",
                                    "Defina o tamanho máximo se aplicável (ex: array de tamanho N).",
                                    "Implemente uma função auxiliar para copiar ou restaurar o estado inicial."
                                  ],
                                  "verification": "Escreva código inicializando a estrutura para um problema teste e imprima o estado vazio.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (VS Code), linguagem como Python ou JavaScript",
                                  "tips": "Use arrays mutáveis para eficiência, mas passe por referência com cuidado na recursão.",
                                  "learningObjective": "Selecionar e preparar estruturas de dados mutáveis para rastrear soluções parciais.",
                                  "commonMistakes": "Escolher estrutura fixa quando dinâmica é necessária; não considerar overhead de cópia."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Adição e Remoção na Exploração Recursiva",
                                  "subSteps": [
                                    "No passo recursivo, adicione o candidato atual à estrutura (append/push).",
                                    "Chame recursão para o próximo nível após verificar restrições parciais.",
                                    "Ao backtrack, remova o último elemento adicionado (pop).",
                                    "Garanta que remoção reverta exatamente o estado anterior.",
                                    "Adicione logs ou prints para rastrear mudanças na estrutura durante a execução."
                                  ],
                                  "verification": "Execute o backtracking em um problema simples e verifique via logs que add/remove funcionam corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código, debugger integrado",
                                  "tips": "Sempre remova após a chamada recursiva para evitar vazamentos de estado.",
                                  "learningObjective": "Implementar operações mutáveis que preservem o backtracking correto.",
                                  "commonMistakes": "Esquecer de remover no backtrack; modificar estrutura global em vez de local."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Otimizar a Representação Parcial",
                                  "subSteps": [
                                    "Teste com casos variados: entrada pequena, grande, com restrições falhas.",
                                    "Meça eficiência: tempo e espaço para soluções parciais.",
                                    "Otimize se necessário: use bitmasks para estados binários em vez de arrays.",
                                    "Compare com implementações sem representação explícita (ex: parâmetros recursivos).",
                                    "Documente a escolha da estrutura no código com comentários."
                                  ],
                                  "verification": "Gere todas as soluções esperadas e confirme que estados parciais são corretos em breakpoints.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código, ferramenta de testes unitários (ex: Jest ou unittest)",
                                  "tips": "Use asserts para verificar invariantes após cada add/remove.",
                                  "learningObjective": "Validar robustez e eficiência da representação em cenários reais.",
                                  "commonMistakes": "Não testar backtracks profundos; ignorar overhead de estruturas grandes."
                                }
                              ],
                              "practicalExample": "No problema de gerar todas as permutações de 'abc': Use uma lista (array) para construir a permutação parcial. Inicialize como []. Para 'a', adicione -> ['a'], recurse; backtrack removendo 'a'. Continue com 'b', etc. Ao atingir len=3, processe como solução completa.",
                              "finalVerifications": [
                                "A estrutura reflete corretamente o estado parcial em cada nível recursivo.",
                                "Adições e remoções revertem o estado sem resíduos.",
                                "Todas as soluções completas são geradas sem duplicatas ou perdas.",
                                "Restrições parciais são checadas usando a estrutura atual.",
                                "Execução termina sem estouro de pilha para entradas válidas.",
                                "Logs mostram transições add/remove consistentes."
                              ],
                              "assessmentCriteria": [
                                "Correção: Soluções parciais evoluem corretamente para completas.",
                                "Eficiência: Operações O(1) para add/remove em média.",
                                "Clareza: Código legível com comentários sobre o estado parcial.",
                                "Robustez: Lida com entradas vazias ou unitárias.",
                                "Escalabilidade: Funciona para n até 10 sem lentidão excessiva.",
                                "Documentação: Explica escolha da estrutura de dados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos (espaço de soluções como árvore).",
                                "Lógica: Verificação de restrições parciais como predicados booleanos.",
                                "Ciência da Computação: Gerenciamento de memória em recursão.",
                                "Engenharia de Software: Padrões de design para estados mutáveis."
                              ],
                              "realWorldApplication": "Em solvers de sudoku ou otimização de rotas (TSP), arrays representam tabuleiros parciais ou caminhos atuais, permitindo exploração eficiente de bilhões de estados parciais em problemas reais como planejamento logístico."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.1.3",
                            "name": "Definir níveis de decisão na árvore de busca",
                            "description": "Mapear as etapas de construção da solução aos níveis da árvore, identificando escolhas possíveis em cada profundidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema e identificar as etapas de construção da solução",
                                  "subSteps": [
                                    "Leia e compreenda o problema, identificando as variáveis de decisão principais.",
                                    "Decomponha a solução em etapas sequenciais que constroem a solução parcial.",
                                    "Liste as componentes que evoluem a cada etapa (ex: posições preenchidas em um tabuleiro).",
                                    "Registre as restrições que afetam cada etapa.",
                                    "Crie um fluxograma simples das etapas."
                                  ],
                                  "verification": "Verifique se o fluxograma cobre todas as partes do problema sem lacunas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Descrição do problema impressa"
                                  ],
                                  "tips": "Comece pelo final: pense na solução completa e volte para as etapas iniciais.",
                                  "learningObjective": "Identificar as etapas sequenciais que formam a base para os níveis da árvore.",
                                  "commonMistakes": [
                                    "Ignorar restrições iniciais",
                                    "Confundir variáveis com valores possíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear as etapas aos níveis da árvore de busca",
                                  "subSteps": [
                                    "Atribua cada etapa identificada a um nível sequencial na árvore (nível 1 = primeira decisão).",
                                    "Defina o estado parcial representado em cada nível (ex: solução após k decisões).",
                                    "Desenhe a raiz da árvore e os ramos iniciais para o primeiro nível.",
                                    "Garanta que os níveis reflitam a profundidade crescente da solução.",
                                    "Anotar a profundidade máxima (número total de níveis)."
                                  ],
                                  "verification": "Confirme que cada nível corresponde exatamente a uma etapa do fluxograma.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Marcadores coloridos"
                                  ],
                                  "tips": "Use cores diferentes para níveis para visualizar melhor a hierarquia.",
                                  "learningObjective": "Associar etapas de construção da solução aos nós de profundidade na árvore.",
                                  "commonMistakes": [
                                    "Pular níveis ou duplicar etapas",
                                    "Definir níveis baseados em resultados, não em decisões"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar escolhas possíveis em cada nível",
                                  "subSteps": [
                                    "Para cada nível, liste todos os valores possíveis para a decisão atual, considerando restrições anteriores.",
                                    "Elimine escolhas inválidas baseadas em estados parciais de níveis superiores.",
                                    "Quantifique o número de ramos por nó (grau de branching).",
                                    "Desenhe os ramos de cada nó representando as escolhas viáveis.",
                                    "Marque pontos de backtrack potenciais (escolhas que levam a falhas futuras)."
                                  ],
                                  "verification": "Simule uma expansão manual de 2-3 nós para checar consistência das escolhas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplo de código backtracking simples"
                                  ],
                                  "tips": "Considere o domínio de cada decisão (ex: 0 a N-1 para posições).",
                                  "learningObjective": "Listar exaustivamente as opções válidas por nível, respeitando podas.",
                                  "commonMistakes": [
                                    "Incluir escolhas inválidas",
                                    "Esquecer podas de restrições cumulativas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar a estrutura da árvore de busca",
                                  "subSteps": [
                                    "Expanda a árvore até a folha para um caminho completo e verifique se atinge solução.",
                                    "Identifique simetrias ou podas para otimizar a árvore.",
                                    "Compare com uma implementação de backtracking para validar níveis.",
                                    "Documente a árvore completa com legendas.",
                                    "Teste com um caso pequeno para confirmar cobertura total do espaço."
                                  ],
                                  "verification": "A árvore cobre todas as soluções possíveis sem loops ou omissões.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de imagens ou draw.io",
                                    "Código de backtracking em Python"
                                  ],
                                  "tips": "Use software de desenho para árvores complexas.",
                                  "learningObjective": "Construir e validar uma árvore de busca que representa fielmente o espaço de soluções.",
                                  "commonMistakes": [
                                    "Árvore infinita sem critério de parada",
                                    "Ignorar folhas como soluções inválidas"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema das 4-Rainhas: Nível 1 decide a linha da rainha na coluna 0 (escolhas: linhas 0,1,2,3); Nível 2 para coluna 1 (escolhas válidas excluindo ataques da rainha anterior), e assim por diante até coluna 3. Backtrack ocorre se não houver escolha válida em um nível.",
                              "finalVerifications": [
                                "Desenhar a árvore completa com pelo menos 3 níveis expandidos.",
                                "Simular um caminho de backtrack manualmente.",
                                "Listar todas as folhas como soluções válidas ou inválidas.",
                                "Confirmar que o número de folhas corresponde ao tamanho esperado do espaço de soluções.",
                                "Validar com código: a árvore guia uma implementação correta de backtracking.",
                                "Identificar pontos de poda precoce."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de níveis (100% mapeamento correto das etapas).",
                                "Exaustividade das escolhas por nível (sem omissões ou inválidas).",
                                "Clareza na representação visual da árvore.",
                                "Correta identificação de backtracks e podas.",
                                "Consistência com o contexto do problema (restrições aplicadas).",
                                "Documentação completa com explicações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Estruturas de árvores e grafos direcionados.",
                                "Programação: Recursão e estruturas de dados hierárquicas.",
                                "Lógica: Raciocínio dedutivo e prova por exaustão.",
                                "Inteligência Artificial: Algoritmos de busca em espaços de estados.",
                                "Design de Jogos: Modelagem de árvores de decisão em puzzles."
                              ],
                              "realWorldApplication": "Usado em solvers de Sudoku e quebra-cabeças, otimização de roteiros de entrega (problema do caixeiro viajante com backtracking), configuração de redes (alocação de canais sem interferência) e jogos de tabuleiro como xadrez para simulação de movimentos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.2",
                        "name": "Função Recursiva de Backtracking",
                        "description": "Implementar a estrutura recursiva principal que gera candidatos, verifica condições e realiza retrocesso.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.2.1",
                            "name": "Construir a função recursiva base de backtracking",
                            "description": "Desenvolver uma função que avance para o próximo nível adicionando um candidato, chame recursivamente e remova o candidato ao retornar (backtrack).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a assinatura da função recursiva e inicializar o estado",
                                  "subSteps": [
                                    "Escolha uma linguagem de programação, como Python, para implementar a função.",
                                    "Defina a assinatura da função, por exemplo: def backtrack(current_path): onde current_path é uma lista representando o estado atual.",
                                    "Inicialize uma estrutura global ou passada por referência para armazenar soluções, como uma lista solutions = [].",
                                    "Crie variáveis para os candidatos disponíveis, como candidates = [1, 2, 3] para um exemplo simples de subconjuntos."
                                  ],
                                  "verification": "Verifique se a função é definida corretamente e pode ser chamada sem erros de sintaxe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Documentação de Python sobre funções e listas"
                                  ],
                                  "tips": "Use listas mutáveis para o estado atual para facilitar adições e remoções eficientes.",
                                  "learningObjective": "Compreender a estrutura básica de uma função recursiva em backtracking e preparar o estado inicial.",
                                  "commonMistakes": [
                                    "Esquecer de passar o estado atual como parâmetro",
                                    "Não inicializar a lista de soluções fora da função"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a adição de um candidato ao estado atual",
                                  "subSteps": [
                                    "Adicione um loop for para iterar sobre os candidatos disponíveis: for candidate in candidates:.",
                                    "Dentro do loop, verifique se o candidato é válido (para base, pode ser sempre válido inicialmente).",
                                    "Adicione o candidato ao estado atual: current_path.append(candidate).",
                                    "Imprima ou logue o estado atual para depuração: print(f'Adicionado {candidate}: {current_path}')."
                                  ],
                                  "verification": "Execute a função com um candidato único e confirme que o estado atual reflete a adição corretamente via prints.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para depuração"
                                  ],
                                  "tips": "Sempre logue mudanças no estado para visualizar o fluxo de backtracking.",
                                  "learningObjective": "Dominar a operação de 'escolha' em backtracking, adicionando candidatos ao estado explorado.",
                                  "commonMistakes": [
                                    "Usar append em uma lista imutável como tupla",
                                    "Não iterar corretamente sobre candidatos duplicados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a chamada recursiva para avançar ao próximo nível",
                                  "subSteps": [
                                    "Após adicionar o candidato, chame recursivamente a função: backtrack(current_path).",
                                    "Isso avança para o próximo nível de recursão com o estado atualizado.",
                                    "Adicione uma condição base simples, como if len(current_path) == target_length: solutions.append(current_path[:]); return.",
                                    "Teste com profundidade limitada para evitar recursão infinita."
                                  ],
                                  "verification": "Chame a função inicial e verifique se múltiplos níveis de recursão são executados via logs aninhados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo de código de permutações ou subconjuntos"
                                  ],
                                  "tips": "Use cópia superficial ([:]) ao registrar soluções para evitar referências compartilhadas.",
                                  "learningObjective": "Entender como a recursão constrói soluções parciais avançando níveis.",
                                  "commonMistakes": [
                                    "Chamar recursão antes de adicionar o candidato",
                                    "Falta de condição base levando a stack overflow"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o backtrack removendo o candidato ao retornar",
                                  "subSteps": [
                                    "Após a chamada recursiva, remova o último candidato: current_path.pop().",
                                    "Imprima o estado após remoção: print(f'Removido: {current_path}').",
                                    "Isso restaura o estado para o próximo candidato no loop.",
                                    "Execute a função completa e verifique todas as combinações possíveis."
                                  ],
                                  "verification": "Confirme que o estado é restaurado corretamente após cada ramo recursivo e que todas as soluções são geradas sem duplicatas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Lista de candidatos de teste como [1,2,3]"
                                  ],
                                  "tips": "Pop() remove o último elemento eficientemente em listas.",
                                  "learningObjective": "Mastar a operação de 'backtrack' para explorar todos os ramos possíveis.",
                                  "commonMistakes": [
                                    "Esquecer o pop(), causando acúmulo permanente no estado",
                                    "Pop em índice errado"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente a função para gerar todas as permutações de [1,2,3]. Inicialize com backtrack([]), candidates=[1,2,3]. A função deve produzir: [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]].",
                              "finalVerifications": [
                                "A função gera todas as soluções esperadas sem duplicatas ou omissões.",
                                "Logs mostram adição, recursão e remoção corretas em cada nível.",
                                "Não há vazamento de estado entre ramos (cada solução é independente).",
                                "A recursão termina sem stack overflow para entradas pequenas.",
                                "O estado é restaurado corretamente após cada backtrack."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todas as combinações válidas são exploradas.",
                                "Eficiência: Usa append/pop em O(1) sem cópias desnecessárias.",
                                "Clareza: Código legível com comentários e logs.",
                                "Robustez: Lida com listas vazias ou de tamanho 1.",
                                "Modularidade: Fácil estender para validações adicionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e permutações combinatoriais.",
                                "Lógica: Estruturas de árvores de decisão e exploração exaustiva.",
                                "Ciência da Computação: Conceitos de pilha de chamadas e recursão terminal.",
                                "Resolução de Problemas: Estratégias de divide-and-conquer adaptadas."
                              ],
                              "realWorldApplication": "Usado em solvers de sudoku, N-Queens para planejamento de rotas, configuração de sistemas (ex: alocação de recursos em redes), e otimização combinatorial em IA como em jogos de palavras ou criptografia de força bruta."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.3.2.2",
                            "name": "Gerar e iterar sobre candidatos válidos",
                            "description": "Implementar loops ou recursões para enumerar todas as opções possíveis no nível atual, respeitando restrições parciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de candidatos válidos em backtracking",
                                  "subSteps": [
                                    "Estude a estrutura geral de uma função recursiva de backtracking: escolha, restrições, exploração e backtrack.",
                                    "Identifique o 'nível atual' como o ponto de decisão onde novos candidatos são gerados.",
                                    "Defina 'candidatos válidos' como opções do domínio que satisfazem restrições parciais acumuladas até o momento.",
                                    "Analise exemplos simples, como permutações, onde candidatos são elementos restantes não usados.",
                                    "Diferencie candidatos totais (domínio completo) de válidos (filtrados por restrições)."
                                  ],
                                  "verification": "Explique em suas palavras o que são candidatos válidos e dê um exemplo de restrição parcial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de backtracking básico",
                                    "Vídeo tutorial sobre backtracking (5-10 min)",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Desenhe a árvore de decisão para visualizar níveis e candidatos.",
                                  "learningObjective": "Entender o papel dos candidatos válidos no fluxo de backtracking.",
                                  "commonMistakes": [
                                    "Confundir candidatos válidos com soluções completas.",
                                    "Ignorar restrições parciais acumuladas de níveis anteriores."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o domínio de candidatos para o nível atual",
                                  "subSteps": [
                                    "Analise o problema para identificar o conjunto total de opções possíveis no nível atual (ex: colunas 0 a N-1).",
                                    "Liste explicitamente o domínio em código ou pseudocódigo (ex: for candidate in 0..N-1).",
                                    "Considere o estado global ou parâmetros passados (ex: array de posições usadas).",
                                    "Documente como o domínio pode variar por nível (ex: permutações usam lista restante).",
                                    "Teste com um problema pequeno para listar domínios manualmente."
                                  ],
                                  "verification": "Escreva o loop inicial sem filtros e liste 5 candidatos para um exemplo concreto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Exemplo de problema: N-Rainhas com N=4"
                                  ],
                                  "tips": "Use ranges ou listas prontas para domínios fixos; passe listas dinâmicas para variáveis.",
                                  "learningObjective": "Mapear o domínio de candidatos específico ao nível de decisão.",
                                  "commonMistakes": [
                                    "Definir domínio muito amplo ignorando estado anterior.",
                                    "Usar domínio fixo quando deve ser dinâmico."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar iteração sobre candidatos com verificação de restrições parciais",
                                  "subSteps": [
                                    "Escreva um loop (for/while) ou recursão para percorrer todos os candidatos do domínio.",
                                    "Para cada candidato, implemente funções de verificação de restrições parciais (ex: isSafe(posição)).",
                                    "Só avance recursivamente se o candidato for válido: if (isValid(candidate)) { recurse(); }.",
                                    "Adicione backtrack: desfaça mudanças após exploração (ex: unmark usado).",
                                    "Teste unitário: rode com logs para ver quais candidatos são aceitos/rejeitados."
                                  ],
                                  "verification": "Execute o código em um caso teste e confirme que só válidos são explorados (sem duplicatas ou inválidos).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python/C++)",
                                    "Ferramenta de debug (print/logs)",
                                    "Testes unitários prontos"
                                  ],
                                  "tips": "Mantenha verificações eficientes (O(1) ideal); evite recomputar restrições desnecessárias.",
                                  "learningObjective": "Codificar iteração filtrada que respeita restrições parciais.",
                                  "commonMistakes": [
                                    "Verificar restrições após recursão em vez de antes.",
                                    "Não fazer backtrack corretamente, causando loops infinitos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar na função recursiva completa e otimizar",
                                  "subSteps": [
                                    "Incorpore a geração de candidatos na função recursiva principal.",
                                    "Adicione condição de parada (ex: nível == tamanho alvo).",
                                    "Otimize para evitar redundâncias (ex: bitmasks para domínios booleanos).",
                                    "Profile o código: meça tempo e cobertura de candidatos.",
                                    "Refatore para legibilidade: nomeie funções claras como generateValidCandidates()."
                                  ],
                                  "verification": "Resolva um problema completo (ex: N-Rainhas) e valide todas soluções encontradas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código completo de backtracking",
                                    "Benchmark tool (timeit em Python)"
                                  ],
                                  "tips": "Use generators ou yield para iteração lazy em domínios grandes.",
                                  "learningObjective": "Construir módulo de candidatos integrável em backtracking full.",
                                  "commonMistakes": [
                                    "Explorar candidatos inválidos por falta de filtro.",
                                    "Sobrecarga computacional por domínio ineficiente."
                                  ]
                                }
                              ],
                              "practicalExample": "No problema das N-Rainhas (N=4), no nível da linha 2, domínio = colunas [0,1,2,3]. Candidatos válidos após restrições parciais (rainhas em (0,1) e (1,3)): só coluna 0 e 2 (não atacam diagonal/horizontal das anteriores). Loop: for col in 0..3 { if (!atacaAnteriores(row=2, col)) { colocar rainha; recurse(3); remover(); } }",
                              "finalVerifications": [
                                "Lista corretamente todos candidatos válidos para estados parciais dados.",
                                "Implementa loop/recursão sem pular ou duplicar candidatos.",
                                "Respeita TODAS restrições parciais sem falsos positivos.",
                                "Integra perfeitamente na recursão sem vazamentos de estado.",
                                "Encontra soluções completas idênticas a implementações referência.",
                                "Código é eficiente e legível com comentários."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração: 100% dos válidos gerados, nenhum inválido.",
                                "Eficiência: tempo polinomial no tamanho do domínio por nível.",
                                "Correção na integração: backtrack limpo, sem side-effects.",
                                "Robustez: funciona para múltiplos problemas (permutações, subconjuntos).",
                                "Clareza: código comentado, funções modulares.",
                                "Testes: pelo menos 3 casos com cobertura de edge cases."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e geração de subconjuntos.",
                                "Lógica e Programação: Estruturas condicionais e controle de fluxo.",
                                "Ciência da Computação: Complexidade e otimização de algoritmos.",
                                "Matemática Discreta: Combinações e permutações parciais."
                              ],
                              "realWorldApplication": "Em sistemas de configuração automática (ex: roteadores WiFi gerando canais não interferentes), ou em IA para jogos (gerar movimentos legais em xadrez respeitando regras parciais), ou em criptografia (enumerar chaves candidatas válidas sob restrições de força)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.2.3",
                            "name": "Gerenciar o estado global da solução",
                            "description": "Usar variáveis globais ou parâmetros passados por referência para rastrear a solução atual e soluções encontradas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os elementos do estado global necessários",
                                  "subSteps": [
                                    "Analise o problema de backtracking para listar componentes como 'solução atual', 'contador de soluções' e 'estado parcial'.",
                                    "Defina o tipo de dados para cada elemento (ex: lista para caminho atual, inteiro para contador).",
                                    "Documente como o estado muda em cada chamada recursiva (adição, remoção).",
                                    "Crie um diagrama simples de fluxo mostrando o estado antes/depois da recursão.",
                                    "Verifique se todos os elementos são compartilhados entre chamadas recursivas."
                                  ],
                                  "verification": "Lista completa de elementos do estado documentada e mapeada ao problema.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação (ex: Draw.io)",
                                    "Descrição do problema de backtracking"
                                  ],
                                  "tips": "Comece pelo estado mais simples: a solução atual como uma lista mutável.",
                                  "learningObjective": "Compreender quais dados precisam ser persistentes entre chamadas recursivas.",
                                  "commonMistakes": [
                                    "Ignorar o contador de soluções.",
                                    "Confundir estado local com global."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e inicializar o mecanismo de gerenciamento de estado",
                                  "subSteps": [
                                    "Decida entre variáveis globais (simples para protótipos) ou parâmetros por referência (melhor para modularidade).",
                                    "Inicialize as variáveis globais ou estruturas por referência fora da função recursiva.",
                                    "Garanta que o estado seja mutável (listas em Python, arrays em C++).",
                                    "Teste a inicialização com um print ou log simples.",
                                    "Defina valores iniciais apropriados (ex: lista vazia para solução atual)."
                                  ],
                                  "verification": "Estado inicializado corretamente e acessível na função recursiva.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Linguagem de programação com suporte a referências (Python/C++)"
                                  ],
                                  "tips": "Prefira parâmetros por referência para evitar poluição global em códigos maiores.",
                                  "learningObjective": "Selecionar o método adequado para compartilhar estado em recursão.",
                                  "commonMistakes": [
                                    "Usar variáveis locais imutáveis.",
                                    "Não inicializar fora da recursão."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar atualizações e backtrack do estado na recursão",
                                  "subSteps": [
                                    "Na função recursiva, adicione o elemento atual ao estado (ex: append na lista).",
                                    "Chame a recursão e verifique condições de solução (ex: se completa, incremente contador).",
                                    "Implemente o backtrack removendo/restaurando o estado (ex: pop da lista).",
                                    "Adicione logs para rastrear mudanças no estado durante a execução.",
                                    "Teste com um problema pequeno para observar atualizações."
                                  ],
                                  "verification": "Estado é modificado corretamente e restaurado após backtrack.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo base de backtracking sem estado gerenciado"
                                  ],
                                  "tips": "Sempre backtrack imediatamente após a recursão para evitar vazamentos de estado.",
                                  "learningObjective": "Integrar modificações mutáveis no fluxo recursivo de backtracking.",
                                  "commonMistakes": [
                                    "Esquecer o backtrack (pop).",
                                    "Atualizar estado sem condicional."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e debugar o gerenciamento de estado",
                                  "subSteps": [
                                    "Execute o algoritmo em um caso de teste pequeno e inspecione o estado em cada nível.",
                                    "Verifique se múltiplas soluções são contadas corretamente sem sobrescrita.",
                                    "Use breakpoints ou prints para simular pilha de recursão.",
                                    "Corrija erros comuns como estado não restaurado ou contadores errados.",
                                    "Otimize logs removendo-os após validação."
                                  ],
                                  "verification": "Algoritmo encontra todas as soluções com estado consistente em testes.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Debugger do IDE",
                                    "Casos de teste pré-definidos (ex: N=4 para N-Rainhas)"
                                  ],
                                  "tips": "Visualize a pilha de chamadas para entender o escopo do estado.",
                                  "learningObjective": "Garantir robustez e correção no gerenciamento de estado global.",
                                  "commonMistakes": [
                                    "Não testar com múltiplas soluções.",
                                    "Ignorar restauração em falhas."
                                  ]
                                }
                              ],
                              "practicalExample": "No problema das N-Rainhas (N=4), use uma lista global 'solucao_atual' para armazenar posições das rainhas por coluna. Na recursão: append posição válida, recurse para próxima coluna, se solução completa incremente 'num_solucoes' e imprima, então pop para backtrack. Resultado: encontra 2 soluções com estado restaurado corretamente.",
                              "finalVerifications": [
                                "O estado da solução atual é corretamente expandido e restaurado em cada backtrack.",
                                "Contador de soluções reflete o número exato de soluções válidas.",
                                "Múltiplas execuções não acumulam estado residual.",
                                "Logs mostram consistência do estado em todos os níveis recursivos.",
                                "Testes com N pequeno (ex: 4) produzem saídas corretas.",
                                "Não há vazamentos de memória ou mutações indesejadas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e inicialização do estado global (80% dos elementos corretos).",
                                "Implementação correta de append/pop no backtrack sem erros lógicos.",
                                "Funcionalidade completa: encontra e conta soluções corretamente.",
                                "Código limpo com comentários explicando gerenciamento de estado.",
                                "Robustez em testes variados (pequeno/grande N).",
                                "Eficiência: sem operações desnecessárias no estado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e contagem de permutações.",
                                "Engenharia de Software: Padrões de design State e Singleton.",
                                "Programação Funcional: Contraste com imutabilidade e pureza.",
                                "Análise de Algoritmos: Complexidade de espaço em recursão."
                              ],
                              "realWorldApplication": "Em solvers de sudoku para apps de jogos, planejamento de rotas em GPS com restrições dinâmicas, ou configuração de redes em telecomunicações, onde backtracking gerencia estados parciais de soluções viáveis globalmente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.3.3",
                        "name": "Poda de Subárvores Inviáveis",
                        "description": "Aplicar critérios de poda para eliminar ramos da árvore de busca que não levam a soluções válidas, otimizando a exploração.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.3.3.1",
                            "name": "Definir critérios de viabilidade parcial",
                            "description": "Estabelecer condições que verifiquem se uma solução parcial pode ser estendida a uma solução completa válida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender soluções parciais e completas em Backtracking",
                                  "subSteps": [
                                    "Revise o funcionamento básico do Backtracking como busca exaustiva com poda.",
                                    "Identifique o que é uma solução parcial: configuração intermediária que pode levar a uma solução completa.",
                                    "Diferencie solução parcial viável de inviável analisando exemplos simples como permutações.",
                                    "Estude o papel da poda de subárvores inviáveis para otimizar a busca.",
                                    "Anote exemplos onde soluções parciais falham em estender-se."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito a diferença entre solução parcial viável e inviável com um diagrama de árvore de busca.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Documentação de Backtracking (ex: Wikipedia ou slides de aula)"
                                  ],
                                  "tips": "Use diagramas de árvore para visualizar o processo de backtracking.",
                                  "learningObjective": "Entender o conceito fundamental de soluções parciais no contexto de backtracking.",
                                  "commonMistakes": [
                                    "Confundir solução parcial com solução completa.",
                                    "Ignorar o impacto da poda na eficiência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar condições de inviabilidade em problemas de Backtracking",
                                  "subSteps": [
                                    "Escolha um problema clássico como N-Rainhas ou Sudoku.",
                                    "Simule manualmente a construção de soluções parciais passo a passo.",
                                    "Identifique pontos onde a extensão é impossível (ex: conflito inevitável).",
                                    "Liste condições genéricas de falha: violações de restrições parciais ou limites superiores.",
                                    "Compare com problemas sem poda para medir ganho de eficiência."
                                  ],
                                  "verification": "Crie uma tabela comparando soluções parciais viáveis e inviáveis para um problema específico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de problemas: N-Rainhas 4x4",
                                    "Planilha ou papel quadriculado"
                                  ],
                                  "tips": "Comece com instâncias pequenas (N=4) para evitar complexidade.",
                                  "learningObjective": "Reconhecer padrões de inviabilidade em soluções parciais.",
                                  "commonMistakes": [
                                    "Focar apenas em violações imediatas, ignorando violações futuras.",
                                    "Não considerar restrições globais do problema."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular critérios de viabilidade parcial específicos",
                                  "subSteps": [
                                    "Defina critérios baseados nas restrições do problema (ex: não-ataque em N-Rainhas).",
                                    "Escreva funções condicionais booleanas para checar viabilidade em cada nível da recursão.",
                                    "Inclua critérios relaxados: checagens parciais que garantam possibilidade de extensão.",
                                    "Teste os critérios em cenários edge-case (ex: quase solução).",
                                    "Refine os critérios iterativamente com base em testes manuais."
                                  ],
                                  "verification": "Implemente pseudocódigo de um critério e valide em 3 soluções parciais diferentes.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Exemplos de código Backtracking em Python"
                                  ],
                                  "tips": "Priorize critérios computacionalmente baratos para poda precoce.",
                                  "learningObjective": "Criar critérios acionáveis e precisos para poda.",
                                  "commonMistakes": [
                                    "Critérios muito restritivos que podam soluções válidas.",
                                    "Critérios vagos que não previnem explorações inúteis."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e integrar critérios em um algoritmo de Backtracking",
                                  "subSteps": [
                                    "Integre os critérios no esqueleto de um algoritmo Backtracking.",
                                    "Execute simulações comparando com e sem poda.",
                                    "Meça redução no espaço de busca (número de nós visitados).",
                                    "Ajuste critérios com base em resultados empíricos.",
                                    "Documente os critérios para reutilização em problemas similares."
                                  ],
                                  "verification": "Compare métricas de performance antes/depois da poda em um problema teste.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ambiente de programação (Python/Jupyter)",
                                    "Problema teste: N-Rainhas ou Knapsack"
                                  ],
                                  "tips": "Use contadores de nós para quantificar eficiência.",
                                  "learningObjective": "Aplicar e validar critérios de viabilidade em prática.",
                                  "commonMistakes": [
                                    "Não testar com instâncias grandes o suficiente.",
                                    "Esquecer de resetar estados na backtrack."
                                  ]
                                }
                              ],
                              "practicalExample": "No problema das N-Rainhas (N=8), um critério de viabilidade parcial é: para uma rainha na linha i, coluna j, verifique se não há rainha anterior atacando diagonal, coluna ou linha futura possível. Se uma coluna inteira estiver bloqueada por diagonais, poda a subárvore.",
                              "finalVerifications": [
                                "Define critérios corretos para pelo menos 2 problemas de Backtracking diferentes.",
                                "Explica como o critério garante extensão a solução completa.",
                                "Identifica inviabilidades em 80% das soluções parciais testadas.",
                                "Integra critério em código funcional sem erros.",
                                "Compara eficiência com/sem poda numericamente.",
                                "Ajusta critérios baseados em testes falhos."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude dos critérios definidos (90% cobertura de casos).",
                                "Eficiência computacional do critério (O(1) ou baixo custo).",
                                "Capacidade de generalização para problemas similares.",
                                "Correção em validações empíricas (sem falsos positivos/negativos).",
                                "Clareza na documentação e explicação.",
                                "Redução mensurável no espaço de busca (>50%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e teoria de grafos (conflitos como arestas).",
                                "Programação: Estruturas condicionais, recursão e otimização de algoritmos.",
                                "Engenharia de Software: Design de heurísticas para eficiência.",
                                "Inteligência Artificial: Podas em buscas heurísticas e A*."
                              ],
                              "realWorldApplication": "Em solvers de quebra-cabeças como Sudoku ou CSPs industriais (agendamento de tarefas, configuração de redes), onde podas precoces evitam explorações exaustivas em problemas NP-completos, economizando tempo em aplicações como logística e jogos de IA."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.2",
                            "name": "Implementar poda condicional na recursão",
                            "description": "Inserir verificações antes da chamada recursiva para abortar subárvores inviáveis, evitando explorações desnecessárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de poda condicional em backtracking",
                                  "subSteps": [
                                    "Estude a estrutura básica de uma função recursiva de backtracking.",
                                    "Identifique onde ocorrem chamadas recursivas desnecessárias em problemas exaustivos.",
                                    "Aprenda que poda condicional insere um 'if' para verificar viabilidade antes de recursar.",
                                    "Analise diagramas de árvore de recursão com e sem poda.",
                                    "Discuta trade-offs: corretude vs. velocidade."
                                  ],
                                  "verification": "Explique em suas palavras como a poda evita explorações desnecessárias e desenhe uma árvore de recursão simplificada.",
                                  "estimatedTime": "30 minutes",
                                  "materials": [
                                    "Documentação de backtracking",
                                    "Exemplos de código em Python ou C++",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": "Comece com problemas simples como geração de subconjuntos para visualizar a poda.",
                                  "learningObjective": "Dominar os princípios teóricos da poda condicional para identificar oportunidades em algoritmos recursivos.",
                                  "commonMistakes": [
                                    "Confundir poda com corte de solução válida",
                                    "Ignorar condições parciais vs. finais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar um problema de backtracking e identificar pontos de poda",
                                  "subSteps": [
                                    "Escolha um problema base, como N-Rainhas ou Sudoku.",
                                    "Execute o backtracking sem poda e meça o número de chamadas recursivas.",
                                    "Identifique restrições do problema (ex: ataques em N-Rainhas).",
                                    "Mapeie condições booleanas que invalidam subárvores (ex: linha/coluna/diagonal ocupada).",
                                    "Documente potenciais pontos de inserção da poda antes da recursão."
                                  ],
                                  "verification": "Liste 3-5 condições específicas de poda para o problema escolhido e justifique por que elas são seguras.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Código base de backtracking sem poda",
                                    "Ferramenta de profiling como Python's cProfile",
                                    "Exemplos de problemas clássicos"
                                  ],
                                  "tips": "Use prints ou contadores para visualizar chamadas recursivas antes e depois.",
                                  "learningObjective": "Desenvolver habilidade para diagnosticar ineficiências em backtracking e propor podas.",
                                  "commonMistakes": [
                                    "Poda prematura que exclui soluções válidas",
                                    "Condições muito fracas que não reduzem buscas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a poda condicional na função recursiva",
                                  "subSteps": [
                                    "Modifique a função recursiva adicionando um 'if' antes da chamada recursiva.",
                                    "Defina a condição de poda como uma função auxiliar para clareza.",
                                    "Integre atualizações de estado (ex: marcar posições usadas).",
                                    "Garanta que a poda seja reversível no backtrack (undo).",
                                    "Teste unitariamente a condição de poda com casos edge."
                                  ],
                                  "verification": "Execute o código modificado e confirme que branches inviáveis são abortadas sem erros.",
                                  "estimatedTime": "60 minutes",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Código do Step 2",
                                    "Test cases pré-definidos"
                                  ],
                                  "tips": "Mantenha a condição de poda simples e leia bem; use asserts para validação.",
                                  "learningObjective": "Implementar poda condicional de forma correta e eficiente em código real.",
                                  "commonMistakes": [
                                    "Esquecer de undo após recursão",
                                    "Condição de poda invertida (poda soluções válidas)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, validar e otimizar a implementação",
                                  "subSteps": [
                                    "Compare performance com e sem poda (tempo e chamadas recursivas).",
                                    "Teste com inputs variados: pequenos, médios e grandes.",
                                    "Verifique se todas soluções corretas são encontradas.",
                                    "Otimize a condição de poda se necessário (ex: pré-calcular).",
                                    "Documente o código com comentários sobre a poda."
                                  ],
                                  "verification": "Gere relatório mostrando redução de pelo menos 50% em chamadas recursivas para casos teste.",
                                  "estimatedTime": "45 minutes",
                                  "materials": [
                                    "Benchmark scripts",
                                    "Dados de teste para N-Rainhas (N=4 a 12)",
                                    "Ferramentas de timing"
                                  ],
                                  "tips": "Use memoization apenas se aplicável, mas foque em poda pura primeiro.",
                                  "learningObjective": "Avaliar o impacto da poda e refinar implementações para máxima eficiência.",
                                  "commonMistakes": [
                                    "Overfitting em casos pequenos",
                                    "Ignorar overflow em contadores para grandes N"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema das N-Rainhas, antes de tentar colocar uma rainha na posição (row, col), verifique se col está livre, e diagonais não intersectam rainhas anteriores. Se qualquer verificação falhar: return sem recursar para próxima linha. Exemplo em Python: if is_safe(row, col): place_queen(row, col); backtrack(row+1); remove_queen(row, col).",
                              "finalVerifications": [
                                "Função recursiva inclui pelo menos uma condição 'if' antes de recursar.",
                                "Execução em problema padrão (ex: N-Rainhas N=8) encontra solução sem explorar >50% das branches originais.",
                                "Nenhum erro de index out of bounds ou estados inconsistentes.",
                                "Undo do backtrack restaura estado corretamente após poda.",
                                "Código é legível com comentários explicando podas.",
                                "Testes unitários passam para casos com e sem poda necessária."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Soluções completas e únicas são encontradas.",
                                "Eficiência: Redução mensurável em chamadas recursivas e tempo.",
                                "Clareza: Condições de poda bem nomeadas e comentadas.",
                                "Robustez: Lida com edge cases (N=1, N=0, impossíveis).",
                                "Modularidade: Podas em funções auxiliares separadas.",
                                "Documentação: Explica lógica de cada poda."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e teoria de grafos (árvores de decisão).",
                                "Inteligência Artificial: Algoritmos de busca e otimização heurística.",
                                "Engenharia de Software: Refatoração e profiling de performance.",
                                "Análise de Algoritmos: Complexidade temporal com poda (pruning).",
                                "Programação Funcional: Padrões de recursão com guards."
                              ],
                              "realWorldApplication": "Em motores de xadrez para podar movimentos inviáveis, solvers de sudoku em apps mobile, otimização de rotas em logística (evitar caminhos bloqueados), e constraint programming em scheduling de tarefas industriais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.2.3.3.3",
                            "name": "Avaliar impacto da poda na eficiência",
                            "description": "Comparar o tempo de execução com e sem poda em exemplos, medindo redução no tamanho do espaço explorado.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar problema e implementar backtracking sem poda",
                                  "subSteps": [
                                    "Escolha um problema clássico de backtracking, como Subset Sum: encontre subconjuntos de [3,5,2,6,4] que somem 9.",
                                    "Implemente a função recursiva básica: parâmetros incluem índice atual, soma atual, lista de números e target.",
                                    "Explore todas as branches: incluir ou excluir cada número recursivamente.",
                                    "Adicione um contador global de chamadas recursivas para medir nós visitados.",
                                    "Teste com entrada pequena e verifique se encontra soluções corretas (ex: [3,6], [5,4])."
                                  ],
                                  "verification": "Código roda sem erros, contador registra >10 chamadas para input pequeno, lista soluções corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Editor de código (VS Code/PyCharm), Python 3+, Jupyter Notebook para testes.",
                                  "tips": "Use print statements iniciais para visualizar a árvore de recursão.",
                                  "learningObjective": "Compreender a estrutura básica de backtracking e identificar o espaço de busca completo.",
                                  "commonMistakes": "Esquecer de passar índice atual, levando a loops infinitos; não resetar soma corretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar e medir desempenho sem poda",
                                  "subSteps": [
                                    "Execute o backtracking sem poda com input maior: [1,2,3,4,5,6,7], target=15.",
                                    "Registre: tempo de execução (use time.perf_counter()), número de nós visitados (contador).",
                                    "Repita 10 vezes para média, variando seeds se randomizado.",
                                    "Salve resultados em tabela: tempo médio (s), nós médios.",
                                    "Visualize árvore parcial com prints ou graphviz se possível."
                                  ],
                                  "verification": "Tabela com métricas salvas (ex: CSV), tempo >0.1s para input médio, nós >100.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Python com time e pandas para tabelas, planilha Excel opcional.",
                                  "tips": "Use @lru_cache(None) temporariamente para debug, mas desative para medições reais.",
                                  "learningObjective": "Aprender a instrumentar código para profiling quantitativo em algoritmos recursivos.",
                                  "commonMistakes": "Medir tempo incluindo I/O; não fazer múltiplas runs para variância."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar backtracking com poda de subárvores inviáveis",
                                  "subSteps": [
                                    "Adicione condição de poda: se soma restante dos números não selecionados < target - soma atual, pare recursão.",
                                    "Calcule soma restante dinamicamente: soma de nums[índice:] - soma atual possível.",
                                    "Atualize função recursiva com if (soma_restante < target_restante): return.",
                                    "Mantenha contador de nós para versão com poda.",
                                    "Teste com mesmo input anterior, confirme soluções iguais mas menos nós."
                                  ],
                                  "verification": "Código encontra mesmas soluções, mas contador mostra <50% nós originais para input testado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmo ambiente Python, debugger para verificar podas.",
                                  "tips": "Precalcule soma total para otimizar cálculo de restante.",
                                  "learningObjective": "Dominar poda por bounding em backtracking para reduzir espaço exponencial.",
                                  "commonMistakes": "Poda prematura que exclui soluções válidas; erro em cálculo de soma restante."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Medir com poda, comparar e analisar impacto",
                                  "subSteps": [
                                    "Execute versão com poda no mesmo input grande, colete tempo e nós como no step 2.",
                                    "Compare métricas: % redução em nós = (1 - nós_com_poda/nós_sem) *100; mesmo para tempo.",
                                    "Crie gráfico de barras (matplotlib) comparando tempo/nós sem vs com poda.",
                                    "Analise: discuta por que poda reduz drasticamente em casos com targets médios.",
                                    "Teste sensibilidade: varie target de 1 a soma_total, plote reduções."
                                  ],
                                  "verification": "Gráficos salvos, relatório com %redução >30% em nós e tempo para input médio.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Matplotlib/Seaborn para plots, Jupyter para visualizações interativas.",
                                  "tips": "Use inputs com diferentes tamanhos (n=10-20) para mostrar escalabilidade.",
                                  "learningObjective": "Quantificar ganhos de otimização e interpretar resultados empíricos.",
                                  "commonMistakes": "Comparar apples-to-oranges (diferentes inputs); ignorar overhead da poda."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar conclusões e generalizar",
                                  "subSteps": [
                                    "Escreva relatório: resuma tabelas/gráficos, calcule speedup médio.",
                                    "Discuta limitações: poda menos efetiva se target pequeno/grande.",
                                    "Generalize para outros problemas (N-Queens, TSP): explique princípios.",
                                    "Sugira melhorias: poda bidirecional ou heurísticas.",
                                    "Compartilhe código em GitHub para reprodutibilidade."
                                  ],
                                  "verification": "Relatório de 1 página com achados chave, repositório com código funcional.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Markdown/Word para relatório, GitHub.",
                                  "tips": "Inclua screenshots de árvores podadas vs não.",
                                  "learningObjective": "Sintetizar análise empírica em insights acionáveis para algoritmos.",
                                  "commonMistakes": "Overclaim resultados sem múltiplos testes; não citar complexidade teórica O(2^n)."
                                }
                              ],
                              "practicalExample": "Problema Subset Sum: números=[3,5,2,6,4], target=9. Sem poda: ~31 nós visitados, 0.02s. Com poda (soma_restante < target_restante): 15 nós, 0.01s. Redução: 52% nós, 50% tempo. Visual: árvore completa vs podada após 5+2 (soma=7, restante=13<2, poda).",
                              "finalVerifications": [
                                "Códigos sem/com poda encontram soluções idênticas.",
                                "Métricas coletadas para ≥3 tamanhos de input.",
                                "Gráficos mostram redução ≥30% em nós/tempo.",
                                "Relatório quantifica speedup médio.",
                                "Testes de borda (target=0, target=soma_total) validados.",
                                "Código reproduzível com README."
                              ],
                              "assessmentCriteria": [
                                "Precisão das medições (baixa variância em runs múltiplas).",
                                "Correção da poda (não perde soluções).",
                                "Profundidade da análise (%redução, sensibilidade a inputs).",
                                "Qualidade visual (gráficos claros, legíveis).",
                                "Generalização para outros problemas.",
                                "Clareza do relatório (estruturado, conciso)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de complexidade assintótica (O(2^n) vs podado).",
                                "Programação: Técnicas de profiling e otimização de código.",
                                "Inteligência Artificial: Podas em busca heurística (A*, Monte Carlo Tree Search).",
                                "Estatística: Análise empírica, testes de hipótese em performance.",
                                "Engenharia de Software: Benchmarking e reprodutibilidade."
                              ],
                              "realWorldApplication": "Em solvers de quebra-cabeças (Sudoku via backtracking podado), otimização de rotas logísticas (TSP podado), validação de configurações em cybersecurity (senhas/cracking reduzido), e compiladores (otimização de código via poda de caminhos inviáveis), reduzindo tempo de computação de horas para segundos em espaços grandes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.3.2.2",
                              "10.1.2.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.4",
                    "name": "Geração de Permutações e Combinações",
                    "description": "Métodos para gerar exaustivamente permutações e combinações em problemas de otimização.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.4.1",
                        "name": "Geração de Permutações",
                        "description": "Técnicas para gerar exaustivamente todas as permutações de um conjunto de elementos, utilizando abordagens recursivas e iterativas, aplicadas em problemas de otimização combinatória.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.1.1",
                            "name": "Implementar algoritmo recursivo de backtracking para permutações",
                            "description": "Desenvolver uma função recursiva que gera todas as permutações de um vetor de n elementos, utilizando backtracking para explorar todas as ordens possíveis, evitando duplicatas e otimizando com trocas in-place.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de backtracking e permutações",
                                  "subSteps": [
                                    "Estude o que são permutações: todas as rearranjos possíveis de n elementos distintos.",
                                    "Aprenda backtracking: técnica recursiva que constrói soluções candidatas e abandona caminhos inválidos.",
                                    "Analise exemplo manual para n=3: liste permutações de [A,B,C] passo a passo.",
                                    "Identifique trocas in-place: swap de elementos sem alocar novo espaço.",
                                    "Revise recursão: função chama a si mesma com subproblemas menores."
                                  ],
                                  "verification": "Explique em voz alta ou anote como backtracking gera permutações sem duplicatas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Documentação de recursão em Python/C++",
                                    "Vídeo tutorial sobre backtracking (opcional)"
                                  ],
                                  "tips": "Desenhe uma árvore de recursão para visualizar chamadas.",
                                  "learningObjective": "Dominar fundamentos teóricos para implementação correta.",
                                  "commonMistakes": [
                                    "Confundir permutações com combinações",
                                    "Ignorar o papel das trocas in-place"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a estrutura da função recursiva",
                                  "subSteps": [
                                    "Defina assinatura: def permute(arr, l, r, result): onde l=0, r=len(arr)-1.",
                                    "Estrutura base: se l == r, adicione cópia de arr ao result.",
                                    "Loop principal: para i de l a r, swap arr[l] e arr[i], recurse(l+1, r), backtrack swap de volta.",
                                    "Planeje lista result para armazenar todas permutações.",
                                    "Considere handling de duplicatas: opcional sort + skip iguais, mas para distintos assume único."
                                  ],
                                  "verification": "Escreva pseudocódigo completo e trace para n=2.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Quadro branco ou papel"
                                  ],
                                  "tips": "Use índices l e r para focar em subarray não fixado.",
                                  "learningObjective": "Criar blueprint exato da recursão antes de codificar.",
                                  "commonMistakes": [
                                    "Esquecer backtrack (swap de volta)",
                                    "Loop errado: i de l+1 ao invés de l"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a função com backtracking in-place",
                                  "subSteps": [
                                    "Crie função auxiliar permute(arr, l, r, result).",
                                    "Implemente caso base: if l == r: result.append(arr[:]).",
                                    "Adicione loop: for i in range(l, r+1): swap(arr,l,i), permute(arr,l+1,r,result), swap(arr,l,i).",
                                    "Função principal: inicialize result=[], chame permute(arr,0,len-1,result), retorne result.",
                                    "Teste unitário rápido com [1,2]."
                                  ],
                                  "verification": "Execute com [1,2,3] e confira 6 permutações únicas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "IDE como VSCode ou Jupyter",
                                    "Linguagem Python ou C++"
                                  ],
                                  "tips": "Use arr[:] para cópia rasa em Python para evitar referências.",
                                  "learningObjective": "Codificar recursão funcional com otimizações in-place.",
                                  "commonMistakes": [
                                    "Cópia errada levando a mutações",
                                    "Índices off-by-one no swap"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, otimizar e verificar corretude",
                                  "subSteps": [
                                    "Teste casos: n=1 (1 perm), n=4 (24 perms), com duplicatas se aplicável.",
                                    "Meça tempo: confirme O(n!) sem vazamentos.",
                                    "Adicione handling duplicatas: sort arr, skip if arr[i]==arr[i-1].",
                                    "Profile memória: confirme in-place não aloca extra.",
                                    "Documente código com comentários."
                                  ],
                                  "verification": "Compare output com permutações esperadas manualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Testes unitários (pytest/unittest)",
                                    "Profiler simples como timeit"
                                  ],
                                  "tips": "Gere expected manualmente para pequenos n.",
                                  "learningObjective": "Garantir robustez e eficiência da implementação.",
                                  "commonMistakes": [
                                    "Não tratar duplicatas",
                                    "Stack overflow em n grande por falta de otimização"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente para array=['A','B','C']. A função deve retornar [['A','B','C'], ['A','C','B'], ['B','A','C'], ['B','C','A'], ['C','A','B'], ['C','B','A']] sem duplicatas, usando trocas in-place para eficiência.",
                              "finalVerifications": [
                                "Gera exatamente n! permutações para elementos distintos.",
                                "Nenhuma duplicata no resultado.",
                                "Uso de espaço O(1) extra além da pilha de recursão.",
                                "Funciona corretamente para n=1 até n=8 sem crash.",
                                "Backtrack restaura array original.",
                                "Tempo escala como O(n * n!)."
                              ],
                              "assessmentCriteria": [
                                "Corretude: todas permutações únicas geradas.",
                                "Eficiência: trocas in-place, sem alocações desnecessárias.",
                                "Estrutura recursiva: base, loop, recurse, backtrack.",
                                "Tratamento de bordas: n=0, n=1.",
                                "Código limpo: comentários, indentação.",
                                "Testes: cobertura de casos variados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e fatorial (n!).",
                                "Inteligência Artificial: Busca exaustiva em espaços de estados.",
                                "Engenharia de Software: Design recursivo e otimização de memória.",
                                "Criptografia: Geração de chaves e quebra de códigos."
                              ],
                              "realWorldApplication": "Em otimização combinatorial como Problema das N-Rainhas ou Caixeiro Viajante; geração de sequências em jogos (anagramas); análise de DNA (permutações genéticas); testes de sistemas (todas ordens de execução)."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.2",
                            "name": "Utilizar next_permutation para geração iterativa",
                            "description": "Aplicar a função std::next_permutation da STL em C++ para gerar permutações em ordem lexicográfica, incluindo ordenação inicial e loop até retornar ao estado original, com análise de complexidade O(n! * n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a função std::next_permutation",
                                  "subSteps": [
                                    "Ler a documentação oficial da STL para std::next_permutation no cppreference.com.",
                                    "Identificar os parâmetros: iteradores bidirecionais first e last.",
                                    "Entender o comportamento: retorna true se gera a próxima permutação em ordem lexicográfica, false quando retorna ao estado inicial ordenado.",
                                    "Notar pré-requisitos: o range deve estar ordenado em ordem crescente antes da primeira chamada.",
                                    "Estudar o cabeçalho necessário: #include <algorithm>."
                                  ],
                                  "verification": "Explicar em palavras próprias o funcionamento, parâmetros e retorno da função.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação cppreference.com",
                                    "Compilador C++ (g++ ou clang++)"
                                  ],
                                  "tips": [
                                    "Sempre verifique se o range é ordenado inicialmente para evitar loops infinitos.",
                                    "Teste com exemplos pequenos para visualizar o comportamento."
                                  ],
                                  "learningObjective": "Dominar os conceitos fundamentais e pré-requisitos da função next_permutation.",
                                  "commonMistakes": [
                                    "Não ordenar o range antes da primeira chamada.",
                                    "Confundir com std::prev_permutation."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar o container para geração de permutações",
                                  "subSteps": [
                                    "Criar um std::vector ou array com elementos iniciais.",
                                    "Incluir as bibliotecas: #include <algorithm>, #include <vector>.",
                                    "Aplicar std::sort(first, last) para ordenar em ordem crescente.",
                                    "Imprimir o container para verificar a ordenação inicial.",
                                    "Testar compilação do código de preparação."
                                  ],
                                  "verification": "Compilar e executar: o container deve aparecer ordenado em ordem lexicográfica crescente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "IDE com suporte a C++ (VS Code, Code::Blocks)",
                                    "Compilador g++"
                                  ],
                                  "tips": [
                                    "Use std::vector para flexibilidade; evite arrays fixos para testes.",
                                    "Elementos duplicados são suportados, mas geram menos permutações únicas."
                                  ],
                                  "learningObjective": "Preparar corretamente o input ordenado para o algoritmo de permutações.",
                                  "commonMistakes": [
                                    "Esquecer std::sort antes do loop.",
                                    "Definir range incorreto nos iteradores (ex: v.end() exclusivo)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop iterativo de geração de permutações",
                                  "subSteps": [
                                    "Estruturar um laço do-while: do { processar_permutacao(); } while (std::next_permutation(first, last));",
                                    "No corpo do laço, imprimir ou processar a permutação atual (ex: for_each ou loop).",
                                    "Incluir #include <iostream> para saída.",
                                    "Executar e contar o número de iterações (deve ser n! para n elementos distintos).",
                                    "Verificar se o loop para corretamente quando next_permutation retorna false."
                                  ],
                                  "verification": "Executar o programa: deve imprimir exatamente n! permutações únicas em ordem lexicográfica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Compilador C++",
                                    "Terminal para execução"
                                  ],
                                  "tips": [
                                    "Use do-while para incluir a permutação inicial ordenada.",
                                    "Adicione um contador para validar o número de permutações."
                                  ],
                                  "learningObjective": "Implementar corretamente o ciclo completo de geração iterativa de permutações.",
                                  "commonMistakes": [
                                    "Usar while simples, perdendo a primeira permutação.",
                                    "Não incluir <algorithm> causando erro de compilação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar complexidade, casos especiais e verificações finais",
                                  "subSteps": [
                                    "Calcular complexidade temporal: O(n!) invocações, cada uma O(n) → O(n! * n).",
                                    "Testar com elementos duplicados: confirme que pula permutações idênticas.",
                                    "Verificar pós-loop: o container retorna ao estado ordenado inicial.",
                                    "Discutir limitações: viável apenas para n ≤ 10 devido à explosão combinatória.",
                                    "Explorar extensão: uso de std::prev_permutation para ordem reversa."
                                  ],
                                  "verification": "Executar testes com n=3 (6 perms), n=4 (24 perms) e analisar tempo/output; explicar complexidade por escrito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e calculadora para fatoriais",
                                    "Cronômetro para medir tempo em n=8"
                                  ],
                                  "tips": [
                                    "Para n grande, considere backtracking otimizado.",
                                    "Sempre valide com std::is_sorted após o loop."
                                  ],
                                  "learningObjective": "Analisar performance, limitações e casos edge do algoritmo.",
                                  "commonMistakes": [
                                    "Subestimar complexidade O(n! * n) como polinomial.",
                                    "Ignorar comportamento com duplicatas."
                                  ]
                                }
                              ],
                              "practicalExample": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nint main() {\n    std::vector<int> v = {1, 3, 2};\n    std::sort(v.begin(), v.end());\n    int count = 0;\n    do {\n        std::cout << \"Permutação \" << ++count << \": \";\n        for (int x : v) std::cout << x << ' ';\n        std::cout << '\\n';\n    } while (std::next_permutation(v.begin(), v.end()));\n    // Saída esperada: 6 permutações de 1,2,3 em ordem lex.\n    return 0;\n}",
                              "finalVerifications": [
                                "Gera exatamente n! permutações únicas para elementos distintos.",
                                "Permutações impressas em estrita ordem lexicográfica crescente.",
                                "Após o loop, o container está ordenado novamente (std::is_sorted confirma).",
                                "Funciona corretamente com duplicatas, gerando apenas permutações únicas.",
                                "Número de iterações pode ser contado e validado.",
                                "Não há loops infinitos ou crashes."
                              ],
                              "assessmentCriteria": [
                                "Código compila sem erros ou warnings usando g++ -std=c++11.",
                                "Saída exata das permutações esperadas para input de teste.",
                                "Uso correto de do-while para capturar todas as permutações.",
                                "Pré-ordenação com std::sort aplicada antes do loop.",
                                "Análise de complexidade O(n! * n) explicada corretamente.",
                                "Testes com duplicatas e edge cases (n=1, n=0) passam.",
                                "Comentários no código explicando cada parte."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de permutações e combinatória (fatorial n!).",
                                "Algoritmos: Métodos exaustivos e backtracking.",
                                "Programação Competitiva: Brute-force em problemas de otimização.",
                                "Ciência de Dados: Geração de features em ML para espaços discretos.",
                                "Engenharia de Software: Testes exaustivos de configurações."
                              ],
                              "realWorldApplication": "Em solvers de quebra-cabeças (ex: permutações em Sudoku ou N-Queens), geração exaustiva de configurações em testes de hardware/software, otimização de rotas pequenas em logística, e brute-force em criptoanálise ou jogos como xadrez para posições limitadas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.1.3",
                            "name": "Aplicar geração de permutações em problemas de otimização exaustiva",
                            "description": "Resolver problemas como o Caixeiro Viajante (TSP) gerando todas as permutações de cidades e avaliando o custo total de cada rota, identificando a solução ótima com poda de branches desnecessárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema de otimização exaustiva e representar os dados",
                                  "subSteps": [
                                    "Identifique o problema TSP: dada uma matriz de distâncias entre n cidades, encontre a rota mais curta visitando cada cidade exatamente uma vez e retornando à origem.",
                                    "Crie uma matriz de distâncias simétrica ou assimétrica com valores reais representando custos.",
                                    "Defina as cidades como nós numerados de 0 a n-1, excluindo a cidade inicial fixa (ex: cidade 0).",
                                    "Inicialize variáveis: melhor_custo = infinito, melhor_rota = []",
                                    "Valide a matriz: verifique se distâncias são positivas e dist[ i ][ i ] = 0."
                                  ],
                                  "verification": "Matriz de distâncias criada e impressa corretamente; variáveis iniciais definidas sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (Python/Jupyter), biblioteca itertools para testes iniciais.",
                                  "tips": "Use listas 2D para matriz; fixe cidade 0 como partida para reduzir permutações pela metade.",
                                  "learningObjective": "Compreender a representação de dados em problemas TSP para geração de permutações.",
                                  "commonMistakes": "Esquecer de retornar à origem no cálculo de custo; usar índices incorretos na matriz."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar geração de todas as permutações das cidades restantes",
                                  "subSteps": [
                                    "Importe itertools.permutations para gerar todas as sequências possíveis das cidades 1 a n-1.",
                                    "Gere o iterador de permutações: permutations(range(1, n)) onde n é o número total de cidades.",
                                    "Para cada permutação gerada, construa a rota completa: [0] + list(permutacao) + [0].",
                                    "Conte o número total de permutações esperadas: (n-1)! para confirmação.",
                                    "Armazene ou processe cada permutação em um loop sem materializar toda a lista para eficiência."
                                  ],
                                  "verification": "Número de permutações geradas igual a (n-1)! ; primeira e última permutações impressas corretamente.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python com itertools; papel para calcular (n-1)! manualmente.",
                                  "tips": "Não fixe a ordem inicial; use yield ou iteradores para problemas maiores.",
                                  "learningObjective": "Dominar geração exaustiva de permutações usando bibliotecas padrão.",
                                  "commonMistakes": "Incluir cidade 0 nas permutações; gerar n! em vez de (n-1)!."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o custo total de cada rota permutada",
                                  "subSteps": [
                                    "Para cada rota completa (cidades + retorno), inicialize custo_total = 0.",
                                    "Some dist[rota[i]][rota[i+1]] para i de 0 a len(rota)-2.",
                                    "Compare custo_total com melhor_custo; se menor, atualize melhor_custo e melhor_rota.",
                                    "Registre estatísticas: número de rotas avaliadas, custo mínimo encontrado.",
                                    "Implemente uma função separada calcular_custo(rota, dist) para reutilização."
                                  ],
                                  "verification": "Para um TSP de 4 cidades, custo mínimo calculado e rota impressa corretamente.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código do Step 1 e 2; exemplo de matriz 4x4.",
                                  "tips": "Use soma cumulativa para depuração; evite rotas com auto-loops.",
                                  "learningObjective": "Avaliar eficiência de soluções candidatas em busca exaustiva.",
                                  "commonMistakes": "Índice off-by-one no loop de soma; não resetar custo_total por iteração."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar poda de branches desnecessárias (Branch and Bound básico)",
                                  "subSteps": [
                                    "Calcule limite inferior para sub-rota parcial usando MST (Minimum Spanning Tree) ou soma mínima restante.",
                                    "Em cada permutação parcial, se custo_parcial + limite_inferior >= melhor_custo, poda o branch.",
                                    "Implemente recursão para gerar permutações parciais com poda: backtracking com pruning.",
                                    "Compare tempo/execuções com e sem poda para n=8 cidades.",
                                    "Atualize melhor_custo dinamicamente durante a busca para poda mais agressiva."
                                  ],
                                  "verification": "Número de rotas avaliadas reduzido em pelo menos 20%; solução ótima idêntica à exaustiva.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Código anterior; biblioteca networkx para MST opcional.",
                                  "tips": "Comece com poda simples por custo_parcial; refine com relaxações.",
                                  "learningObjective": "Otimizar busca exaustiva com pruning para escalabilidade.",
                                  "commonMistakes": "Poda prematura levando a soluções subótimas; cálculo incorreto de lower bound."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, depurar e validar a solução completa",
                                  "subSteps": [
                                    "Teste com TSP de 3-5 cidades conhecidas (ex: distâncias euclidianas).",
                                    "Meça tempo de execução e compare com soluções ótimas pré-calculadas.",
                                    "Depure casos edge: n=2, matriz não simétrica.",
                                    "Gere relatório: rota ótima, custo, % de branches podados.",
                                    "Otimize código: vetorize somas se possível."
                                  ],
                                  "verification": "Solução ótima encontrada para todos testes; código roda <1s para n=6.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Datasets TSP pequenos (TSPLIB subset); timer Python.",
                                  "tips": "Use assert para validações automáticas de custos.",
                                  "learningObjective": "Garantir robustez e corretude da implementação.",
                                  "commonMistakes": "Overflow em fatoriais grandes; ignorar simetria da matriz."
                                }
                              ],
                              "practicalExample": "Para 4 cidades A(0), B(1), C(2), D(3) com matriz dist = [[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]], a solução ótima é A-B-D-C-A com custo 80. Gere permutações de [1,2,3], calcule custos, encontre min e aplique poda se custo parcial >80.",
                              "finalVerifications": [
                                "Solução ótima encontrada com custo correto para TSP de 4-6 cidades.",
                                "Número de permutações avaliadas reduzido pela poda em pelo menos 15%.",
                                "Código lida com matrizes assimétricas sem erros.",
                                "Tempo de execução <5s para n=7.",
                                "Relatório inclui rota, custo e estatísticas de poda.",
                                "Testes unitários passam para casos edge (n=2)."
                              ],
                              "assessmentCriteria": [
                                "Correção: Solução ótima idêntica à referência.",
                                "Eficiência: Poda funcional reduz avaliações significativamente.",
                                "Clareza: Código comentado com funções modulares.",
                                "Escalabilidade: Funciona para n até 8 com otimizações.",
                                "Robustez: Trata entradas inválidas (distâncias negativas).",
                                "Documentação: Explica lower bounds usados na poda."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e teoria de grafos (árvores geradoras mínimas).",
                                "Programação: Algoritmos recursivos e backtracking.",
                                "Otimização: Introdução a heurísticas como nearest neighbor.",
                                "Ciência de Dados: Análise de complexidade O((n-1)!)",
                                "Logística: Modelagem de problemas NP-difíceis."
                              ],
                              "realWorldApplication": "Roteirização de veículos de entrega (ex: Amazon/UPS otimiza rotas urbanas); planejamento de circuitos de torneios esportivos; sequenciamento de tarefas em manufatura para minimizar tempo total."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.4.2",
                        "name": "Geração de Combinações",
                        "description": "Métodos para gerar exaustivamente todas as combinações de k elementos de um conjunto de n, sem considerar ordem, usando recursão e iteração para enumeração eficiente em otimização.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.4.2.1",
                            "name": "Implementar backtracking recursivo para combinações",
                            "description": "Criar um algoritmo recursivo que seleciona k elementos de n sem repetição e sem ordem, utilizando índices crescentes para evitar permutações duplicadas, com representação em vetor de posições.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de backtracking e combinações",
                                  "subSteps": [
                                    "Defina o que é uma combinação: seleção de k elementos de n sem repetição e sem considerar ordem.",
                                    "Explique backtracking: técnica de busca exaustiva que constrói soluções candidatas e abandona caminhos inválidos.",
                                    "Entenda o uso de índices crescentes para evitar duplicatas: sempre escolha o próximo índice maior que o atual.",
                                    "Represente a solução em um vetor de posições (ex: vetor de tamanho k com índices selecionados).",
                                    "Estude o problema base: gerar C(n,k) combinações."
                                  ],
                                  "verification": "Resuma em suas palavras os conceitos e desenhe um diagrama de árvore de recursão para n=4, k=2.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Documentação de combinatória básica"
                                  ],
                                  "tips": "Visualize a árvore de decisão para entender por que índices crescentes evitam permutações.",
                                  "learningObjective": "Compreender os fundamentos teóricos de combinações e backtracking recursivo.",
                                  "commonMistakes": [
                                    "Confundir combinações com permutações",
                                    "Ignorar a restrição de índices crescentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a estrutura básica da função recursiva",
                                  "subSteps": [
                                    "Crie uma função recursiva com parâmetros: posição atual no vetor (start), índice atual (idx), n e k.",
                                    "Inicialize um vetor resultado de tamanho k.",
                                    "Defina a condição base: se idx == k, imprima ou armazene a combinação.",
                                    "Estruture os parâmetros globais: n, k, vetor resultado.",
                                    "Esboce o esqueleto da função em pseudocódigo."
                                  ],
                                  "verification": "Escreva o pseudocódigo da função recursiva e verifique se a condição base está correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Linguagem de programação (C ou Python)"
                                  ],
                                  "tips": "Use parâmetros passados por referência para o vetor em linguagens como C.",
                                  "learningObjective": "Estruturar a assinatura e lógica base de uma função recursiva para backtracking.",
                                  "commonMistakes": [
                                    "Esquecer de passar o vetor por referência",
                                    "Condição base incorreta (idx > k em vez de == k)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a lógica de escolha com índices crescentes",
                                  "subSteps": [
                                    "Adicione o loop for para escolher o próximo elemento: de start até n-1.",
                                    "Coloque o elemento atual no vetor[idx].",
                                    "Chame recursivamente com start = i+1 (índice crescente) e idx+1.",
                                    "Garanta que o loop respeite n-k+idx para otimização (corte de poda).",
                                    "Teste manualmente com n=3, k=2."
                                  ],
                                  "verification": "Execute o código parcial e verifique se constrói caminhos parciais corretamente sem duplicatas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para depuração"
                                  ],
                                  "tips": "Use print statements para rastrear chamadas recursivas e valores de start/idx.",
                                  "learningObjective": "Implementar a ramificação de escolha evitando duplicatas via índices crescentes.",
                                  "commonMistakes": [
                                    "Loop de i=0 a n (causa duplicatas)",
                                    "Não incrementar start=i+1"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar o backtracking e gerar soluções completas",
                                  "subSteps": [
                                    "Após a chamada recursiva, remova o elemento do vetor[idx] (backtrack).",
                                    "Implemente a coleta de soluções: armazene em uma lista ou imprima.",
                                    "Adicione otimização de poda: se (n - start) < (k - idx), retorne.",
                                    "Chame a função inicial com start=0, idx=0.",
                                    "Compile e execute para n=5, k=3."
                                  ],
                                  "verification": "Confirme que o vetor é restaurado após backtrack e todas combinações são geradas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Lista de combinações esperadas para verificação"
                                  ],
                                  "tips": "Sempre backtrack imediatamente após a recursão para reutilizar o vetor.",
                                  "learningObjective": "Completar o ciclo de backtracking e otimizar com poda.",
                                  "commonMistakes": [
                                    "Esquecer o backtrack (vetor não é restaurado)",
                                    "Poda incorreta"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, depurar e otimizar a implementação",
                                  "subSteps": [
                                    "Teste com casos: n=4 k=2 (esperado: 6), n=1 k=1, n=5 k=0.",
                                    "Meça tempo de execução e compare com C(n,k).",
                                    "Adicione contadores para validar número exato de combinações.",
                                    "Depure erros comuns como stack overflow ou duplicatas.",
                                    "Refatore para função reutilizável."
                                  ],
                                  "verification": "Gere combinações e compare manualmente com lista esperada; contador == C(n,k).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora combinatória online",
                                    "Ferramentas de profiling (opcional)"
                                  ],
                                  "tips": "Use asserts ou unit tests para automação.",
                                  "learningObjective": "Validar a corretude e eficiência da implementação completa.",
                                  "commonMistakes": [
                                    "Stack overflow por falta de poda",
                                    "Contagem errada de soluções"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente uma função que gere todas as combinações de 3 números do conjunto {1,2,3,4,5,6}, representando cada uma como um vetor [1,3,5], imprimindo-as no console. Exemplo de saída: [1,2,3], [1,2,4], ..., total de 20 combinações.",
                              "finalVerifications": [
                                "O código gera exatamente C(n,k) combinações sem duplicatas ou omissões.",
                                "Índices no vetor estão em ordem crescente.",
                                "Backtracking restaura o estado corretamente (sem resíduos).",
                                "Funciona para casos extremos: k=0, k=1, k=n.",
                                "Nenhuma permutação duplicada é produzida.",
                                "Execução termina sem stack overflow para n<=20."
                              ],
                              "assessmentCriteria": [
                                "Correção: Gera todas as combinações únicas e ordenadas.",
                                "Eficiência: Usa poda e O(C(n,k)) soluções sem redundâncias.",
                                "Clareza: Código legível com comentários e nomes descritivos.",
                                "Robustez: Trata casos edge sem crashes.",
                                "Otimização: Implementa corte de poda (n-start < k-idx).",
                                "Documentação: Explica lógica recursiva."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria combinatória e binômio de Newton.",
                                "Algoritmos: Busca exaustiva e otimização.",
                                "Programação: Recursão, estruturas de dados (vetores).",
                                "Lógica: Árvores de decisão e poda.",
                                "Inteligência Artificial: Backtracking em problemas CSP."
                              ],
                              "realWorldApplication": "Seleção de subconjuntos em sistemas de recomendação (ex: escolher 5 itens de 100 para um pacote), configuração de testes de software (combinações de parâmetros), geração de senhas ou chaves criptográficas, e problemas de otimização combinatorial em logística."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.2",
                            "name": "Gerar combinações usando abordagem iterativa com bits",
                            "description": "Utilizar máscaras de bits para enumerar todas as combinações de k em n, iterando de 0 a 2^n -1 e contando bits setados, otimizando para problemas de subconjuntos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a representação de subconjuntos com máscaras de bits",
                                  "subSteps": [
                                    "Explique como cada número binário de 0 a 2^n - 1 representa um subconjunto único dos elementos {0, 1, ..., n-1}.",
                                    "Bits setados (1) indicam elementos incluídos no subconjunto.",
                                    "Exemplo: Para n=3, 0b101 representa {0,2}.",
                                    "Pratique convertendo números decimais para binário e identificando posições de bits setados.",
                                    "Discuta por que isso gera todos os 2^n subconjuntos possíveis."
                                  ],
                                  "verification": "Descreva corretamente 3 exemplos de máscaras binárias para n=4 e liste os subconjuntos correspondentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (Python ou C++)",
                                    "Calculadora binária online",
                                    "Papel e caneta para desenhos binários"
                                  ],
                                  "tips": "Sempre comece contando do bit menos significativo (posição 0). Use funções como bin() em Python para visualizar.",
                                  "learningObjective": "Dominar como máscaras de bits codificam subconjuntos de forma exaustiva.",
                                  "commonMistakes": [
                                    "Confundir posições de bits (LSB vs MSB)",
                                    "Esquecer que o loop vai até (1<<n) - 1",
                                    "Ignorar subconjunto vazio (todos bits 0)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar iteração sobre todos os subconjuntos",
                                  "subSteps": [
                                    "Escreva um loop for i in range((1<<n)): para iterar de 0 a 2^n - 1.",
                                    "Para cada i, imprima sua representação binária para visualizar.",
                                    "Colete todos os subconjuntos em uma lista temporária.",
                                    "Teste com n=3 e verifique se gera 8 subconjuntos.",
                                    "Adicione uma função auxiliar para converter i em lista de posições setadas."
                                  ],
                                  "verification": "Execute o código e confirme que imprime exatamente 2^n subconjuntos únicos para n=4.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python IDE (VS Code ou Jupyter)",
                                    "Documentação de bitwise operators em Python"
                                  ],
                                  "tips": "Use 1 << n em vez de 2**n para precisão em linguagens com inteiros grandes.",
                                  "learningObjective": "Implementar loop exaustivo para gerar todos os subconjuntos via bits.",
                                  "commonMistakes": [
                                    "Loop até 1<<n em vez de (1<<n)-1",
                                    "Usar range(2**n) sem shift",
                                    "Overflow em linguagens com inteiros fixos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contar bits setados (popcount) para filtrar subconjuntos de tamanho k",
                                  "subSteps": [
                                    "Implemente uma função popcount(i) que conta bits 1 em i (use bin(i).count('1') ou loop while i: count += i&1; i>>=1).",
                                    "No loop principal, se popcount(i) == k, adicione o subconjunto à lista de combinações.",
                                    "Teste popcount para valores como 0b101 (deve retornar 2).",
                                    "Otimize evitando funções lentas para n grande (use lookup table se necessário).",
                                    "Verifique tempo de execução para n=20."
                                  ],
                                  "verification": "Para n=4, k=2, confirme que filtra exatamente C(4,2)=6 subconjuntos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do Step 2",
                                    "Ferramenta de profiling (timeit em Python)"
                                  ],
                                  "tips": "Para performance, prefira i.bit_count() no Python 3.10+ ou Kernighan’s algorithm: while i: i &= i-1; count +=1.",
                                  "learningObjective": "Filtrar subconjuntos por tamanho exato usando contagem de bits.",
                                  "commonMistakes": [
                                    "Contar bits errados (incluir leading zeros)",
                                    "Filtrar antes de extrair posições",
                                    "Erro em popcount para i=0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair posições dos bits setados para formar a combinação",
                                  "subSteps": [
                                    "Para cada i válido (popcount==k), extraia posições: pos = []; temp=i; j=0; while temp: if temp&1: pos.append(j); temp>>=1; j+=1.",
                                    "Ordene as posições se necessário (já saem em ordem crescente).",
                                    "Adicione à lista final de combinações.",
                                    "Teste com n=4, k=2: espere [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]].",
                                    "Compare com itertools.combinations para validação."
                                  ],
                                  "verification": "Gere combinações para n=5,k=3 e confirme igualdade com solução padrão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca itertools para validação",
                                    "Código dos steps anteriores"
                                  ],
                                  "tips": "Mantenha j incrementando fora do if para posições corretas.",
                                  "learningObjective": "Converter máscara de bits em lista ordenada de índices da combinação.",
                                  "commonMistakes": [
                                    "Posições em ordem decrescente",
                                    "Duplicar posições",
                                    "Pular bit 0"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar, testar e generalizar a solução",
                                  "subSteps": [
                                    "Adicione função completa def combinations(n, k): ... retornando lista de listas.",
                                    "Teste edge cases: k=0 (subconjunto vazio), k=n (um subconjunto), k> n (lista vazia).",
                                    "Meça complexidade: O(2^n * n) tempo, otimize popcount para O(1) médio.",
                                    "Discuta quando usar vs abordagens recursivas.",
                                    "Implemente em outra linguagem para prática."
                                  ],
                                  "verification": "Todos os testes passam e tempo <1s para n=20,k=10.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Unittests framework (pytest)",
                                    "Diferentes IDEs para C++/Java"
                                  ],
                                  "tips": "Use memoização de popcount para n<=64 com array pré-computado.",
                                  "learningObjective": "Criar solução robusta, otimizada e testada para geração de combinações.",
                                  "commonMistakes": [
                                    "Não tratar k=0",
                                    "Assumir n pequeno sem otimização",
                                    "Retornar permutações em vez de combinações"
                                  ]
                                }
                              ],
                              "practicalExample": "Gerar todas as combinações de k=2 elementos de n=4 (conjunto {0,1,2,3}). Saída esperada: [[0,1], [0,2], [0,3], [1,2], [1,3], [2,3]]. Código Python: for i in range(1<<4): if bin(i).count('1')==2: comb=[]; j=0; temp=i; while temp: if temp&1: comb.append(j); temp>>=1; j+=1; print(comb).",
                              "finalVerifications": [
                                "Lista contém exatamente C(n,k) combinações únicas e ordenadas.",
                                "Cada combinação tem exatamente k elementos distintos entre 0 e n-1.",
                                "Funciona para edge cases: k=0, k=1, k=n, k>n.",
                                "Eficiência: executa em tempo razoável para n<=25.",
                                "Sem duplicatas ou omissões comparado a itertools.combinations.",
                                "Extração de posições correta sem erros de indexação."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todas as combinações geradas sem erros ou duplicatas (peso 40%).",
                                "Eficiência: Popcount otimizado e loop limpo (peso 20%).",
                                "Robustez: Trata todos edge cases e n,k variados (peso 20%).",
                                "Clareza: Código comentado com extração de posições legível (peso 10%).",
                                "Performance: Medida e dentro de limites esperados (peso 10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória (C(n,k) = 2^n filtrado por popcount).",
                                "Programação: Operações bitwise, loops eficientes, algoritmos exaustivos.",
                                "Ciência da Computação: Enumeração em problemas NP-completos como subconjunto sum.",
                                "Engenharia: Otimização em hardware (máscaras em FPGA/ASIC).",
                                "Estatística: Seleção de features em machine learning."
                              ],
                              "realWorldApplication": "Usado em algoritmos de força bruta para problemas de otimização combinatorial como 'knapsack' ou 'feature selection' em ML, onde se enumeram subconjuntos de tamanho fixo; em criptografia para testar chaves; e em jogos para gerar níveis procedurais com escolhas fixas de itens."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.3",
                            "name": "Aplicar combinações em problemas de otimização exaustiva",
                            "description": "Usar geração de combinações para resolver problemas como seleção de subconjuntos ótimos em knapsack 0/1 exaustivo ou emparelhamentos, avaliando somas e identificando máxima/mínima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Combinações e Otimização Exaustiva",
                                  "subSteps": [
                                    "Estude a definição de combinações: seleção de k itens de n sem ordem.",
                                    "Revise otimização exaustiva: testar todas as possibilidades para encontrar o ótimo.",
                                    "Analise exemplos simples, como escolher 2 frutas de 4 tipos para máximo sabor.",
                                    "Diferencie combinações de permutações e subconjuntos.",
                                    "Entenda problemas como Knapsack 0/1: maximizar valor com restrição de peso."
                                  ],
                                  "verification": "Explique em suas palavras como combinações resolvem otimização exaustiva, com um exemplo escrito.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Vídeos tutoriais sobre combinatória (YouTube/Khan Academy)",
                                    "Documentação de algoritmos exaustivos"
                                  ],
                                  "tips": "Use diagramas de árvore para visualizar todas as combinações possíveis.",
                                  "learningObjective": "Dominar os conceitos teóricos de combinações e sua aplicação em buscas exaustivas.",
                                  "commonMistakes": "Confundir combinações (sem ordem) com permutações (com ordem) ou ignorar restrições do problema."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Algoritmo de Geração de Combinações",
                                  "subSteps": [
                                    "Escolha um método: recursivo, bitmasks ou itertools em Python.",
                                    "Implemente função recursiva para gerar combinações de tamanho k de n elementos.",
                                    "Teste com n=4, k=2: verifique se gera todas as 6 combinações.",
                                    "Adapte para gerar todos subconjuntos (k de 0 a n).",
                                    "Otimize para evitar duplicatas e garantir eficiência básica."
                                  ],
                                  "verification": "Execute o código e liste todas as combinações geradas para um conjunto de entrada pequeno; compare com cálculo manual.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Python instalado",
                                    "Biblioteca itertools (opcional)"
                                  ],
                                  "tips": "Comece com bitmasks para simplicidade: para cada máscara binária, selecione itens onde bit=1.",
                                  "learningObjective": "Desenvolver algoritmo funcional para gerar combinações programaticamente.",
                                  "commonMistakes": "Gerar permutações em vez de combinações ou exceder limites de recursão em n grande."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Modelar e Formular Problema de Otimização Exaustiva",
                                  "subSteps": [
                                    "Defina o problema Knapsack 0/1: itens com peso e valor, capacidade W, maximizar valor total.",
                                    "Formalize função objetivo: para cada combinação, calcule soma de valores se soma pesos <= W.",
                                    "Identifique variáveis: lista de itens, W, rastrear melhor solução.",
                                    "Crie pseudocódigo: gerar combinações → avaliar → atualizar máximo.",
                                    "Teste manualmente com 3 itens para validar modelo."
                                  ],
                                  "verification": "Escreva pseudocódigo completo e resolva manualmente um Knapsack pequeno, anotando o ótimo.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Papel para cálculos manuais",
                                    "Planilha Excel para simulações iniciais"
                                  ],
                                  "tips": "Sempre verifique viabilidade (peso total <= W) antes de calcular valor.",
                                  "learningObjective": "Capacitar modelagem precisa de problemas de otimização usando combinações.",
                                  "commonMistakes": "Esquecer itens com peso zero ou não considerar o subconjunto vazio."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Avaliar Solução Completa",
                                  "subSteps": [
                                    "Integre geração de combinações com avaliação no código.",
                                    "Implemente loop: para cada combinação, calcule métricas e rastreie melhor.",
                                    "Adicione logs para mostrar progresso e soluções candidatas.",
                                    "Teste com dataset: itens=[(1,10),(2,20),(3,30),(4,40)], W=5.",
                                    "Analise tempo de execução e resultados."
                                  ],
                                  "verification": "Execute o programa, confirme que encontra valor máximo 50 (itens 2 e 3) e liste a combinação ótima.",
                                  "estimatedTime": "1 hora e 15 minutos",
                                  "materials": [
                                    "Python/Jupyter",
                                    "Conjunto de teste de dados",
                                    "Cronômetro para medir tempo"
                                  ],
                                  "tips": "Use tuplas (peso, valor) para itens e armazene melhor_solucao como lista de índices.",
                                  "learningObjective": "Construir e validar algoritmo completo de otimização exaustiva.",
                                  "commonMistakes": "Não inicializar variáveis de máximo corretamente ou pular combinações inválidas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Explorar Extensões",
                                  "subSteps": [
                                    "Compare solução exaustiva com ótima conhecida (DP para Knapsack).",
                                    "Meça complexidade: O(2^n) e discuta limites (n<=20 viável).",
                                    "Adapte para minimização (ex: menor custo).",
                                    "Experimente emparelhamentos: combinações para matching ótimo.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Gere relatório com tempo, solução e comparação com método alternativo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "Implementação DP simples para comparação"
                                  ],
                                  "tips": "Para n grande, note que exaustivo é impraticável, motivando heurísticas.",
                                  "learningObjective": "Avaliar limitações e conexões com algoritmos avançados.",
                                  "commonMistakes": "Ignorar overhead de tempo ou afirmar exaustivo como sempre ótimo sem prova."
                                }
                              ],
                              "practicalExample": "Problema Knapsack 0/1: 4 itens com pesos [1,3,4,2] e valores [10,40,50,30], capacidade W=5. Gere todas combinações, encontre subconjunto {2,4} (pesos 3+2=5, valor 40+30=70) como ótimo.",
                              "finalVerifications": [
                                "Gera corretamente todas as combinações para n=5, k=3.",
                                "Resolve Knapsack exaustivo com n=10 em tempo razoável (<1s).",
                                "Identifica manualmente ótima em problema pequeno sem código.",
                                "Explica por que solução é ótima (todas alternativas avaliadas).",
                                "Adapta código para minimizar soma em vez de maximizar.",
                                "Discute quando exaustivo falha (n>25)."
                              ],
                              "assessmentCriteria": [
                                "Correção: Solução ótima encontrada em todos testes.",
                                "Eficiência: Código gera combinações sem duplicatas ou omissões.",
                                "Clareza: Código comentado e legível.",
                                "Generalidade: Funciona para diferentes k e problemas similares.",
                                "Análise: Relatório inclui tempo, complexidade e limitações.",
                                "Criatividade: Extensões como logging ou visualização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e Teoria de Conjuntos.",
                                "Programação: Algoritmos Recursivos e Estruturas de Dados.",
                                "Pesquisa Operacional: Otimização Combinatória.",
                                "Inteligência Artificial: Busca Exaustiva em Espaços de Estados.",
                                "Economia: Alocação de Recursos Limitados."
                              ],
                              "realWorldApplication": "Seleção de investimentos em portfólio com restrições de risco (maximizar retorno); planejamento logístico de cargas em aviões (maximizar lucro com limite de peso); configuração ótima de máquinas em manufatura (selecionar ferramentas para job mínimo custo)."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.4.2.4",
                            "name": "Otimizar geração com poda em backtracking",
                            "description": "Incorporar condições de poda (branch and bound) durante a geração de combinações para descartar ramos infactíveis precocemente, reduzindo o espaço de busca em problemas de otimização.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar backtracking básico para geração de combinações",
                                  "subSteps": [
                                    "Implemente uma função recursiva básica para gerar todas as combinações possíveis de k elementos de um conjunto n.",
                                    "Entenda a estrutura: escolha (choose), explore (explore), desfaça (backtrack).",
                                    "Teste com um conjunto pequeno (ex: [1,2,3,4] k=2) e liste todas as combinações geradas.",
                                    "Meça o tempo de execução sem otimizações.",
                                    "Analise o espaço de busca exponencial gerado."
                                  ],
                                  "verification": "Execute o código e confirme que gera todas as combinações corretas sem duplicatas ou omissões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python ou C++)",
                                    "Conjunto de teste pequeno"
                                  ],
                                  "tips": "Use print statements para visualizar a pilha de recursão e entender o fluxo.",
                                  "learningObjective": "Dominar a geração exaustiva de combinações via backtracking.",
                                  "commonMistakes": [
                                    "Índices off-by-one no loop de escolha",
                                    "Não desfazer a escolha corretamente",
                                    "Gerar permutações em vez de combinações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir conceitos de poda e branch and bound",
                                  "subSteps": [
                                    "Estude o princípio de poda: descartar ramos da árvore de busca que não levam a soluções viáveis.",
                                    "Aprenda branch and bound: use limites superior/inferior para guiar a poda em otimização.",
                                    "Identifique pontos de poda comuns: restrições de viabilidade (ex: soma > limite) ou bounding (ex: custo atual > melhor solução).",
                                    "Desenhe a árvore de busca de um exemplo simples mostrando ramos podados.",
                                    "Compare árvores com e sem poda visualmente."
                                  ],
                                  "verification": "Crie um diagrama da árvore de busca com podas marcadas e explique por que cada ramo foi descartado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Artigos ou vídeos sobre branch and bound"
                                  ],
                                  "tips": "Comece com problemas unidimensionais como subset sum para simplicidade.",
                                  "learningObjective": "Compreender como poda reduz o espaço de busca sem perder soluções ótimas.",
                                  "commonMistakes": [
                                    "Poda excessiva que elimina soluções viáveis",
                                    "Confundir poda de viabilidade com bounding",
                                    "Não considerar relaxações para bounds"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar condições de poda no backtracking para combinações",
                                  "subSteps": [
                                    "Modifique a função recursiva adicionando verificações de poda antes da recursão.",
                                    "Implemente poda de viabilidade: ex, se soma parcial > limite, pare.",
                                    "Adicione bounding: calcule bound superior restante e compare com melhor solução atual.",
                                    "Atualize uma variável global para a melhor solução encontrada até o momento.",
                                    "Teste incrementalmente com logs para contar ramos podados."
                                  ],
                                  "verification": "Compare contadores de nós visitados com e sem poda; deve haver redução significativa.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Problema de teste: knapsack 0/1 simplificado com combinações"
                                  ],
                                  "tips": "Use uma heurística simples para bound inicial (ex: soma gulosa).",
                                  "learningObjective": "Implementar poda integrada que descarta ramos infactíveis precocemente.",
                                  "commonMistakes": [
                                    "Atualizar bound incorretamente",
                                    "Poda só no final da folha em vez de intermediário",
                                    "Variáveis globais não thread-safe em testes paralelos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, otimizar e validar a implementação",
                                  "subSteps": [
                                    "Aplique em um problema real: maximize valor com peso <= W em combinações.",
                                    "Meça performance: tempo, nós visitados, com/sem poda em instâncias crescentes.",
                                    "Otimize: ordene elementos por densidade valor/peso para poda mais efetiva.",
                                    "Valide correção: compare solução ótima com exaustiva em casos pequenos.",
                                    "Documente métricas e insights sobre quando poda é mais impactante."
                                  ],
                                  "verification": "Solução ótima encontrada com redução de pelo menos 50% no tempo para n=20.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Datasets de teste escaláveis",
                                    "Ferramenta de profiling (timeit em Python)"
                                  ],
                                  "tips": "Ordene itens decrescente por valor/peso para melhor bounding.",
                                  "learningObjective": "Avaliar e refinar algoritmo otimizado em cenários práticos.",
                                  "commonMistakes": [
                                    "Não ordenar itens adequadamente",
                                    "Ignorar overhead da verificação de poda",
                                    "Erros de arredondamento em bounds float"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de Knapsack 0/1, gere combinações de itens para maximizar valor sem exceder peso W. Com poda: ao adicionar um item, se peso parcial + peso restante mínimo > W, poda; se valor parcial + valor bound superior <= melhor atual, poda. Exemplo: itens=[(peso=2,val=3),(3,4),(4,5)], W=5 → poda ramos que somam >5 cedo.",
                              "finalVerifications": [
                                "Algoritmo gera apenas combinações viáveis e encontra solução ótima.",
                                "Número de nós visitados reduzido em >50% vs backtracking puro.",
                                "Código passa em testes unitários para casos pequenos e médios.",
                                "Logs mostram podas efetivas com razões claras.",
                                "Performance escalável para n até 25 itens.",
                                "Correção mantida: mesma solução ótima que exaustiva."
                              ],
                              "assessmentCriteria": [
                                "Precisão: solução ótima correta em todos os testes.",
                                "Eficiência: redução mensurável no espaço/tempo de busca.",
                                "Robustez: lida com casos edge (W=0, itens vazios).",
                                "Clareza: código comentado com explicações de poda.",
                                "Otimização: uso de ordenação e bounds tight.",
                                "Documentação: relatório com métricas comparativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização combinatória e programação dinâmica.",
                                "Inteligência Artificial: Algoritmos de busca heurística e A*.",
                                "Engenharia de Software: Análise de complexidade e profiling.",
                                "Economia: Otimização de recursos limitados (knapsack em finanças)."
                              ],
                              "realWorldApplication": "Em logística para selecionar combinações ótimas de entregas em veículos com capacidade limitada, reduzindo tempo de planejamento de horas para minutos em sistemas de roteirização dinâmica."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.2.5",
                    "name": "Análise de Complexidade e Limitações",
                    "description": "Complexidade exponencial típica e condições de aplicabilidade para instâncias de tamanho limitado.",
                    "individualConcepts": [
                      {
                        "id": "10.1.2.5.1",
                        "name": "Complexidade Temporal dos Métodos Exaustivos",
                        "description": "Análise da complexidade temporal típica dos métodos exaustivos, geralmente exponencial em O(2^n) ou similar, dependendo da estrutura do problema.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.1.1",
                            "name": "Identificar a complexidade temporal padrão",
                            "description": "Reconhecer que métodos exaustivos, como busca exaustiva ou backtracking simples, apresentam complexidade exponencial O(2^n) para problemas com n variáveis ou estados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos dos Métodos Exaustivos",
                                  "subSteps": [
                                    "Defina métodos exaustivos como abordagens que exploram todas as combinações possíveis de soluções.",
                                    "Diferencie busca exaustiva (verificação de todas as possibilidades) de backtracking (construção recursiva com poda parcial).",
                                    "Revise noções básicas de notação Big O, focando em complexidade temporal.",
                                    "Identifique problemas típicos: subconjuntos, permutações e combinações."
                                  ],
                                  "verification": "Escreva definições curtas e exemplos de problemas para cada método.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre algoritmos",
                                    "Folha de papel ou editor de texto"
                                  ],
                                  "tips": "Use analogias como 'provar todas as chaves em uma fechadura' para busca exaustiva.",
                                  "learningObjective": "Entender o que caracteriza métodos exaustivos e sua relação com exploração completa de espaços de estados.",
                                  "commonMistakes": "Confundir exaustivo com heurístico; ignorar que backtracking ainda é exaustivo em pior caso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Complexidade da Busca Exaustiva",
                                  "subSteps": [
                                    "Para um problema com n elementos, calcule o número de subconjuntos: 2^n.",
                                    "Some o tempo por verificação: O(2^n * tempo_por_verificação).",
                                    "Implemente um exemplo simples: gerar todos os subconjuntos de um array de tamanho n.",
                                    "Meça o tempo de execução para n=10, 20 e observe o crescimento exponencial."
                                  ],
                                  "verification": "Gere e liste todos os subconjuntos para n=3 e confirme 8 resultados; plote tempo vs n.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Linguagem de programação (Python/Java)",
                                    "Relógio ou profiler de código"
                                  ],
                                  "tips": "Comece com n pequeno para evitar lentidão; use print para contar iterações.",
                                  "learningObjective": "Calcular e visualizar por que busca exaustiva leva O(2^n) tempo.",
                                  "commonMistakes": "Esquecer custo da verificação por subconjunto; confundir com O(n!)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Complexidade do Backtracking Simples",
                                  "subSteps": [
                                    "Entenda backtracking como recursão que constrói soluções parciais e retrocede.",
                                    "Para problemas como N-rainhas ou sudoku, note que sem poda efetiva, explora ~2^n estados.",
                                    "Implemente backtracking sem poda para permutações e conte chamadas recursivas.",
                                    "Compare contagem de estados com 2^n."
                                  ],
                                  "verification": "Execute código e verifique que número de folhas na árvore de recursão aproxima 2^n.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código-fonte de backtracking básico",
                                    "Ferramenta de depuração ou contador de chamadas"
                                  ],
                                  "tips": "Adicione contadores globais para rastrear explorações; visualize árvore de recursão manualmente.",
                                  "learningObjective": "Reconhecer que backtracking simples herda complexidade exponencial de árvore binária completa.",
                                  "commonMistakes": "Assumir poda sempre reduz para polinomial; ignorar pior caso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar e Identificar o Padrão O(2^n)",
                                  "subSteps": [
                                    "Resuma: ambos métodos constroem árvore de decisão com 2 escolhas por nível (incluir/não incluir).",
                                    "Profundidade n leva a 2^n folhas.",
                                    "Discuta limitações: impraticável para n>30-40.",
                                    "Crie tabela comparativa: método, pior caso, exemplo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que é O(2^n) para n variáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela em papel ou planilha"
                                  ],
                                  "tips": "Pense em termos de 'árvore binária completa' para intuição visual.",
                                  "learningObjective": "Identificar o padrão exponencial comum a métodos exaustivos.",
                                  "commonMistakes": "Confundir com O(n^2); superestimar poda em backtracking simples."
                                }
                              ],
                              "practicalExample": "Implemente busca exaustiva para encontrar subconjuntos que somam um target (subconjunto sum). Para n=25, observe que leva segundos/minutos, confirmando explosão em 2^25 ~ 33 milhões de verificações.",
                              "finalVerifications": [
                                "Explica corretamente por que métodos exaustivos têm O(2^n).",
                                "Calcula número de operações para n dado.",
                                "Distingue de métodos polinomiais.",
                                "Identifica exemplos reais de falha prática por n grande.",
                                "Visualiza árvore de decisão com 2^n folhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de 2^n (altura n, ramificação 2).",
                                "Uso correto de exemplos concretos.",
                                "Identificação de pior caso vs médio.",
                                "Clareza na explicação oral/escrita.",
                                "Aplicação a novos problemas semelhantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Séries geométricas e exponenciais (2^n).",
                                "Física: Simulações Monte Carlo exaustivas em espaços de fase.",
                                "Economia: Otimização combinatorial em portfólios (limites computacionais).",
                                "Biologia: Enumeração exaustiva em genômica (sequências)."
                              ],
                              "realWorldApplication": "Em criptografia, quebra de chaves curtas por força bruta (2^56 para DES antigo) mostra por que chaves longas são seguras; em IA, limita solvers exatos para SAT em instâncias reais, levando a heurísticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.2",
                            "name": "Calcular complexidade para backtracking",
                            "description": "Calcular a complexidade temporal de algoritmos de backtracking, considerando o número de folhas e nós internos na árvore de decisão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura da Árvore de Decisão em Backtracking",
                                  "subSteps": [
                                    "Defina backtracking como uma estratégia de busca que explora todas as possibilidades construindo soluções parciais e retrocedendo quando necessário.",
                                    "Descreva a árvore de decisão: raiz representa estado inicial, cada nível uma escolha, ramos representam decisões possíveis.",
                                    "Identifique folhas como nós terminais onde solução completa é avaliada (sucesso ou falha).",
                                    "Diferencie nós internos como pontos de ramificação onde escolhas são feitas e expandidas.",
                                    "Explique que a complexidade temporal é proporcional ao número total de nós visitados no pior caso."
                                  ],
                                  "verification": "Desenhe manualmente a árvore de decisão para um problema simples como gerar permutações de 2 elementos e rotule folhas e nós internos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Diagrama de exemplo de backtracking impresso ou digital"
                                  ],
                                  "tips": "Visualize a árvore como uma representação explícita da recursão para facilitar a contagem.",
                                  "learningObjective": "Dominar a representação gráfica da exploração em backtracking.",
                                  "commonMistakes": [
                                    "Confundir nós podados com folhas.",
                                    "Ignorar que podas afetam apenas casos médios, não o pior caso."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Contar Folhas e Nós Internos",
                                  "subSteps": [
                                    "Para um problema dado, determine o número de folhas: produto das ramificações em cada nível até a profundidade máxima.",
                                    "Conte nós internos: soma de 1 (raiz) + nós no nível 1 + ... + nós no penúltimo nível.",
                                    "Use fórmula recursiva: T(n) = 1 + soma de T(subproblemas) para nós expandidos.",
                                    "Calcule total de nós: folhas + nós internos.",
                                    "Verifique com exemplo pequeno: liste todos os nós explicitamente."
                                  ],
                                  "verification": "Conte manualmente folhas e nós internos para uma árvore de backtracking de permutações de 3 elementos e some o total.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Planilha para contagem (Excel ou papel quadriculado)"
                                  ],
                                  "tips": "Comece com problemas pequenos (n=2 ou 3) para validar contagens antes de generalizar.",
                                  "learningObjective": "Capacitar contagem precisa de elementos na árvore de decisão.",
                                  "commonMistakes": [
                                    "Contar apenas folhas válidas, ignorando falhas.",
                                    "Duplicar contagem em ramos simétricos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formular a Complexidade Temporal Baseada na Árvore",
                                  "subSteps": [
                                    "Estabeleça que tempo por nó é O(1) para análise assintótica, então T = O(total de nós).",
                                    "Derive recorrência: para backtracking com k escolhas por nível e profundidade n, folhas ≈ k^n.",
                                    "Some nós internos: aproximadamente folhas / (k-1) em árvores balanceadas.",
                                    "Expresse complexidade como O(b^d) onde b é fator de ramificação, d profundidade.",
                                    "Compare com exponential: confirme T ∈ Θ(φ^n) para casos como N-Queens."
                                  ],
                                  "verification": "Escreva a recorrência T(n) para Subset Sum e resolva para n=4, confirmando com contagem manual.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Livro de algoritmos ou referência online sobre recorrências",
                                    "Ferramenta de desenho de árvores (Draw.io)"
                                  ],
                                  "tips": "Use notação big-O focando no pior caso, assumindo sem podas significativas.",
                                  "learningObjective": "Traduzir estrutura da árvore em fórmula de complexidade assintótica.",
                                  "commonMistakes": [
                                    "Confundir complexidade com número de soluções ótimas.",
                                    "Esquecer custo de verificação nas folhas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Analisar Complexidade em um Exemplo Completo",
                                  "subSteps": [
                                    "Escolha um problema: desenhe árvore para N-Queens n=3 ou Subset Sum com soma=5 e números {1,2,3}.",
                                    "Conte folhas e nós internos explicitamente.",
                                    "Calcule total de nós e estime T(n) = O(2^n) ou similar.",
                                    "Discuta limitações: quando backtracking é viável (n pequeno).",
                                    "Compare com bounds inferiores para validar."
                                  ],
                                  "verification": "Produza um relatório curto com diagrama, contagens e fórmula O() para o exemplo escolhido.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Código Python simples de backtracking com contadores de nós",
                                    "Papel para diagrama final"
                                  ],
                                  "tips": "Implemente contadores no código para validar contagem manual.",
                                  "learningObjective": "Integrar contagem e formulação em análise prática de complexidade.",
                                  "commonMistakes": [
                                    "Subestimar nós internos em árvores desbalanceadas.",
                                    "Ignorar constantes ocultas no O()."
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de Subset Sum com números {1,2,3} e target=5: a árvore tem ramificação 2 (incluir/excluir) por nível até 3. Folhas: 8 (2^3), nós internos: 1 (raiz) + 2 (n1) + 4 (n2) = 7, total nós=15, complexidade O(2^n) onde n=3.",
                              "finalVerifications": [
                                "Desenhar corretamente árvore de decisão para problema pequeno.",
                                "Contar precisamente folhas e nós internos.",
                                "Formular recorrência T(n) correta.",
                                "Calcular total de nós e big-O assintótico.",
                                "Identificar quando análise considera pior caso.",
                                "Comparar com exemplo conhecido como N-Queens."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de elementos da árvore (100% para n<=4).",
                                "Correção da recorrência e solução assintótica.",
                                "Clareza no diagrama e explicações.",
                                "Identificação de erros comuns e podas.",
                                "Aplicação consistente a novos problemas.",
                                "Uso apropriado de notação big-O/Θ."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise combinatoria e árvores de recorrência.",
                                "Programação: Implementação recursiva e profiling de código.",
                                "Otimização: Relação com branch-and-bound e heurísticas.",
                                "Teoria da Computação: Classes de complexidade NP.",
                                "Engenharia de Software: Análise de performance em solvers."
                              ],
                              "realWorldApplication": "Em desenvolvimento de solvers para problemas NP-difíceis como planejamento de rotas em logística (TSP variants), configuração de redes, ou jogos como Sudoku, onde entender a complexidade do backtracking guia decisões sobre escalabilidade e necessidade de otimizações como podas ou aproximações."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.1.3",
                            "name": "Analisar impacto do branching factor",
                            "description": "Determinar como o fator de ramificação afeta a complexidade exponencial, usando fórmulas como O(b^d) onde b é o branching factor e d a profundidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Branching Factor",
                                  "subSteps": [
                                    "Defina branching factor como o número médio de filhos por nó em uma árvore de busca.",
                                    "Identifique exemplos em métodos exaustivos, como backtracking em problemas de permutação.",
                                    "Desenhe uma árvore simples com branching factor constante e variável.",
                                    "Compare árvores com diferentes branching factors (ex: b=2 vs b=4).",
                                    "Explique como o branching factor modela o espaço de busca em algoritmos exaustivos."
                                  ],
                                  "verification": "Desenhe uma árvore de busca com b=3 e d=3, contando o número de folhas corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Ferramenta online de visualização de árvores (ex: draw.io)",
                                    "Vídeo sobre backtracking"
                                  ],
                                  "tips": "Sempre comece com diagramas visuais para internalizar o conceito; evite abstrações iniciais.",
                                  "learningObjective": "Definir branching factor e ilustrar seu papel em árvores de busca exaustivas.",
                                  "commonMistakes": [
                                    "Confundir branching factor com número total de nós",
                                    "Assumir que é sempre constante em problemas reais",
                                    "Ignorar variações por nível da árvore"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Fórmula de Complexidade O(b^d)",
                                  "subSteps": [
                                    "Estude a notação Big-O para complexidade temporal em buscas exaustivas.",
                                    "Derive intuitivamente por que o número de nós é aproximadamente b^d.",
                                    "Memorize e escreva a fórmula: tempo ~ O(b^d), onde b=branching factor, d=profundidade máxima.",
                                    "Discuta por que é exponencial: cada nível multiplica por b.",
                                    "Relacione com limitações computacionais (ex: tempo explode com d)."
                                  ],
                                  "verification": "Escreva e explique a fórmula O(b^d) com um exemplo numérico simples (b=2, d=5).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de fórmulas de complexidade",
                                    "Calculadora ou Python para potências",
                                    "Artigo sobre complexidade de backtracking"
                                  ],
                                  "tips": "Pense em termos de 'explosão' de nós; calcule manualmente para pequenos valores para sentir o crescimento.",
                                  "learningObjective": "Explicar e derivar a fórmula de complexidade exponencial baseada no branching factor.",
                                  "commonMistakes": [
                                    "Confundir O(b^d) com O(b*d) linear",
                                    "Esquecer que d inclui níveis intermediários",
                                    "Subestimar o impacto para b>1 e d>20"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Comparar Exemplos Numéricos",
                                  "subSteps": [
                                    "Calcule o número de nós para cenários: b=2/d=10, b=3/d=8, b=10/d=4.",
                                    "Use uma tabela para comparar tempos assumindo 1ms por nó.",
                                    "Implemente uma função simples em Python para computar b^d.",
                                    "Analise quando o tempo excede limites práticos (ex: 1 segundo = 10^8 operações).",
                                    "Gráfico de log(b^d) vs d para visualizar crescimento."
                                  ],
                                  "verification": "Produza uma tabela com 3 cálculos corretos e interpretação do impacto no tempo de execução.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Calculadora ou Google Sheets para tabelas",
                                    "Python/Jupyter para simulação",
                                    "Gráfico de crescimento exponencial online"
                                  ],
                                  "tips": "Use logaritmos para valores grandes: log10(b^d) = d*log10(b) para estimar dígitos.",
                                  "learningObjective": "Aplicar a fórmula em cálculos quantitativos e comparar impactos variáveis de b e d.",
                                  "commonMistakes": [
                                    "Erros de cálculo em potências grandes (use ferramentas)",
                                    "Ignorar overhead além de b^d",
                                    "Confundir nós gerados com soluções encontradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Impacto e Limitações Práticas",
                                  "subSteps": [
                                    "Discuta como alto b força redução via poda ou heurísticas.",
                                    "Avalie trade-offs: aumentar d vs reduzir b em problemas reais.",
                                    "Simule redução de b em backtracking (ex: constraints precoces).",
                                    "Preveja cenários onde métodos exaustivos falham (ex: xadrez, b~35).",
                                    "Conclua com quando evitar exaustivos baseados em b e d."
                                  ],
                                  "verification": "Escreva um parágrafo analisando por que b=4/d=15 é impraticável e sugira alternativas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplos de problemas NP-completos",
                                    "Pseudocódigo de backtracking com poda",
                                    "Leitura sobre heurísticas em IA"
                                  ],
                                  "tips": "Relacione sempre a problemas concretos para ancorar a análise abstrata.",
                                  "learningObjective": "Interpretar qualitativamente e quantitativamente o impacto do branching factor em viabilidade.",
                                  "commonMistakes": [
                                    "Superestimar poda resolvendo exponencialidade",
                                    "Ignorar que b efetivo pode ser reduzido mas ainda exponencial",
                                    "Focar só em teoria sem ligar a prática"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar e Aplicar em um Caso de Estudo",
                                  "subSteps": [
                                    "Escolha um problema (ex: N-Queens) e estime b e d.",
                                    "Calcule complexidade e proponha otimizações para reduzir b.",
                                    "Compare com variantes (ex: adicionar simetria para baixar b).",
                                    "Documente conclusões em um relatório curto.",
                                    "Teste com código simples para validar estimativas."
                                  ],
                                  "verification": "Relatório de 1 página com cálculos, análise e recomendações corretas.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Código de exemplo N-Queens em Python",
                                    "Ferramentas de profiling de tempo"
                                  ],
                                  "tips": "Valide estimativas com execuções reais para calibração.",
                                  "learningObjective": "Integrar todos os conceitos em uma análise completa de um problema real.",
                                  "commonMistakes": [
                                    "Estimativas irreais sem validação",
                                    "Esquecer variações dinâmicas de b",
                                    "Não quantificar ganhos de otimizações"
                                  ]
                                }
                              ],
                              "practicalExample": "Em backtracking para o problema das N-Rainhas com N=8: branching factor inicial ~N, profundidade N; calcular O(8^8) ~16 milhões de nós, mostrando por que precisa de poda para ser viável (b efetivo reduz para ~2-3). Implemente e meça tempo real.",
                              "finalVerifications": [
                                "Calcular corretamente O(b^d) para 3 pares (b,d) dados.",
                                "Explicar em palavras o porquê do crescimento exponencial.",
                                "Identificar quando b^d > 10^9 é impraticável.",
                                "Propor pelo menos 2 maneiras de reduzir b efetivo.",
                                "Analisar um exemplo real com números precisos.",
                                "Gráfico ou tabela mostrando impacto de +1 em b ou d."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nos cálculos de b^d (100% correto).",
                                "Profundidade na interpretação qualitativa do impacto.",
                                "Criatividade em exemplos e conexões práticas.",
                                "Clareza na comunicação via diagramas/tabelas.",
                                "Identificação correta de limitações e alternativas.",
                                "Consistência em verificações e substeps completos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções exponenciais e logaritmos.",
                                "Inteligência Artificial: Algoritmos de busca e heurísticas.",
                                "Otimização: Problemas combinatoriais NP-difíceis.",
                                "Ciência da Computação: Análise assintótica Big-O.",
                                "Engenharia de Software: Escalabilidade e profiling."
                              ],
                              "realWorldApplication": "Em desenvolvimento de IA para jogos como xadrez (b~35, d~40 inviável sem alpha-beta que reduz b efetivo), planejamento logístico (rotas com b alto por opções), ou cibersegurança (busca de senhas com b=95 por caractere), guiando escolha entre exaustivo vs aproximado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.2",
                        "name": "Complexidade Espacial Associada",
                        "description": "Exame da complexidade espacial dos métodos exaustivos, frequentemente linear ou polinomial em relação à entrada, mas limitada pela recursão profunda.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.2.1",
                            "name": "Avaliar uso de memória em recursão",
                            "description": "Calcular o espaço de pilha necessário em implementações recursivas de métodos exaustivos, tipicamente O(n) para profundidade máxima n.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a pilha de chamadas em funções recursivas",
                                  "subSteps": [
                                    "Explique o que é uma pilha de chamadas (call stack) e como ela funciona em linguagens de programação.",
                                    "Desenhe um diagrama simples de uma recursão básica, como fatorial, mostrando frames de pilha sendo empilhados e desempilhados.",
                                    "Identifique os componentes típicos de um frame de pilha: endereço de retorno, parâmetros, variáveis locais e registradores.",
                                    "Discuta por que a recursão usa pilha em vez de heap para gerenciamento de estado.",
                                    "Compare recursão com iteração em termos de uso de memória."
                                  ],
                                  "verification": "Desenhe e explique um diagrama de pilha para recursão de fatorial(n=4) corretamente.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Editor de código com depurador (ex: VS Code com Python)"
                                  ],
                                  "tips": "Use um depurador para observar a pilha em tempo real durante a execução recursiva.",
                                  "learningObjective": "Entender como a pilha de chamadas gerencia estados em recursão.",
                                  "commonMistakes": [
                                    "Confundir pilha com heap; ignorar que cada chamada recursiva cria um novo frame."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a profundidade máxima de recursão em métodos exaustivos",
                                  "subSteps": [
                                    "Analise a estrutura de um método exaustivo, como backtracking em permutações ou subconjuntos.",
                                    "Trace a árvore de recursão, contando o nível máximo de chamadas aninhadas.",
                                    "Determine fatores que limitam a profundidade: parâmetros de entrada (ex: n para profundidade n).",
                                    "Calcule a profundidade para exemplos como geração de subconjuntos (profundidade n).",
                                    "Considere ramificações: profundidade máxima vs. largura da árvore."
                                  ],
                                  "verification": "Para um algoritmo de permutações de n=3, trace e identifique profundidade máxima de 3.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Pseudocódigo de backtracking",
                                    "Ferramenta de visualização de árvores (ex: draw.io)"
                                  ],
                                  "tips": "Pense na recursão como uma árvore: profundidade é a altura máxima.",
                                  "learningObjective": "Calcular a profundidade máxima da árvore de recursão em algoritmos exaustivos.",
                                  "commonMistakes": [
                                    "Confundir profundidade com número total de chamadas; ignorar caminhos de backtrack curtos."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estimar o tamanho de cada frame de pilha",
                                  "subSteps": [
                                    "Liste componentes de um frame: parâmetros (ex: array de tamanho fixo), variáveis locais, ponteiros.",
                                    "Meça tamanhos aproximados: int (4-8 bytes), array local (O(1) ou O(n)), overhead do sistema.",
                                    "Use ferramentas como sizeof() em C ou sys.getsizeof() em Python para medir.",
                                    "Considere overhead constante por frame (ex: 20-50 bytes + variáveis).",
                                    "Abstraia para análise assintótica: frame size = O(1) ou O(n) dependendo do algoritmo."
                                  ],
                                  "verification": "Estime frame size para uma função recursiva simples e valide com depurador.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Compilador C/Python",
                                    "Ferramenta de profiling de memória (ex: Valgrind)"
                                  ],
                                  "tips": "Ignore constantes exatas para Big O; foque no dominante.",
                                  "learningObjective": "Quantificar o espaço por frame em recursão.",
                                  "commonMistakes": [
                                    "Subestimar overhead do sistema; assumir todos frames têm tamanho fixo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular complexidade espacial total e analisar limitações",
                                  "subSteps": [
                                    "Multiplique profundidade máxima pelo tamanho do frame: Espaço = O(profundidade * frame_size).",
                                    "Para métodos exaustivos típicos, conclua O(n) espacial se frame O(1).",
                                    "Discuta stack overflow: limites reais (ex: 1MB em muitas linguagens).",
                                    "Compare com otimizações: tail recursion ou memoização.",
                                    "Aplique a um exemplo completo: calcule para N-Queens recursivo."
                                  ],
                                  "verification": "Calcule corretamente O(n) para backtracking de subconjuntos e identifique limite para n=1000.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Código de exemplo N-Queens",
                                    "Calculadora ou planilha para simulações"
                                  ],
                                  "tips": "Lembre: espaço máximo é no pior caso, na folha mais profunda da árvore.",
                                  "learningObjective": "Derivar complexidade espacial O(n) e discutir trade-offs.",
                                  "commonMistakes": [
                                    "Confundir espaço recursivo com tempo; ignorar que heap pode ser usado paralelamente."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um solver recursivo de N-Queens para n=8: cada chamada recursiva usa ~50 bytes (parâmetros row/col, array board[8]). Profundidade máxima=8, então espaço de pilha ~400 bytes, O(n). Simule com código Python e observe stack trace.",
                              "finalVerifications": [
                                "Trace pilha para fatorial(5) e liste frames.",
                                "Calcule profundidade máxima para permutações(n=4).",
                                "Estime frame size e total para backtracking simples.",
                                "Explique por que recursão exaustiva falha para n grande (ex: n=30).",
                                "Converta recursão para iterativa para validar análise.",
                                "Use depurador para confirmar uso de memória."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de profundidade máxima (100% nos traces).",
                                "Correta estimação de frame size com justificativa (erro <20%).",
                                "Derivação assintótica O(n) com exemplo numérico.",
                                "Identificação de limitações reais (stack overflow).",
                                "Clareza em diagramas e explicações.",
                                "Aplicação correta a pelo menos 2 algoritmos exaustivos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica Big O e árvores de recursão.",
                                "Física: Analogia com empilhamento físico e limites de estabilidade.",
                                "Engenharia de Software: Otimização de memória e profiling.",
                                "Matemática Discreta: Contagem de estados em backtracking."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, analisar recursão em solvers de otimização (ex: roteirização de veículos em logística) para evitar stack overflow em instâncias reais com n=100+, optando por iterações ou heurísticas quando O(n) excede limites de hardware."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.2.2",
                            "name": "Comparar abordagens iterativas vs recursivas",
                            "description": "Comparar o overhead espacial de versões recursivas versus iterativas com pilhas explícitas em métodos exaustivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o mecanismo de pilha de chamadas na recursão",
                                  "subSteps": [
                                    "Estude o conceito de stack frame em chamadas de função recursivas, incluindo parâmetros, endereço de retorno e variáveis locais.",
                                    "Analise diagramas de pilha para uma recursão simples, como fatorial, mostrando crescimento da pilha com a profundidade.",
                                    "Identifique componentes de overhead em cada frame: ponteiro de frame, endereço de retorno e espaço para argumentos.",
                                    "Calcule o overhead aproximado por frame (tipicamente 20-50 bytes em arquiteturas modernas).",
                                    "Compare com pilha do sistema operacional versus alocação dinâmica."
                                  ],
                                  "verification": "Desenhe um diagrama da pilha para uma recursão de profundidade 5 e liste os componentes de cada frame.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Documentação de linguagens como C++ ou Python sobre stack frames; ferramenta como GDB para inspecionar pilha.",
                                  "tips": "Use funções recursivas simples primeiro para visualizar sem complexidade de algoritmos exaustivos.",
                                  "learningObjective": "Compreender como a recursão consome memória da pilha do sistema de forma implícita.",
                                  "commonMistakes": "Confundir pilha de execução com heap; ignorar overhead fixo por chamada além das variáveis locais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e analisar versão recursiva de um método exaustivo",
                                  "subSteps": [
                                    "Escolha um exemplo: backtracking para gerar power set de {1,2,3}.",
                                    "Implemente a função recursiva que decide incluir/excluir cada elemento.",
                                    "Execute com tamanhos crescentes (n=1 a 10) e observe falhas por stack overflow.",
                                    "Use ferramentas como Valgrind ou perf para medir pico de uso de memória da pilha.",
                                    "Registre overhead espacial: O(n * tamanho_frame) onde n é profundidade máxima."
                                  ],
                                  "verification": "Implementação gera todos 8 subconjuntos corretamente; relatório de memória mostra crescimento linear com n.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Editor de código (VS Code); bibliotecas de profiling (Valgrind para C++, memory_profiler para Python).",
                                  "tips": "Compile com flags de otimização desabilitada (-O0) para medir overhead real.",
                                  "learningObjective": "Aplicar recursão em método exaustivo e quantificar seu custo espacial.",
                                  "commonMistakes": "Não considerar tail recursion optimization, que pode reduzir overhead em alguns compiladores."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar versão iterativa com pilha explícita",
                                  "subSteps": [
                                    "Refatore o power set para iterativo: use uma std::stack ou lista para simular estados de decisão.",
                                    "Estruture a pilha para armazenar apenas dados essenciais: índice atual e caminho parcial.",
                                    "Implemente loop principal: push/pop para explorar branches incluir/excluir.",
                                    "Meça uso de memória da pilha explícita (heap) com as mesmas ferramentas.",
                                    "Compare tamanhos: pilha explícita tipicamente armazena só o necessário vs frames completos."
                                  ],
                                  "verification": "Implementação produz os mesmos subconjuntos; memória medida é consistentemente menor ou igual.",
                                  "estimatedTime": "75 minutos",
                                  "materials": "Mesmas ferramentas de profiling; exemplos de código de backtracking iterativo online.",
                                  "tips": "Minimize dados na pilha: use structs leves com índice e bitmask para caminho.",
                                  "learningObjective": "Simular recursão com controle explícito de memória para reduzir overhead.",
                                  "commonMistakes": "Replicar exatamente os frames recursivos, adicionando overhead desnecessário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar overhead espacial quantitativamente",
                                  "subSteps": [
                                    "Execute ambas implementações para n=5 a 15, registrando pico de memória.",
                                    "Calcule overhead por nó: recursivo (frame_size * profundidade) vs iterativo (struct_size * largura).",
                                    "Gere gráficos de uso de memória vs n usando Python/Matplotlib.",
                                    "Discuta trade-offs: recursivo mais legível mas risco de overflow; iterativo mais escalável.",
                                    "Teste em hardware real vs simuladores para validar."
                                  ],
                                  "verification": "Tabela/gráfico mostra recursivo com 2-5x mais overhead; explicação escrita das diferenças.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilhas ou Jupyter Notebook para gráficos; hardware com limite de stack configurável.",
                                  "tips": "Aumente limite de stack artificialmente para testes maiores, mas note limitações reais.",
                                  "learningObjective": "Quantificar e comparar complexidade espacial O(n) em ambos.",
                                  "commonMistakes": "Ignorar alocações auxiliares ou garbage collection em linguagens gerenciadas."
                                }
                              ],
                              "practicalExample": "Implemente power set de {1,2,3}: recursivo usa até 3 frames (overhead ~150 bytes); iterativo usa stack com structs de 8 bytes cada (overhead ~24 bytes). Execute e compare picos reais com Valgrind.",
                              "finalVerifications": [
                                "Explicar por que recursão tem overhead maior (endereços de retorno, frames).",
                                "Calcular overhead para n=10: recursivo vs iterativo.",
                                "Identificar quando iterativo é preferível (profundidade >1000).",
                                "Converter um backtracking recursivo dado para iterativo.",
                                "Discutir impacto em problemas como N-Queens.",
                                "Gere gráfico de memória vs n mostrando superioridade iterativa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de componentes de stack frame (80% cobertura).",
                                "Implementações corretas e equivalentes em saída.",
                                "Medições quantitativas com <10% erro vs ferramentas.",
                                "Análise escrita clara de trade-offs (legibilidade vs eficiência).",
                                "Gráficos/tabelas profissionais e interpretados.",
                                "Tratamento de edge cases (n=0, n=1)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica O(n) e teoria de grafos (árvore de recursão).",
                                "Engenharia de Software: Otimização de performance e refatoração de código.",
                                "Sistemas Operacionais: Gerenciamento de pilha do processo e limites ulimit.",
                                "Análise de Algoritmos: Amortized analysis para pilhas dinâmicas."
                              ],
                              "realWorldApplication": "Em solvers de SAT ou TSP exaustivos (ex: MiniSAT), versões iterativas evitam stack overflow em instâncias industriais com milhões de variáveis, permitindo escalabilidade em hardware limitado."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.2.5.3",
                        "name": "Condições de Aplicabilidade e Limitações",
                        "description": "Definição das condições sob as quais métodos exaustivos são viáveis, limitados a instâncias pequenas, e suas restrições práticas.",
                        "specificSkills": [
                          {
                            "id": "10.1.2.5.3.1",
                            "name": "Determinar tamanho máximo de instância viável",
                            "description": "Estimar o tamanho máximo de n para o qual um método exaustivo roda em tempo razoável, considerando hardware típico (ex: n≤30 para O(2^n)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar a complexidade temporal do método exaustivo",
                                  "subSteps": [
                                    "Analise o algoritmo exaustivo e determine sua notação Big-O, como O(2^n) para buscas em subconjuntos.",
                                    "Identifique o expoente principal (ex: 2^n) e quaisquer fatores multiplicativos constantes.",
                                    "Registre a complexidade em termos de n, o tamanho da instância.",
                                    "Compare com complexidades semelhantes, como O(n!) para permutações.",
                                    "Documente suposições sobre o modelo de máquina (RAM padrão)."
                                  ],
                                  "verification": "Confirme que a fórmula de complexidade está escrita corretamente e corresponde ao pseudocódigo do algoritmo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Pseudocódigo do algoritmo, tabela de notações Big-O.",
                                  "tips": "Sempre expresse em termos assintóticos, ignorando constantes menores inicialmente.",
                                  "learningObjective": "Compreender e extrair precisamente a complexidade temporal de algoritmos exaustivos.",
                                  "commonMistakes": "Confundir complexidade espacial com temporal; ignorar recorrências."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir parâmetros de hardware e tempo aceitável",
                                  "subSteps": [
                                    "Pesquise velocidades típicas de CPU modernas (ex: 3-4 GHz, ou 3-4 x 10^9 ciclos/segundo).",
                                    "Estime operações por ciclo (ex: 1-10 ops/ciclo para instruções simples).",
                                    "Defina tempo razoável (ex: 1 segundo para protótipos, 1 hora para análises profundas).",
                                    "Calcule operações viáveis por segundo (ex: 10^9 ops/s).",
                                    "Considere overheads como I/O ou memória."
                                  ],
                                  "verification": "Liste valores numéricos para clock speed, ops/ciclo e tempo limite, com fontes citadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Benchmarks de CPU (ex: sites como CPU Monkey), calculadora.",
                                  "tips": "Use hardware mediano, não o mais rápido, para estimativas realistas.",
                                  "learningObjective": "Estabelecer benchmarks realistas de performance computacional.",
                                  "commonMistakes": "Superestimar ops/segundo sem considerar gargalos reais como cache misses."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o número máximo de operações viáveis",
                                  "subSteps": [
                                    "Multiplique ops/segundo pelo tempo aceitável para obter total de ops viáveis (ex: 10^9 para 1s).",
                                    "Ajuste por constantes do algoritmo (ex: se O(c * 2^n), multiplique por c estimado).",
                                    "Inclua fator de segurança (ex: dividir por 10 para overheads).",
                                    "Registre o limite de operações, como 10^8 - 10^10 ops.",
                                    "Teste sensibilidade variando parâmetros."
                                  ],
                                  "verification": "Verifique se o cálculo aritmético está correto com uma calculadora ou planilha.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Calculadora científica, planilha Excel/Google Sheets.",
                                  "tips": "Use notação científica para evitar erros em números grandes.",
                                  "learningObjective": "Quantificar limites computacionais baseados em hardware.",
                                  "commonMistakes": "Esquecer fatores de segurança ou constantes multiplicativas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Resolver para o tamanho máximo de n",
                                  "subSteps": [
                                    "Configure a equação: ops(n) ≤ ops_viáveis, ex: 2^n ≤ 10^9.",
                                    "Aplique logaritmo: n ≤ log2(10^9) ≈ 30.",
                                    "Para outras bases, use log_b(M) = ln(M)/ln(b).",
                                    "Arredonde para baixo e teste n=29,30,31 empiricamente.",
                                    "Gere uma tabela de n vs. tempo estimado."
                                  ],
                                  "verification": "Crie uma tabela mostrando n, 2^n e tempo estimado; confirme n_max onde tempo ≤ limite.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora com logaritmos, tabela de potências de 2.",
                                  "tips": "Lembre: log2(10) ≈ 3.32 para conversões rápidas.",
                                  "learningObjective": "Aplicar logaritmos para inverter funções exponenciais.",
                                  "commonMistakes": "Usar log10 em vez de log2; arredondar para cima."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e refinar a estimativa",
                                  "subSteps": [
                                    "Implemente um benchmark simples em Python/C++ para medir tempo real em n próximos.",
                                    "Compare teoria vs. prática e ajuste constantes.",
                                    "Considere otimizações como bitsets ou pruning que podem aumentar n_max.",
                                    "Documente faixa de n viável (ex: n≤28 garantido, n≤32 com otimizações).",
                                    "Discuta cenários onde limites mudam (ex: GPU vs. CPU)."
                                  ],
                                  "verification": "Execute código de benchmark e compare tempos medidos com preditos (erro < 2x).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ambiente de programação (Python com timeit), hardware de teste.",
                                  "tips": "Use loops vazios para isolar overheads de contagem.",
                                  "learningObjective": "Validar estimativas teóricas com experimentos empíricos.",
                                  "commonMistakes": "Benchmark em hardware não típico; ignorar compilação otimizada."
                                }
                              ],
                              "practicalExample": "Para o problema de Subconjunto Soma com O(2^n): assuma CPU 3GHz, 1 op/ciclo, 1s limite → 3x10^9 ops. Então 2^n ≤ 3x10^9 → n ≤ log2(3x10^9) ≈ 31.7 → n_max=31. Benchmark: código Python loop 2**n confirma ~0.5s para n=30.",
                              "finalVerifications": [
                                "Tabela de n vs. ops/tempo mostra corte claro em n_max.",
                                "Benchmark empírico confirma predição teórica dentro de fator 2.",
                                "Equação logarítmica resolvida corretamente com valor numérico exato.",
                                "Fatores de hardware e segurança explicitamente justificados.",
                                "Discussão de variações (ex: +10% para pruning) incluída.",
                                "n_max conservador e realista para hardware típico."
                              ],
                              "assessmentCriteria": [
                                "Precisão da complexidade identificada (100% match com análise padrão).",
                                "Cálculos logarítmicos corretos (erro <1 unidade em n).",
                                "Uso realista de parâmetros de hardware (citados fontes).",
                                "Inclusão de validação empírica via benchmark.",
                                "Clareza na tabela de resultados e discussão de limites.",
                                "Consideração de otimizações e cenários alternativos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Logaritmos e funções exponenciais (Cálculo/Álgebra).",
                                "Arquitetura de Computadores: Modelo de máquina RAM e performance de CPU.",
                                "Programação: Implementação de benchmarks e medição de tempo.",
                                "Otimização: Trade-offs entre exaustivo e heurísticos.",
                                "Estatística: Análise de sensibilidade e intervalos de confiança em estimativas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, determinar se backtracking exaustivo é viável para scheduling de tarefas (n=20 jobs) antes de investir em heurísticas; em criptoanálise, estimar quebra de chaves por força bruta (n=40 bits viável em clusters)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.2",
                            "name": "Identificar cenários de aplicabilidade",
                            "description": "Reconhecer quando usar métodos exaustivos: problemas pequenos, subproblemas de otimização exata ou protótipos para heurísticas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os fundamentos dos métodos exaustivos",
                                  "subSteps": [
                                    "Defina métodos exaustivos como algoritmos que exploram todas as soluções possíveis.",
                                    "Explique a garantia de otimalidade devido à enumeração completa.",
                                    "Discuta a complexidade exponencial típica (ex.: O(n!)).",
                                    "Compare com heurísticas que sacrificam otimalidade por velocidade.",
                                    "Identifique trade-offs: precisão vs. escalabilidade."
                                  ],
                                  "verification": "Resuma em 3 frases os prós e contras dos métodos exaustivos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Livro de Algoritmos Avançados (cap. Métodos Exaustivos), slides de aula sobre complexidade.",
                                  "tips": "Use analogias como 'provar teorema checando todos os casos' para fixar conceitos.",
                                  "learningObjective": "Entender as características essenciais que definem cenários viáveis para métodos exaustivos.",
                                  "commonMistakes": "Confundir exaustivo com guloso, ignorando a garantia de exaustividade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar cenários de problemas pequenos",
                                  "subSteps": [
                                    "Liste problemas com n ≤ 10-15 (ex.: permutações de 10 itens).",
                                    "Calcule tempo de execução para tamanhos pequenos usando fórmula de complexidade.",
                                    "Avalie viabilidade computacional com benchmarks reais (ex.: 1 segundo para n=12).",
                                    "Pratique com exemplos como sudoku 4x4 ou TSP com 8 cidades.",
                                    "Documente thresholds de tamanho por hardware disponível."
                                  ],
                                  "verification": "Resolva um problema exaustivo com n=10 e confirme tempo < 1s.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Python/Jupyter Notebook, timer de execução, dataset pequeno de TSP.",
                                  "tips": "Sempre meça tempo real em vez de só teoria para calibrar intuição.",
                                  "learningObjective": "Reconhecer quando o tamanho do problema permite enumeração completa sem timeouts.",
                                  "commonMistakes": "Superestimar velocidade para n médio, esquecendo crescimento factorial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer subproblemas de otimização exata",
                                  "subSteps": [
                                    "Identifique subproblemas em DP ou branch-and-bound onde exaustivo é usado (ex.: subgrafos pequenos).",
                                    "Analise quando exatidão é crítica (ex.: certificados de prova em pesquisa).",
                                    "Estude casos como knapsack exato para frações do problema principal.",
                                    "Compare com aproximações: use exaustivo só onde erro zero é obrigatório.",
                                    "Crie fluxograma: 'É subproblema isolado e pequeno? Sim → Exaustivo'."
                                  ],
                                  "verification": "Decomponha um problema maior (ex.: grafo) em subproblemas exaustivos viáveis.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Papel e lápis para fluxogramas, exemplos de códigos de branch-and-bound.",
                                  "tips": "Pense em 'ilhas de exatidão' dentro de algoritmos híbridos.",
                                  "learningObjective": "Detectar oportunidades de exaustivo em partes precisas de problemas maiores.",
                                  "commonMistakes": "Aplicar exaustivo ao problema inteiro em vez de subpartes."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar em protótipos para heurísticas",
                                  "subSteps": [
                                    "Desenvolva protótipo exaustivo como baseline para heurísticas.",
                                    "Gere dados de performance para validar heurísticas (ex.: gaps de otimalidade).",
                                    "Use para debugging: compare saídas exatas vs. aproximadas.",
                                    "Documente insights: 'Heurística A atinge 95% do ótimo em 1/1000 do tempo'.",
                                    "Evolua protótipo para ferramentas de benchmark em pesquisa."
                                  ],
                                  "verification": "Crie protótipo simples e compare com heurística conhecida.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Ambiente de programação (Python), bibliotecas como itertools para enumeração.",
                                  "tips": "Comece com n mínimo viável para gerar baselines rápidos.",
                                  "learningObjective": "Utilizar exaustivo como ferramenta de validação e prototipagem.",
                                  "commonMistakes": "Ignorar protótipos, pulando direto para heurísticas sem baseline."
                                }
                              ],
                              "practicalExample": "No problema do Caixeiro Viajante (TSP) com 10 cidades: use método exaustivo (permutações via itertools) para encontrar o tour ótimo em <1s, servindo como baseline para heurísticas como Nearest Neighbor em instâncias maiores.",
                              "finalVerifications": [
                                "Lista 3 cenários específicos onde exaustivo é ideal (pequeno n, subproblema exato, protótipo).",
                                "Calcula corretamente complexidade e tempo para n=12 em máquina padrão.",
                                "Decompoe um problema real em partes exaustivas viáveis.",
                                "Compara exaustivo vs. heurística em exemplo prático com métricas.",
                                "Identifica 2 casos onde NÃO usar exaustivo (n>20, tempo real).",
                                "Cria fluxograma pessoal para decisão de aplicabilidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cenários: 90%+ corretos em quiz de 10 itens.",
                                "Profundidade de análise: inclui cálculos de complexidade e tempos reais.",
                                "Criatividade em exemplos: usa casos concretos além dos aulas.",
                                "Clareza na justificativa: explica trade-offs em cada cenário.",
                                "Aplicação prática: protótipo funcional com baseline gerado.",
                                "Consciência de limitações: menciona corretamente quando evitar."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e teoria de grafos para modelagem de problemas.",
                                "Engenharia de Software: Prototipagem e benchmarking de algoritmos.",
                                "Pesquisa Científica: Geração de baselines exatos para validação experimental.",
                                "Gestão de Projetos: Avaliação de viabilidade computacional em planejamento."
                              ],
                              "realWorldApplication": "Em pesquisa de IA, métodos exaustivos em problemas pequenos validam heurísticas de ML para roteirização de entregas (ex.: otimização de rotas em logística urbana com sub-regiões exatas)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.2.5.3.3",
                            "name": "Analisar limitações práticas e alternativas",
                            "description": "Discutir limitações como explosão combinatorial e sugerir alternativas como poda, programação dinâmica ou algoritmos aproximados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Limitações Práticas dos Métodos Exaustivos",
                                  "subSteps": [
                                    "Revisar definições de complexidade temporal O(2^n) ou O(n!) típica de métodos exaustivos.",
                                    "Analisar impacto no tempo de execução para inputs reais (n=20, n=50).",
                                    "Discutir limitações de hardware: memória e CPU disponíveis.",
                                    "Exemplificar com problemas como Subconjunto de Soma ou Caixeiro Viajante (TSP).",
                                    "Calcular thresholds práticos onde o método falha (ex: n>15)."
                                  ],
                                  "verification": "Listar 4 limitações com cálculos de tempo para n=10,20,30.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Notas sobre notação Big-O, calculadora ou Python para simulações, exemplos de problemas NP-completos.",
                                  "tips": "Use tabelas para comparar tempos exponenciais vs polinomiais.",
                                  "learningObjective": "Reconhecer quando métodos exaustivos são inviáveis na prática.",
                                  "commonMistakes": "Ignorar overheads reais como constantes ou memória, focando só na teoria assintótica."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Explosão Combinatorial Especificamente",
                                  "subSteps": [
                                    "Explicar explosão combinatorial: crescimento factorial ou exponencial no espaço de busca.",
                                    "Derivar fórmulas para problemas clássicos (ex:  n! para permutações em TSP).",
                                    "Simular crescimento com gráficos ou tabelas (2^n vs n^2).",
                                    "Discutir efeitos em cenários reais: timeouts, custos computacionais.",
                                    "Identificar padrões em problemas de busca exaustiva."
                                  ],
                                  "verification": "Gerar gráfico ou tabela mostrando explosão para n=1 a 20.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha Excel/Google Sheets ou Python (matplotlib), exemplos de TSP/Backtracking.",
                                  "tips": "Comece com n pequeno e dobre iterativamente para visualizar o boom.",
                                  "learningObjective": "Quantificar matematicamente a explosão e suas implicações práticas.",
                                  "commonMistakes": "Confundir explosão com crescimento linear, subestimando fatoriais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Alternativas aos Métodos Exaustivos",
                                  "subSteps": [
                                    "Estudar poda (branch and bound): eliminar ramos inviáveis cedo.",
                                    "Analisar Programação Dinâmica (DP): memoização para subproblemas sobrepostos.",
                                    "Investigar algoritmos aproximados/heurísticos: greedy, simulated annealing.",
                                    "Comparar complexidades: poda O(2^n / poly(n)), DP O(n^2) para alguns casos.",
                                    "Exemplificar cada alternativa em um problema comum como TSP."
                                  ],
                                  "verification": "Descrever uma alternativa por problema com pseudocódigo simples.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Pseudocódigos de poda/DP/heurísticas, ferramenta online como GeeksforGeeks.",
                                  "tips": "Foque em trade-offs: exatidão vs velocidade.",
                                  "learningObjective": "Selecionar alternativas adequadas baseadas em limitações identificadas.",
                                  "commonMistakes": "Sugeri alternativas sem justificar redução de complexidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar e Discutir Aplicabilidade das Alternativas",
                                  "subSteps": [
                                    "Criar tabela comparativa: exaustivo vs poda vs DP vs aproximados (tempo, precisão, casos de uso).",
                                    "Discutir condições para escolher cada: tamanho n, precisão necessária.",
                                    "Avaliar híbridos: exaustivo + poda para n médio.",
                                    "Simular um caso: TSP com n=8 exaustivo vs heurística.",
                                    "Concluir com guidelines para decisão."
                                  ],
                                  "verification": "Produzir tabela comparativa com pelo menos 3 métricas por método.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Ferramenta de tabela (Markdown/Excel), simulador TSP online.",
                                  "tips": "Priorize métricas reais: tempo em ms, erro relativo.",
                                  "learningObjective": "Integrar análise para recomendar soluções otimizadas.",
                                  "commonMistakes": "Recomendar alternativa sem considerar restrições do problema."
                                }
                              ],
                              "practicalExample": "No problema do Caixeiro Viajante (TSP) com 12 cidades, método exaustivo gera ~239 milhões de tours (12!/2), levando horas em PC comum. Com poda (branch and bound), reduz para milhares de nós viáveis em minutos; DP resolve em O(2^n * n^2) ~ 500ms; heurística nearest neighbor dá solução 85% ótima em segundos.",
                              "finalVerifications": [
                                "Explica explosão combinatorial com fórmula e exemplo numérico.",
                                "Lista 3 limitações práticas com impactos reais.",
                                "Sugere pelo menos 2 alternativas com justificativa de redução de complexidade.",
                                "Compara exaustivo vs alternativas em tabela com métricas.",
                                "Identifica cenário onde cada alternativa é preferível.",
                                "Demonstra trade-off precisão vs performance em exemplo concreto."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de limitações (explosão, memória, tempo).",
                                "Profundidade na análise combinatorial com cálculos quantitativos.",
                                "Diversidade e adequação das alternativas sugeridas.",
                                "Clareza na comparação (tabelas/gráficos usados).",
                                "Relevância das discussões para problemas reais.",
                                "Ausência de erros conceituais em complexidades."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Combinatória e Teoria de Grafos para modelagem de problemas.",
                                "Engenharia de Software: Otimização de Algoritmos e Profiling de Performance.",
                                "Economia/Gestão: Otimização de Recursos e Modelagem de Custos Computacionais.",
                                "Física/Química: Simulações Computacionais em Problemas de Otimização Molecular."
                              ],
                              "realWorldApplication": "Em logística (ex: Amazon rotas de entrega), onde TSP exaustivo é impossível para 100+ paradas; usa poda/DP para sub-rotas e heurísticas para soluções near-ótimas, economizando milhões em combustível e tempo."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.1",
                              "10.1.2.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.2.5.3.4",
                            "name": "Avaliar trade-offs com base em benchmarks",
                            "description": "Usar referências bibliográficas (Cormen, Skiena) para avaliar tempos reais e decidir aplicabilidade em contextos de programação competitiva.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Fundamentais de Benchmarks e Trade-offs",
                                  "subSteps": [
                                    "Ler capítulos relevantes sobre análise empírica em Cormen (Capítulo 3-4) e Skiena (Capítulo 5).",
                                    "Identificar definições de benchmark: conjunto de testes padronizados para medir performance.",
                                    "Estudar trade-offs: troca entre tempo, espaço, precisão e simplicidade.",
                                    "Anotar exemplos de complexidades reais vs. teóricas para métodos exaustivos (ex: brute force O(n!)).",
                                    "Comparar com aproximações em contextos de programação competitiva."
                                  ],
                                  "verification": "Resumir em 1 página os conceitos chave com citações dos livros.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Introduction to Algorithms (Cormen et al.)",
                                    "The Algorithm Design Manual (Skiena)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Foque em tabelas de tempos reais nos livros para n=10-20.",
                                  "learningObjective": "Dominar definições e importância de benchmarks na avaliação prática de algoritmos.",
                                  "commonMistakes": [
                                    "Confundir complexidade assintótica com tempos reais",
                                    "Ignorar overheads de implementação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Ambiente de Benchmarking",
                                  "subSteps": [
                                    "Instalar ferramentas: C++ com chrono, Python com timeit, ou judge online como Codeforces.",
                                    "Criar scripts para gerar instâncias de teste variadas (tamanhos n=1 a 30).",
                                    "Implementar um algoritmo exaustivo baseline (ex: brute force para Subset Sum).",
                                    "Configurar medições: tempo médio de 10-100 runs por instância, com seed fixa.",
                                    "Registrar métricas: tempo CPU, memória peak, throughput."
                                  ],
                                  "verification": "Executar benchmark simples e gerar CSV com tempos para n=1-15.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Compilador C++/Python",
                                    "Editor de código (VSCode)",
                                    "Datasets geradores (ex: random graphs)"
                                  ],
                                  "tips": "Use wall-clock time em ambientes controlados para simular contests.",
                                  "learningObjective": "Preparar infraestrutura reproducível para medições empíricas.",
                                  "commonMistakes": [
                                    "Não controlar variáveis como cache ou OS",
                                    "Poucas runs levando a variância alta"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar e Coletar Benchmarks de Algoritmos Exaustivos",
                                  "subSteps": [
                                    "Implementar 2-3 variantes: brute force puro, backtracking otimizado, branch-and-bound.",
                                    "Rodar benchmarks em problemas de programação competitiva (ex: TSP, N-Queens).",
                                    "Comparar com referências: validar tempos vs. Cormen/Skiena para n semelhantes.",
                                    "Plotar gráficos: tempo vs. n (log-scale), usando matplotlib ou gnuplot.",
                                    "Identificar pontos de ruptura: onde tempo excede 1s/10s (limites de contest)."
                                  ],
                                  "verification": "Produzir relatório com tabelas/gráficos mostrando tempos reais para cada variante.",
                                  "estimatedTime": "5 horas",
                                  "materials": [
                                    "Livros Cormen/Skiena para validação",
                                    "Ferramentas de plot (matplotlib)",
                                    "Problemas de sample do UVa/Codeforces"
                                  ],
                                  "tips": "Teste em máquina similar a judges (ex: 2s time limit).",
                                  "learningObjective": "Coletar dados empíricos comparáveis com literatura.",
                                  "commonMistakes": [
                                    "Overfitting em instâncias fáceis",
                                    "Ignorar worst-case"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Trade-offs e Decidir Aplicabilidade",
                                  "subSteps": [
                                    "Calcular trade-offs quantitativos: speedup, custo-espacial, robustez.",
                                    "Referenciar livros para contextos: quando exaustivo é viável (n<20).",
                                    "Simular cenários de contest: priorizar por score/time limit.",
                                    "Documentar decisão: 'Use backtracking se n<=18, senão DP approx'.",
                                    "Revisar com pares ou fóruns (Codeforces blogs)."
                                  ],
                                  "verification": "Escrever análise de 300 palavras decidindo para um problema específico.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Benchmarks coletados",
                                    "Livros para suporte teórico",
                                    "Ferramenta de escrita (Google Docs)"
                                  ],
                                  "tips": "Use matriz de decisão: linhas=algoritmos, colunas=métricas.",
                                  "learningObjective": "Avaliar e justificar escolhas baseadas em dados reais.",
                                  "commonMistakes": [
                                    "Subestimar constantes ocultas",
                                    "Não considerar input distribution"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um problema de TSP com n=12 cidades (Codeforces-like), benchmark brute force (O(n!)) leva 0.5s, backtracking com pruning 0.1s. Decida usar backtracking pois trade-off tempo/espaço permite AC dentro de 2s limit.",
                              "finalVerifications": [
                                "Pode citar tempos reais de Cormen para brute force n=15-20.",
                                "Gera benchmarks reproducíveis com <5% variância.",
                                "Justifica trade-off com dados numéricos e referências.",
                                "Identifica corretamente limites de aplicabilidade em contests.",
                                "Compara 3+ variantes com gráficos claros.",
                                "Documenta decisão em formato relatório."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos benchmarks (validados vs. literatura).",
                                "Profundidade da análise de trade-offs (quantitativa/qualitativa).",
                                "Reprodutibilidade do setup e resultados.",
                                "Integração correta de referências bibliográficas.",
                                "Clareza na decisão de aplicabilidade.",
                                "Uso apropriado de visualizações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e logaritmos para plots.",
                                "Estatística: Médias, desvios padrão em medições empíricas.",
                                "Engenharia de Software: Boas práticas de benchmarking (reprodutibilidade).",
                                "Economia: Conceitos de custo-benefício em trade-offs.",
                                "Física: Analogia com experimentos empíricos."
                              ],
                              "realWorldApplication": "Em programação competitiva (ICPC/Codeforces), decide entre exaustivo e heurística para maximizar score; em indústria, otimiza solvers para NP-hard como scheduling, evitando timeouts em produção."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.2.5.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.3",
                "name": "Algoritmos Gulosos",
                "description": "Estratégias que selecionam a opção localmente ótima em cada etapa, visando uma solução global eficiente.",
                "totalSkills": 42,
                "atomicTopics": [
                  {
                    "id": "10.1.3.1",
                    "name": "Definição de Algoritmos Gulosos",
                    "description": "Estratégias que selecionam a opção localmente ótima em cada etapa, visando uma solução globalmente eficiente.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.1.1.1",
                        "name": "Paradigma do Algoritmo Guloso",
                        "description": "Estratégia de design de algoritmos que constrói a solução de forma incremental, selecionando em cada etapa a opção localmente ótima, com a esperança de que essas escolhas levem a uma solução globalmente eficiente.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.1.1",
                            "name": "Definir algoritmo guloso",
                            "description": "Explicar formalmente que um algoritmo guloso é um paradigma que faz a melhor escolha possível em cada etapa, sem reconsiderar escolhas anteriores, visando otimizar a solução global.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Algoritmos",
                                  "subSteps": [
                                    "Defina o que é um algoritmo em termos simples: uma sequência finita de instruções bem definidas para resolver um problema.",
                                    "Discuta os critérios de análise de algoritmos: corretude, eficiência (tempo e espaço) e otimalidade.",
                                    "Identifique problemas de otimização, onde o objetivo é encontrar a solução com o melhor valor possível entre todas as soluções viáveis.",
                                    "Liste exemplos de problemas de otimização: mochila, caminho mais curto, seleção de atividades.",
                                    "Explique a diferença entre soluções ótimas e aproximadas."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo os conceitos fundamentais e dê um exemplo de problema de otimização.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Algoritmos (capítulo introdutório)",
                                    "Notebook para anotações",
                                    "Vídeo introdutório sobre algoritmos (Khan Academy)"
                                  ],
                                  "tips": "Use analogias do dia a dia, como receitas de cozinha, para fixar o conceito de algoritmo.",
                                  "learningObjective": "Compreender os pré-requisitos necessários para paradigmas algorítmicos avançados.",
                                  "commonMistakes": [
                                    "Confundir algoritmo com programa",
                                    "Ignorar a distinção entre otimização e busca exaustiva"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir o Paradigma Guloso",
                                  "subSteps": [
                                    "Defina 'paradigma guloso' como uma abordagem que constrói a solução incrementalmente, fazendo a melhor escolha possível em cada etapa.",
                                    "Explique a 'escolha gulosa': selecionar localmente a opção ótima sem considerar impactos futuros.",
                                    "Descreva o processo: parta de uma solução vazia e adicione elementos greedy até completar.",
                                    "Discuta a ausência de reconsideração: uma vez feita a escolha, não há backtracking.",
                                    "Ilustre com um diagrama simples de decisões sequenciais."
                                  ],
                                  "verification": "Desenhe um fluxograma de um processo guloso simples e rotule as escolhas locais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para fluxograma",
                                    "Ferramenta online como Draw.io",
                                    "Artigo sobre paradigmas algorítmicos"
                                  ],
                                  "tips": "Pense em 'guloso' como alguém que pega o maior pedaço de bolo disponível agora, sem planejar o resto.",
                                  "learningObjective": "Graspar o cerne do paradigma guloso e sua estratégia de decisão.",
                                  "commonMistakes": [
                                    "Confundir com programação dinâmica (que reconsidera)",
                                    "Achar que toda escolha local leva a global ótima"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Características e Condições de Otimalidade",
                                  "subSteps": [
                                    "Liste as três propriedades chave: escolha gulosa, subestrutura ótima e otimalidade global.",
                                    "Explique 'subestrutura ótima': a solução ótima para o problema contém soluções ótimas para subproblemas.",
                                    "Descreva como testar se um problema admite solução gulosa: verifique as propriedades de matroide ou troca gulosa.",
                                    "Compare com paradigmas opostos: guloso vs. exaustivo vs. dinâmico.",
                                    "Analise quando falha: exemplo onde escolha local não leva a global ótima (ex: mochila fracionária mal formulada).",
                                    "Formalize: solução S é ótima se S = greedy_choice + óptimo(subproblema)."
                                  ],
                                  "verification": "Identifique se um problema dado (ex: seleção de atividades) satisfaz as propriedades guloso e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de exemplos clássicos",
                                    "Tabela comparativa de paradigmas",
                                    "Exercícios de verificação de propriedades"
                                  ],
                                  "tips": "Use a heurística 'se a escolha gulosa + resto ótimo funciona, é guloso'.",
                                  "learningObjective": "Entender por que alguns problemas funcionam com guloso e outros não.",
                                  "commonMistakes": [
                                    "Assumir otimalidade sem verificar propriedades",
                                    "Misturar com aproximações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a Definição Completa",
                                  "subSteps": [
                                    "Escreva a definição formal: 'Um algoritmo guloso é um paradigma que constrói a solução ótima fazendo escolhas localmente ótimas em cada etapa, sem reconsiderar anteriores, assumindo que elas levam à solução global ótima.'",
                                    "Forneça pseudocódigo genérico: G = {}; while problema não resolvido: escolha = argmax local; G.add(escolha); atualize problema.",
                                    "Inclua teorema de corretude: prove usando indução ou troca gulosa.",
                                    "Resuma vantagens: simplicidade, eficiência O(n log n) típica; desvantagens: nem sempre ótimo.",
                                    "Crie uma definição em uma frase para memorização."
                                  ],
                                  "verification": "Redija a definição formal completa e pseudocódigo, explicando cada linha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Referência: Cormen 'Introduction to Algorithms' capítulo guloso",
                                    "Quiz online sobre guloso"
                                  ],
                                  "tips": "Memorize a definição ancorando em exemplos como Dijkstra ou Kruskal.",
                                  "learningObjective": "Capacitar-se a definir e pseudocodificar algoritmos gulosos formalmente.",
                                  "commonMistakes": [
                                    "Omitir 'sem reconsiderar' na definição",
                                    "Esquecer condições de otimalidade"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema da troca de moedas (coin change com denominations canônicas como 1,5,10,25): em cada etapa, escolha a maior moeda possível que não exceda o valor restante (ex: para 36, pegue 25+10+1), sem voltar atrás, resultando na solução ótima mínima de moedas.",
                              "finalVerifications": [
                                "Explique em suas palavras a definição formal de algoritmo guloso.",
                                "Identifique as características chave sem consultar notas.",
                                "Dê um exemplo onde guloso funciona e justifique por quê.",
                                "Dê um contraexemplo onde falha e explique.",
                                "Escreva pseudocódigo genérico de um algoritmo guloso.",
                                "Compare guloso com outro paradigma em 2 frases."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (inclui escolha local, irrevogabilidade e otimalidade aspiração).",
                                "Compreensão das propriedades de corretude (escolha gulosa e subestrutura).",
                                "Capacidade de aplicar a exemplos concretos.",
                                "Identificação correta de limitações.",
                                "Clareza na explicação oral ou escrita.",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização linear e teoria de grafos (árvores geradoras mínimas).",
                                "Economia: Teoria de decisões sob incerteza e maximização local de utilidade.",
                                "Física: Modelagem de caminhos mínimos em redes (ex: circuitos elétricos).",
                                "Gestão: Agendamento de tarefas e alocação de recursos limitados."
                              ],
                              "realWorldApplication": "Em roteamento GPS (algoritmo de Dijkstra, guloso por nó), onde seleciona o menor caminho parcial disponível a cada passo, otimizando tempo de viagem sem reconsiderar rotas anteriores; ou em compiladores para seleção de registradores."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.1.2",
                            "name": "Identificar estrutura incremental",
                            "description": "Reconhecer que algoritmos gulosos constroem a solução de maneira progressiva, adicionando componentes irrevogavelmente em cada iteração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Construção Incremental",
                                  "subSteps": [
                                    "Leia a definição de algoritmo guloso e destaque a frase sobre 'construção progressiva'.",
                                    "Anote exemplos cotidianos de decisões incrementais, como empilhar blocos um a um.",
                                    "Compare com processos não incrementais, como resolver um cubo mágico de uma vez.",
                                    "Desenhe um diagrama simples mostrando adição sequencial de elementos.",
                                    "Resuma em uma frase o que significa 'incremental' no contexto de algoritmos."
                                  ],
                                  "verification": "Capacidade de explicar o conceito em palavras próprias sem consultar materiais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Definição de algoritmo guloso impressa ou digital, papel e caneta para diagramas.",
                                  "tips": "Use analogias visuais para fixar o conceito, como construir uma torre de blocos.",
                                  "learningObjective": "Definir e ilustrar o que é uma estrutura incremental em algoritmos.",
                                  "commonMistakes": "Confundir incremental com recursivo; incremental adiciona partes finais sem volta atrás."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Progressividade em Exemplos Simples",
                                  "subSteps": [
                                    "Analise o pseudocódigo de um algoritmo guloso básico, como seleção de moedas.",
                                    "Marque as linhas onde uma escolha é adicionada à solução atual.",
                                    "Conte o número de iterações e observe como a solução cresce a cada uma.",
                                    "Simule manualmente 3 iterações, registrando o estado da solução antes e depois.",
                                    "Compare o tamanho da solução após cada iteração para visualizar o crescimento."
                                  ],
                                  "verification": "Simulação manual correta de pelo menos 3 iterações com solução crescendo progressivamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Pseudocódigo do algoritmo de troco ótimo, calculadora para simulações.",
                                  "tips": "Use uma tabela para rastrear o estado da solução em cada iteração.",
                                  "learningObjective": "Reconhecer padrões de adição sequencial em código guloso.",
                                  "commonMistakes": "Ignorar que a progressividade é iterativa, não em lotes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconhecer a Irreversibilidade das Escolhas",
                                  "subSteps": [
                                    "No mesmo exemplo, identifique por que a escolha atual não é desfeita depois.",
                                    "Explique o impacto de uma escolha errada irreversível em uma iteração.",
                                    "Compare com backtracking, destacando a ausência de reversão no guloso.",
                                    "Crie um cenário hipotético onde irreversibilidade falha e discuta.",
                                    "Anote critérios que garantem que escolhas gulosas sejam seguras (otimalidade local)."
                                  ],
                                  "verification": "Descrição clara de pelo menos dois exemplos onde irreversibilidade é crítica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Pseudocódigo anotado, quadro branco para cenários hipotéticos.",
                                  "tips": "Pense em 'sem arrependimentos': cada adição deve ser permanentemente ótima.",
                                  "learningObjective": "Diferenciar progressão gulosa de abordagens que permitem reversões.",
                                  "commonMistakes": "Assumir que todo incremental é guloso; foco na irreversibilidade define o guloso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Identificação em um Caso Completo",
                                  "subSteps": [
                                    "Escolha um problema guloso clássico (ex: seleção de atividades) e trace a execução.",
                                    "Destaque todas as adições irrevogáveis à solução.",
                                    "Verifique se a solução final é construída puramente de forma incremental.",
                                    "Crie um fluxograma mostrando o loop de iterações incrementais.",
                                    "Teste com dados de entrada diferentes para confirmar consistência."
                                  ],
                                  "verification": "Fluxograma e traçado corretos mostrando estrutura incremental completa.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Exemplo de seleção de atividades com dados de entrada, software de fluxograma (opcional).",
                                  "tips": "Comece com poucos itens para visualizar, depois escale.",
                                  "learningObjective": "Identificar estrutura incremental em um algoritmo guloso real.",
                                  "commonMistakes": "Confundir com ordenação prévia; incremental ocorre durante as iterações."
                                }
                              ],
                              "practicalExample": "No problema de Seleção de Atividades, ordene atividades por tempo de fim. Em cada iteração, adicione irrevogavelmente a atividade que termina primeiro e não sobrepõe a última selecionada, construindo progressivamente o conjunto máximo até não haver mais compatíveis.",
                              "finalVerifications": [
                                "Explique em 2-3 frases a estrutura incremental de um algoritmo guloso exemplo.",
                                "Identifique corretamente as adições irrevogáveis em um pseudocódigo fornecido.",
                                "Diferencie estrutura gulosa de dinâmica em um diagrama comparativo.",
                                "Simule 5 iterações de um exemplo e mostre crescimento da solução.",
                                "Responda a 3 perguntas sobre irreversibilidade sem hesitação."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de iterações incrementais (90%+ acerto).",
                                "Clareza na explicação de irreversibilidade com exemplos.",
                                "Uso correto de terminologia (progressivo, irrevogável).",
                                "Capacidade de traçar execução em novos dados.",
                                "Diferenciação de paradigmas semelhantes.",
                                "Profundidade nos fluxogramas e simulações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização linear e escolha marginal.",
                                "Economia: Decisões de alocação de recursos sem reversão.",
                                "Física: Construção sequencial de estruturas estáveis.",
                                "Gestão: Planejamento de projetos em fases irrevogáveis."
                              ],
                              "realWorldApplication": "Em sistemas de agendamento de voos ou reuniões, onde cada alocação de slot é adicionada progressivamente sem remover anteriores, maximizando ocupação sem sobreposições."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.1.3",
                            "name": "Comparar com busca exaustiva",
                            "description": "Diferenciar algoritmos gulosos de métodos exaustivos, destacando que os gulosos evitam explorar todas as possibilidades para priorizar eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Busca Exaustiva",
                                  "subSteps": [
                                    "Defina busca exaustiva como um método que explora todas as combinações possíveis de soluções.",
                                    "Identifique que ela garante a solução ótima, mas com alto custo computacional (tempo exponencial).",
                                    "Analise exemplos simples, como permutações de um conjunto pequeno.",
                                    "Calcule a complexidade temporal, como O(n!) para problemas de permutação.",
                                    "Discuta cenários onde é viável (pequenos conjuntos de dados)."
                                  ],
                                  "verification": "Liste 3 características principais da busca exaustiva e um exemplo de complexidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Visualize como uma árvore de decisões completa para entender a exaustividade.",
                                  "learningObjective": "Dominar o conceito e limitações da busca exaustiva.",
                                  "commonMistakes": "Confundir com métodos aproximados; sempre verificar se explora TODAS as possibilidades."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender o Algoritmo Guloso",
                                  "subSteps": [
                                    "Defina algoritmo guloso como um que faz escolhas localmente ótimas em cada passo, sem volta.",
                                    "Explique a heurística usada para priorizar eficiência sobre exaustividade.",
                                    "Estude propriedades: matroide, submodularidade para garantia de otimalidade.",
                                    "Implemente pseudocódigo básico de um exemplo como seleção de atividades.",
                                    "Compare ganho de eficiência com perda potencial de otimalidade."
                                  ],
                                  "verification": "Escreva pseudocódigo de um algoritmo guloso simples e explique sua heurística.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Computador com Python ou pseudocódigo",
                                    "Exemplos de problemas clássicos"
                                  ],
                                  "tips": "Lembre-se: 'guloso' significa escolher o melhor imediato, como comer o doce agora.",
                                  "learningObjective": "Entender o mecanismo e heurísticas dos algoritmos gulosos.",
                                  "commonMistakes": "Achar que sempre é ótimo; teste com contraexemplos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Diferenças Fundamentais",
                                  "subSteps": [
                                    "Compare garantias: exaustiva sempre ótima; guloso nem sempre.",
                                    "Analise complexidade: exaustiva O(2^n); guloso O(n log n).",
                                    "Discuta trade-offs: precisão vs. velocidade.",
                                    "Crie uma tabela comparativa com colunas para tempo, otimalidade e aplicabilidade.",
                                    "Debata quando um é preferível ao outro com base no tamanho do input."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 4 diferenças chave.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Calculadora para complexidades"
                                  ],
                                  "tips": "Use notação Big O para quantificar diferenças de forma precisa.",
                                  "learningObjective": "Diferenciar claramente os dois paradigmas.",
                                  "commonMistakes": "Ignorar casos onde guloso falha; sempre valide com exemplos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação em Exemplos Práticos",
                                  "subSteps": [
                                    "Escolha um problema (ex: mochila) e resolva com ambos os métodos.",
                                    "Meça tempos de execução simulados ou reais.",
                                    "Avalie soluções: qual é ótima e qual é aproximada?",
                                    "Discuta critérios para escolher: restrições de tempo vs. necessidade de exatidão.",
                                    "Reflita sobre escalabilidade em problemas reais."
                                  ],
                                  "verification": "Resolva um problema pequeno com ambos e compare resultados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Ambiente de programação Python",
                                    "Dados de teste para o problema"
                                  ],
                                  "tips": "Comece com n=5 itens para exaustiva ser viável.",
                                  "learningObjective": "Aplicar a comparação em contextos concretos.",
                                  "commonMistakes": "Não considerar tamanho do input; teste com dados variados."
                                }
                              ],
                              "practicalExample": "No problema da Mochila 0/1: Busca exaustiva testa todas as 2^n subconjuntos para a solução ótima. Algoritmo guloso ordena itens por valor/peso e pega os melhores até encher, sendo mais rápido mas possivelmente subótimo (ex: itens [10/6, 9/5, 8/4] com capacidade 10: guloso pega 10/6 + 8/4=18/10; ótimo é 9/5 + 8/4=17/9, mas ajuste para contraexemplo real).",
                              "finalVerifications": [
                                "Explicar verbalmente 3 diferenças chave entre gulosos e exaustivos.",
                                "Calcular complexidades para n=10 em ambos.",
                                "Identificar quando usar cada um em um cenário dado.",
                                "Resolver um problema pequeno com os dois métodos.",
                                "Listar 2 problemas onde guloso falha vs. exaustivo.",
                                "Criar tabela comparativa precisa."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e diferenças (90% correto).",
                                "Uso correto de notação Big O e exemplos.",
                                "Capacidade de aplicar em problemas reais.",
                                "Identificação de trade-offs sem erros.",
                                "Criatividade em exemplos e conexões.",
                                "Clareza na comunicação da comparação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização combinatória e teoria de grafos.",
                                "Economia: Tomada de decisões sob restrições (greedy como heurística comportamental).",
                                "Física: Simulações de partículas (métodos exaustivos em espaços pequenos).",
                                "Gestão: Planejamento de projetos (seleção gulosa de tarefas prioritárias)."
                              ],
                              "realWorldApplication": "Em roteirização de entregas (GPS usa guloso para eficiência rápida; exaustivo só para frotas pequenas). Na compressão de dados (Huffman guloso vs. exaustivo para códigos ótimos em arquivos pequenos)."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.1.2",
                        "name": "Propriedade da Escolha Gulosa",
                        "description": "Condição que garante que uma escolha localmente ótima em uma etapa possa ser estendida para uma solução ótima global, sem perda de otimalidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.2.1",
                            "name": "Explicar propriedade da escolha gulosa",
                            "description": "Descrever que existe uma escolha gulosa ótima para o problema, permitindo que o algoritmo selecione o melhor elemento local e prove sua inclusão na solução ótima global.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito Fundamental da Propriedade da Escolha Gulosa",
                                  "subSteps": [
                                    "Defina a propriedade da escolha gulosa: ela afirma que existe uma solução ótima que inclui a escolha gulosa local ótima.",
                                    "Diferencie escolha local ótima de solução global ótima.",
                                    "Estude a definição formal: para todo subproblema, há uma solução ótima que inclui a escolha gulosa.",
                                    "Leia exemplos introdutórios em textos de algoritmos gulosos.",
                                    "Anote as palavras-chave: 'greedy choice', 'optimal substructure'."
                                  ],
                                  "verification": "Escreva uma definição em suas próprias palavras e compare com fontes confiáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro de Algoritmos (ex: CLRS), Capítulo de Algoritmos Gulosos",
                                    "Notas em branco",
                                    "Acesso a Wikipedia: Greedy Algorithm"
                                  ],
                                  "tips": "Use analogias como escolher o maior pedaço de bolo primeiro e provar que isso leva ao melhor resultado total.",
                                  "learningObjective": "Compreender a definição precisa e intuitiva da propriedade da escolha gulosa.",
                                  "commonMistakes": [
                                    "Confundir com propriedade de otimalidade subestrutural",
                                    "Achar que toda escolha local ótima leva a global ótima sem prova"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar as Condições Necessárias para a Propriedade",
                                  "subSteps": [
                                    "Identifique problemas onde a propriedade segura: exija que a escolha gulosa seja segura para soluções ótimas.",
                                    "Estude o 'exchange argument': suponha uma solução ótima sem a escolha gulosa e troque para incluir ela sem piorar.",
                                    "Liste critérios: herança de otimalidade e matroide-like structures.",
                                    "Discuta contraexemplos onde falha (ex: problema da mochila 0/1).",
                                    "Crie um fluxograma da verificação da propriedade."
                                  ],
                                  "verification": "Crie um fluxograma ou diagrama explicando o exchange argument.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Vídeo tutorial sobre Greedy Choice Property (YouTube: MIT OCW)",
                                    "Pseudocódigo de prova por troca"
                                  ],
                                  "tips": "Sempre pergunte: 'Posso trocar elementos de uma solução ótima para incluir a gulosa sem perda?'",
                                  "learningObjective": "Dominar o mecanismo de prova da propriedade via argumento de troca.",
                                  "commonMistakes": [
                                    "Ignorar subproblemas restantes",
                                    "Aplicar a problemas não-gulosos sem verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Propriedade a um Exemplo Clássico",
                                  "subSteps": [
                                    "Escolha o problema de Seleção de Atividades: ordene por tempo de fim.",
                                    "Prove a propriedade: mostre que a primeira atividade gulosa (menor fim) está em alguma solução ótima.",
                                    "Use exchange: troque qualquer atividade anterior na solução ótima pela gulosa.",
                                    "Implemente pseudocódigo destacando a escolha gulosa.",
                                    "Simule com 5 atividades exemplo."
                                  ],
                                  "verification": "Resolva o exemplo e escreva a prova passo a passo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de atividades: A1(1-4), A2(3-5), A3(0-6), etc.",
                                    "Editor de texto para pseudocódigo",
                                    "Calculadora para simulações"
                                  ],
                                  "tips": "Visualize com um cronograma gráfico para ver sobreposições.",
                                  "learningObjective": "Aplicar e provar a propriedade em um problema padrão.",
                                  "commonMistakes": [
                                    "Ordenar errado (por início em vez de fim)",
                                    "Falhar na troca por não considerar subproblemas idênticos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar e Praticar a Explicação da Propriedade",
                                  "subSteps": [
                                    "Explique verbalmente ou por escrito para um 'aluno fictício'.",
                                    "Aplique a outro problema: ex: Kruskal para MST.",
                                    "Identifique por que falha em alguns casos (ex: Dijkstra vs Bellman-Ford).",
                                    "Crie um checklist para verificar propriedade em novos problemas.",
                                    "Resuma em 1 parágrafo coeso."
                                  ],
                                  "verification": "Grave uma explicação de 1 minuto ou escreva resumo aprovado por auto-revisão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Gravador de voz ou app de notas",
                                    "Lista de problemas gulosos (Kruskal, Prim, Huffman)",
                                    "Checklist template"
                                  ],
                                  "tips": "Pratique explicando como se fosse para um colega iniciante, use termos simples.",
                                  "learningObjective": "Capacitar-se a explicar e identificar a propriedade em contextos variados.",
                                  "commonMistakes": [
                                    "Generalizar demais sem prova",
                                    "Confundir com safe choice em programação dinâmica"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de Seleção de Atividades, ordene atividades por tempo de término crescente. Escolha a primeira (gulosa). Prove: qualquer solução ótima S com atividade diferente A pode trocar A pela gulosa G (que termina primeiro), liberando mais espaço para o resto, mantendo |S| máximo.",
                              "finalVerifications": [
                                "Defina corretamente a propriedade da escolha gulosa em suas palavras.",
                                "Explique o exchange argument com um diagrama.",
                                "Prove a propriedade para o problema de seleção de atividades.",
                                "Identifique um problema onde a propriedade falha e por quê.",
                                "Crie um checklist para verificar propriedade em novos problemas.",
                                "Explique verbalmente em menos de 2 minutos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (sem omissões chave).",
                                "Clareza na explicação do exchange argument.",
                                "Correta aplicação e prova em exemplo clássico.",
                                "Identificação de limitações e contraexemplos.",
                                "Capacidade de generalizar para outros problemas.",
                                "Uso de linguagem acessível e exemplos visuais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Estruturas Matroides.",
                                "Otimização: Programação Linear Inteira e Relaxações.",
                                "Economia: Tomada de decisões sob restrições locais.",
                                "Filosofia: Racionalidade limitada vs otimalidade global."
                              ],
                              "realWorldApplication": "Em roteirização de entregas (Vehicle Routing), escolher a entrega mais curta primeiro (gulosa) se provada segura, otimizando combustível e tempo em logística como Amazon ou Uber Eats."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2.2",
                            "name": "Verificar propriedade em exemplo",
                            "description": "Analisar um problema simples, como seleção de atividades, para verificar se a propriedade da escolha gulosa se aplica, justificando a seleção do intervalo mais curto primeiro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o problema e preparar o exemplo específico",
                                  "subSteps": [
                                    "Descreva o problema de seleção de atividades: dado um conjunto de intervalos de tempo, selecione o máximo número possível sem sobreposições.",
                                    "Liste 4-6 intervalos com início, fim e comprimento (ex: A[1-3] len=2, B[2-6] len=4, C[5-7] len=2, D[0-8] len=8).",
                                    "Defina claramente o critério guloso: selecionar o intervalo mais curto primeiro entre os compatíveis.",
                                    "Calcule comprimentos para todos os intervalos.",
                                    "Desenhe uma linha do tempo visualizando os intervalos."
                                  ],
                                  "verification": "Exemplo escrito com intervalos, comprimentos e diagrama de linha do tempo completo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Folha quadriculada para diagrama"
                                  ],
                                  "tips": "Use intervalos com comprimentos variados para tornar a verificação interessante.",
                                  "learningObjective": "Compreender o setup do problema e representar visualmente os intervalos.",
                                  "commonMistakes": "Confundir comprimento (fim-início) com ponto de término; ignorar sobreposições parciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e justificar a escolha gulosa inicial",
                                  "subSteps": [
                                    "Ordene os intervalos por comprimento crescente.",
                                    "Selecione o intervalo mais curto como primeira escolha gulosa.",
                                    "Justifique por que essa é uma escolha 'gulosa': localmente ótima por liberar tempo rapidamente.",
                                    "Elimine intervalos que se sobrepõem com a escolha selecionada.",
                                    "Atualize a lista de candidatos restantes."
                                  ],
                                  "verification": "Escolha gulosa identificada, ordenação mostrada e lista atualizada sem sobreposições.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel com lista de intervalos",
                                    "Marcadores para riscar eliminados"
                                  ],
                                  "tips": "Considere sobreposições como qualquer interseção, inclusive bordas.",
                                  "learningObjective": "Reconhecer a heurística gulosa de 'mais curto primeiro' e aplicá-la inicialmente.",
                                  "commonMistakes": "Selecionar pelo menor início em vez de comprimento; não eliminar todos os sobrepostos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o algoritmo guloso completamente e encontrar solução ótima alternativa",
                                  "subSteps": [
                                    "Repita o processo guloso na lista restante até não haver mais intervalos compatíveis.",
                                    "Registre a solução gulosa (ex: A e C, total 2).",
                                    "Manualmente enumere todas as combinações possíveis para encontrar a solução ótima real.",
                                    "Compare o tamanho da solução gulosa com o ótimo.",
                                    "Documente pelo menos uma solução ótima alternativa se existir."
                                  ],
                                  "verification": "Solução gulosa completa listada e pelo menos uma solução ótima alternativa computada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para enumerar combinações",
                                    "Calculadora para contar tamanhos"
                                  ],
                                  "tips": "Para exemplos pequenos, brute-force é viável; foque em máximo não-sobrepostos.",
                                  "learningObjective": "Executar o algoritmo guloso iterativamente e validar contra ótimo exaustivo.",
                                  "commonMistakes": "Parar prematuramente no guloso; confundir máximo número com soma de comprimentos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a propriedade da escolha gulosa com argumento de troca",
                                  "subSteps": [
                                    "Assuma uma solução ótima S* que não inclui a escolha gulosa inicial G.",
                                    "Mostre que existe um intervalo em S* que se sobrepõe com G e tem comprimento >= G.",
                                    "Argumente que trocar esse intervalo por G mantém ou melhora o tamanho de S*.",
                                    "Conclua que toda solução ótima pode incluir G sem perda, provando a propriedade.",
                                    "Generalize se a propriedade segura para o problema inteiro."
                                  ],
                                  "verification": "Argumento de troca escrito passo a passo, concluindo se a propriedade aplica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel para diagramas de troca",
                                    "Exemplo anotado"
                                  ],
                                  "tips": "Use prova por contradição: suponha S* melhor sem G, derive contradição.",
                                  "learningObjective": "Aplicar prova de 'escolha segura' para validar algoritmo guloso.",
                                  "commonMistakes": "Ignorar casos onde troca não é 1:1; assumir propriedade sem prova formal."
                                }
                              ],
                              "practicalExample": "Intervalos: A[1-3] (len=2), B[2-6] (len=4), C[5-7] (len=2), D[0-8] (len=8). Guloso: Escolhe A (mais curto), elimina B e D (sobrepostos), escolhe C. Solução: {A,C} tamanho 2. Ótimo: mesmo tamanho. Troca: Qualquer S* sem A (ex: {B}) tem tamanho 1 < 2; trocar B por A + C possível.",
                              "finalVerifications": [
                                "Pode listar todos os intervalos com comprimentos corretos?",
                                "Descreve a solução gulosa e seu tamanho?",
                                "Apresenta uma solução ótima alternativa?",
                                "Explica o argumento de troca sem falhas lógicas?",
                                "Conclui corretamente se a propriedade da escolha gulosa aplica?",
                                "Generaliza a verificação para o problema?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação e cálculo de comprimentos e sobreposições (30%)",
                                "Correta execução iterativa do algoritmo guloso (20%)",
                                "Validade da solução ótima exaustiva (15%)",
                                "Rigor lógico no argumento de troca/prova (25%)",
                                "Clareza na justificativa e conclusão (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por contradição e indução em otimização combinatória",
                                "Lógica: Argumentos de troca e invariantes em algoritmos",
                                "Gestão de Projetos: Alocação ótima de recursos limitados no tempo",
                                "Física: Escalonamento de experimentos em laboratórios com horários concorrentes"
                              ],
                              "realWorldApplication": "Em centros de conferências, agendar o máximo de workshops curtos sem sobreposições para maximizar participação, justificando heurísticas de priorizar sessões rápidas para eficiência global."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.2.3",
                            "name": "Relacionar com Cormen",
                            "description": "Referenciar a definição de Cormen et al. (2002), explicando como a propriedade é usada na prova de correção de algoritmos gulosos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Localizar e ler a definição de algoritmos gulosos em Cormen et al. (2002)",
                                  "subSteps": [
                                    "Acesse o livro 'Introduction to Algorithms' de Cormen et al., 2ª edição (2001/2002), Capítulo 16 sobre Algoritmos Gulosos.",
                                    "Leia a seção introdutória (páginas aproximadas 385-390) focando na definição formal de algoritmo guloso.",
                                    "Anote os elementos chave: subestrutura ótima e propriedade da escolha gulosa.",
                                    "Identifique a referência exata: 'Um algoritmo guloso resolve problemas de otimização fazendo escolhas locais ótimas em cada etapa.'",
                                    "Compare com definições genéricas para destacar a precisão de Cormen."
                                  ],
                                  "verification": "Você pode citar verbatim a definição de Cormen e listar seus componentes principais em um resumo escrito.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro Introduction to Algorithms (Cormen et al., 2002) - PDF ou cópia física",
                                    "Bloco de notas ou editor de texto"
                                  ],
                                  "tips": "Use a busca por palavras-chave como 'greedy choice property' para navegar rapidamente.",
                                  "learningObjective": "Compreender a definição formal de algoritmos gulosos conforme Cormen.",
                                  "commonMistakes": [
                                    "Confundir com heurísticas em vez de algoritmos exatos",
                                    "Ignorar a edição específica (2002)",
                                    "Não anotar referências de página"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar a Propriedade da Escolha Gulosa conforme Cormen",
                                  "subSteps": [
                                    "Leia a definição da 'greedy choice property' em Cormen: existe uma escolha ótima que pode ser incluída na solução ótima global.",
                                    "Analise o teorema: Se S é uma solução ótima e y é uma escolha gulosa, então existe uma solução ótima que inclui y.",
                                    "Desenhe um diagrama ilustrando a troca de elementos na prova.",
                                    "Relacione com subestrutura ótima: após a escolha gulosa, o subproblema restante tem solução ótima.",
                                    "Resuma em suas palavras: 'A propriedade garante que a escolha local não compromete a otimalidade global.'",
                                    "Compare com contraexemplos onde a propriedade falha."
                                  ],
                                  "verification": "Crie um fluxograma da propriedade e explique-o oralmente ou por escrito sem consultar o livro.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Cormen et al. (Capítulo 16)",
                                    "Papel e caneta para diagramas",
                                    "Ferramenta de desenho como Draw.io"
                                  ],
                                  "tips": "Visualize com árvores de decisão para entender a 'troca' na prova.",
                                  "learningObjective": "Dominar a definição e ilustração da propriedade da escolha gulosa.",
                                  "commonMistakes": [
                                    "Confundir com propriedade de otimalidade local apenas",
                                    "Não diferenciar de 'safe choice'",
                                    "Omitir a parte da subestrutura ótima"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar o uso da propriedade na prova de correção de algoritmos gulosos",
                                  "subSteps": [
                                    "Estude o framework geral de prova em Cormen (Seções 16.1-16.2): lembre-se da solução ótima + troca pela escolha gulosa.",
                                    "Aplique ao exemplo de Atividades com Intervalos: prove que escolher a atividade mais curta primeiro satisfaz a propriedade.",
                                    "Leia provas de outros algoritmos (ex: Huffman, MST) e identifique o padrão: indução + propriedade gulosa.",
                                    "Escreva uma prova genérica: assuma S ótima, substitua por escolha gulosa y, mostre que custo não aumenta.",
                                    "Discuta limitações: nem todo problema guloso tem essa propriedade (ex: 0-1 Knapsack).",
                                    "Crie um template reutilizável para provas futuras."
                                  ],
                                  "verification": "Escreva uma prova completa para um algoritmo guloso simples usando a propriedade de Cormen.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Cormen et al. (Seções 16.1-16.4)",
                                    "Exemplos de códigos ou pseudocódigos de algoritmos gulosos"
                                  ],
                                  "tips": "Use indução matemática: base + passo indutivo com a troca gulosa.",
                                  "learningObjective": "Aplicar a propriedade de Cormen em provas de correção.",
                                  "commonMistakes": [
                                    "Pular a indução e assumir otimalidade",
                                    "Não justificar a troca como custo-neutro",
                                    "Aplicar a problemas não-gulosos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar e relacionar a propriedade com o contexto de algoritmos gulosos",
                                  "subSteps": [
                                    "Resuma: 'Cormen usa a propriedade para provar que escolhas gulosas levam a soluções ótimas via troca e indução.'",
                                    "Compare com outras referências (ex: Kleinberg & Tardos) para validar.",
                                    "Crie um mapa mental conectando definição → propriedade → prova → exemplos.",
                                    "Teste seu entendimento respondendo perguntas como: 'Por que a propriedade é essencial?'",
                                    "Prepare uma explicação de 5 minutos para 'ensinar' o conceito."
                                  ],
                                  "verification": "Grave ou escreva uma explicação clara relacionando tudo, sem erros conceituais.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Mapa mental tool (MindMeister ou papel)",
                                    "Gravação de áudio/vídeo opcional"
                                  ],
                                  "tips": "Ensine para um 'aluno imaginário' para reforçar.",
                                  "learningObjective": "Integrar o conhecimento de Cormen ao contexto da propriedade gulosa.",
                                  "commonMistakes": [
                                    "Generalizar demais sem referência específica",
                                    "Ignorar contraexemplos",
                                    "Não conectar à prova de correção"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de Agendamento de Intervalos (Cormen, Seção 16.1): Escolha gulosa é a atividade com menor tempo de finalização. Prova: Suponha S ótima; troque a primeira atividade de S pela gulosa y (com fim mais cedo), resultando em S' com no máximo |S| atividades, preservando otimalidade.",
                              "finalVerifications": [
                                "Citar corretamente a definição de Cormen et al. (2002) com página aproximada.",
                                "Explicar a propriedade da escolha gulosa com diagrama de troca.",
                                "Aplicar a propriedade em uma prova de correção para um exemplo clássico.",
                                "Identificar quando a propriedade falha em um contraexemplo.",
                                "Resumir o framework de prova guloso em 3 passos.",
                                "Relacionar à subestrutura ótima sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação e referência a Cormen (30%)",
                                "Clareza na explicação da propriedade e seu papel na prova (25%)",
                                "Uso correto de conceitos como troca e indução (20%)",
                                "Exemplos relevantes e aplicação prática (15%)",
                                "Identificação de limitações e erros comuns evitados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por indução matemática e invariantes.",
                                "Lógica Formal: Estruturas de prova por contradição e troca de elementos.",
                                "Filosofia da Ciência: Raciocínio hipotético-dedutivo em algoritmos.",
                                "Economia: Otimização sob restrições com escolhas marginais."
                              ],
                              "realWorldApplication": "Em roteirização de entregas (ex: Amazon): Escolha gulosa de pacote mais próximo primeiro, provada ótima via propriedade de Cormen para garantir eficiência total no tour de veículo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.1.1.3",
                        "name": "Subestrutura Ótima",
                        "description": "Característica dos problemas que permite decompor uma solução ótima em subproblemas cujas soluções ótimas também são subestruturas ótimas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.1.1.3.1",
                            "name": "Definir subestrutura ótima",
                            "description": "Explicar que problemas com subestrutura ótima têm soluções ótimas compostas por soluções ótimas de subproblemas, essencial para algoritmos gulosos e dinâmicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender problemas de otimização e soluções ótimas",
                                  "subSteps": [
                                    "Revise o conceito de problema de otimização: identificar a melhor solução entre várias possibilidades.",
                                    "Defina solução ótima como a que atinge o valor máximo ou mínimo desejado.",
                                    "Diferencie soluções ótimas de soluções viáveis ou heurísticas.",
                                    "Analise um exemplo simples, como maximizar lucro com recursos limitados.",
                                    "Registre em um diagrama a estrutura de um problema de otimização básico."
                                  ],
                                  "verification": "Crie um diagrama de um problema de otimização e explique verbalmente o que é uma solução ótima.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, caneta, acesso a notas de aula sobre otimização.",
                                  "tips": "Use analogias cotidianas, como escolher a rota mais curta no trânsito.",
                                  "learningObjective": "Entender a base de problemas de otimização e o conceito de solução ótima.",
                                  "commonMistakes": "Confundir solução ótima com a primeira solução encontrada."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e exemplificar subestrutura ótima",
                                  "subSteps": [
                                    "Leia a definição: um problema possui subestrutura ótima se sua solução ótima é composta por soluções ótimas de subproblemas.",
                                    "Estude a propriedade formal: OPT(S) = melhor subproblema + OPT(subproblemas restantes).",
                                    "Identifique subproblemas como partes menores e independentes do problema original.",
                                    "Compare com problemas sem subestrutura ótima, como o problema da mochila 0/1.",
                                    "Anote a definição em suas próprias palavras."
                                  ],
                                  "verification": "Escreva a definição de subestrutura ótima e dê um exemplo curto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Livro ou slides sobre algoritmos gulosos, caderno.",
                                  "tips": "Pense em 'construir blocos' onde cada bloco é o melhor possível.",
                                  "learningObjective": "Dominar a definição precisa de subestrutura ótima.",
                                  "commonMistakes": "Achar que todo problema de otimização tem subestrutura ótima automaticamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar subestrutura ótima em problemas reais",
                                  "subSteps": [
                                    "Escolha um problema candidato, como seleção de atividades não sobrepostas.",
                                    "Divida o problema em subproblemas: considere a atividade com menor tempo de término.",
                                    "Verifique se a solução ótima inclui a solução ótima do subproblema restante.",
                                    "Prove por contradição: suponha que não seja ótima e encontre inconsistência.",
                                    "Repita com outro exemplo, como problema das frações."
                                  ],
                                  "verification": "Para um problema dado, descreva os subproblemas e prove a subestrutura ótima.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de problemas de algoritmos gulosos, calculadora.",
                                  "tips": "Sempre ordene os elementos para facilitar a identificação de subproblemas.",
                                  "learningObjective": "Aplicar a verificação de subestrutura ótima em problemas concretos.",
                                  "commonMistakes": "Ignorar dependências entre subproblemas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com algoritmos gulosos e programação dinâmica",
                                  "subSteps": [
                                    "Explique como subestrutura ótima permite escolha gulosa: selecione o melhor localmente.",
                                    "Compare com DP: subestrutura ótima + sobreposição de subproblemas.",
                                    "Discuta quando falha: exemplo de problema sem essa propriedade.",
                                    "Crie um fluxograma mostrando o papel na decisão gulosa.",
                                    "Resuma a importância para eficiência algorítmica."
                                  ],
                                  "verification": "Crie um fluxograma ligando subestrutura ótima a um algoritmo guloso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de diagrama (Draw.io ou papel), pseudocódigo.",
                                  "tips": "Lembre: gulosos usam subestrutura ótima sem memoização.",
                                  "learningObjective": "Conectar o conceito a paradigmas algorítmicos maiores.",
                                  "commonMistakes": "Confundir subestrutura ótima com optimalidade global garantida sem prova."
                                }
                              ],
                              "practicalExample": "No problema de seleção de atividades: dada uma lista de atividades com horários de início e fim, ordene por tempo de término. A solução ótima inclui a primeira atividade possível e a solução ótima recursiva para as restantes, provando subestrutura ótima.",
                              "finalVerifications": [
                                "Defina subestrutura ótima corretamente sem erros.",
                                "Identifique subproblemas em pelo menos dois exemplos clássicos.",
                                "Prove a propriedade para um problema guloso dado.",
                                "Diferencie de problemas sem subestrutura ótima.",
                                "Explique o impacto em algoritmos gulosos e DP.",
                                "Crie um diagrama ilustrando a composição de soluções."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (100% correta).",
                                "Capacidade de identificar e provar em exemplos (clareza lógica).",
                                "Conexão com algoritmos gulosos e DP (profundidade).",
                                "Uso de exemplos concretos e diagramas.",
                                "Evitar de erros comuns como confusão com optimalidade local.",
                                "Fluência na explicação verbal ou escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização linear e inteira.",
                                "Programação: Implementação de recursão e memoização.",
                                "Economia: Alocação ótima de recursos escassos.",
                                "Engenharia: Design de sistemas com decisões locais ótimas."
                              ],
                              "realWorldApplication": "Em roteirização de veículos (selecionar rotas ótimas compostas por sub-rotas), agendamento de tarefas em fábricas ou compiladores otimizando código com escolhas gulosas baseadas em subestruturas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3.2",
                            "name": "Diferenciar de programação dinâmica",
                            "description": "Comparar subestrutura ótima em gulosos (escolha única local) versus dinâmica (considera múltiplas opções com memoização).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Subestrutura Ótima em Algoritmos Gulosos",
                                  "subSteps": [
                                    "Defina subestrutura ótima: solução ótima para subproblema leva à solução global ótima.",
                                    "Explique escolha gulosa: seleciona opção localmente ótima em cada passo.",
                                    "Discuta propriedade: decisão irreversível sem backtracking.",
                                    "Identifique pré-requisito: problema deve satisfazer 'escolha gulosa segura'.",
                                    "Liste exemplos clássicos como seleção de atividades."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e dê um exemplo simples sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo de algoritmo guloso para Interval Scheduling",
                                    "Diagrama de árvore de decisões gulosa"
                                  ],
                                  "tips": "Visualize como uma 'corrida' onde cada escolha acelera o progresso sem olhar para trás.",
                                  "learningObjective": "Compreender como a subestrutura ótima gulosa depende de escolhas locais únicas.",
                                  "commonMistakes": "Confundir com backtracking; gulosos não revisam decisões passadas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Subestrutura Ótima em Programação Dinâmica",
                                  "subSteps": [
                                    "Defina subestrutura ótima: solução ótima combina soluções de subproblemas sobrepostos.",
                                    "Explique memoização: armazena resultados de subproblemas para evitar recomputação.",
                                    "Descreva abordagem bottom-up ou top-down com tabela de DP.",
                                    "Discuta múltiplas opções: considera todas as vias possíveis até encontrar ótima.",
                                    "Liste exemplos como problema da mochila (Knapsack)."
                                  ],
                                  "verification": "Construa uma tabela DP simples para um subproblema de Knapsack com n=3 itens.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de DP para 0/1 Knapsack",
                                    "Tabela de exemplo preenchida passo a passo"
                                  ],
                                  "tips": "Pense em DP como 'construir uma casa tijolo por tijolo', reutilizando tijolos já feitos.",
                                  "learningObjective": "Dominar como DP lida com múltiplas opções via sobreposição e memoização.",
                                  "commonMistakes": "Ignorar sobreposição de subproblemas; sempre verifique se subproblemas se repetem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Diferenças Chave entre Gulosos e Dinâmica",
                                  "subSteps": [
                                    "Compare escolha: guloso (única local) vs DP (múltiplas com memoização).",
                                    "Analise complexidade: guloso O(n log n) vs DP O(nW) ou exponencial sem memo.",
                                    "Discuta garantias: guloso precisa de prova matemática vs DP sempre ótima.",
                                    "Identifique trade-offs: velocidade guloso vs exatidão DP.",
                                    "Crie tabela comparativa com colunas: Estrutura, Exemplo, Quando falha."
                                  ],
                                  "verification": "Preencha uma tabela comparativa com pelo menos 4 linhas de diferenças.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Tabela modelo em branco para comparação",
                                    "Exemplos de problemas onde guloso falha (ex: Knapsack)"
                                  ],
                                  "tips": "Use setas para mostrar fluxo: guloso 'vai reto', DP 'explora ramificações'.",
                                  "learningObjective": "Identificar e articular diferenças fundamentais em subestrutura ótima.",
                                  "commonMistakes": "Assumir gulosos sempre corretos; teste com contraexemplos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar Comparação em um Exemplo Prático",
                                  "subSteps": [
                                    "Escolha problema: Seleção de Atividades (guloso funciona) vs Fração Knapsack (guloso) e 0/1 (DP).",
                                    "Implemente guloso e verifique otimalidade.",
                                    "Simule DP no mesmo problema e compare resultados/tempo.",
                                    "Analise por que um funciona e outro não.",
                                    "Documente lições aprendidas."
                                  ],
                                  "verification": "Execute ambos algoritmos em código ou papel e compare saídas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código Python simples para ambos algoritmos",
                                    "Dataset de teste com 10 atividades/itens"
                                  ],
                                  "tips": "Comece com instâncias pequenas onde ambos diferem para ver falhas claramente.",
                                  "learningObjective": "Aplicar diferenciação prática para reforçar conceitos.",
                                  "commonMistakes": "Usar problema onde ambos funcionam; escolha um onde guloso falha."
                                }
                              ],
                              "practicalExample": "No problema de Seleção de Atividades: Guloso ordena por fim mais cedo (escolha local única → ótima global). No 0/1 Knapsack: Guloso por densidade falha (ex: itens A=valor10/peso6, B=valor8/peso5, C=valor7/peso4; guloso pega A+C=17, ótimo B+C=15? Espera, ajuste: clássico onde densidade engana). DP considera todas combinações com memoização para 17 ótima.",
                              "finalVerifications": [
                                "Explique em 1 frase: 'Por que gulosos não precisam de memoização?'",
                                "Dê um exemplo onde guloso é ótimo e DP é desnecessário.",
                                "Identifique 2 condições para subestrutura ótima gulosa.",
                                "Compare tempo: O(n log n) vs O(n²) em tabela.",
                                "Resolva mini-problema: 'Guloso ou DP para troco ótimo?'",
                                "Liste 3 diferenças em subestrutura ótima."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de subestrutura ótima gulosa (sem backtracking).",
                                "Correta explicação de memoização e sobreposição em DP.",
                                "Tabela comparativa completa com pelo menos 4 diferenças chave.",
                                "Exemplo prático mostrando falha de guloso onde DP succeeds.",
                                "Uso correto de terminologia (ex: 'escolha segura' vs 'otimalidade ótima').",
                                "Análise de trade-offs (tempo vs garantia de otimalidade)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização linear e provas por indução.",
                                "Economia: Tomada de decisões sob restrições (marginal vs global).",
                                "Física: Princípio da menor ação (escolha local ótima).",
                                "Gestão: Planejamento de projetos (crítico path vs exploração)."
                              ],
                              "realWorldApplication": "Em roteirização de entregas (guloso para heurística rápida em GPS como Google Maps) vs otimização de portfólio financeiro (DP para combinações exatas de ativos sob risco)."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3.3",
                            "name": "Aplicar em contexto guloso",
                            "description": "Demonstrar como a subestrutura ótima suporta a extensão da escolha gulosa para o problema restante após uma iteração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição de subestrutura ótima em algoritmos gulosos",
                                  "subSteps": [
                                    "Defina subestrutura ótima como a propriedade onde a solução ótima para o problema inclui uma solução ótima para um subproblema relevante.",
                                    "Explique que em algoritmos gulosos, após a escolha gulosa, o subproblema restante deve preservar essa propriedade.",
                                    "Diferencie de programação dinâmica, onde subestruturas se sobrepõem.",
                                    "Estude exemplos clássicos como seleção de intervalos para ilustrar.",
                                    "Anote as condições necessárias para subestrutura ótima em contextos gulosos."
                                  ],
                                  "verification": "Escreva uma definição precisa em suas próprias palavras e compare com fontes confiáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas de aula sobre algoritmos gulosos",
                                    "Pseudocódigo de exemplo de interval scheduling"
                                  ],
                                  "tips": "Use diagramas para visualizar a decomposição do problema em subproblemas.",
                                  "learningObjective": "Compreender o conceito fundamental de subestrutura ótima aplicado a escolhas gulosas.",
                                  "commonMistakes": [
                                    "Confundir com optimalidade global sem verificar subproblemas",
                                    "Ignorar a necessidade de prova formal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e realizar a escolha gulosa inicial",
                                  "subSteps": [
                                    "Selecione o critério guloso específico do problema (ex: menor finalização em interval scheduling).",
                                    "Aplique a escolha gulosa à instância do problema.",
                                    "Remova a escolha do problema original, gerando o subproblema restante.",
                                    "Documente o custo ou valor da escolha gulosa.",
                                    "Verifique se a escolha é segura e não compromete a otimalidade."
                                  ],
                                  "verification": "Simule a escolha em um exemplo pequeno e liste o subproblema resultante.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de problema de seleção de atividades",
                                    "Folha de cálculo ou papel para simulação"
                                  ],
                                  "tips": "Sempre priorize a escolha que maximiza o progresso imediato sem olhar para o futuro.",
                                  "learningObjective": "Executar a primeira iteração gulosa corretamente, identificando o subproblema.",
                                  "commonMistakes": [
                                    "Escolher incorretamente o critério guloso",
                                    "Não isolar completamente o subproblema"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que o subproblema preserva a subestrutura ótima",
                                  "subSteps": [
                                    "Assuma uma solução ótima S* para o problema original.",
                                    "Mostre que S* inclui a escolha gulosa ou uma equivalente.",
                                    "Prove por contradição que qualquer solução ótima deve incluir a escolha gulosa.",
                                    "Demonstre que o restante de S* é ótimo para o subproblema.",
                                    "Formalize usando indução ou propriedades do problema."
                                  ],
                                  "verification": "Escreva uma prova curta (3-5 linhas) para um exemplo específico.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Template de prova por contradição",
                                    "Livro de algoritmos (ex: CLRS, seção de gulosos)"
                                  ],
                                  "tips": "Use 'seja S* uma solução ótima' como ponto de partida em provas.",
                                  "learningObjective": "Dominar a prova de extensão da escolha gulosa ao subproblema.",
                                  "commonMistakes": [
                                    "Pular a contradição para soluções alternativas",
                                    "Não induzir para iterações múltiplas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e verificar em um exemplo completo",
                                  "subSteps": [
                                    "Escolha um problema guloso clássico (ex: interval scheduling).",
                                    "Execute múltiplas iterações, verificando subestrutura em cada uma.",
                                    "Compare a solução gulosa com uma solução ótima exaustiva.",
                                    "Generalize para o problema inteiro.",
                                    "Registre lições aprendidas sobre falhas potenciais."
                                  ],
                                  "verification": "A solução gulosa coincide com a ótima e todas as subestruturas foram validadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Conjunto de dados de teste com 10 intervalos",
                                    "Implementação simples em Python ou pseudocódigo"
                                  ],
                                  "tips": "Teste com casos degenerados (ex: intervalos sobrepostos) para robustez.",
                                  "learningObjective": "Integrar o conceito em uma resolução completa de problema.",
                                  "commonMistakes": [
                                    "Assumir sem provar em todas as iterações",
                                    "Usar problemas não-gulosos"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de Agendamento de Intervalos: Escolha o intervalo com menor tempo de finalização (gulosa). Prove que qualquer agendamento ótimo inclui este ou equivalente, e o subproblema (intervalos restantes compatíveis) tem solução ótima gulosa recursiva. Exemplo: Intervalos [(1,4), (3,5), (0,6), (5,7), (8,9), (5,9)]. Escolha (1,4), subproblema preserva otimalidade.",
                              "finalVerifications": [
                                "Explica verbalmente como a subestrutura ótima suporta a iteração gulosa.",
                                "Dado um problema, identifica corretamente o subproblema após escolha gulosa.",
                                "Escreve uma prova válida para um novo exemplo.",
                                "Simula 3 iterações sem erros.",
                                "Distingue problemas onde isso falha (ex: não-gulosos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da escolha gulosa (100% correta).",
                                "Validade da prova de subestrutura ótima (lógica sem falhas).",
                                "Número e detalhe de subpassos em simulações (mínimo 4 por iteração).",
                                "Capacidade de generalização para problemas similares.",
                                "Tempo de resolução eficiente sem comprometer acurácia.",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Provas por indução e contradição.",
                                "Programação: Implementação recursiva de algoritmos gulosos.",
                                "Otimização: Comparação com programação dinâmica e lineares.",
                                "Engenharia de Software: Design de algoritmos eficientes."
                              ],
                              "realWorldApplication": "Em gerenciamento de projetos (agendamento de tarefas não sobrepostas para maximizar produtividade), compiladores (seleção de registros greedy), ou redes (alocação de canais de frequência minimizando interferências)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.1.1.3.4",
                            "name": "Identificar falhas sem subestrutura",
                            "description": "Exemplificar problemas onde falta subestrutura ótima, como o problema da mochila 0/1, explicando por que greedy falha.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Conceito de Subestrutura Ótima em Algoritmos Gulosos",
                                  "subSteps": [
                                    "Defina subestrutura ótima: uma solução ótima para o problema completo contém soluções ótimas para subproblemas.",
                                    "Explique como greedy explora isso escolhendo a opção localmente ótima assumindo que leva à global.",
                                    "Discuta pré-condição: greedy funciona só se subestrutura ótima existir.",
                                    "Liste exemplos onde greedy succeeds (ex: seleção de atividades).",
                                    "Compare com DP que sempre constrói subestruturas ótimas."
                                  ],
                                  "verification": "Escreva uma definição precisa de subestrutura ótima e dê um exemplo onde ela existe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou editor de texto; acesso a notas de aula sobre greedy.",
                                  "tips": "Use diagramas para visualizar como soluções parciais se combinam em ótimas.",
                                  "learningObjective": "Compreender a dependência de greedy na propriedade de subestrutura ótima.",
                                  "commonMistakes": "Confundir subestrutura ótima com otimalidade local; assumir que todo problema de otimização tem essa propriedade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender o Problema da Mochila 0/1",
                                  "subSteps": [
                                    "Descreva o problema: maximizar valor de itens com pesos ≤ capacidade W, cada item 0 ou 1 vez.",
                                    "Defina entrada: lista de itens com peso wi e valor vi; saída: subconjunto máximo valor sem exceder W.",
                                    "Calcule solução ótima manualmente para um pequeno exemplo (ex: W=10, itens: (w=5,v=10), (w=6,v=12), (w=3,v=6)).",
                                    "Identifique que é NP-difícil, mas para fins pedagógicos use instâncias pequenas.",
                                    "Discuta fractional knapsack como variação onde greedy funciona."
                                  ],
                                  "verification": "Resolva um exemplo pequeno e liste o subconjunto ótimo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Calculadora ou planilha; exemplos impressos ou online de knapsack.",
                                  "tips": "Comece com W pequeno para enumerar todas possibilidades.",
                                  "learningObjective": "Dominar formulação e solução exata do problema da mochila 0/1.",
                                  "commonMistakes": "Confundir 0/1 com unbounded knapsack; ignorar restrição binária."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Abordagem Greedy e Identificar Falha",
                                  "subSteps": [
                                    "Escolha heurística greedy comum: ordene por vi/wi (maior densidade primeiro).",
                                    "Aplique ao exemplo: pegue item de maior densidade até encher mochila.",
                                    "Compare valor greedy vs. ótimo: mostre caso onde greedy dá menos (ex: itens A:(5,10), B:(6,12), C:(3,6) com W=10; greedy pega A+C=16, ótimo B+C=18).",
                                    "Teste outras heurísticas (maior valor, menor peso) e veja falhas semelhantes.",
                                    "Registre o contraexemplo onde greedy falha."
                                  ],
                                  "verification": "Construa um contraexemplo onde greedy obtém valor subótimo e calcule a diferença.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela comparativa em papel ou Excel para valores greedy vs. ótimo.",
                                  "tips": "Sempre compute densidade vi/wi para ilustrar por que essa heurística intuitiva falha.",
                                  "learningObjective": "Demonstrar empiricamente falha de greedy na mochila 0/1.",
                                  "commonMistakes": "Escolher heurística que acidentalmente funciona no exemplo; não quantificar perda."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar Por Que Falta Subestrutura Ótima",
                                  "subSteps": [
                                    "Analise: em greedy, após escolher item localmente ótimo, subproblema restante pode não ter solução ótima combinável.",
                                    "No contraexemplo, escolher A (alta densidade) bloqueia B (melhor globalmente com C).",
                                    "Formalize: suponha S* ótimo; greedy pode divergir cedo sem preservar otimalidade de resto.",
                                    "Contrast com fractional knapsack onde cortar permite subestrutura.",
                                    "Generalize: problemas com dependências não-greedy carecem dessa propriedade."
                                  ],
                                  "verification": "Escreva parágrafo explicando mecanismo da falha usando contraexemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Pseudocódigo de greedy; diagrama de árvore de decisões.",
                                  "tips": "Use prova por contradição: assuma greedy funciona e encontre violação.",
                                  "learningObjective": "Raciocinar teoricamente sobre ausência de subestrutura ótima.",
                                  "commonMistakes": "Atribuir falha só a 'má heurística' sem ligar à subestrutura."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Generalizar e Verificar Compreensão",
                                  "subSteps": [
                                    "Liste outros problemas sem subestrutura ótima (ex: TSP, scheduling com deadlines).",
                                    "Discuta teste matroid para greedy funcionar.",
                                    "Crie seu próprio contraexemplo para knapsack.",
                                    "Resuma critérios para identificar falta de subestrutura: existência de contraexemplos greedy.",
                                    "Planeje como testar em novos problemas."
                                  ],
                                  "verification": "Identifique 2 problemas similares e explique falha greedy.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Lista de problemas de otimização clássicos.",
                                  "tips": "Procure padrões: problemas com 'trade-offs irrecuperáveis' falham.",
                                  "learningObjective": "Aplicar lição a problemas além de knapsack.",
                                  "commonMistakes": "Generalizar excessivamente sem contraexemplos."
                                }
                              ],
                              "practicalExample": "Capacidade W=10. Itens: A (peso 5, valor 10, densidade 2), B (6,12,2), C (3,6,2). Greedy por densidade pega A então C (total 16). Ótimo: B+C (18). Falha porque A bloqueia combinação melhor.",
                              "finalVerifications": [
                                "Pode construir contraexemplo onde greedy falha na knapsack 0/1?",
                                "Explica por que subestrutura ótima falta nesse caso?",
                                "Distingue knapsack 0/1 de fractional onde greedy succeeds?",
                                "Identifica heurísticas comuns e suas falhas?",
                                "Aplica conceito a outro problema sem subestrutura ótima?",
                                "Resume teste para subestrutura ótima em greedy?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de subestrutura ótima (20%)",
                                "Correção do contraexemplo e cálculos (25%)",
                                "Explicação clara da falha greedy (25%)",
                                "Generalização para outros problemas (15%)",
                                "Uso de verificações e dicas (10%)",
                                "Clareza e estrutura da resposta (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização combinatória e teoria de matroides.",
                                "Programação: Implementação de DP vs. greedy em código.",
                                "Economia: Alocação de recursos limitados com trade-offs.",
                                "Física: Problemas de empacotamento e otimização de carga."
                              ],
                              "realWorldApplication": "Em logística de entregas (ex: FedEx otimizando carga de aviões), onde selecionar pacotes binários sem subestrutura ótima leva a perdas; usa DP ou aproximações em vez de puro greedy."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.2",
                    "name": "Propriedade da Escolha Gulosa",
                    "description": "Condição que garante que a escolha local ótima preserva a possibilidade de solução ótima global.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.2.1",
                        "name": "Definição da Propriedade da Escolha Gulosa",
                        "description": "Conceito fundamental que estabelece que existe uma solução ótima global que inclui a escolha local ótima feita pelo algoritmo guloso, preservando a otimalidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.1.1",
                            "name": "Explicar a definição formal",
                            "description": "Descrever com precisão a propriedade da escolha gulosa conforme definida em Cormen et al., destacando que para todo subproblema, existe uma solução ótima que inclui a escolha gulosa local.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Algoritmos de Otimização",
                                  "subSteps": [
                                    "Leia a seção introdutória sobre problemas de otimização em Cormen et al.",
                                    "Identifique diferenças entre problemas de otimização e de decisão.",
                                    "Anote exemplos de problemas que admitem soluções ótimas globais via escolhas locais.",
                                    "Defina informalmente 'algoritmo guloso' como uma heurística que faz a melhor escolha imediata.",
                                    "Discuta por que nem todos os problemas permitem isso."
                                  ],
                                  "verification": "Escreva um resumo de 100 palavras explicando otimização vs. decisão e dê um exemplo de algoritmo guloso falhando.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro 'Introduction to Algorithms' (Cormen et al.), caderno e caneta",
                                  "tips": "Use diagramas para visualizar soluções ótimas vs. subótimas.",
                                  "learningObjective": "Compreender o contexto de problemas de otimização onde a propriedade gulosa se aplica.",
                                  "commonMistakes": "Confundir otimização com busca exaustiva; assumir que guloso sempre funciona."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Escolha Gulosa Informalmente",
                                  "subSteps": [
                                    "Defina 'escolha gulosa local' como a opção que parece melhor no momento atual.",
                                    "Explique 'solução ótima global' como a melhor solução para todo o problema.",
                                    "Discuta a intuição: a escolha local não compromete a otimalidade global.",
                                    "Liste condições necessárias: subproblemas devem herdar estrutura ótima.",
                                    "Compare com programação dinâmica, onde escolhas locais podem ser revistas."
                                  ],
                                  "verification": "Crie um fluxograma mostrando como uma escolha local leva à global em um problema simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Livro Cormen (Capítulo 16), software de diagramação como Draw.io",
                                  "tips": "Pense em 'guloso' como 'avareza' que funciona quando o futuro não contradiz o presente.",
                                  "learningObjective": "Diferenciar escolha gulosa local de solução ótima global intuitivamente.",
                                  "commonMistakes": "Ignorar que a propriedade requer prova; generalizar para todos os problemas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Apresentar e Dissecar a Definição Formal de Cormen",
                                  "subSteps": [
                                    "Localize a definição exata no Cormen: 'Uma solução ótima para todo subproblema após a primeira escolha contém a escolha gulosa'.",
                                    "Parse a notação: Seja OPT uma solução ótima para o subproblema S; existe OPT' ótima tal que OPT' inclui a escolha gulosa g.",
                                    "Escreva formalmente: Para todo subproblema após g, ∃ solução ótima incluindo g.",
                                    "Explique 'para todo subproblema': aplica recursivamente.",
                                    "Reescreva em pseudocódigo ou proposição matemática."
                                  ],
                                  "verification": "Reescreva a definição verbatim e parafraseie em suas palavras, citando página do Cormen.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Cormen et al. (páginas 389-390, 3ª ed.), LaTeX ou editor de texto para fórmulas",
                                  "tips": "Use símbolos: g* para escolha gulosa, OPT(S) para ótima de S.",
                                  "learningObjective": "Memorizar e explicar precisamente a definição formal da propriedade.",
                                  "commonMistakes": "Omitir 'para todo subproblema'; confundir com propriedade de otimalidade ótima."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a Propriedade com Exemplo e Contraexemplo",
                                  "subSteps": [
                                    "Aplique à seleção de atividades: escolha gulosa = atividade que termina primeiro.",
                                    "Prove que existe solução ótima incluindo essa escolha (troca argumento).",
                                    "Teste em problema onde falha, como mochila fracionária sem propriedade.",
                                    "Gere diagrama mostrando subproblemas após escolha gulosa.",
                                    "Resuma prova por indução implícita na definição."
                                  ],
                                  "verification": "Resolva um problema de exemplo mostrando explicitamente a existência da solução ótima gulosa.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Papel quadriculado, exemplos do Cormen (Seção 16.1), calculadora",
                                  "tips": "Sempre pergunte: 'Posso trocar a escolha gulosa por outra sem piorar?'",
                                  "learningObjective": "Aplicar a definição formal para validar ou refutar em casos concretos.",
                                  "commonMistakes": "Confundir propriedade gulosa com segurança gulosa; pular prova de existência."
                                }
                              ],
                              "practicalExample": "No problema de Interval Scheduling (Cormen 16.1): Dadas atividades com intervalos, escolha gulosa: selecione a que termina primeiro. A propriedade segura que existe uma solução ótima para o subproblema restante (atividades compatíveis após o fim) que inclui essa escolha, permitindo construção recursiva da solução ótima.",
                              "finalVerifications": [
                                "Pode citar verbatim a definição de Cormen e explicar cada termo?",
                                "Identifica corretamente 'para todo subproblema' como chave recursiva?",
                                "Aplica a propriedade corretamente em um exemplo como seleção de atividades?",
                                "Distingue da propriedade de subestrutura ótima?",
                                "Explica por que a definição garante construção gulosa da solução ótima?",
                                "Fornece contraexemplo onde propriedade falha?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na citação da definição formal (100% match com Cormen).",
                                "Clareza na explicação de 'escolha gulosa local' vs. 'ótima global'.",
                                "Correta identificação do papel recursivo dos subproblemas.",
                                "Uso apropriado de notação matemática ou pseudocódigo.",
                                "Aplicação válida em pelo menos um exemplo com prova de troca.",
                                "Ausência de confusões com outras propriedades (ex: matroide)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por indução e existência em teoria de conjuntos.",
                                "Lógica: Raciocínio dedutivo e propriedades existenciais.",
                                "Filosofia: Decisões locais vs. consequências globais em ética utilitária.",
                                "Economia: Otimização marginal em teoria dos jogos."
                              ],
                              "realWorldApplication": "Em roteamento de redes (algoritmo de Dijkstra), a propriedade gulosa permite escolher o menor caminho parcial com garantia de otimalidade global para distâncias não-negativas, usado em GPS e internet routing para eficiência em tempo real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.2",
                            "name": "Diferenciar de outras propriedades",
                            "description": "Comparar a propriedade da escolha gulosa com a estrutura ótima de subproblemas, explicando por que ambas são necessárias para algoritmos gulosos corretos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Definição da Propriedade da Escolha Gulosa",
                                  "subSteps": [
                                    "Leia a definição formal: uma escolha gulosa é ótima se pode ser estendida para uma solução ótima global.",
                                    "Identifique exemplos clássicos como seleção de atividades ou Huffman coding.",
                                    "Anote os elementos chave: escolha local ótima leva a global ótima.",
                                    "Compare com intuição: 'escolha agora o melhor disponível'.",
                                    "Registre uma frase resumida em suas palavras."
                                  ],
                                  "verification": "Escreva um parágrafo definindo a propriedade e dê um exemplo simples; verifique se menciona extensão para solução ótima.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Livro-texto de Algoritmos (ex: CLRS), notas de aula sobre algoritmos gulosos, quadro branco ou papel para anotações.",
                                  "tips": "Use diagramas de árvore de decisões para visualizar como a escolha inicial se propaga.",
                                  "learningObjective": "Compreender precisamente o que a propriedade da escolha gulosa afirma sobre soluções locais e globais.",
                                  "commonMistakes": "Confundir com mera heurística gulosa sem garantia de otimalidade; ignorar a extensão para solução ótima."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar a Estrutura Ótima de Subproblemas",
                                  "subSteps": [
                                    "Defina formalmente: solução ótima do problema contém soluções ótimas de subproblemas.",
                                    "Estude exemplos como problema da mochila ou MST (árvore geradora mínima).",
                                    "Destaque recursão: subproblema após remoção de elementos da solução ótima.",
                                    "Anote diferenças com programação dinâmica vs. guloso.",
                                    "Crie um fluxograma mostrando decomposição em subproblemas."
                                  ],
                                  "verification": "Desenhe um diagrama de um problema guloso mostrando subproblemas ótimos; confirme se todos os subproblemas são resolvidos independentemente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "CLRS capítulo sobre gulosos, exemplos online de Kruskal/Prim, software de desenho como Draw.io.",
                                  "tips": "Pense em 'dividir para conquistar' mas com otimalidade preservada em cada divisão.",
                                  "learningObjective": "Dominar como a estrutura ótima permite construção recursiva de soluções.",
                                  "commonMistakes": "Achar que é só 'problema menor'; esquecer que deve ser ótima, não apenas factível."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar as Duas Propriedades Diretamente",
                                  "subSteps": [
                                    "Crie uma tabela comparativa: foco (local vs. recursivo), dependência (inicial vs. subsequente), prova (troca vs. indução).",
                                    "Analise um exemplo compartilhado como seleção de atividades: aplique cada propriedade.",
                                    "Identifique similaridades: ambas garantem otimalidade.",
                                    "Destaque diferenças: escolha gulosa é sobre o primeiro passo; subestrutura é sobre o resto.",
                                    "Discuta cenários onde uma falha mas a outra segura."
                                  ],
                                  "verification": "Preencha tabela comparativa com pelo menos 5 linhas de diferenças/semelhanças; revise com um colega ou autoavaliação.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Google Sheets ou papel para tabela, exemplos de algoritmos gulosos impressos.",
                                  "tips": "Use setas para mostrar fluxo: escolha gulosa → subproblema ótimo → solução global.",
                                  "learningObjective": "Discernir claramente as distinções e sobreposições entre as propriedades.",
                                  "commonMistakes": "Tratar como sinônimos; ignorar que escolha gulosa é específica para o passo inicial."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar a Necessidade Conjunta para Correção Gulosa",
                                  "subSteps": [
                                    "Descreva prova de correção: escolha gulosa + subestrutura ótima = algoritmo correto.",
                                    "Use contraexemplo: algoritmo com só uma propriedade falha (ex: mochila 0/1 sem subestrutura gulosa).",
                                    "Simule prova por troca: substitua escolha não-gulosa por gulosa sem piorar.",
                                    "Conclua por indução: base (escolha) + passo (subestrutura).",
                                    "Resuma em um diagrama de dependência."
                                  ],
                                  "verification": "Escreva uma explicação de 200 palavras provando por que faltar uma invalida o guloso; teste com exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Pseudocódigo de algoritmo guloso, vídeo explicativo de provas gulosas (YouTube/Khan Academy).",
                                  "tips": "Lembre: sem escolha gulosa, primeira decisão erra; sem subestrutura, resto não segue.",
                                  "learningObjective": "Justificar matematicamente por que ambas propriedades são indispensáveis.",
                                  "commonMistakes": "Achar que uma implica a outra; subestimar contraexemplos."
                                }
                              ],
                              "practicalExample": "No algoritmo de Kruskal para MST: Propriedade da escolha gulosa permite adicionar a menor aresta sem ciclo inicialmente (escolha local segura). Estrutura ótima de subproblemas garante que o resto do grafo forma um MST ótimo após remoção. Sem ambas, poderíamos adicionar arestas erradas ou falhar em completar o spanning tree.",
                              "finalVerifications": [
                                "Explique verbalmente a diferença entre as propriedades sem consultar notas.",
                                "Identifique qual propriedade falha em um contraexemplo dado (ex: mochila 0/1).",
                                "Construa tabela comparativa de memória para dois algoritmos gulosos.",
                                "Prove correção de um algoritmo simples usando ambas propriedades.",
                                "Diferencie de propriedade de matroide ou troca segura.",
                                "Aplique conceitos a um novo problema hipotético."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas sem confusões (30%)",
                                "Clareza na comparação: tabela ou explicação destacando diferenças chave (25%)",
                                "Profundidade na justificação: uso de provas/contraexemplos (20%)",
                                "Exemplos relevantes: aplicação prática a algoritmos reais (15%)",
                                "Comunicação: explicação concisa e estruturada (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por indução matemática e recursão.",
                                "Lógica: Análise de contraexemplos e silogismos deductivos.",
                                "Filosofia: Raciocínio sobre otimalidade local vs. global (utilitarismo).",
                                "Economia: Decisões marginais em otimização de recursos."
                              ],
                              "realWorldApplication": "Em roteirização de entregas (ex: GPS como Waze), a escolha gulosa inicial (próxima parada mais curta) combinada com subestrutura ótima garante rota eficiente global, evitando loops infinitos ou caminhos subótimos em logística real."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.1.3",
                            "name": "Identificar em problemas simples",
                            "description": "Reconhecer a propriedade em problemas como seleção de intervalos ou troca de moedas, justificando por que a escolha gulosa local é segura.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição da Propriedade da Escolha Gulosa",
                                  "subSteps": [
                                    "Ler e anotar a definição formal: a propriedade afirma que uma solução ótima contém uma escolha gulosa localmente ótima como parte dela.",
                                    "Identificar os elementos chave: escolha local ótima, prova de segurança (exchange argument).",
                                    "Diferenciar da subestrutura ótima: foco na escolha inicial vs. recursão em subproblemas.",
                                    "Estudar quando a propriedade falha: exemplos como mochila fracionária sem essa propriedade.",
                                    "Resumir em um diagrama: escolha local → extensão para ótima global."
                                  ],
                                  "verification": "Escrever um resumo de 3-5 frases explicando a propriedade e dar um exemplo onde ela não se aplica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre algoritmos gulosos",
                                    "Papel e caneta",
                                    "Vídeo introdutório sobre greedy algorithms (ex: YouTube - MIT OCW)"
                                  ],
                                  "tips": "Use analogia: como escolher o maior pedaço de bolo primeiro sem desperdiçar o resto.",
                                  "learningObjective": "Definir com precisão a propriedade da escolha gulosa e seus requisitos.",
                                  "commonMistakes": [
                                    "Confundir com subestrutura ótima",
                                    "Assumir que toda heurística gulosa tem essa propriedade",
                                    "Ignorar a necessidade de prova de segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Exemplo Clássico de Seleção de Intervalos",
                                  "subSteps": [
                                    "Descrever o problema: dado n intervalos, selecionar o máximo sem sobreposição.",
                                    "Explicar a escolha gulosa: ordenar por tempo de fim crescente e selecionar o que acaba primeiro.",
                                    "Provar a propriedade: usar argumento de troca - suponha solução ótima S; se difere da gulosa, troque intervalos para mostrar que não piora.",
                                    "Simular com exemplo pequeno: intervalos [1-3], [2-4], [3-5] → seleciona [1-3] e [3-5]? Não, correto é [1-3],[3-5] wait, ajusta.",
                                    "Verificar numericamente: calcular tamanho da solução gulosa vs. ótima."
                                  ],
                                  "verification": "Resolver um conjunto de 4 intervalos e justificar por que a escolha inicial é segura.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos impressos de intervalos",
                                    "Planilha ou Python simples para simulação",
                                    "Pseudocódigo do algoritmo"
                                  ],
                                  "tips": "Sempre ordene por fim, não por início, para maximizar espaço restante.",
                                  "learningObjective": "Reconhecer e provar a propriedade gulosa no problema de intervalos.",
                                  "commonMistakes": [
                                    "Ordenar por início em vez de fim",
                                    "Não usar exchange argument na prova",
                                    "Confundir com coloração de intervalos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar o Exemplo de Troca de Moedas",
                                  "subSteps": [
                                    "Entender o problema: dar troco V com mínimo de moedas de denominações d1 > d2 > ...",
                                    "Descrever heurística gulosa: sempre pegar a maior moeda possível.",
                                    "Provar propriedade para sistemas canônicos (ex: {1,5,10,25}): maior ≤ V, resto recursivo.",
                                    "Argumento de segurança: suponha ótima usa menor; troque por mais maiores sem exceder.",
                                    "Testar com exemplo: troco 30 com {1,10,25} → 25+5? Ajusta para canônico."
                                  ],
                                  "verification": "Provar para troco 40 com {1,5,10,25} que guloso (25+10+5) é ótimo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Moedas fictícias ou app simulador",
                                    "Tabela de denominações",
                                    "Artigo sobre coin change problem"
                                  ],
                                  "tips": "Teste com não-canônicos como {1,4,6} para V=8 onde guloso falha (6+1+1 vs 4+4).",
                                  "learningObjective": "Identificar condições para propriedade gulosa em troca de moedas.",
                                  "commonMistakes": [
                                    "Assumir guloso sempre ótimo sem canonicidade",
                                    "Usar DP em vez de prova gulosa",
                                    "Ignorar resto após escolha"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Justificativa em Problemas Simples",
                                  "subSteps": [
                                    "Receber 3 problemas simples (ex: seleção de atividades, problema de frações).",
                                    "Identificar estratégia gulosa possível e testar propriedade.",
                                    "Justificar segurança: esboçar exchange ou contraprova.",
                                    "Comparar com brute-force em instâncias pequenas.",
                                    "Documentar: problema, escolha gulosa, prova resumida."
                                  ],
                                  "verification": "Analisar 2 novos problemas e escrever justificativas de 1 parágrafo cada.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Lista de 5 problemas gulosos simples",
                                    "Timer para brute-force manual",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Pergunte: 'Uma escolha local ótima pode ser mantida na solução global?'",
                                  "learningObjective": "Aplicar identificação autônoma da propriedade em problemas variados.",
                                  "commonMistakes": [
                                    "Forçar guloso onde não há propriedade",
                                    "Justificativa vaga sem exchange",
                                    "Não testar com múltiplas instâncias"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de seleção de intervalos com [[1,4],[3,5],[0,6],[5,7],[3,9],[5,9],[6,10],[8,11],[8,12],[2,14],[0,3]], a escolha gulosa seleciona primeiro [0,3], depois [5,7], etc., maximizando 4 intervalos. Justificativa: qualquer solução ótima pode trocar um intervalo sobreposto por um guloso sem perda.",
                              "finalVerifications": [
                                "Definir corretamente a propriedade gulosa em termos de escolha local e segurança.",
                                "Provar propriedade para seleção de intervalos usando exchange argument.",
                                "Explicar por que troca de moedas funciona em sistemas canônicos.",
                                "Identificar propriedade em um novo problema simples (ex: agendamento de jobs).",
                                "Dar contra-exemplo onde guloso falha (ex: não-canônico coins).",
                                "Simular algoritmo guloso e comparar com ótima em instância pequena."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e distinção de conceitos relacionados (90%+ correto).",
                                "Qualidade da prova de segurança com exchange argument lógico.",
                                "Correta identificação em 80%+ dos problemas propostos.",
                                "Justificativas claras, concisas e sem erros conceituais.",
                                "Uso de exemplos concretos para suporte.",
                                "Capacidade de contra-exemplos para delimitação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização combinatória e provas por contradição.",
                                "Economia: Tomada de decisões sequenciais sob restrições.",
                                "Gestão: Alocação eficiente de recursos limitados.",
                                "Física: Seleção de trajetórias ótimas em problemas de energia mínima."
                              ],
                              "realWorldApplication": "Em sistemas de agendamento de voos ou salas de conferência (seleção de intervalos) para maximizar ocupação, ou em caixas registradoras para minimizar moedas entregues em troco, otimizando tempo e conveniência em transações financeiras diárias."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.2",
                        "name": "Verificação e Prova da Propriedade",
                        "description": "Métodos para provar que uma escolha gulosa preserva soluções ótimas globais, utilizando argumentos de troca ou indução.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.2.1",
                            "name": "Aplicar argumento de troca",
                            "description": "Usar o método de troca (exchange argument) para provar que qualquer solução ótima pode ser transformada em uma que inclui a escolha gulosa sem piorar o custo, como em árvores geradoras mínimas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais do exchange argument",
                                  "subSteps": [
                                    "Revise a definição de algoritmo guloso e propriedade da escolha gulosa em contextos como MST.",
                                    "Defina solução ótima (S*) e escolha gulosa (e.g., aresta de menor peso e sem ciclo).",
                                    "Estude o lema: Para provar greedy choice property, mostre que existe S* que inclui a escolha gulosa.",
                                    "Identifique pré-requisitos: grafos, pesos, ciclos e aciclicidade.",
                                    "Anote exemplos de onde o exchange é usado (Kruskal, Prim)."
                                  ],
                                  "verification": "Explique em suas palavras o que o exchange argument prova e dê um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Diagrama de grafo exemplo",
                                    "Referência: CLRS capítulo 23"
                                  ],
                                  "tips": "Comece com um grafo pequeno (3-4 vértices) para visualizar.",
                                  "learningObjective": "Dominar os termos chave e o objetivo da prova.",
                                  "commonMistakes": [
                                    "Confundir com optimal substructure",
                                    "Ignorar a necessidade de não piorar o custo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a hipótese: Suponha uma solução ótima sem a escolha gulosa",
                                  "subSteps": [
                                    "Escolha um grafo G e a escolha gulosa e (menor peso, não forma ciclo sozinha).",
                                    "Defina S* como MST ótima que não inclui e.",
                                    "Adicione e a S*, formando um ciclo C em S* ∪ {e}.",
                                    "Identifique todas as arestas no ciclo C.",
                                    "Classifique arestas em C: as de S* e e."
                                  ],
                                  "verification": "Desenhe o grafo com S* ∪ {e} e destaque o ciclo C.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de desenho de grafos (Draw.io ou Graphviz)",
                                    "Grafo exemplo impresso"
                                  ],
                                  "tips": "Garanta que e conecte componentes diferentes inicialmente.",
                                  "learningObjective": "Construir a configuração inicial para o exchange.",
                                  "commonMistakes": [
                                    "Escolher e que já forma ciclo sozinha",
                                    "Não verificar se S* é realmente MST"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o exchange: Trocar arestas no ciclo",
                                  "subSteps": [
                                    "No ciclo C, encontre f ∈ S* ∩ C tal que peso(f) ≥ peso(e).",
                                    "Crie S' = (S* - {f}) ∪ {e}.",
                                    "Verifique que S' é acíclica e conectada (mesmo número de arestas, substituição preserva).",
                                    "Calcule custo(S') = custo(S*) - peso(f) + peso(e) ≤ custo(S*).",
                                    "Confirme que S' é spanning tree."
                                  ],
                                  "verification": "Mostre que custo(S') ≤ custo(S*) e S' é válida MST candidata.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Calculadora para pesos",
                                    "Planilha para rastrear custos"
                                  ],
                                  "tips": "Sempre prove que existe tal f pelo fato de e ser a menor possível.",
                                  "learningObjective": "Executar a transformação sem piorar o custo.",
                                  "commonMistakes": [
                                    "Trocar por f com peso(f) < peso(e)",
                                    "Criar ciclo em S'"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e generalizar a propriedade da escolha gulosa",
                                  "subSteps": [
                                    "Repita o processo para múltiplas escolhas gulosas.",
                                    "Generalize: Qualquer S* pode ser transformada em S** que inclui todas as escolhas gulosas até agora.",
                                    "Discuta por que isso prova a greedy choice property.",
                                    "Aplique a um exemplo completo (Kruskal full proof).",
                                    "Identifique limitações (nem todo problema guloso usa exchange)."
                                  ],
                                  "verification": "Escreva uma prova curta para um grafo dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplo de grafo com solução não-gulosa inicial",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use indução para múltiplas iterações.",
                                  "learningObjective": "Conectar o exchange à corretude do algoritmo guloso.",
                                  "commonMistakes": [
                                    "Assumir que S' é ótima sem prova",
                                    "Ignorar safe substructure"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere grafo com vértices A,B,C,D. Arestas: AB=1, AC=2, AD=3, BC=4, BD=5, CD=6. Escolha gulosa: AB=1. Suponha S* = {AC=2, AD=3, BD=5} custo=10. Adicione AB, ciclo A-B-D-A. Troque BD=5 por AB=1, novo S'={AC=2,AD=3,AB=1} custo=6 ≤10, inclui AB.",
                              "finalVerifications": [
                                "Identifica corretamente o ciclo em S* ∪ {e}.",
                                "Seleciona f com peso(f) ≥ peso(e).",
                                "Verifica que S' é spanning tree válida.",
                                "Calcula e compara custos corretamente.",
                                "Explica por que isso prova a existência de OPT com escolha gulosa.",
                                "Aplica a um grafo novo sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do ciclo e escolha de f.",
                                "Correção matemática no cálculo de custos.",
                                "Clareza na explicação da transformação.",
                                "Capacidade de generalizar para outros problemas gulosos.",
                                "Ausência de erros comuns como piorar o custo.",
                                "Profundidade na conexão com optimal substructure."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de grafos e ciclos.",
                                "Programação: Implementação de Kruskal com Union-Find.",
                                "Teoria da Computação: Análise de corretude de algoritmos.",
                                "Otimização: Problemas de mochila fracionária gulosos."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações, otimizar o custo de cabos conectando cidades (MST via Kruskal), provando que escolher a conexão mais barata primeiro leva à rede mínima sem necessidade de backtracking."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.2",
                            "name": "Provar por indução",
                            "description": "Demonstrar a propriedade por indução sobre o tamanho do problema, mostrando que após a escolha gulosa, o subproblema restante mantém a otimalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e Provar o Caso Base",
                                  "subSteps": [
                                    "Identifique o menor tamanho de problema possível (ex: n=1 ou tamanho mínimo viável).",
                                    "Verifique se a propriedade gulosa holds: a escolha gulosa leva a uma solução ótima.",
                                    "Mostre explicitamente que a solução ótima é obtida pela escolha gulosa nesse caso.",
                                    "Registre a solução ótima e compare com a gulosa.",
                                    "Confirme que não há sobreposições ou violações."
                                  ],
                                  "verification": "Escreva a prova formal do caso base e verifique se a solução gulosa coincide com a ótima enumerando todas as possibilidades.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplo de problema guloso simples (ex: agendamento de 1 intervalo)"
                                  ],
                                  "tips": "Comece sempre com o menor n possível para evitar ambiguidades; desenhe diagramas para visualização.",
                                  "learningObjective": "Compreender e demonstrar que a propriedade gulosa vale para o caso trivial.",
                                  "commonMistakes": [
                                    "Ignorar casos edge como n=0",
                                    "Assumir sem provar explicitamente a otimalidade"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estabelecer a Hipótese Indutiva",
                                  "subSteps": [
                                    "Assuma que a propriedade gulosa vale para todos os problemas de tamanho até k (k >= base).",
                                    "Defina formalmente: Para qualquer instância de tamanho <=k, a escolha gulosa leva a subproblema ótimo.",
                                    "Especifique o que significa 'manter a otimalidade' no subproblema restante.",
                                    "Anote símbolos: denote OPT(S) como solução ótima para subconjunto S.",
                                    "Garanta que a hipótese cubra o subproblema após remoção da escolha gulosa."
                                  ],
                                  "verification": "Escreva a declaração formal da hipótese indutiva e confirme que ela é clara e cobre subproblemas relevantes.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Referência ao algoritmo guloso específico"
                                  ],
                                  "tips": "Use notação matemática precisa (ex: P(k): propriedade para tamanho k); evite ambiguidades nas definições.",
                                  "learningObjective": "Formular corretamente a hipótese indutiva para indução forte sobre o tamanho.",
                                  "commonMistakes": [
                                    "Hipótese fraca que não cobre subproblemas",
                                    "Confundir tamanho do problema com número de escolhas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar o Passo Indutivo",
                                  "subSteps": [
                                    "Considere um problema de tamanho k+1; faça a escolha gulosa ótima (cG).",
                                    "Mostre que qualquer solução ótima OPT deve incluir cG ou uma alternativa pior.",
                                    "Prove por contradição: se OPT não inclui cG, substitua por cG sem piorar a solução.",
                                    "Demonstre que o subproblema restante (após cG) tem tamanho <=k e é ótimo pela hipótese.",
                                    "Conclua que a solução gulosa total é ótima."
                                  ],
                                  "verification": "Escreva a prova completa do passo indutivo, incluindo contradição e ligação à hipótese.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Exemplo concreto com n=k+1",
                                    "Software de desenho para diagramas de prova"
                                  ],
                                  "tips": "Use 'exchange argument': troque elementos em OPT para incluir cG; foque em 'não piora'.",
                                  "learningObjective": "Demonstrar que a escolha gulosa preserva otimalidade no subproblema.",
                                  "commonMistakes": [
                                    "Falhar na contradição (ex: não provar que substituição é possível)",
                                    "Ignorar conflitos entre elementos de OPT"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a Prova e Verificar Consistência",
                                  "subSteps": [
                                    "Reúna caso base, hipótese e passo indutivo para afirmar que vale para todos n.",
                                    "Verifique se a indução cobre todos os tamanhos (forte indução se necessário).",
                                    "Teste com um exemplo médio para validar.",
                                    "Discuta limitações ou suposições do algoritmo.",
                                    "Resuma a prova em parágrafos concisos."
                                  ],
                                  "verification": "A prova deve cobrir todos n por indução; valide com contraexemplo se possível.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Documento final da prova",
                                    "Exemplo de teste"
                                  ],
                                  "tips": "Escreva 'Portanto, por princípio da indução matemática...' para fechamento formal.",
                                  "learningObjective": "Sintetizar a prova completa e identificar gaps.",
                                  "commonMistakes": [
                                    "Pular verificação de indução forte",
                                    "Generalizar além das suposições"
                                  ]
                                }
                              ],
                              "practicalExample": "No problema de Agendamento de Intervalos (selecionar máximo de intervalos não sobrepostos): Caso base n=1: selecione o único. Hipótese: vale para <=k. Para k+1, escolha o que acaba primeiro (cG); prove que OPT pode trocar qualquer outro por cG sem perda, deixando subproblema de <=k ótimo.",
                              "finalVerifications": [
                                "Caso base provado explicitamente com todas instâncias.",
                                "Hipótese indutiva formal e cobre subproblemas.",
                                "Passo indutivo usa exchange argument sem falhas.",
                                "Conclusão liga todos elementos por indução matemática.",
                                "Testado com exemplo numérico (ex: 4 intervalos).",
                                "Sem suposições não declaradas."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na notação matemática (20%).",
                                "Correção lógica no exchange argument (30%).",
                                "Cobertura completa de casos (base, hipótese, passo) (20%).",
                                "Uso apropriado de contradição ou troca (15%).",
                                "Exemplo prático integrado e validado (10%).",
                                "Concisão e estrutura formal (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Princípios de indução matemática.",
                                "Programação: Implementação e testes de algoritmos gulosos.",
                                "Lógica: Provas por contradição e exchange arguments.",
                                "Otimização: Teoria de programação dinâmica vs. guloso."
                              ],
                              "realWorldApplication": "Em compiladores, prova gulosa para registro allocation garante alocação ótima de registradores minimizando spills; em redes, agendamento de jobs em clusters para maximizar throughput sem sobreposições."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.2.3",
                            "name": "Analisar falhas da propriedade",
                            "description": "Identificar problemas onde a propriedade falha, como no problema da mochila fracionária mal formulado, contrastando com programação dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a definição da propriedade da escolha gulosa",
                                  "subSteps": [
                                    "Relembrar a definição formal: uma escolha gulosa é ótima se, após pegá-la, o subproblema restante satisfaz a propriedade.",
                                    "Estudar exemplos onde ela segura (ex: seleção de atividades).",
                                    "Identificar os três aspectos chave: escolha ótima local, subestrutura ótima, segurança da escolha.",
                                    "Anotar condições necessárias para a propriedade valer.",
                                    "Comparar com problemas onde ela falha intuitivamente."
                                  ],
                                  "verification": "Capacidade de explicar a propriedade em suas próprias palavras e citar um exemplo positivo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, notas de aula sobre algoritmos gulosos, pseudocódigo de exemplos clássicos.",
                                  "tips": "Use diagramas para visualizar a recursão da propriedade.",
                                  "learningObjective": "Compreender precisamente o que significa 'propriedade da escolha gulosa' para detectar violações.",
                                  "commonMistakes": "Confundir com otimalidade global; ignorar o subproblema restante."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar e analisar um problema candidato à falha gulosa",
                                  "subSteps": [
                                    "Escolher um problema de otimização (ex: mochila 0/1).",
                                    "Formular o problema com restrições claras (capacidade, itens indivisíveis).",
                                    "Propor uma heurística gulosa possível (ex: ordenar por densidade valor/peso).",
                                    "Executar a heurística em uma instância pequena manualmente.",
                                    "Calcular o valor obtido e suspeitar de subotimalidade."
                                  ],
                                  "verification": "Descrição escrita do problema e da heurística gulosa aplicada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha ou papel para cálculos, exemplos de problemas NP-difíceis.",
                                  "tips": "Comece com instâncias pequenas (3-5 itens) para facilitar análise.",
                                  "learningObjective": "Identificar problemas onde heurísticas gulosas são intuitivas mas potencialmente falhas.",
                                  "commonMistakes": "Escolher problemas onde guloso funciona (ex: mochila fracionária verdadeira)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir um contra-exemplo onde a propriedade falha",
                                  "subSteps": [
                                    "Criar itens com valores e pesos que violem a subotimalidade (ex: itens A(v=60,w=10), B(v=100,w=20), C(v=120,w=30); W=50).",
                                    "Simular escolha gulosa: ordenar por v/w, pegar A então B (total 160).",
                                    "Encontrar solução melhor: B+C (220).",
                                    "Verificar que após escolha gulosa (A), o subproblema não permite recuperar otimalidade.",
                                    "Documentar a falha explicitamente."
                                  ],
                                  "verification": "Contra-exemplo escrito com cálculos de guloso vs ótimo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora, tabela de itens em formato JSON ou tabela.",
                                  "tips": "Ajuste valores iterativamente até a falha ser clara (gap >20%).",
                                  "learningObjective": "Construir provas por contradição específicas para algoritmos gulosos.",
                                  "commonMistakes": "Usar frações quando o problema é 0/1; não garantir indivisibilidade."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Contrastar com programação dinâmica e generalizar lições",
                                  "subSteps": [
                                    "Esboçar solução DP para o contra-exemplo (tabela de 2D para subproblemas).",
                                    "Comparar complexidade: guloso O(n log n) vs DP O(nW).",
                                    "Identificar por que DP captura otimalidade (subestrutura sobreposta).",
                                    "Listar lições: quando suspeitar falha gulosa (itens indivisíveis, dependências).",
                                    "Aplicar a outro problema similar (ex: particionamento)."
                                  ],
                                  "verification": "Tabela DP resolvida e lista de 3 lições generalizadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Papel quadriculado para tabela DP, pseudocódigo de DP para knapsack.",
                                  "tips": "Use memoização mental para pequenos W.",
                                  "learningObjective": "Entender trade-offs e quando preferir DP sobre guloso.",
                                  "commonMistakes": "Ignorar tempo/espaço de DP; super-generalizar falhas."
                                }
                              ],
                              "practicalExample": "No problema da mochila 0/1 com capacidade 50: itens A(60,10), B(100,20), C(120,30). Guloso por densidade pega A+B=160; ótimo B+C=220. A propriedade falha pois após A, não se recupera o ótimo.",
                              "finalVerifications": [
                                "Construir contra-exemplo independente para knapsack 0/1.",
                                "Explicar verbalmente por que a propriedade gulosa falha no subproblema.",
                                "Comparar soluções gulosa e DP numericamente.",
                                "Identificar 2 problemas onde guloso funciona vs 2 onde falha.",
                                "Aplicar análise a um novo problema proposto."
                              ],
                              "assessmentCriteria": [
                                "Precisão no contra-exemplo (gap ótimo-guloso >0).",
                                "Clareza na explicação da falha da propriedade.",
                                "Correção da solução DP contrastante.",
                                "Profundidade das lições generalizadas.",
                                "Criatividade em conexões com outros problemas.",
                                "Documentação completa e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por contradição e contrapositiva.",
                                "Lógica: Análise de contra-exemplos em teoremas.",
                                "Economia: Otimização de recursos limitados com heurísticas falhas.",
                                "Engenharia de Software: Testes de borda para algoritmos."
                              ],
                              "realWorldApplication": "Em planejamento de projetos (ex: alocação de recursos limitados em TI), identificar quando heurísticas gulosas falham leva a soluções exatas via DP, evitando perdas em cenários como logística ou finanças."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.2.3",
                        "name": "Aplicações em Algoritmos Clássicos",
                        "description": "Exemplos práticos em grafos e árvores onde a propriedade da escolha gulosa é essencial para corretude.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.2.3.1",
                            "name": "Verificar em Kruskal",
                            "description": "Explicar como a propriedade se aplica ao algoritmo de Kruskal para árvore geradora mínima, escolhendo arestas de menor peso sem formar ciclos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos do Algoritmo de Kruskal",
                                  "subSteps": [
                                    "Estude a definição de Árvore Geradora Mínima (MST): grafo conexo sem ciclos com soma mínima de pesos.",
                                    "Descreva o algoritmo: ordene arestas por peso crescente, adicione à floresta se não formar ciclo.",
                                    "Explique o uso de Union-Find para detectar ciclos e unir componentes.",
                                    "Liste os pré-requisitos: grafo não direcionado, conexo e com pesos positivos.",
                                    "Desenhe um grafo simples de exemplo com 4 vértices para visualizar."
                                  ],
                                  "verification": "Resuma o algoritmo em 3 frases e desenhe a execução inicial em um grafo exemplo sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, ou ferramenta online como draw.io para grafos.",
                                  "tips": "Sempre comece ordenando as arestas para visualizar o processo sequencial.",
                                  "learningObjective": "Compreender os componentes básicos do Kruskal e seu objetivo de construir MST.",
                                  "commonMistakes": "Confundir Kruskal com Prim (Kruskal trabalha com arestas globais, Prim local)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a Escolha Gulosa no Kruskal",
                                  "subSteps": [
                                    "Defina propriedade gulosa: escolha local ótima (menor peso) que leva à solução global ótima.",
                                    "No Kruskal, identifique a escolha: próxima aresta de menor peso que não forma ciclo.",
                                    "Explique por que é gulosa: decisão irreversível baseada em critério local (peso mínimo).",
                                    "Compare com não-guloso: adicionar aresta pesada cedo pode bloquear MST ótima.",
                                    "Anote as condições: grafo conexo, pesos distintos para simplicidade."
                                  ],
                                  "verification": "Escreva uma frase justificando por que a escolha de aresta mínima é gulosa, citando detecção de ciclo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha de anotações, pseudocódigo do Kruskal impresso.",
                                  "tips": "Pense na escolha como 'gregária': pegue o melhor disponível agora, sem arrependimentos.",
                                  "learningObjective": "Reconhecer explicitamente onde a propriedade gulosa é aplicada no algoritmo.",
                                  "commonMistakes": "Achar que toda adição de aresta é gulosa, ignorando a verificação de ciclo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a Aplicação da Propriedade Gulosa",
                                  "subSteps": [
                                    "Prove matematicamente: suponha escolha errada leva a MST não-ótima; contradiga por substituição de aresta.",
                                    "Use o lema do caminho seguro: em MST ótima, substitua aresta por menor peso no ciclo.",
                                    "Simule falha: se pular menor peso, custo total aumenta.",
                                    "Discuta generalidade: funciona para qualquer grafo conexo com pesos não-negativos.",
                                    "Registre exceções: grafos desconexos (floresta geradora mínima)."
                                  ],
                                  "verification": "Esboce uma prova curta (3-4 linhas) mostrando que a escolha local preserva otimalidade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Quadro branco ou papel para diagramas de prova, referência teórica de grafos.",
                                  "tips": "Use contra-exemplo hipotético para testar sua prova: inverta pesos e veja falha.",
                                  "learningObjective": "Validar rigorosamente por que a propriedade gulosa garante MST ótima no Kruskal.",
                                  "commonMistakes": "Ignorar prova de otimalidade, assumindo apenas 'funciona empiricamente'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar e Validar em Exemplo Prático",
                                  "subSteps": [
                                    "Crie grafo exemplo: vértices A,B,C,D; arestas A-B:1, C-D:1.5, B-C:2, A-C:3, B-D:4.",
                                    "Execute Kruskal: ordene, adicione A-B, C-D, B-C (MST peso 4.5).",
                                    "Verifique guloso: cada adição mínima evitou ciclo via Union-Find.",
                                    "Compare com MST manual: confirme otimalidade.",
                                    "Implemente pseudocódigo simples para automação."
                                  ],
                                  "verification": "Execute o exemplo e calcule MST correta; explique cada escolha gulosa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora, Python com Union-Find (opcional), grafo desenhado.",
                                  "tips": "Implemente Union-Find básico: find e union por rank para eficiência.",
                                  "learningObjective": "Demonstrar a propriedade em prática, ligando teoria a execução.",
                                  "commonMistakes": "Adicionar aresta que forma ciclo por erro em Union-Find."
                                }
                              ],
                              "practicalExample": "Grafo com vértices A,B,C,D e arestas: A-B(1), C-D(1.5), B-C(2), A-C(3), B-D(4). Kruskal ordena e adiciona A-B, C-D, B-C (total 4.5), rejeitando A-C (ciclo ABC) e B-D (já conectado). Cada escolha de menor peso sem ciclo exemplifica a propriedade gulosa.",
                              "finalVerifications": [
                                "Explica corretamente como Union-Find detecta ciclos na escolha gulosa.",
                                "Justifica por que pular a aresta mínima aumenta o custo total da MST.",
                                "Aplica o algoritmo em um grafo de 5+ vértices sem erros.",
                                "Descreve o lema do caminho seguro para provar otimalidade.",
                                "Identifica quando Kruskal falha (grafo desconexo).",
                                "Compara com Prim, destacando diferenças guloso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da escolha gulosa (peso mínimo sem ciclo).",
                                "Profundidade da prova de otimalidade (uso de lemas ou contra-exemplos).",
                                "Correção na execução de exemplo com Union-Find.",
                                "Clareza na explicação verbal ou escrita da propriedade.",
                                "Capacidade de generalizar para outros algoritmos gulosos.",
                                "Detecção e correção de erros comuns em simulações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Provas por Contradição.",
                                "Programação: Estruturas de Dados (Union-Find/Disjoint Set).",
                                "Otimização: Problemas NP-completos aproximados por gulosos.",
                                "Engenharia: Design de redes (roteamento mínimo)."
                              ],
                              "realWorldApplication": "No planejamento de redes de telecomunicações, Kruskal otimiza o layout de cabos conectando cidades com custo mínimo total, escolhendo links mais baratos sem loops desnecessários, economizando milhões em infraestrutura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.2.3.2",
                            "name": "Verificar em Prim",
                            "description": "Demonstrar a propriedade no algoritmo de Prim, onde a escolha gulosa da aresta mais barata conectando ao componente atual preserva otimalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o funcionamento básico do algoritmo de Prim",
                                  "subSteps": [
                                    "Estude a descrição formal do algoritmo de Prim para construção de Árvore Geradora Mínima (MST).",
                                    "Desenhe um grafo de exemplo não conexo e aplique o algoritmo passo a passo manualmente.",
                                    "Identifique o conjunto inicial (um vértice) e como ele cresce adicionando arestas.",
                                    "Registre as escolhas de arestas em cada iteração, notando a menor peso conectando o componente atual aos outros."
                                  ],
                                  "verification": "Você consegue executar o algoritmo em um grafo de 5 vértices sem erros e listar todas as arestas selecionadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Um grafo de exemplo com 5-7 vértices e pesos nas arestas"
                                  ],
                                  "tips": "Comece sempre do mesmo vértice para facilitar comparações; use uma tabela para rastrear distâncias mínimas.",
                                  "learningObjective": "Compreender os passos iterativos do Prim e identificar o componente conectado atual.",
                                  "commonMistakes": "Confundir com Kruskal (que ordena todas as arestas); esquecer de atualizar distâncias após adicionar vértice."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar a escolha gulosa no algoritmo de Prim",
                                  "subSteps": [
                                    "Localize no pseudocódigo a linha onde se seleciona a aresta de menor peso conectando o componente atual a um vértice fora dele.",
                                    "Explique por que essa escolha é 'gulosa': pega o melhor imediato sem olhar o futuro.",
                                    "Compare com escolhas não-gulosas: simule adicionar uma aresta mais cara e veja o impacto.",
                                    "Documente matematicamente: defina o 'key[v]' como a distância mínima do componente a v."
                                  ],
                                  "verification": "Escreva uma frase definindo a escolha gulosa e aponte sua localização no algoritmo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo do Prim impresso ou digital",
                                    "Grafo do passo 1"
                                  ],
                                  "tips": "Pense na escolha como 'o mais barato agora que expande o tree sem ciclos'.",
                                  "learningObjective": "Reconhecer precisamente onde e como a propriedade gulosa é aplicada no Prim.",
                                  "commonMistakes": "Achar que é guloso por vértice ao invés de aresta; ignorar a condição de conexão ao componente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Demonstrar que a escolha gulosa preserva otimalidade",
                                  "subSteps": [
                                    "Assuma que existe uma MST ótima T* diferente da construída por Prim até certo ponto.",
                                    "Use argumento de troca: encontre na T* uma aresta que conecta o componente atual de forma mais barata; contradiz a escolha de Prim.",
                                    "Prove por contradição: se Prim escolheu errado, deve existir aresta mais barata em T*, mas Prim sempre pega a mínima.",
                                    "Generalize para todas as iterações, mostrando que cada prefixo é ótimo."
                                  ],
                                  "verification": "Escreva uma prova curta (3-5 linhas) usando troca de arestas provando segurança da escolha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha para prova",
                                    "Referência: livro de Algoritmos como CLRS seção 23.2"
                                  ],
                                  "tips": "Visualize grafos: desenhe T parcial e T* sobrepostos para ver a troca.",
                                  "learningObjective": "Aplicar argumento de troca para verificar que a escolha gulosa é segura no Prim.",
                                  "commonMistakes": "Confundir prova com simulação; pular generalização para todas iterações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar com exemplo concreto e contra-argumentos",
                                  "subSteps": [
                                    "Aplique Prim em um grafo onde há tentação de escolher aresta mais cara (ex: grafo com armadilha).",
                                    "Calcule custo total da MST de Prim e compare com MST conhecida (enumere todas).",
                                    "Simule erro guloso: force escolha errada e mostre custo maior.",
                                    "Conclua que só a escolha gulosa leva à otimalidade nesse caso."
                                  ],
                                  "verification": "Mostre cálculo de custos iguais para Prim e MST ótima, e maior para alternativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Grafo específico: vértices A,B,C,D; arestas AB=1,AC=4,AD=3,BC=2,BD=5,CD=1"
                                  ],
                                  "tips": "Use grafos pequenos para enumeração exaustiva de MSTs.",
                                  "learningObjective": "Validar teoricamente com prática, confirmando preservação de otimalidade.",
                                  "commonMistakes": "Escolher grafo onde todas escolhas levam à MST; não testar alternativa não-gulosa."
                                }
                              ],
                              "practicalExample": "Considere grafo com vértices A,B,C,D e arestas: AB=1, AC=4, AD=3, BC=2, BD=5, CD=1. Iniciando em A, Prim escolhe AB=1 (mais barata), depois AC? Não, AD=3 ou BC via B? key atualiza: após AB, BC=2 para C, AD=3 para D; escolhe BC=2, então CD=1 para D. MST custo 1+2+1=4. Qualquer outra ordem (ex: AD primeiro=3, então AB? Ciclo, etc.) confirma mínimo.",
                              "finalVerifications": [
                                "Explica corretamente a escolha gulosa em Prim.",
                                "Aplica argumento de troca sem erros.",
                                "Calcula MST correta em exemplo dado.",
                                "Identifica por que não-guloso falha.",
                                "Generaliza para qualquer grafo conexo denso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação da escolha gulosa (100%).",
                                "Validade da prova por troca (clareza e correção).",
                                "Correção no exemplo prático (custo MST exato).",
                                "Profundidade na análise de alternativas não-gulosas.",
                                "Capacidade de generalização para outros grafos."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos (propriedades de MSTs).",
                                "Matemática Discreta (provas por contradição e indução).",
                                "Otimização Combinatória (algoritmos gulosos vs. exaustivos).",
                                "Engenharia de Software (análise de complexidade O(E log V)).",
                                "Economia (problemas de custo mínimo em redes)."
                              ],
                              "realWorldApplication": "No projeto de redes de telecomunicações, o algoritmo de Prim otimiza o layout de cabos entre cidades, escolhendo sempre a conexão mais barata disponível para minimizar custos totais sem loops, preservando a solução ótima global."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.3",
                    "name": "Critério de Otimalidade Gulosa",
                    "description": "Verificação de subestrutura ótima e escolha segura para validar a corretude do algoritmo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.3.1",
                        "name": "Subestrutura Ótima",
                        "description": "Propriedade fundamental nos algoritmos gulosos que garante que uma solução ótima para o problema contenha soluções ótimas para subproblemas relevantes, permitindo a construção incremental da solução global.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.1.1",
                            "name": "Definir subestrutura ótima",
                            "description": "Explicar formalmente o conceito de subestrutura ótima, diferenciando-o de programação dinâmica e ilustrando com exemplos como a árvore geradora mínima (AGM).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito básico de subestrutura ótima",
                                  "subSteps": [
                                    "Leia a definição formal: uma solução ótima para o problema completo contém soluções ótimas para subproblemas.",
                                    "Identifique os elementos chave: problema original, subproblemas e relação de otimalidade.",
                                    "Anote exemplos intuitivos, como escolher o menor caminho em um grafo onde sub-caminhos também são mínimos.",
                                    "Resuma em suas palavras o que significa 'subestrutura ótima' em algoritmos.",
                                    "Compare com estruturas não-ótimas para reforçar a distinção."
                                  ],
                                  "verification": "Escreva uma definição em 1 parágrafo e valide com uma fonte confiável como livro de Algoritmos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Livro 'Introduction to Algorithms' (CLRS), capítulo de Algoritmos Gulosos",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use analogias cotidianas, como montar um quebra-cabeça onde cada peça encaixa perfeitamente em sub-regiões.",
                                  "learningObjective": "Definir precisamente o conceito de subestrutura ótima e seus componentes essenciais.",
                                  "commonMistakes": [
                                    "Confundir com recursão simples",
                                    "Ignorar a propriedade de otimalidade nas subestruturas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar subestrutura ótima de programação dinâmica",
                                  "subSteps": [
                                    "Revise subproblemas sobrepostos e ordenação ótima em Programação Dinâmica (PD).",
                                    "Compare: em algoritmos gulosos, subestruturas são independentes; em PD, são sobrepostas e resolvidas bottom-up.",
                                    "Crie uma tabela comparativa: colunas para Gulosos vs PD (ex: dependência de escolhas, estrutura de dados).",
                                    "Discuta por que gulosos são mais eficientes quando subestrutura ótima existe sem sobreposições.",
                                    "Teste com pseudocódigo simples de cada abordagem."
                                  ],
                                  "verification": "Preencha a tabela comparativa e explique verbalmente ou por escrito as diferenças principais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Artigo online sobre Algoritmos Gulosos vs PD",
                                    "Ferramenta de desenho como Draw.io para tabelas"
                                  ],
                                  "tips": "Lembre-se: PD resolve todos subproblemas; gulosos confiam em uma escolha gulosa que preserva otimalidade.",
                                  "learningObjective": "Distinguir claramente as subestruturas em gulosos de PD, destacando eficiência e condições.",
                                  "commonMistakes": [
                                    "Achar que PD sempre usa subestrutura ótima",
                                    "Não notar ausência de sobreposições em gulosos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Ilustrar com o exemplo da Árvore Geradora Mínima (AGM)",
                                  "subSteps": [
                                    "Desenhe um grafo simples com 4 vértices e 5 arestas pesadas.",
                                    "Aplique algoritmo de Kruskal: ordene arestas, adicione sem ciclos, verificando subestruturas.",
                                    "Para cada adição de aresta, prove que a sub-AGM formada é ótima para os vértices conectados.",
                                    "Simule remoção de uma aresta e veja se a otimalidade se mantém.",
                                    "Calcule o custo total e compare com uma solução não-ótima."
                                  ],
                                  "verification": "Desenhe o grafo resolvido e anote provas de otimalidade para 2 subestruturas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis ou software como Graphviz",
                                    "Exemplo de grafo pronto de tutoriais online"
                                  ],
                                  "tips": "Sempre verifique ciclos com Union-Find para simular corretamente.",
                                  "learningObjective": "Aplicar e provar subestrutura ótima no contexto de AGM usando Kruskal ou Prim.",
                                  "commonMistakes": [
                                    "Adicionar arestas que formam ciclos cedo",
                                    "Não provar otimalidade das sub-AGMs"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar e testar o conceito em outros cenários",
                                  "subSteps": [
                                    "Escolha outro algoritmo guloso, como Seleção de Atividades, e identifique subestruturas ótimas.",
                                    "Crie um contra-exemplo onde subestrutura ótima falha (ex: problema sem propriedade gulosa).",
                                    "Discuta condições necessárias para existência de subestrutura ótima.",
                                    "Resolva um problema pequeno manualmente, destacando as subestruturas.",
                                    "Reflita sobre implicações para escolha de algoritmos."
                                  ],
                                  "verification": "Resolva o exemplo de Seleção de Atividades e liste 3 subestruturas ótimas identificadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de problemas gulosos clássicos",
                                    "Calculadora para custos"
                                  ],
                                  "tips": "Pergunte: 'Se eu resolver o subproblema, a solução global permanece ótima?'",
                                  "learningObjective": "Generalizar o conceito além de AGM e identificar quando aplica.",
                                  "commonMistakes": [
                                    "Aplicar guloso onde PD é necessário",
                                    "Ignorar contra-exemplos"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo com vértices A,B,C,D e arestas AB(1), AC(2), BD(3), CD(4), BC(5): usando Kruskal, adicione AB(1) → sub-AGM {A,B} ótima; adicione AC(2) → sub-AGM {A,B,C} ótima (custo 3, mínimo possível); finalize com BD(3) → AGM total custo 6, com todas subestruturas ótimas.",
                              "finalVerifications": [
                                "Defina subestrutura ótima em <50 palavras corretamente.",
                                "Diferencie de PD em uma tabela com 4 diferenças chave.",
                                "Prove subestrutura ótima para AGM em um grafo dado.",
                                "Identifique subestrutura em Seleção de Atividades.",
                                "Cite um problema sem subestrutura ótima gulosa.",
                                "Explique por que AGM satisfaz o critério."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (sem ambiguidades).",
                                "Correta diferenciação com PD (exemplos contrastantes).",
                                "Prova válida de subestrutura em AGM (lógica irrefutável).",
                                "Generalização para outros algoritmos gulosos.",
                                "Identificação de condições e contra-exemplos.",
                                "Clareza em exemplos práticos e diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria dos Grafos e propriedades de árvores.",
                                "Otimização Matemática: Critérios de otimalidade em problemas combinatórios.",
                                "Ciência da Computação: Análise de complexidade em Algoritmos Avançados.",
                                "Economia: Modelos de minimização de custos em redes de suprimentos.",
                                "Engenharia: Design de redes elétricas ou de transporte."
                              ],
                              "realWorldApplication": "Em telecomunicações, conectar cidades com cabos de fibra ótica minimizando custo total: cada sub-rede conectada (subestrutura) deve ser mínima, garantindo a rede global ótima sem recálculos desnecessários."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.2",
                            "name": "Identificar subestrutura ótima em problemas",
                            "description": "Analisar um problema dado (ex.: seleção de intervalos ou mochila fracionária) para verificar se possui subestrutura ótima, usando contraexemplos quando não possui.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição de subestrutura ótima",
                                  "subSteps": [
                                    "Ler a definição formal: uma solução ótima para o problema inclui soluções ótimas para subproblemas relevantes.",
                                    "Analisar os elementos chave: escolha gulosa e indução sobre o tamanho do problema.",
                                    "Estudar a notação matemática: OT(S) = g + OT(S') onde g é a escolha gulosa e S' o subproblema.",
                                    "Diferenciar de outras propriedades gulosas como propriedade gulosa segura.",
                                    "Anotar exemplos iniciais de problemas que possuem essa propriedade."
                                  ],
                                  "verification": "Explicar em 3-5 frases próprias o conceito e fornecer um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Livro de Algoritmos Avançados (ex: Cormen et al.)",
                                    "Notas de aula sobre algoritmos gulosos",
                                    "Papel e caneta"
                                  ],
                                  "tips": "Use diagramas para visualizar a decomposição do problema em subproblemas.",
                                  "learningObjective": "Dominar a definição precisa e os componentes da subestrutura ótima.",
                                  "commonMistakes": [
                                    "Confundir subestrutura ótima com otimalidade global imediata.",
                                    "Ignorar a necessidade de indução formal.",
                                    "Aplicar a definição sem considerar o contexto guloso."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever e decompor o problema candidato",
                                  "subSteps": [
                                    "Selecionar um problema específico (ex: seleção de intervalos ou mochila fracionária).",
                                    "Definir entradas, saídas e objetivo de otimização claramente.",
                                    "Ordenar ou estruturar o problema conforme o critério guloso proposto.",
                                    "Identificar possíveis escolhas gulosas e os subproblemas resultantes.",
                                    "Esboçar um exemplo numérico pequeno para ilustrar a decomposição."
                                  ],
                                  "verification": "Produzir um diagrama ou descrição escrita da decomposição do problema em subproblemas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de problemas de algoritmos gulosos",
                                    "Ferramenta de desenho (ex: Draw.io ou papel)",
                                    "Calculadora"
                                  ],
                                  "tips": "Comece com instâncias pequenas para facilitar a visualização.",
                                  "learningObjective": "Habilitar a análise estrutural de problemas para identificar subproblemas potenciais.",
                                  "commonMistakes": [
                                    "Não especificar o critério de ordenação guloso.",
                                    "Pular a definição formal das entradas/saídas.",
                                    "Assumir decomposição sem justificativa."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a propriedade de subestrutura ótima",
                                  "subSteps": [
                                    "Assumir uma solução ótima OT e mostrar que inclui a escolha gulosa g.",
                                    "Provar por contradição: suponha OT não inclui g, troque e mostre melhoria ou igualdade.",
                                    "Verificar recursivamente que o subproblema restante S' tem solução ótima.",
                                    "Aplicar indução no tamanho do problema.",
                                    "Documentar a prova formal passo a passo."
                                  ],
                                  "verification": "Escrever uma prova curta (5-10 linhas) confirmando ou refutando a propriedade.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Modelos de provas de algoritmos gulosos",
                                    "Papel para rascunhos matemáticos"
                                  ],
                                  "tips": "Use a técnica de troca (exchange argument) comum em provas gulosas.",
                                  "learningObjective": "Aplicar técnicas de prova para validar subestrutura ótima.",
                                  "commonMistakes": [
                                    "Falhar na hipótese de indução.",
                                    "Não tratar o caso base da indução.",
                                    "Confundir prova com mera intuição."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar com exemplos e contraexemplos",
                                  "subSteps": [
                                    "Construir exemplos onde a propriedade segura (escolha gulosa + subótimo leva a ótimo).",
                                    "Buscar ou criar contraexemplos onde falha (escolha gulosa não leva a ótimo).",
                                    "Analisar instâncias numéricas: calcular soluções ótimas via exaustão e comparar com gulosa.",
                                    "Concluir se o problema possui subestrutura ótima com base nos testes.",
                                    "Registrar lições aprendidas dos contraexemplos."
                                  ],
                                  "verification": "Apresentar pelo menos um exemplo positivo e um contraexemplo, com cálculos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha ou código simples para enumeração (ex: Python para pequenos casos)",
                                    "Exemplos clássicos como intervalos e mochila"
                                  ],
                                  "tips": "Para contraexemplos, ajuste pesos ou restrições para forçar falha gulosa.",
                                  "learningObjective": "Validar teoricamente com evidências empíricas e refutações.",
                                  "commonMistakes": [
                                    "Usar exemplos muito simples que não revelam falhas.",
                                    "Não calcular a solução verdadeiramente ótima.",
                                    "Ignorar casos limítros (ex: n=1 ou n=2)."
                                  ]
                                }
                              ],
                              "practicalExample": "Problema de Seleção de Intervalos: Dado intervalos ordenados por fim, escolha o que termina primeiro (g), remova conflituosos, recursão no resto. Prova: Qualquer OT pode trocar por g sem piorar. Contraexemplo para Mochila 0/1 (não fracionária): Itens A(10un/60$), B(20un/100$), C(50un/120$), capacidade 50. Guloso por $/un pega B+C=70$, mas ótimo A+C=130$.",
                              "finalVerifications": [
                                "Define corretamente subestrutura ótima com notação formal.",
                                "Decompõe problema em subproblemas com diagrama.",
                                "Escreve prova por troca ou indução válida.",
                                "Fornece exemplo positivo e contraexemplo com cálculos numéricos.",
                                "Conclui corretamente se o problema possui a propriedade.",
                                "Explica impacto na viabilidade do algoritmo guloso."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e uso de termos técnicos (30%).",
                                "Qualidade da decomposição e prova formal (25%).",
                                "Robustez dos exemplos e contraexemplos (20%).",
                                "Clareza na documentação e diagramas (15%).",
                                "Conclusão lógica e insights adicionais (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução matemática e provas por contradição.",
                                "Programação: Implementação recursiva e testes unitários para validação.",
                                "Otimização: Modelagem em programação dinâmica vs. gulosa.",
                                "Lógica: Argumentos formais e refutação de hipóteses."
                              ],
                              "realWorldApplication": "Em agendamento de reuniões ou aulas (seleção de intervalos), priorização de tarefas em gerenciamento de projetos, ou alocação de recursos em logística onde decisões locais sequenciais levam a soluções globais ótimas sem backtracking."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.1.3",
                            "name": "Provar subestrutura ótima",
                            "description": "Demonstrar a existência de subestrutura ótima por contradição ou indução, aplicando ao lema de troca em contextos como Kruskal ou Prim para AGM.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Fundamentais de Subestrutura Ótima e Algoritmos AGM",
                                  "subSteps": [
                                    "Defina formalmente o problema da Árvore Geradora Mínima (AGM) em um grafo ponderado conexo.",
                                    "Explique o conceito de subestrutura ótima: uma solução ótima para o problema completo contém soluções ótimas para subproblemas.",
                                    "Descreva brevemente os algoritmos Kruskal e Prim, destacando sua natureza gulosa.",
                                    "Identifique onde a subestrutura ótima é crucial para justificar a corretude gulosa.",
                                    "Estude exemplos simples de grafos para visualizar AGM."
                                  ],
                                  "verification": "Escreva definições precisas e identifique subestruturas em um grafo exemplo.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Livro de Algoritmos (ex: CLRS)",
                                    "Papel e lápis para desenhar grafos",
                                    "Software de grafos como Graphviz ou yEd"
                                  ],
                                  "tips": [
                                    "Use notação matemática padrão para clareza.",
                                    "Desenhe grafos pequenos primeiro para intuição."
                                  ],
                                  "learningObjective": "Compreender os pré-requisitos teóricos para provas de subestrutura ótima.",
                                  "commonMistakes": [
                                    "Confundir AGM com caminho mínimo.",
                                    "Ignorar a conectividade do grafo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar o Lema de Troca para Kruskal ou Prim",
                                  "subSteps": [
                                    "Escolha um algoritmo específico (ex: Kruskal) e revise seu passo guloso principal.",
                                    "Enuncie o Lema de Troca: dada uma solução ótima O e uma solução gulosa G, existe uma troca de arestas que preserva otimalidade.",
                                    "Defina as condições para troca: arestas seguras e ciclos sem arestas mais leves.",
                                    "Prove propriedades auxiliares, como ausência de ciclos negativos.",
                                    "Prepare um grafo exemplo com múltiplas AGMs potenciais."
                                  ],
                                  "verification": "Escreva o lema formalmente e verifique em um grafo com 4-5 vértices.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "CLRS Capítulo 23",
                                    "Editor de texto para notações matemáticas (LaTeX)",
                                    "Ferramenta online para Kruskal (ex: Visualgo)"
                                  ],
                                  "tips": [
                                    "Comece com Prim se preferir árvores de expansão; Kruskal para florestas.",
                                    "Anote hipóteses explicitamente."
                                  ],
                                  "learningObjective": "Dominar o lema de troca como ferramenta para provar subestrutura ótima.",
                                  "commonMistakes": [
                                    "Esquecer que o grafo é não-direcionado e conexo.",
                                    "Não considerar pesos iguais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a Prova por Contradição ou Indução",
                                  "subSteps": [
                                    "Assuma uma solução ótima O que não satisfaz subestrutura ótima após k passos gulosa.",
                                    "Por contradição: mostre que existe uma aresta gulosa que pode substituir uma em O sem aumentar custo.",
                                    "Use indução: base (k=1), passo indutivo trocando arestas para preservar otimalidade.",
                                    "Aplique ao contexto Kruskal: prove que adicionar a aresta mais leve segura preserva AGM ótima.",
                                    "Formalize a prova completa com QED."
                                  ],
                                  "verification": "Escreva a prova passo a passo e cheque por falhas lógicas com um par.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Papel quadriculado para diagramas",
                                    "LaTeX ou Overleaf para prova formal",
                                    "Exemplos de provas de CLRS"
                                  ],
                                  "tips": [
                                    "Desenhe o ciclo de troca visualmente.",
                                    "Use 'suponha por absurdum' para contradição clara."
                                  ],
                                  "learningObjective": "Executar prova rigorosa de subestrutura ótima usando contradição ou indução.",
                                  "commonMistakes": [
                                    "Não lidar com múltiplas arestas de mesmo peso.",
                                    "Pular verificação de conectividade na subestrutura."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar a Prova em Exemplo Concreto e Sintetizar",
                                  "subSteps": [
                                    "Pegue um grafo exemplo (ex: 5 vértices, pesos variados) e compute AGM gulosa.",
                                    "Assuma solução alternativa 'ótima' violando subestrutura e aplique troca.",
                                    "Verifique que a troca resulta em AGM equivalente ou melhor.",
                                    "Generalize para Prim: prove subestrutura em subgrafos induzidos.",
                                    "Documente a prova completa com diagramas."
                                  ],
                                  "verification": "Simule a prova em código ou ferramenta e confirme custo mínimo igual.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Python com NetworkX para simular AGM",
                                    "Grafo exemplo impresso",
                                    "Visualizador de grafos"
                                  ],
                                  "tips": [
                                    "Teste com pesos iguais para robustez.",
                                    "Compare múltiplas AGMs."
                                  ],
                                  "learningObjective": "Aplicar e validar a prova em cenários práticos.",
                                  "commonMistakes": [
                                    "Escolher grafo desconexo.",
                                    "Não mostrar explicitamente a redução de custo ou equivalência."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo com vértices A,B,C,D e arestas: A-B(1), A-C(3), B-C(2), B-D(4), C-D(1). Kruskal adiciona A-B(1), C-D(1), B-C(2). Assuma O' = A-B(1), A-C(3), C-D(1) (custo 5 > 4). Troque B-C por A-C? Não: detecte ciclo A-B-C, troque A-C(3) por B-C(2) em O', obtendo custo 4, provando subestrutura.",
                              "finalVerifications": [
                                "Prova escrita identifica suposição contraditória corretamente.",
                                "Lema de troca aplicado sem erros em exemplo.",
                                "Indução ou contradição leva a QED lógico.",
                                "Exemplo concreto mostra preservação de otimalidade.",
                                "Generalização para Kruskal e Prim explícita.",
                                "Diagramas ilustram trocas de arestas."
                              ],
                              "assessmentCriteria": [
                                "Rigor matemático na definição e prova (sem falhas lógicas).",
                                "Clareza na enunciação do lema de troca e aplicação.",
                                "Correção na identificação de subestruturas ótimas.",
                                "Uso apropriado de contradição ou indução.",
                                "Exemplo prático resolve com custo mínimo verificado.",
                                "Generalização para ambos algoritmos."
                              ],
                              "crossCurricularConnections": [
                                "Lógica Matemática: Provas por contradição e indução.",
                                "Teoria dos Grafos: Estruturas e propriedades de árvores.",
                                "Programação: Implementação e verificação de algoritmos em Python/NetworkX.",
                                "Otimização: Critérios de escolha gulosa em problemas NP.",
                                "Análise de Algoritmos: Provas de corretude."
                              ],
                              "realWorldApplication": "Em design de redes de telecomunicações, provar subestrutura ótima garante que adicionar links mais baratos (Kruskal) mantém rede mínima custo, otimizando infraestrutura global como backbones de internet."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.3.2",
                        "name": "Escolha Gulosa Segura",
                        "description": "Propriedade que assegura que existe uma escolha gulosa local ótima que pode ser incluída em alguma solução ótima global, validando a estratégia gulosa.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.3.2.1",
                            "name": "Definir escolha gulosa segura",
                            "description": "Descrever o conceito de escolha gulosa segura, contrastando com métodos exaustivos e programação dinâmica, com exemplos de ordenação topológica ou Huffman.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Algoritmos Gulosos",
                                  "subSteps": [
                                    "Ler a definição formal de algoritmo guloso: seleção de escolha local ótima em cada etapa.",
                                    "Identificar propriedades: subestrutura ótima e otimalidade gulosa.",
                                    "Estudar o critério de otimalidade gulosa como pré-requisito.",
                                    "Anotar exemplos iniciais como seleção de atividades.",
                                    "Discutir limitações gerais dos métodos gulosos."
                                  ],
                                  "verification": "Escrever um resumo de 3-5 frases explicando algoritmos gulosos e suas propriedades.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre Algoritmos Gulosos",
                                    "Livro 'Introduction to Algorithms' (Cormen)",
                                    "Vídeo introdutório no YouTube sobre greedy algorithms"
                                  ],
                                  "tips": "Use diagramas para visualizar decisões locais versus globais.",
                                  "learningObjective": "Compreender a base conceitual necessária para escolhas gulosas seguras.",
                                  "commonMistakes": [
                                    "Confundir guloso com exaustivo desde o início",
                                    "Ignorar a necessidade de subestrutura ótima"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Conceito de Escolha Gulosa Segura",
                                  "subSteps": [
                                    "Definir escolha gulosa segura: uma escolha local que pode ser parte de uma solução ótima global.",
                                    "Explicar o teste de segurança: provar que a escolha não compromete soluções ótimas subsequentes.",
                                    "Estudar a exchange property: trocar elementos sem piorar a otimalidade.",
                                    "Formalizar com notação matemática: se S é solução ótima e contém escolha c, então existe solução ótima com c.",
                                    "Praticar reescrevendo a definição em suas próprias palavras."
                                  ],
                                  "verification": "Explicar verbalmente ou por escrito o que torna uma escolha 'segura' em um contexto guloso.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Artigo acadêmico sobre greedy choice property",
                                    "Slides do curso TC-55",
                                    "Quadro branco para anotações"
                                  ],
                                  "tips": "Pense em 'segura' como 'não há arrependimento posterior'.",
                                  "learningObjective": "Dominar a definição precisa e o raciocínio por trás da escolha gulosa segura.",
                                  "commonMistakes": [
                                    "Definir como qualquer escolha local ótima",
                                    "Omitir a prova de segurança"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contrastar com Métodos Exaustivos e Programação Dinâmica",
                                  "subSteps": [
                                    "Comparar com exaustivo: guloso evita enumeração completa, mas requer segurança.",
                                    "Contrastar com PD: guloso não usa sobreposição de subproblemas, foca em escolhas seguras únicas.",
                                    "Criar tabela comparativa: eficiência, garantias, exemplos de falha.",
                                    "Analisar quando guloso falha sem segurança (ex: knapsack fracionário vs inteiro).",
                                    "Discutir trade-offs: tempo vs garantia de otimalidade."
                                  ],
                                  "verification": "Preencher uma tabela comparativa com pelo menos 4 critérios diferenciais.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou Google Sheets para tabela",
                                    "Pseudocódigos de algoritmos exaustivo/PD/guloso"
                                  ],
                                  "tips": "Use Big-O para destacar eficiência do guloso quando seguro.",
                                  "learningObjective": "Diferenciar claramente escolha gulosa segura de alternativas.",
                                  "commonMistakes": [
                                    "Achar que PD é sempre superior",
                                    "Ignorar casos onde guloso é exato"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Exemplos Práticos: Ordenação Topológica e Huffman",
                                  "subSteps": [
                                    "Estudar ordenação topológica: escolha gulosa segura de nó sem pré-requisitos.",
                                    "Analisar Huffman: merge dos nós de menor frequência como escolha segura.",
                                    "Provar segurança em cada exemplo usando exchange property.",
                                    "Implementar pseudocódigo simples para um dos exemplos.",
                                    "Identificar por que essas escolhas são seguras e levam à solução ótima."
                                  ],
                                  "verification": "Desenhar o grafo/árvore e simular 3 iterações, justificando segurança.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Ferramenta de grafos como Graphviz ou Draw.io",
                                    "Implementação Python de Huffman (código exemplo)"
                                  ],
                                  "tips": "Simule passo a passo com dados pequenos para visualizar.",
                                  "learningObjective": "Aplicar o conceito em exemplos clássicos para fixação.",
                                  "commonMistakes": [
                                    "Confundir topological sort com Dijkstra",
                                    "Não provar a segurança explicitamente"
                                  ]
                                }
                              ],
                              "practicalExample": "No algoritmo de codificação de Huffman para compressão de dados: dada uma lista de frequências {A:5, B:9, C:12, D:13, E:14, F:45}, a escolha gulosa segura é sempre mesclar os dois nós de menor frequência (inicialmente A e B), criando uma subárvore que pode ser trocada em qualquer árvore ótima sem piorar o custo total, garantindo otimalidade.",
                              "finalVerifications": [
                                "Definir precisamente 'escolha gulosa segura' com exchange property.",
                                "Explicar contraste com métodos exaustivos (eficiência) e PD (sem sobreposição).",
                                "Identificar escolhas seguras em ordenação topológica e Huffman.",
                                "Provar segurança em um exemplo simples.",
                                "Discutir quando uma escolha local não é segura (ex: mochila 0/1)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (80% match com formalismo padrão).",
                                "Clareza no contraste com exaustivo/PD (tabela ou diagrama).",
                                "Correção na análise de exemplos (Huffman/topological).",
                                "Uso de prova de segurança/exchange.",
                                "Profundidade: inclusão de limitações e trade-offs.",
                                "Comunicação: explicação concisa e sem jargões desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (topological sort) e Otimização Combinatória.",
                                "Programação: Implementação de Heaps/Priority Queues em Huffman.",
                                "Economia: Modelos de decisão gulosa em alocação de recursos limitados.",
                                "Engenharia de Software: Agendamento de tarefas com dependências."
                              ],
                              "realWorldApplication": "Em compressão de arquivos ZIP (Huffman para codificação eficiente de dados), ou em sistemas de gerenciamento de projetos (topological sort para ordenar tarefas com dependências, garantindo cronograma ótimo sem ciclos)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.3.2.2",
                            "name": "Identificar escolha gulosa segura",
                            "description": "Reconhecer em problemas específicos (ex.: caminho mais curto em grafos DAG ou fluxo máximo) se uma escolha gulosa é segura, avaliando impactos na otimalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Escolha Gulosa Segura",
                                  "subSteps": [
                                    "Defina uma escolha gulosa como a seleção da opção localmente ótima em cada etapa sem reconsiderações futuras.",
                                    "Explique 'segura' como uma escolha que preserva a existência de uma solução ótima global subsequente.",
                                    "Estude a propriedade de troca (exchange argument): qualquer solução ótima pode ser ajustada para incluir a escolha gulosa sem aumentar o custo.",
                                    "Revise exemplos clássicos como relaxação em grafos DAG para caminhos mais curtos.",
                                    "Compare com escolhas não seguras, como em problemas de mochila fracionária sem subestrutura ótima."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo a definição e dê um exemplo de escolha segura versus não segura.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de algoritmos gulosos",
                                    "Artigo ou vídeo sobre critério de otimalidade gulosa"
                                  ],
                                  "tips": "Sempre relacione a escolha com a preservação da subestrutura ótima restante.",
                                  "learningObjective": "Dominar a definição teórica e a justificativa da escolha gulosa segura.",
                                  "commonMistakes": [
                                    "Confundir segurança com otimalidade imediata",
                                    "Ignorar o exchange argument em exemplos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Estruturas de Problemas Propícias",
                                  "subSteps": [
                                    "Liste problemas clássicos: caminhos mais curtos em DAGs, fluxo máximo com Ford-Fulkerson greedy, MST com Kruskal/Prim.",
                                    "Analise características: matroide, submodularidade ou ordenação topológica.",
                                    "Verifique pré-condições: ausência de ciclos negativos, capacidades não bloqueantes.",
                                    "Classifique problemas: seguidos por 'sim' (DAG shortest path) vs. 'não' (knapsack 0/1).",
                                    "Crie uma tabela comparativa de 5 problemas com razões."
                                  ],
                                  "verification": "Classifique 3 problemas dados como propícios ou não, justificando cada um.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de problemas de algoritmos gulosos",
                                    "Ferramenta de grafos como Graphviz ou papel e lápis"
                                  ],
                                  "tips": "Procure por ordenações naturais ou independências que garantam segurança.",
                                  "learningObjective": "Reconhecer padrões de problemas onde escolhas gulosas são seguras.",
                                  "commonMistakes": [
                                    "Aplicar greedy universalmente sem verificar estrutura",
                                    "Confundir com problemas NP-difíceis"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Avaliar Impacto na Otimalidade",
                                  "subSteps": [
                                    "Aplique o teste de segurança: suponha a escolha gulosa; prove que uma solução ótima existe no subproblema restante.",
                                    "Use indução: base (escolha inicial segura), passo (subproblema herda propriedades).",
                                    "Simule em grafo pequeno: adicione arestas e veja se relaxação mantém distâncias ótimas.",
                                    "Teste contra-contraprova: tente uma instância onde greedy falha e explique por quê.",
                                    "Documente o argumento de troca para o exemplo escolhido."
                                  ],
                                  "verification": "Para um grafo DAG dado, prove formalmente que a escolha greedy de menor distância é segura.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de grafos online (ex: draw.io)",
                                    "Pseudocódigo de algoritmos gulosos"
                                  ],
                                  "tips": "Desenhe o grafo e trace soluções ótimas antes e após a escolha.",
                                  "learningObjective": "Aplicar métodos formais para validar segurança de escolhas gulosas.",
                                  "commonMistakes": [
                                    "Pular a prova de indução",
                                    "Assumir segurança sem contraexemplo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação e Verificação em Exemplos",
                                  "subSteps": [
                                    "Resolva 3 exercícios: identifique escolhas seguras em DAG, fluxo max e um falso positivo.",
                                    "Implemente pseudocódigo destacando a escolha gulosa e comente a segurança.",
                                    "Debata em fórum ou autoavaliação: 'É segura? Por quê ou por quê não?'.",
                                    "Gere um problema próprio e aplique o critério.",
                                    "Revise erros e refine compreensão."
                                  ],
                                  "verification": "Submeta soluções para 5 problemas variados com justificativas corretas em 80%.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exercícios de plataformas como LeetCode ou livros de algoritmos",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Varie tamanhos de instâncias para testar generalidade.",
                                  "learningObjective": "Aplicar o critério de forma autônoma em problemas novos.",
                                  "commonMistakes": [
                                    "Não testar casos fronteira",
                                    "Justificativas vagas sem prova"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo DAG para o problema de caminho mais curto, a escolha gulosa de relaxar o vértice com a menor distância atual é segura porque, pela ordenação topológica, todas as arestas de entrada foram processadas, garantindo que a distância seja ótima e subsequentes relaxações não a invalidem (provado por indução sobre o topo-sort).",
                              "finalVerifications": [
                                "Explique corretamente o exchange argument em pelo menos 2 exemplos clássicos.",
                                "Identifique escolhas seguras em 4/5 problemas dados sem erros.",
                                "Prove segurança usando indução em um grafo personalizado.",
                                "Distinga escolhas seguras de não seguras em problemas mistos.",
                                "Gere e valide um contraexemplo para um problema não-guloso.",
                                "Resuma o critério em um fluxograma acionável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de estruturas propícias (90% acerto).",
                                "Qualidade das provas de segurança (formal e completa).",
                                "Capacidade de gerar contraexemplos relevantes.",
                                "Profundidade na análise de impacto na otimalidade.",
                                "Aplicação consistente em exercícios variados.",
                                "Clareza nas justificativas escritas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por indução e propriedades de matroides.",
                                "Economia: Decisões marginais e otimização local em alocação de recursos.",
                                "Engenharia de Software: Heurísticas em compiladores e scheduling.",
                                "Física: Princípios variacionais em trajetórias ótimas.",
                                "Gestão: Planejamento estratégico greedy em projetos ágeis."
                              ],
                              "realWorldApplication": "Em roteamento de dados em redes sem ciclos (DAGs como em computação em nuvem), identificar escolhas gulosas seguras permite algoritmos eficientes como Dijkstra modificado, otimizando latência sem comprometer a globalidade, usado em CDNs da Netflix ou AWS para paths de menor custo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.3.2.3",
                            "name": "Provar escolha gulosa segura",
                            "description": "Utilizar o lema de escolha gulosa para provar que uma decisão local (ex.: aresta de menor peso em Kruskal) leva a uma solução ótima, integrando com subestrutura ótima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o contexto do problema e identificar a escolha gulosa",
                                  "subSteps": [
                                    "Defina o problema de otimização, como encontrar uma Árvore Geradora Mínima (MST) em um grafo não direcionado ponderado.",
                                    "Identifique a escolha gulosa específica, ex.: no algoritmo de Kruskal, selecionar a aresta de menor peso que não forma ciclo.",
                                    "Descreva as propriedades do grafo: conexo, sem laços, pesos positivos.",
                                    "Estabeleça a solução ótima alvo (MST com peso mínimo total).",
                                    "Anote o lema de escolha gulosa: existe uma solução ótima que inclui a escolha gulosa."
                                  ],
                                  "verification": "Escreva um parágrafo resumindo o problema e a escolha gulosa identificada corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Diagrama de grafo exemplo (ex.: Graphviz ou draw.io)"
                                  ],
                                  "tips": "Desenhe o grafo para visualizar ciclos potenciais e arestas candidatas.",
                                  "learningObjective": "Entender o setup preciso para aplicar o lema de escolha gulosa.",
                                  "commonMistakes": "Ignorar a condição de 'não formar ciclo' ou assumir grafos desconexos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Enunciar formalmente o Lema de Escolha Gulosa Segura",
                                  "subSteps": [
                                    "Escreva o lema: 'Para a escolha gulosa e (menor peso sem ciclo), existe uma MST ótima O tal que e ∈ O'.",
                                    "Explique os componentes: escolha local ótima (menor peso) e propriedade global (incluída em alguma MST).",
                                    "Lembre o teorema de caracterização de MST: uma árvore é MST se para toda aresta não incluída, seu peso é ≥ peso da aresta máxima no caminho entre seus endpoints na árvore.",
                                    "Prepare o contraexemplo hipotético: suponha que toda MST ótima exclua e.",
                                    "Defina notações: G=(V,E), e={u,v} com peso w(e) mínimo."
                                  ],
                                  "verification": "Reescreva o lema e suas premissas em linguagem formal sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de anotações",
                                    "Livro ou referência de Algoritmos (ex.: Cormen et al., Cap. 23)"
                                  ],
                                  "tips": "Use notação matemática padrão (ex.: w(e)) para clareza.",
                                  "learningObjective": "Dominar a formulação precisa do lema para provas formais.",
                                  "commonMistakes": "Confundir lema de escolha gulosa com subestrutura ótima."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a prova por argumento de troca (exchange argument)",
                                  "subSteps": [
                                    "Assuma uma MST ótima O que não contém e; O conecta u e v via um caminho P com aresta f máxima em P.",
                                    "Mostre w(e) ≤ w(f), pois e é a menor peso sem ciclo.",
                                    "Crie O' removendo f de O e adicionando e: O' permanece árvore (conecta componentes).",
                                    "Prove w(O') ≤ w(O), pois w(e) ≤ w(f), então O' também é MST.",
                                    "Conclua: existe MST ótima (O') que inclui e, provando segurança."
                                  ],
                                  "verification": "Desenhe o grafo antes/depois da troca e calcule pesos para confirmar.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de grafos (ex.: GeoGebra ou papel quadriculado)",
                                    "Exemplo numérico impresso"
                                  ],
                                  "tips": "Sempre verifique se adicionar e não cria ciclo (por construção, não).",
                                  "learningObjective": "Aplicar técnica de troca para provar inclusão em solução ótima.",
                                  "commonMistakes": "Esquecer de provar que O' é acíclica ou que w(O') ≤ w(O)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar subestrutura ótima e generalizar a prova",
                                  "subSteps": [
                                    "Induza recursivamente: após fixar e, o subgrafo contraído tem subestrutura ótima.",
                                    "Confirme o Lema de Subestrutura Ótima: solução ótima para subproblema combina com escolha gulosa.",
                                    "Teste com exemplo concreto: grafo K4 com arestas AB=1, AC=2, AD=3, BC=4, BD=5, CD=6.",
                                    "Generalize para outros algoritmos gulosos (ex.: Prim, Huffman).",
                                    "Escreva conclusão: escolha gulosa é segura."
                                  ],
                                  "verification": "Aplique a prova ao exemplo e liste MSTs ótimas incluindo a escolha.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para somas de pesos",
                                    "Referência de exemplos de MST"
                                  ],
                                  "tips": "Use contração de arestas para visualizar subproblemas.",
                                  "learningObjective": "Integrar escolha segura com subestrutura para prova completa de optimalidade.",
                                  "commonMistakes": "Parar na escolha segura sem ligar à recursão total."
                                }
                              ],
                              "practicalExample": "Considere grafo com vértices A,B,C,D e arestas: AB=1, AC=2, AD=4, BC=3, BD=5, CD=6. Escolha gulosa: AB=1 (menor peso, sem ciclo). Assuma MST O={AC=2, BC=3, BD=5} (peso 10, exclui AB). Caminho A-C-B em O tem f=BC=3 ≥1. Troque: O'={AB=1, AC=2, BD=5} (peso 8 ≤10, inclui AB). Logo, existe MST ótima com AB.",
                              "finalVerifications": [
                                "Escreva a prova completa sem lacunas lógicas.",
                                "Identifique corretamente a aresta de troca f em qualquer MST exemplo.",
                                "Confirme que a troca preserva conectividade e aciclicidade.",
                                "Gere pelo menos duas MST ótimas, uma incluindo a escolha gulosa.",
                                "Explique verbalmente os passos para um par.",
                                "Teste prova em grafo diferente com pesos variados."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: argumento de troca válido e sem falácias.",
                                "Clareza: notação formal, diagramas e passos sequenciais.",
                                "Precisão: uso exato do lema e teorema de MST.",
                                "Completude: inclusão de subestrutura ótima.",
                                "Originalidade: adaptação ao exemplo específico.",
                                "Robustez: generalização para casos edge (ex.: múltiplas arestas mínimas)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos (Matemática Discreta): propriedades de MST e ciclos.",
                                "Lógica Matemática: provas por contradição e indução.",
                                "Programação: implementação de Kruskal e verificação de MST.",
                                "Otimização em Engenharia: minimização de custos em redes.",
                                "Estatística: análise de heurísticas gulosas vs. exaustivas."
                              ],
                              "realWorldApplication": "Em planejamento de redes de telecomunicações, provar que selecionar links de menor custo (sem loops) no algoritmo de Kruskal garante a infraestrutura mínima ótima, economizando milhões em cabos de fibra ótica sem comprometer conectividade."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.3.1.3",
                              "10.1.3.3.2.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.4",
                    "name": "Exemplos Clássicos: Seleção de Intervalos",
                    "description": "Algoritmo para maximizar o número de intervalos não sobrepostos ordenando por tempo de término.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.4.1",
                        "name": "Definição do Problema de Seleção de Intervalos",
                        "description": "Compreender o problema clássico de selecionar o máximo número de intervalos não sobrepostos em uma linha reta, onde cada intervalo é definido por um início e um fim.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.1.1",
                            "name": "Representar intervalos",
                            "description": "Definir e representar intervalos como pares ordenados (início, fim) com início < fim, e criar estruturas de dados como listas ou vetores para armazenar múltiplos intervalos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de intervalo",
                                  "subSteps": [
                                    "Ler a definição formal: um intervalo é um par ordenado (início, fim) onde início < fim.",
                                    "Analisar exemplos cotidianos, como horários de reuniões (ex: (9:00, 10:30)).",
                                    "Identificar os requisitos: início sempre menor que fim, representados como números (inteiros ou reais).",
                                    "Diferenciar de outros pares: aqui fim é exclusivo ou inclusivo conforme contexto, mas foco em ordenação.",
                                    "Discutir casos inválidos: início >= fim."
                                  ],
                                  "verification": "Explicar em 2-3 frases o que é um intervalo e dar um exemplo válido e um inválido.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Slides ou documento sobre definição de intervalos",
                                    "Papel e caneta para anotações"
                                  ],
                                  "tips": "Use analogias como 'início de uma aula até o fim' para fixar o conceito.",
                                  "learningObjective": "Dominar a definição conceitual de intervalo como par ordenado com restrição de ordem.",
                                  "commonMistakes": [
                                    "Confundir ordem (fim < início)",
                                    "Ignorar a restrição início < fim",
                                    "Usar tipos de dados inadequados (strings sem conversão)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar um intervalo individual como par ordenado",
                                  "subSteps": [
                                    "Escolher uma linguagem ou pseudocódigo (ex: Python com tupla (inicio, fim)).",
                                    "Criar um intervalo exemplo: intervalo = (8.0, 9.5).",
                                    "Implementar uma função para validar: def is_valid_interval(interval): return interval[0] < interval[1].",
                                    "Testar com casos válidos e inválidos.",
                                    "Documentar o intervalo com comentários no código."
                                  ],
                                  "verification": "Executar código que cria e valida um intervalo, mostrando saída correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Jupyter)",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Sempre use floats para horários para precisão em comparações.",
                                  "learningObjective": "Implementar e validar a representação de um único intervalo em estrutura de dados.",
                                  "commonMistakes": [
                                    "Esquecer validação de ordem",
                                    "Usar listas mutáveis em vez de tuplas imutáveis",
                                    "Erros de sintaxe em pares ordenados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar estruturas para múltiplos intervalos",
                                  "subSteps": [
                                    "Definir uma lista ou vetor: intervals = [(1,3), (2,4), (5,7)].",
                                    "Implementar função para adicionar intervalos com validação automática.",
                                    "Iterar sobre a lista para imprimir ou verificar todos os intervalos.",
                                    "Ordenar a lista por início (opcional, preview para algoritmos gulosos).",
                                    "Salvar/carregar lista em arquivo JSON para persistência."
                                  ],
                                  "verification": "Criar uma lista com 5 intervalos, validar todos e exibir sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de listas em documentação de linguagem"
                                  ],
                                  "tips": "Use comprehensions para validação em massa: all(i[0] < i[1] for i in intervals).",
                                  "learningObjective": "Construir e manipular coleções de intervalos em listas ou vetores.",
                                  "commonMistakes": [
                                    "Não validar intervalos na inserção",
                                    "Índices errados ao acessar pares",
                                    "Listas vazias sem tratamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e refinar representações",
                                  "subSteps": [
                                    "Gerar 10 intervalos aleatórios e armazená-los em lista.",
                                    "Filtrar intervalos inválidos e corrigir.",
                                    "Visualizar com gráfico simples (ex: matplotlib para barras).",
                                    "Comparar representações: lista vs. array numpy.",
                                    "Refatorar código para reutilização em problemas maiores."
                                  ],
                                  "verification": "Produzir código funcional com lista de 10 intervalos validados e visualização.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca de plotting (matplotlib)",
                                    "Gerador de números aleatórios"
                                  ],
                                  "tips": "Teste edge cases: início == fim - epsilon, intervalos sobrepostos.",
                                  "learningObjective": "Aplicar representações em cenários práticos e refinar para escalabilidade.",
                                  "commonMistakes": [
                                    "Overlaps não detectados",
                                    "Performance ruim com listas grandes",
                                    "Falta de visualização para debug"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de agendamento de salas de aula, represente os horários das aulas do dia como lista de intervalos: intervals = [(8.0, 9.30), (9.45, 11.15), (13.0, 14.30), (15.0, 16.45)]. Valide que nenhum tem início >= fim e prepare para seleção gulosa de salas não conflitantes.",
                              "finalVerifications": [
                                "Definir corretamente um intervalo como par ordenado com início < fim.",
                                "Criar e validar uma lista de pelo menos 5 intervalos sem erros.",
                                "Implementar função de validação que rejeita casos inválidos.",
                                "Exibir ou salvar a estrutura de dados corretamente.",
                                "Identificar e corrigir erros comuns em representações.",
                                "Visualizar intervalos em linha do tempo simples."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: 100% de definições corretas.",
                                "Implementação funcional: código roda sem erros e valida corretamente.",
                                "Cobertura de casos: testes incluem válidos, inválidos e edge cases.",
                                "Eficiência: validação em O(n) para listas.",
                                "Clareza: código comentado e estrutura legível.",
                                "Criatividade: extensão com visualização ou persistência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Intervalos numéricos e desigualdades.",
                                "Programação: Estruturas de dados (listas, tuplas) e validação.",
                                "Algoritmos: Preparação para ordenação e algoritmos gulosos.",
                                "Gestão de Projetos: Agendamento de tarefas e recursos.",
                                "Ciência de Dados: Representação temporal em datasets."
                              ],
                              "realWorldApplication": "Em softwares de calendário como Google Calendar ou Microsoft Outlook, intervalos representam eventos; em logística, alocam veículos por turnos; em programação de TV/rádio, slots de transmissão; essencial para evitar sobreposições em sistemas de reservas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.4.1.2",
                            "name": "Detectar sobreposição de intervalos",
                            "description": "Implementar uma função para verificar se dois intervalos se sobrepõem, usando a condição: não(i1.fim <= i2.início ou i2.fim <= i1.início).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Intervalos e Sobreposição Visual",
                                  "subSteps": [
                                    "Defina um intervalo como um par de números reais [início, fim] onde início ≤ fim.",
                                    "Desenhe em um eixo numérico exemplos de dois intervalos que se sobrepõem (ex: [1,3] e [2,4]).",
                                    "Desenhe exemplos de intervalos que não se sobrepõem (ex: [1,2] e [3,4]).",
                                    "Identifique casos adjacentes (ex: [1,2] e [2,3]) e decida se consideram sobreposição (geralmente não).",
                                    "Discuta intervalos com pontos em comum apenas no fim."
                                  ],
                                  "verification": "Desenhar e rotular 5 diagramas de pares de intervalos indicando se sobrepõem ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta online como Desmos ou GeoGebra"
                                  ],
                                  "tips": [
                                    "Sempre visualize graficamente antes de codificar.",
                                    "Use cores diferentes para cada intervalo."
                                  ],
                                  "learningObjective": "Visualizar e diferenciar graficamente sobreposições de intervalos.",
                                  "commonMistakes": [
                                    "Considerar intervalos adjacentes como sobrepostos.",
                                    "Confundir intervalos abertos vs fechados.",
                                    "Ignorar ordem dos intervalos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar a Condição Lógica Matemática",
                                  "subSteps": [
                                    "Analise quando dois intervalos NÃO se sobrepõem: i1.fim ≤ i2.início ou i2.fim ≤ i1.início.",
                                    "Escreva a condição em notação matemática para um par genérico (i1, i2).",
                                    "Negue a condição de não-sobreposição usando De Morgan: sobrepõe se !(não1 OU não2).",
                                    "Simplifique para: i1.início ≤ i2.fim AND i2.início ≤ i1.fim.",
                                    "Teste a condição derivada com exemplos visuais do passo 1."
                                  ],
                                  "verification": "Escrever a condição lógica correta e validá-la com 3 exemplos manuais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de papel para anotações lógicas",
                                    "Calculadora para testes numéricos"
                                  ],
                                  "tips": [
                                    "Use tabelas de verdade para validar negações lógicas.",
                                    "Escreva em pseudocódigo primeiro."
                                  ],
                                  "learningObjective": "Derivar e compreender a fórmula booleana para detecção de sobreposição.",
                                  "commonMistakes": [
                                    "Erro na negação de De Morgan.",
                                    "Usar < em vez de ≤.",
                                    "Confundir início e fim nas condições."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Função de Detecção em Código",
                                  "subSteps": [
                                    "Defina a assinatura da função: def overlaps(interval1, interval2): onde interval é dict {'start': float, 'end': float}.",
                                    "Implemente a lógica: return not (interval1['end'] <= interval2['start'] or interval2['end'] <= interval1['start']).",
                                    "Adicione validação básica: se start > end, levante erro ValueError.",
                                    "Inclua docstring explicando parâmetros, retorno e exemplos.",
                                    "Teste manualmente no interpretador com 2 exemplos."
                                  ],
                                  "verification": "Função executa sem erros e retorna booleano correto para exemplos conhecidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": [
                                    "Use nomes descritivos para variáveis.",
                                    "Considere generalizar para listas de intervalos futuramente."
                                  ],
                                  "learningObjective": "Codificar a lógica de sobreposição de forma limpa e robusta.",
                                  "commonMistakes": [
                                    "Não validar intervalos malformados.",
                                    "Usar == em vez de <=.",
                                    "Esquecer importações se necessário."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar a Função com Casos Abrangentes",
                                  "subSteps": [
                                    "Crie uma suíte de testes: sobrepostos, não sobrepostos, adjacentes, idênticos, um contido no outro.",
                                    "Implemente função de teste usando assert: ex: assert overlaps({'start':1,'end':3}, {'start':2,'end':4}) == True.",
                                    "Teste edge cases: intervalos vazios, negativos, pontos (start==end).",
                                    "Meça performance com 1000 chamadas aleatórias (opcional).",
                                    "Registre falhas e corrija."
                                  ],
                                  "verification": "Todos os 10+ testes passam sem falhas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Biblioteca unittest ou pytest (opcional)"
                                  ],
                                  "tips": [
                                    "Comece com testes simples, depois edge cases.",
                                    "Automatize testes para reutilização."
                                  ],
                                  "learningObjective": "Garantir robustez da função através de testes sistemáticos.",
                                  "commonMistakes": [
                                    "Ignorar edge cases como intervalos invertidos.",
                                    "Testes insuficientes.",
                                    "Não tratar floats com precisão."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de reservas de salas de aula, implemente overlaps para verificar se duas aulas ([08:00, 09:30] e [09:00, 10:00]) conflitam, evitando alocações sobrepostas.",
                              "finalVerifications": [
                                "Explicar verbalmente a condição lógica derivada.",
                                "Implementar função que passa em 10 testes variados.",
                                "Identificar e corrigir um edge case fornecido.",
                                "Visualizar sobreposição para intervalos dados.",
                                "Discutir aplicação em seleção de intervalos gulosa.",
                                "Codificar versão alternativa usando a forma AND."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica em todos os casos testados (100%).",
                                "Clareza e legibilidade do código (docstring, nomes).",
                                "Tratamento de edge cases e validações.",
                                "Eficiência O(1) constante.",
                                "Explicação precisa da derivação matemática.",
                                "Criatividade em exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Lógica proposicional e leis de De Morgan.",
                                "Física: Detecção de colisões em simulações 1D.",
                                "Gestão de Projetos: Alocação de recursos e scheduling.",
                                "Banco de Dados: Verificação de overlaps em consultas temporais."
                              ],
                              "realWorldApplication": "Fundamental no algoritmo guloso de Seleção de Intervalos para maximizar atividades não sobrepostas, usado em agendamento de reuniões, alocação de frequências de rádio e edição de vídeo para evitar sobreposições de clipes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.1.3",
                            "name": "Formular o objetivo do problema",
                            "description": "Enunciar o objetivo de maximizar o número de intervalos selecionados sem sobreposições, distinguindo de problemas relacionados como minimizar salas de aula.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar os elementos fundamentais do problema",
                                  "subSteps": [
                                    "Leia a descrição inicial do problema de seleção de intervalos.",
                                    "Identifique os dados de entrada: um conjunto de intervalos, cada um definido por um tempo de início e fim.",
                                    "Defina a saída desejada: um subconjunto de intervalos.",
                                    "Liste exemplos de intervalos possíveis, como [1-3], [2-5], [4-6].",
                                    "Registre os componentes em um diagrama de linha do tempo."
                                  ],
                                  "verification": "Crie uma lista clara de entrada e saída esperada e desenhe um diagrama simples.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Descrição do problema",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Sempre visualize intervalos em uma linha do tempo para clareza.",
                                  "learningObjective": "Compreender os dados de entrada e saída do problema de seleção de intervalos.",
                                  "commonMistakes": [
                                    "Ignorar que intervalos têm início e fim precisos",
                                    "Confundir intervalos com pontos isolados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a restrição de não sobreposição",
                                  "subSteps": [
                                    "Defina sobreposição: dois intervalos (a,b) e (c,d) se sobrepõem se max(a,c) < min(b,d).",
                                    "Especifique que o subconjunto selecionado não deve ter nenhum par sobreposto.",
                                    "Dê exemplos: [1-3] e [2-4] sobrepõem; [1-3] e [4-5] não.",
                                    "Formalize: para todo par i,j selecionados, b_i <= c_j ou b_j <= c_i.",
                                    "Teste com 3 intervalos e marque pares sobrepostos."
                                  ],
                                  "verification": "Desenhe 3 intervalos e identifique corretamente quais pares não se sobrepõem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para diagrama de linha do tempo",
                                    "Lista de intervalos de exemplo"
                                  ],
                                  "tips": "Use uma régua imaginária na linha do tempo para checar overlaps visualmente.",
                                  "learningObjective": "Formalizar a restrição principal do problema.",
                                  "commonMistakes": [
                                    "Considerar toque nas extremidades como sobreposição",
                                    "Ignorar ordem temporal dos intervalos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estabelecer o objetivo de maximização",
                                  "subSteps": [
                                    "Questione: qual métrica otimizar? Número de intervalos selecionados.",
                                    "Enuncie: maximizar o tamanho do subconjunto sem sobreposições.",
                                    "Compare com cobertura total: aqui não precisamos selecionar todos.",
                                    "Escreva o objetivo: 'Encontrar o maior número k tal que existe k intervalos sem sobreposições'.",
                                    "Calcule para um exemplo pequeno o máximo possível."
                                  ],
                                  "verification": "Escreva o objetivo em uma frase clara e compute para um conjunto de 4 intervalos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos de conjuntos de intervalos",
                                    "Calculadora ou papel"
                                  ],
                                  "tips": "Pense em 'maior subconjunto possível' em vez de cobrir tudo.",
                                  "learningObjective": "Definir precisamente o critério de otimização.",
                                  "commonMistakes": [
                                    "Confundir com minimizar algo",
                                    "Achar que é selecionar todos os intervalos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar de problemas relacionados",
                                  "subSteps": [
                                    "Descreva problema de salas de aula: minimizar salas para alocar TODOS intervalos.",
                                    "Compare: seleção maximiza sem overlap (subconjunto); salas minimiza recursos para todos.",
                                    "Destaque: seleção é 'maior independente set'; salas é 'coloring mínimo'.",
                                    "Dê exemplo: mesmos intervalos, seleção pega 2; salas precisa de 2 salas.",
                                    "Explique por que distinção importa para escolha de algoritmo."
                                  ],
                                  "verification": "Escreva 2-3 frases comparando com alocação de salas e dê um exemplo numérico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Descrições de problemas relacionados",
                                    "Exemplos compartilhados"
                                  ],
                                  "tips": "Use tabelas para comparar objetivos e soluções.",
                                  "learningObjective": "Distinguir o problema de seleção de intervalos de variantes semelhantes.",
                                  "commonMistakes": [
                                    "Misturar maximizar seleção com minimizar salas",
                                    "Ignorar que salas cobre todos"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado o conjunto de intervalos de reuniões: A[9:00-10:00], B[9:30-11:00], C[10:30-11:30], D[12:00-13:00]. O objetivo é selecionar o máximo sem sobreposições, e.g., A e C e D (3 reuniões), distinguindo de alocar salas mínimas para todas (2 salas necessárias).",
                              "finalVerifications": [
                                "Enuncie o objetivo: maximizar número de intervalos sem sobreposições.",
                                "Defina formalmente não-sobreposição para pares de intervalos.",
                                "Dê um exemplo com 4 intervalos e o subconjunto ótimo.",
                                "Explique diferença para minimizar salas de aula.",
                                "Identifique entrada/saída corretamente.",
                                "Justifique por que é um problema de otimização combinatorial."
                              ],
                              "assessmentCriteria": [
                                "Clareza na enunciação do objetivo de maximização.",
                                "Precisão na definição de sobreposição.",
                                "Correta distinção de problemas como alocação de salas.",
                                "Uso de notação formal ou exemplos concretos.",
                                "Compreensão de que não é cobertura total.",
                                "Capacidade de aplicar a um exemplo pequeno."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos (conjunto independente máximo em grafos de intervalo).",
                                "Programação: Implementação de algoritmos gulosos para otimização.",
                                "Gestão de Projetos: Otimização de agendamentos e alocação de recursos.",
                                "Estatística: Modelagem de dados temporais e sequências."
                              ],
                              "realWorldApplication": "Em radiodifusão, selecionar o máximo de propagandas sem sobreposição em um canal para maximizar receita; ou em manufatura, agendar máximo de jobs em uma máquina sem conflitos de tempo."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.2",
                        "name": "Estratégia Gulosa: Ordenação por Tempo de Término",
                        "description": "Explicar a escolha gulosa de ordenar os intervalos pelo tempo de término crescente e selecionar o intervalo que termina primeiro compatível com a seleção anterior.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.2.1",
                            "name": "Ordenar intervalos por fim",
                            "description": "Implementar ordenação dos intervalos com base no tempo de término (fim) em ordem crescente, usando algoritmos como quicksort ou bibliotecas padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Representar Intervalos",
                                  "subSteps": [
                                    "Defina um intervalo como um par (início, fim) onde início < fim.",
                                    "Crie uma lista de exemplo com pelo menos 5-10 intervalos não ordenados.",
                                    "Identifique o critério: ordenar por tempo de término (fim) em ordem crescente.",
                                    "Represente em código como lista de tuplas ou listas: ex. intervals = [(1,4), (3,5), (0,6)]",
                                    "Valide que todos os intervalos são válidos (início < fim)."
                                  ],
                                  "verification": "Lista de intervalos criada e impressa corretamente sem erros de sintaxe.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Linguagem Python instalada"
                                  ],
                                  "tips": "Use tuplas para imutabilidade e eficiência em comparações.",
                                  "learningObjective": "Representar dados de intervalos de forma estruturada para ordenação.",
                                  "commonMistakes": [
                                    "Confundir início com fim nas tuplas",
                                    "Permitir intervalos inválidos (início >= fim)",
                                    "Usar listas em vez de tuplas desnecessariamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Função de Comparação por Fim",
                                  "subSteps": [
                                    "Crie uma função key que extraia o segundo elemento (fim) de cada intervalo.",
                                    "Teste a função em intervalos isolados: print(key((1,4))) deve retornar 4.",
                                    "Garanta ordenação estável: se fins iguais, não reordene desnecessariamente.",
                                    "Implemente comparação personalizada para quicksort: cmp_to_key se necessário.",
                                    "Documente a função com docstring explicando o propósito guloso."
                                  ],
                                  "verification": "Função key aplicada manualmente retorna fins corretos em todos os intervalos de teste.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com functools (para cmp_to_key)"
                                  ],
                                  "tips": "Lembre-se: ordenação crescente por fim maximiza seleção gulosa posterior.",
                                  "learningObjective": "Criar comparador customizado focado no tempo de término para greedy algorithms.",
                                  "commonMistakes": [
                                    "Comparar pelo início em vez do fim",
                                    "Ignorar estabilidade na ordenação",
                                    "Erro de índice: acessar [0] em vez de [1]"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Ordenação Manual com Quicksort",
                                  "subSteps": [
                                    "Implemente quicksort recursivo adaptado para usar a função de comparação por fim.",
                                    "Escolha pivô como primeiro elemento, particione baseado em fim <= pivô_fim.",
                                    "Recurse em sublistas esquerda e direita.",
                                    "Una resultados: sorted_intervals = left + [pivot] + right.",
                                    "Teste com lista pequena: verifique se fins estão crescentes."
                                  ],
                                  "verification": "Lista ordenada manualmente imprime com fins em ordem crescente exata.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Papel e caneta para pseudocódigo inicial"
                                  ],
                                  "tips": "Debugue particionamento imprimindo sublistas em cada recursão.",
                                  "learningObjective": "Entender e codificar quicksort customizado para ordenação por critério específico.",
                                  "commonMistakes": [
                                    "Pivô mal escolhido levando a stack overflow",
                                    "Erro na concatenação de listas",
                                    "Não tratar listas vazias ou de um elemento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Usar Bibliotecas Padrão e Integrar em Algoritmo Guloso",
                                  "subSteps": [
                                    "Use sorted(intervals, key=lambda x: x[1]) para ordenação simples.",
                                    "Integre na seleção gulosa: selecione primeiro, ignore conflituosos.",
                                    "Implemente função completa: sort_and_select(intervals).",
                                    "Compare resultados manual vs biblioteca para validação.",
                                    "Otimize: discuta O(n log n) do quicksort vs outros."
                                  ],
                                  "verification": "Biblioteca produz mesma ordenação que manual; algoritmo guloso seleciona ótimo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação Python sorted()"
                                  ],
                                  "tips": "Lambda é conciso; use key=lambda interval: interval[1] sempre.",
                                  "learningObjective": "Aplicar ordenação eficiente em contexto guloso real.",
                                  "commonMistakes": [
                                    "Esquecer key= no sorted()",
                                    "Não testar com casos de empate em fins",
                                    "Ignorar conflitos na seleção posterior"
                                  ]
                                }
                              ],
                              "practicalExample": "Dada lista de aulas: [(9:00,10:30), (8:00,9:30), (10:00,11:00), (9:30,12:00)]. Ordenar por fim: [(8:00,9:30), (9:00,10:30), (10:00,11:00), (9:30,12:00)]. Seleção gulosa pega 3 aulas sem sobreposição.",
                              "finalVerifications": [
                                "Lista ordenada tem fins estritamente crescentes.",
                                "Função key extraí fim corretamente em 100% dos casos.",
                                "Quicksort manual ordena idêntico à biblioteca.",
                                "Integração gulosa seleciona máximo sem conflitos.",
                                "Tempo de execução < 1s para 1000 intervalos.",
                                "Casos edge (vazio, um item, empates) funcionam."
                              ],
                              "assessmentCriteria": [
                                "Correção: fins ordenados crescentemente em todos testes.",
                                "Eficiência: O(n log n) demonstrado com análise.",
                                "Clareza: Código comentado e funções modulares.",
                                "Robustez: Trata empates e invalidades graciosamente.",
                                "Compreensão: Explica por que ordenar por fim é ótimo guloso.",
                                "Testes: Unit tests para key, sort e seleção."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de ordenação e complexidade (Big O).",
                                "Programação: Estruturas de dados (listas, recursão).",
                                "Otimização: Algoritmos gulosos vs DP.",
                                "Gestão: Agendamento e alocação de recursos."
                              ],
                              "realWorldApplication": "Agendamento de salas de aula ou reuniões em empresas (Google Calendar otimiza assim), alocação de jobs em CPUs, programação de broadcasts em rádios/TV para maximizar slots livres."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.2",
                            "name": "Aplicar critério de seleção gulosa",
                            "description": "Selecionar o primeiro intervalo da lista ordenada, registrar seu tempo de fim e iterar selecionando apenas intervalos cujo início seja >= ao fim atual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar as estruturas do algoritmo guloso",
                                  "subSteps": [
                                    "Crie uma lista vazia chamada 'selecionados' para armazenar os intervalos escolhidos.",
                                    "Defina uma variável 'fim_atual' com valor inicial baixo, como 0 ou -1, para permitir seleção do primeiro intervalo.",
                                    "Confirme que a lista de intervalos de entrada está ordenada por tempo de término em ordem crescente.",
                                    "Prepare um exemplo manual com intervalos para testar."
                                  ],
                                  "verification": "Verifique se 'selecionados' está vazia, 'fim_atual' é inicializado corretamente e a lista está ordenada.",
                                  "estimatedTime": "5-10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Editor de código (ex: Python IDLE ou Jupyter)"
                                  ],
                                  "tips": "Sempre inicialize 'fim_atual' com um valor que não bloqueie o primeiro intervalo.",
                                  "learningObjective": "Preparar corretamente as variáveis para execução do critério guloso.",
                                  "commonMistakes": [
                                    "Esquecer de ordenar a lista antes",
                                    "Inicializar 'fim_atual' com valor alto demais",
                                    "Não criar lista de selecionados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o primeiro intervalo da lista ordenada",
                                  "subSteps": [
                                    "Acesse o primeiro elemento (índice 0) da lista ordenada de intervalos.",
                                    "Adicione esse intervalo à lista 'selecionados'.",
                                    "Atualize 'fim_atual' para o tempo de término desse intervalo.",
                                    "Anote o intervalo selecionado e o novo 'fim_atual' no exemplo manual."
                                  ],
                                  "verification": "'Selecionados' contém exatamente um intervalo (o primeiro) e 'fim_atual' equals ao seu tempo de fim.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Editor de código"
                                  ],
                                  "tips": "O primeiro intervalo sempre tem o menor tempo de fim, priorizando liberação precoce.",
                                  "learningObjective": "Aplicar o critério guloso na escolha inicial para maximizar seleções futuras.",
                                  "commonMistakes": [
                                    "Selecionar pelo menor início em vez de fim",
                                    "Não atualizar 'fim_atual'",
                                    "Índice errado (começar em 1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Iterar pelos intervalos restantes com critério de não-sobreposição",
                                  "subSteps": [
                                    "Inicie um loop for a partir do índice 1 até o final da lista.",
                                    "Para cada intervalo atual, verifique se seu tempo de início >= 'fim_atual'.",
                                    "Se verdadeiro, adicione o intervalo a 'selecionados' e atualize 'fim_atual' para seu tempo de fim.",
                                    "Continue o loop sem pausas até processar todos os intervalos."
                                  ],
                                  "verification": "Todos intervalos foram verificados; apenas os compatíveis foram adicionados e 'fim_atual' atualizado corretamente.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e lápis para rastrear",
                                    "Editor de código para pseudocódigo ou implementação"
                                  ],
                                  "tips": "Use >= para permitir intervalos adjacentes sem sobreposição.",
                                  "learningObjective": "Implementar a iteração gulosa garantindo seleção máxima sem conflitos.",
                                  "commonMistakes": [
                                    "Usar > em vez de >= permitindo adjacentes",
                                    "Atualizar 'fim_atual' sem adicionar",
                                    "Loop começar do índice 0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar a seleção e validar o resultado",
                                  "subSteps": [
                                    "Retorne ou exiba a lista 'selecionados'.",
                                    "Conte o número de intervalos selecionados.",
                                    "Verifique manualmente que nenhum par em 'selecionados' se sobrepõe.",
                                    "Compare o resultado com uma solução ótima conhecida para o exemplo.",
                                    "Teste casos edge como lista vazia ou todos sobrepostos."
                                  ],
                                  "verification": "Lista final não tem sobreposições e maximiza o número de intervalos selecionados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Lista de intervalos de teste"
                                  ],
                                  "tips": "Para validação, implemente uma função auxiliar para checar sobreposições.",
                                  "learningObjective": "Validar a corretude e otimalidade da solução gulosa.",
                                  "commonMistakes": [
                                    "Não checar sobreposições na saída",
                                    "Ignorar casos edge",
                                    "Contar errado o tamanho"
                                  ]
                                }
                              ],
                              "practicalExample": "Lista ordenada por fim: [[1,3], [2,4], [3,5], [0,6], [5,7], [8,9], [8,10]]. Seleção: [1,3] (fim=3), [3,5] (3>=3, fim=5), [5,7] (5>=5, fim=7), [8,9] (8>=7, fim=9). Resultado: 4 intervalos sem sobreposições.",
                              "finalVerifications": [
                                "Nenhum intervalo selecionado se sobrepõe (início_j >= fim_i para todos pares).",
                                "Número de selecionados é máximo possível para o exemplo.",
                                "Todos intervalos da lista foram processados no loop.",
                                "'Fim_atual' foi atualizado apenas após seleções válidas.",
                                "Algoritmo lida com lista vazia retornando 0.",
                                "Funciona para casos onde todos intervalos se sobrepõem (seleciona 1)."
                              ],
                              "assessmentCriteria": [
                                "Inicialização correta de variáveis e ordenação.",
                                "Seleção precisa do primeiro intervalo e update de fim_atual.",
                                "Loop itera corretamente com condição >= fim_atual.",
                                "Ausência de erros em atualizações e adições.",
                                "Eficiência temporal O(n) após ordenação.",
                                "Validação completa incluindo casos edge.",
                                "Código ou passos manuais livres de bugs."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de ordenação e desigualdades.",
                                "Programação: Loops, condicionais e estruturas de dados (listas).",
                                "Gestão e Administração: Otimização de agendamentos e recursos.",
                                "Lógica e Raciocínio: Tomada de decisões locais ótimas globais."
                              ],
                              "realWorldApplication": "Agendamento de salas de reunião em uma empresa, onde intervalos são compromissos; maximiza o número de reuniões sem conflitos de horário, otimizando uso de recursos limitados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.2.3",
                            "name": "Simular execução passo a passo",
                            "description": "Executar o algoritmo manualmente em exemplos com 4-6 intervalos, ilustrando por que a ordenação por fim leva à solução ótima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Listar e representar os intervalos fornecidos",
                                  "subSteps": [
                                    "Identifique todos os intervalos no exemplo, cada um definido por tempo de início (start) e fim (end).",
                                    "Anote-os em uma tabela ou lista clara, incluindo IDs para referência (ex: Intervalo A: [1,3]).",
                                    "Verifique se há 4-6 intervalos e confirme que todos os tempos são positivos e start < end.",
                                    "Desenhe uma linha do tempo simples para visualizar sobreposições iniciais.",
                                    "Registre o número total de intervalos para referência futura."
                                  ],
                                  "verification": "Confirme que a lista está completa e visualmente representada sem erros de transcrição.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Linha do tempo impressa ou quadro branco"
                                  ],
                                  "tips": "Use cores diferentes para cada intervalo para facilitar a visualização de conflitos.",
                                  "learningObjective": "Representar dados de intervalos de forma organizada para análise posterior.",
                                  "commonMistakes": [
                                    "Confundir start e end",
                                    "Omitir intervalos",
                                    "Não notar sobreposições óbvias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Ordenar os intervalos por tempo de término (fim)",
                                  "subSteps": [
                                    "Extraia os tempos de fim de todos os intervalos.",
                                    "Classifique-os em ordem crescente de fim (menor para maior).",
                                    "Em caso de empate em fim, ordene por start crescente (opcional, mas recomendado).",
                                    "Reescreva a lista ordenada com IDs preservados.",
                                    "Verifique a ordenação comparando pares adjacentes."
                                  ],
                                  "verification": "A lista ordenada deve ter fins não decrescentes; teste com sort manual em 3 pares.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel com lista inicial",
                                    "Calculadora para comparações se necessário"
                                  ],
                                  "tips": "Comece comparando o menor fim com os outros para eficiência.",
                                  "learningObjective": "Dominar a ordenação por critério guloso chave: tempo de término mais cedo.",
                                  "commonMistakes": [
                                    "Ordenar por start em vez de end",
                                    "Ignorar empates",
                                    "Erros de transcrição na reescrita"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a seleção gulosa iterativamente",
                                  "subSteps": [
                                    "Inicialize uma lista de solução vazia e defina last_end como -1.",
                                    "Selecione o primeiro intervalo (menor fim) e adicione à solução; atualize last_end com seu fim.",
                                    "Para cada intervalo subsequente na lista ordenada: se start >= last_end, selecione-o, adicione e atualize last_end.",
                                    "Continue até o fim da lista ordenada.",
                                    "Conte o número de intervalos selecionados."
                                  ],
                                  "verification": "Simule em papel e confirme que nenhum conflito (start < last_end) foi selecionado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista ordenada",
                                    "Marcadores para selecionados/rejeitados"
                                  ],
                                  "tips": "Anote 'S' para selecionado e 'R' para rejeitado ao lado de cada um.",
                                  "learningObjective": "Aplicar a heurística gulosa de 'terminar cedo' para maximizar seleções.",
                                  "commonMistakes": [
                                    "Selecionar intervalos conflitantes",
                                    "Pular atualizações de last_end",
                                    "Não iterar todos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar otimalidade e ilustrar a razão gulosa",
                                  "subSteps": [
                                    "Conte o tamanho da solução gulosa (número selecionado).",
                                    "Tente manualmente uma solução alternativa não-gulosa e compare tamanhos.",
                                    "Explique por que ordenar por fim garante otimalidade: prova gulosa (ótimo subestrutural + escolha segura).",
                                    "Desenhe a linha do tempo final destacando selecionados e conflitos evitados.",
                                    "Registre se a solução é máxima possível."
                                  ],
                                  "verification": "Solução gulosa tem tamanho >= qualquer alternativa manual testada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Linha do tempo final",
                                    "Papel para alternativas"
                                  ],
                                  "tips": "Use prova por indução simples: assuma ótimo até i, mostre i+1 preserva.",
                                  "learningObjective": "Justificar matematicamente por que a estratégia gulosa é ótima aqui.",
                                  "commonMistakes": [
                                    "Achar solução maior que não existe",
                                    "Não testar alternativas",
                                    "Confundir com ordenação por start"
                                  ]
                                }
                              ],
                              "practicalExample": "Exemplo com 5 intervalos: A[1,4], B[2,7], C[3,5], D[6,8], E[0,9]. Ordenados por fim: A(4), C(5), D(8), B(7? wait B7), E9. Correto: A(4), C(5), D(8). Seleção: A, então C (3>=4? No, assume >= não conflita), wait padrão: C start3 <4? Conflito se start < end anterior. Ajuste: A[1,4], C[4,5] ok se >=. Solução: A,C,D (3 intervalos). Alternativa: B,D (2). Ilustra otimalidade.",
                              "finalVerifications": [
                                "Pode listar e ordenar corretamente 4-6 intervalos novos.",
                                "Simula seleção sem conflitos em <5 minutos.",
                                "Identifica pelo menos uma alternativa subótima.",
                                "Explica prova gulosa em 2-3 frases.",
                                "Desenha linha do tempo precisa com selecionados.",
                                "Confirma tamanho ótimo manualmente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na ordenação (100% correta).",
                                "Execução da seleção sem violações de conflito.",
                                "Justificativa clara da otimalidade.",
                                "Visualizações (tabelas/linhas) legíveis e úteis.",
                                "Identificação de erros comuns evitados.",
                                "Tempo de simulação eficiente (<1h total)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por indução e ordenação.",
                                "Programação: Implementação em Python (sorted(key=lambda x: x[1])).",
                                "Lógica: Heurísticas e algoritmos aproximados.",
                                "Gestão: Otimização de recursos limitados."
                              ],
                              "realWorldApplication": "Agendamento de salas de aula ou reuniões: maximizar número de eventos sem sobreposições, priorizando os que terminam cedo para liberar espaço rapidamente, como em universidades ou estações de rádio alocando faixas de frequência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.4.3",
                        "name": "Implementação, Complexidade e Corretude",
                        "description": "Codificar o algoritmo completo, analisar sua eficiência e provar que a solução gulosa é ótima comparada a abordagens exaustivas ou dinâmicas.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.4.3.1",
                            "name": "Implementar o algoritmo completo",
                            "description": "Escrever código em pseudocódigo ou linguagem como C++/Python: ordenar, inicializar fim_atual = -inf, contar seleções iterando e atualizando fim_atual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir estrutura de dados para intervalos e ordená-los por tempo de fim",
                                  "subSteps": [
                                    "Criar uma lista de intervalos, onde cada intervalo é representado como uma tupla ou lista [inicio, fim].",
                                    "Implementar função de ordenação que ordene a lista primariamente pelo tempo de fim (segundo elemento), usando stable sort se possível.",
                                    "Adicionar método de entrada para ler N intervalos do usuário ou de um arquivo de teste.",
                                    "Validar que todos os intervalos têm fim >= inicio.",
                                    "Imprimir ou logar a lista ordenada para verificação visual."
                                  ],
                                  "verification": "Lista ordenada corretamente: o primeiro intervalo tem o menor tempo de fim, sem erros de sintaxe no código.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou Jupyter), lista de exemplo de intervalos como [(1,4),(3,5),(0,6),(5,7),(3,8),(5,9),(6,10),(8,11)]",
                                  "tips": "Use key=lambda x: x[1] em Python para ordenar por segundo elemento; em C++, overload operador < para pair.",
                                  "learningObjective": "Compreender como a ordenação gulosa por tempo de fim garante otimalidade no algoritmo.",
                                  "commonMistakes": "Ordenar por inicio em vez de fim; esquecer de tratar empates (usar stable sort)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar variáveis de controle",
                                  "subSteps": [
                                    "Declarar variável count = 0 para contar intervalos selecionados.",
                                    "Inicializar fim_atual = -float('inf') ou valor mínimo possível (ex: -1 em contextos discretos).",
                                    "Preparar uma lista vazia selected_intervals para armazenar intervalos escolhidos (opcional para debug).",
                                    "Definir a função principal que recebe a lista ordenada como parâmetro.",
                                    "Adicionar comentários explicando o papel de cada variável."
                                  ],
                                  "verification": "Código roda sem erros de inicialização; fim_atual é menor que qualquer tempo de fim possível.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Mesmo editor; pseudocódigo pronto para referência",
                                  "tips": "Em C++, use numeric_limits<double>::lowest(); em Python, float('-inf').",
                                  "learningObjective": "Estabelecer estado inicial que permite seleção do primeiro intervalo sempre.",
                                  "commonMistakes": "Inicializar fim_atual como 0 (falha se intervalos começam negativos); usar int em vez de float se necessário."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop de iteração e seleção gulosa",
                                  "subSteps": [
                                    "Iniciar loop for sobre cada intervalo na lista ordenada.",
                                    "Para cada intervalo [s, f], checar se s >= fim_atual.",
                                    "Se sim, incrementar count, adicionar à selected_intervals, e atualizar fim_atual = f.",
                                    "Se não, pular o intervalo.",
                                    "Finalizar loop e preparar retorno de count (e selected se aplicável)."
                                  ],
                                  "verification": "Simular manualmente com 3 intervalos: deve selecionar corretamente sem sobreposições.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Exemplos de teste impressos; debugger do IDE",
                                  "tips": "Use print statements dentro do loop para debug; otimize evitando listas extras se só count for necessário.",
                                  "learningObjective": "Aplicar decisão gulosa: selecionar o que acaba primeiro entre compatíveis.",
                                  "commonMistakes": "Atualizar fim_atual com max(fim_atual, f) errado; condição if s > fim_atual em vez de >= (perde intervalos adjacentes)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar implementação e adicionar análise de complexidade",
                                  "subSteps": [
                                    "Criar 3-5 casos de teste: trivial (1 intervalo), sobrepostos, não sobrepostos, ordenados/desordenados.",
                                    "Executar função e comparar output esperado (ex: 4 seleções no exemplo padrão).",
                                    "Implementar análise: O(N log N) por sort + O(N) loop = O(N log N).",
                                    "Adicionar docstring com complexidade temporal e espacial.",
                                    "Refatorar código para clareza e eficiência."
                                  ],
                                  "verification": "Todos testes passam 100%; complexidade documentada corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Lista de test cases prontos; calculadora para N=1000",
                                  "tips": "Use assert em Python para testes unitários; profile tempo para grandes N.",
                                  "learningObjective": "Validar corretude e eficiência da implementação gulosa.",
                                  "commonMistakes": "Esquecer sort em testes; confundir O(N log N) com O(N^2)."
                                }
                              ],
                              "practicalExample": "Intervalos: [[1,4],[3,5],[0,6],[5,7],[3,8],[5,9],[6,10],[8,11]]. Ordenados por fim: [[1,4],[3,5],[5,7],[6,10],[3,8],[0,6],[5,9],[8,11]]. Selecionados: [1,4],[5,7],[8,11] -> count=3. Código Python: def interval_selection(intervals): intervals.sort(key=lambda x: x[1]) count=0 fim_atual=float('-inf') for s,f in intervals: if s >= fim_atual: count+=1 fim_atual=f return count",
                              "finalVerifications": [
                                "Código compila/executa sem erros.",
                                "Ordenação correta: menor fim primeiro.",
                                "Loop seleciona máximo sem sobreposição (teste com 10+ intervalos).",
                                "Output matches expected para 5 casos variados.",
                                "Complexidade O(N log N) confirmada via comentário ou print.",
                                "Lista selected (se impl.) tem no overlap e é máxima.",
                                "Edge cases: N=0 (0), todos sobrepostos (1), nenhum overlap (N)."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Solução ótima em todos testes (peso 40%).",
                                "Eficiência: Tempo/espaço adequados, sem loops desnecessários (20%).",
                                "Clareza: Código legível, comentado, estrutura lógica (20%).",
                                "Robustez: Trata inputs inválidos/edges (10%).",
                                "Documentação: Inclui complexidade e prova gulosa (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de ordenação e complexidade assintótica (Big O).",
                                "Otimização: Modelagem de problemas NP-hard aproximados por guloso.",
                                "Gestão: Agendamento de recursos limitados (salas/projetos).",
                                "Lógica: Prova de corretude por indução/contradição.",
                                "Estatística: Análise de performance em datasets reais."
                              ],
                              "realWorldApplication": "Agendamento de salas de aula/universidades para maximizar uso sem conflitos; planejamento de reuniões em empresas; alocação de faixas de frequência em telecomunicações; sequenciamento de jobs em manufatura para minimizar idle time."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.2",
                            "name": "Analisar complexidade temporal e espacial",
                            "description": "Demonstrar O(n log n) devido à ordenação e O(n) na seleção, com espaço O(1) auxiliar se ordenação in-place.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo de Seleção de Intervalos Gulosos",
                                  "subSteps": [
                                    "Liste os passos do algoritmo: ordenar intervalos por tempo de fim, inicializar lista vazia de intervalos selecionados, iterar pelos intervalos ordenados.",
                                    "Identifique as operações principais: ordenação e iteração linear para seleção.",
                                    "Anote os loops e chamadas de função envolvidas.",
                                    "Desenhe um fluxograma simples do algoritmo.",
                                    "Confirme que a ordenação é por tempo de fim e a seleção é gulosa."
                                  ],
                                  "verification": "Fluxograma ou lista de passos escrita corretamente sem erros lógicos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto/diagrama (ex: Draw.io).",
                                  "tips": "Foquem em separar claramente a fase de ordenação da fase de seleção.",
                                  "learningObjective": "Compreender a estrutura do algoritmo para isolar componentes de complexidade.",
                                  "commonMistakes": "Confundir ordenação por início em vez de fim; ignorar inicializações."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Complexidade Temporal da Fase de Ordenação",
                                  "subSteps": [
                                    "Identifique o algoritmo de ordenação usado (ex: QuickSort ou MergeSort).",
                                    "Conte o número de elementos n (intervalos).",
                                    "Calcule comparações e trocas: O(n log n) no pior caso para ordenação eficiente.",
                                    "Some custos de overhead como alocação de arrays auxiliares.",
                                    "Expresse em notação Big O, considerando dominante."
                                  ],
                                  "verification": "Equação escrita: T_ordenacao = O(n log n), com justificativa de contagens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Pseudocódigo do algoritmo de ordenação; calculadora para log n.",
                                  "tips": "Use T(n) = T(n/2) + O(n) para MergeSort como referência.",
                                  "learningObjective": "Dominar análise de ordenação e seu impacto no tempo total.",
                                  "commonMistakes": "Esquecer fator log n; assumir O(n^2) para todos os sorts."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Complexidade Temporal da Fase de Seleção",
                                  "subSteps": [
                                    "Examine o loop principal: iteração única pelos n intervalos ordenados.",
                                    "Conte operações por iteração: comparações constantes (O(1)).",
                                    "Some condições if/else e adições à lista de resultado.",
                                    "Confirme ausência de loops aninhados.",
                                    "Registre T_selecao = O(n)."
                                  ],
                                  "verification": "Demonstração que loop roda n vezes com O(1) por iteração.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Pseudocódigo do loop de seleção; exemplos com n=5 intervalos.",
                                  "tips": "Trace execução com 3-4 intervalos para validar contagens.",
                                  "learningObjective": "Identificar complexidades lineares em iterações simples.",
                                  "commonMistakes": "Contar ordenação novamente; superestimar comparações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Complexidade Espacial",
                                  "subSteps": [
                                    "Liste estruturas de dados: array de entrada (O(n)), lista de resultado (O(n)).",
                                    "Verifique se ordenação é in-place (ex: HeapSort) ou usa O(n) auxiliar.",
                                    "Confirme variáveis locais O(1).",
                                    "Some espaços: O(n) entrada + O(1) auxiliar se in-place.",
                                    "Expresse como O(1) auxiliar, excluindo entrada/saída."
                                  ],
                                  "verification": "Diagrama de memória mostrando picos de uso espacial.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta de visualização de memória (ex: Python tutor online).",
                                  "tips": "Distinga espaço auxiliar de entrada; priorize in-place quando possível.",
                                  "learningObjective": "Diferenciar tempo e espaço, focando em auxiliar.",
                                  "commonMistakes": "Incluir entrada como auxiliar; ignorar recursão em sorts."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Combinar Análises para Complexidade Total",
                                  "subSteps": [
                                    "Some tempos: O(n log n) + O(n) = O(n log n).",
                                    "Confirme espaço dominante: O(1) auxiliar.",
                                    "Discuta casos: pior/médio/melhor (todos O(n log n) tempo).",
                                    "Escreva declaração final da complexidade.",
                                    "Compare com alternativas não-gulosas."
                                  ],
                                  "verification": "Declaração completa: Tempo O(n log n), Espaço O(1) auxiliar.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Resumo dos passos anteriores.",
                                  "tips": "Use regra da soma: termo dominante prevalece.",
                                  "learningObjective": "Sintetizar análises parciais em Big O total.",
                                  "commonMistakes": "Dominar incorretamente; esquecer espaço."
                                }
                              ],
                              "practicalExample": "Dado 5 intervalos: [(1,4), (3,5), (0,6), (5,7), (3,8), (5,9), (6,10), (8,11), (8,12), (2,13), (12,14)]. Ordenar por fim: O(10 log 10). Seleção: itera 10x, seleciona 4. Tempo total ~ O(10 log 10) = 33 operações; espaço O(1) auxiliar com HeapSort in-place.",
                              "finalVerifications": [
                                "Explica corretamente ordenação como O(n log n).",
                                "Identifica seleção como O(n).",
                                "Declara tempo total O(n log n).",
                                "Justifica espaço O(1) auxiliar para ordenação in-place.",
                                "Fornece contagens precisas para exemplo prático.",
                                "Discute variações de algoritmos de sort."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação Big O (100% correto).",
                                "Justificativas detalhadas com contagens de operações.",
                                "Correta distinção temporal vs espacial.",
                                "Uso de exemplos concretos para validação.",
                                "Identificação de erros comuns evitados.",
                                "Clareza na comunicação da análise."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e logaritmos.",
                                "Matemática Discreta: Provas de recorrência em sorts.",
                                "Otimização: Modelos lineares em agendamento.",
                                "Engenharia de Software: Trade-offs tempo/espaço em design."
                              ],
                              "realWorldApplication": "Em sistemas de agendamento como Google Calendar ou AWS scheduling, onde ordenar tarefas por deadline (O(n log n)) e selecionar não-conflitantes otimiza uso de recursos com baixo overhead espacial."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.3",
                            "name": "Provar otimalidade da solução gulosa",
                            "description": "Usar prova por contradição ou troca: mostrar que qualquer solução ótima pode ser transformada na gulosa sem diminuir o número de intervalos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Formalizar o Problema e a Solução Gulosa",
                                  "subSteps": [
                                    "Liste os intervalos com tempos de início (s_i) e fim (f_i).",
                                    "Ordene os intervalos em ordem não-decrescente de f_i (tempo de fim).",
                                    "Descreva o algoritmo guloso: selecione o primeiro intervalo (g1, menor f_i), remova todos os conflitantes (aqueles com s_j <= f_{g1}), repita no subconjunto restante.",
                                    "Escreva o pseudocódigo formal do algoritmo.",
                                    "Execute o algoritmo em um exemplo simples com 4-5 intervalos para visualizar a seleção."
                                  ],
                                  "verification": "Confirme que o pseudocódigo está correto e a execução no exemplo seleciona o máximo possível sem sobreposições.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta, editor de texto para pseudocódigo, exemplos de intervalos impressos ou digitais.",
                                  "tips": "Sempre priorize ordenação por f_i, não por s_i, para liberar a 'linha do tempo' mais cedo.",
                                  "learningObjective": "Definir precisamente o problema de seleção de intervalos e o algoritmo guloso.",
                                  "commonMistakes": "Ordenar por tempo de início em vez de fim; ignorar conflitos corretamente definidos (s_j <= f_i)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir Solução Ótima Arbitrária e Primeira Escolha Gulosa",
                                  "subSteps": [
                                    "Defina uma solução ótima OPT como qualquer conjunto máximo de intervalos não sobrepostos.",
                                    "Identifique g1 como o primeiro intervalo guloso (menor f_i).",
                                    "Considere dois casos: (a) OPT inclui g1; (b) OPT não inclui g1.",
                                    "Para o caso (a), note que o subproblema após f_{g1} é similar.",
                                    "Para preparar o caso (b), identifique o primeiro intervalo s1 em OPT (ordenado por f_i)."
                                  ],
                                  "verification": "Escreva as definições e casos, confirmando que |OPT| é máximo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel para diagramas de linha do tempo, pseudocódigo do passo anterior.",
                                  "tips": "Desenhe uma linha do tempo visual para marcar s_i e f_i de g1 e OPT.",
                                  "learningObjective": "Estabelecer a base para comparação entre guloso e ótima.",
                                  "commonMistakes": "Assumir que OPT sempre coincide com guloso no início; confundir ordem de OPT."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Argumento de Troca para Transformar OPT",
                                  "subSteps": [
                                    "No caso OPT não inclui g1, note que s1 (primeiro de OPT) tem f_{s1} >= f_{g1}.",
                                    "Mostre que g1 é compatível com todos os intervalos em OPT exceto possivelmente s1 (pois f_{g1} <= f_{s1}, qualquer intervalo após s1 não sobrepõe g1).",
                                    "Crie OPT' substituindo s1 por g1: |OPT'| = |OPT|, mas agora inclui g1.",
                                    "Verifique que OPT' permanece válida (sem sobreposições novas).",
                                    "Repita o processo para o resto, mostrando transformação gradual para G."
                                  ],
                                  "verification": "Demonstre com diagrama que a substituição preserva o tamanho e compatibilidade.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Diagrama de linha do tempo ampliado, exemplos numéricos.",
                                  "tips": "Lembre: a chave é f_{g1} <= f_{s1}, então g1 'libera' mais espaço futuro.",
                                  "learningObjective": "Executar a prova por troca, mostrando equivalência ótima.",
                                  "commonMistakes": "Ignorar que intervalos após s1 podem sobrepor g1 (não acontece devido aos tempos de fim); trocar múltiplos de uma vez."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a Prova por Indução e Generalizar",
                                  "subSteps": [
                                    "Use indução: base (1 intervalo) trivial; assuma para subproblema após g1.",
                                    "Como OPT' coincide com G no primeiro passo, por hipótese indutiva |G| >= |OPT'| = |OPT|.",
                                    "Generalize para qualquer conjunto ordenado por f_i.",
                                    "Discuta extensões (ex: se empates em f_i, quebre por s_i).",
                                    "Resuma a prova em parágrafos formais."
                                  ],
                                  "verification": "Escreva a conclusão indutiva e verifique que cobre todos os casos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Resumo escrito da prova completa, quadro para indução.",
                                  "tips": "Indução forte: subproblema é idêntico após f_{g1}.",
                                  "learningObjective": "Completar e formalizar a prova de otimalidade.",
                                  "commonMistakes": "Pular a base da indução; não generalizar para n intervalos."
                                }
                              ],
                              "practicalExample": "Considere intervalos ordenados por fim: s2=[1,4], s1=[2,5], s3=[6,7]. Guloso G: s2 e s3 (tamanho 2). OPT: s1 e s3 (tamanho 2). Troca: substitua s1 por s2 em OPT → [1,4] e [6,7], agora igual a G, preservando tamanho e compatibilidade, pois 4 < 5 libera o mesmo ou mais para s3.",
                              "finalVerifications": [
                                "A ordenação por f_i é usada consistentemente.",
                                "A troca preserva o número de intervalos e remove sobreposições.",
                                "Todos os casos (inclui g1 ou não) são cobertos.",
                                "Indução aplica-se corretamente ao subproblema.",
                                "Nenhum contraexemplo possível é ignorado.",
                                "Prova generaliza para qualquer instância válida."
                              ],
                              "assessmentCriteria": [
                                "Lógica da troca é precisa e usa f_{g1} <= f_{s1}.",
                                "Definições formais de OPT e G estão corretas.",
                                "Indução é válida com base e passo claros.",
                                "Exemplo prático demonstra a troca sem erros.",
                                "Ausência de falácias como contradição incompleta.",
                                "Clareza e rigor matemático na redação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Provas por indução e argumento de troca.",
                                "Lógica: Raciocínio por casos e contradição implícita.",
                                "Otimização: Conceitos de relaxações e aproximações em OR.",
                                "Análise de Algoritmos: Provas de corretude em geral."
                              ],
                              "realWorldApplication": "Em agendamento de salas de conferências ou reuniões, provar que priorizar eventos que terminam mais cedo maximiza o número de eventos, otimizando uso de recursos limitados como salas ou máquinas em manufatura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.3.4.3.4",
                            "name": "Comparar com alternativas não-gulosas",
                            "description": "Contrastar com brute-force O(2^n) ou programação dinâmica O(n^2), destacando vantagens do guloso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo Guloso para Seleção de Intervalos",
                                  "subSteps": [
                                    "Relembre o problema: dado um conjunto de intervalos, selecione o máximo sem sobreposições.",
                                    "Descreva o algoritmo guloso: ordene por fim de intervalo, selecione o que termina primeiro, ignore sobrepostos.",
                                    "Implemente pseudocódigo ou código simples em Python.",
                                    "Calcule a complexidade: O(n log n) devido à ordenação.",
                                    "Verifique corretude com um exemplo pequeno."
                                  ],
                                  "verification": "Execute o algoritmo em um exemplo com 5 intervalos e confirme o número ótimo de intervalos selecionados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou Jupyter), papel e caneta para esboços.",
                                  "tips": "Sempre ordene por fim de intervalo para priorizar 'espaço livre' posterior.",
                                  "learningObjective": "Compreender a heurística gulosa e sua complexidade no contexto específico.",
                                  "commonMistakes": "Ordenar por início em vez de fim, levando a soluções subótimas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Abordagem Brute-Force",
                                  "subSteps": [
                                    "Entenda brute-force: gere todas as 2^n subconjuntos possíveis de intervalos.",
                                    "Para cada subconjunto, verifique se não há sobreposições (O(n) por subconjunto).",
                                    "Encontre o maior subconjunto válido.",
                                    "Calcule complexidade total: O(2^n * n), exponencial.",
                                    "Teste com n=10 para ver lentidão prática."
                                  ],
                                  "verification": "Implemente uma versão simples e meça tempo para n=15; deve ser inviável.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Python com timeit para medição, lista de intervalos de teste.",
                                  "tips": "Use bitmasks para representar subconjuntos eficientemente em código.",
                                  "learningObjective": "Identificar por que brute-force é impraticável para n grande.",
                                  "commonMistakes": "Ignorar verificação de sobreposições, contando subconjuntos inválidos como ótimos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Abordagem de Programação Dinâmica",
                                  "subSteps": [
                                    "Defina DP: dp[i] = máximo de intervalos usando os primeiros i intervalos ordenados.",
                                    "Recorrência: dp[i] = max(dp[i-1], 1 + dp[j]) onde j é o último compatível antes de i.",
                                    "Preencha tabela bottom-up, complexidade O(n^2).",
                                    "Compare com guloso em termos de espaço (O(n) vs O(n)).",
                                    "Implemente e teste no mesmo exemplo."
                                  ],
                                  "verification": "Construa a tabela DP para n=5 e confirme que coincide com o ótimo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha ou array em Python para tabela DP, exemplos de intervalos.",
                                  "tips": "Ordene intervalos por início para facilitar busca de compatíveis.",
                                  "learningObjective": "Dominar DP para o problema e sua complexidade quadrática.",
                                  "commonMistakes": "Não ordenar intervalos, causando recorrências incorretas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Abordagens e Destacar Vantagens do Guloso",
                                  "subSteps": [
                                    "Tabela comparativa: Complexidade (O(n log n) vs O(n^2) vs O(2^n n)), Espaço, Corretude.",
                                    "Discuta por que guloso é correto aqui (propriedade ótima: escolha gulosa leva a ótimo global).",
                                    "Meça tempos empíricos para n=1000.",
                                    "Identifique cenários onde guloso falha (ex: problema da mochila).",
                                    "Conclua vantagens: velocidade para grandes n."
                                  ],
                                  "verification": "Crie tabela Markdown ou imagem resumindo comparações e explique verbalmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramenta de tabela (Google Sheets ou Markdown), códigos das abordagens anteriores.",
                                  "tips": "Use notação Big-O para comparações formais e gráficos de tempo para visuais.",
                                  "learningObjective": "Contrastar eficiência e corretude, justificando guloso.",
                                  "commonMistakes": "Afirmar guloso sempre ótimo sem mencionar propriedades específicas."
                                }
                              ],
                              "practicalExample": "Considere intervalos: [(1,4), (3,5), (0,6), (5,7), (3,8), (5,9), (6,10), (8,11), (8,12), (2,13), (12,14)]. Guloso seleciona 4 intervalos em O(n log n). Brute-force: 2^11=2048 subsets, inviável. DP: tabela 11x11, ~100 operações. Guloso é 10x mais rápido para n=1000.",
                              "finalVerifications": [
                                "Explicar por que complexidade O(n log n) é superior a O(n^2) para n=10^5.",
                                "Demonstrar com código que guloso e DP dão mesmo ótimo neste problema.",
                                "Identificar propriedade que garante corretude gulosa (escolha mais curta primeiro).",
                                "Comparar tempos reais para n=100.",
                                "Discutir quando DP seria preferível (ex: n pequeno, mas guloso falha)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de complexidades de cada abordagem (100% correto).",
                                "Capacidade de implementar e comparar códigos funcionalmente.",
                                "Justificativa clara da corretude gulosa vs propriedades do problema.",
                                "Análise qualitativa/quantitativa de vantagens (tempo/espaço).",
                                "Identificação de limitações (guloso nem sempre ótimo).",
                                "Uso de exemplos concretos e tabelas comparativas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Assintótica e Notação Big-O.",
                                "Economia: Otimização de Recursos Escassos (agendamento).",
                                "Física: Modelagem de Conflitos de Tempo (partículas em trilhas).",
                                "Gestão: Planejamento de Projetos com Restrições Temporais."
                              ],
                              "realWorldApplication": "Em sistemas de agendamento de salas de aula ou conferências (Google Calendar otimiza slots), alocação de faixas de rádio sem interferência, ou sequenciamento de tarefas em manufatura para maximizar produção sem sobreposições."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.3.4.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.3.5",
                    "name": "Aplicação: Árvore Geradora Mínima (Kruskal)",
                    "description": "Construção gulosa de AGM por ordenação de arestas e detecção de ciclos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.3.5.1",
                        "name": "Ordenação de Arestas",
                        "description": "Processo de organizar as arestas do grafo não direcionado e ponderado em ordem crescente de peso para aplicação no algoritmo guloso de Kruskal.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.1.1",
                            "name": "Representar grafo como lista de arestas",
                            "description": "Estruturar o grafo como uma lista de tuplas contendo vértices u, v e peso w, facilitando a ordenação e iteração sequencial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o grafo fornecido e identificar vértices e arestas",
                                  "subSteps": [
                                    "Examine o diagrama ou descrição do grafo para listar todos os vértices.",
                                    "Identifique todas as arestas conectando pares de vértices.",
                                    "Registre os pesos associados a cada aresta.",
                                    "Confirme se o grafo é não-direcionado e sem arestas múltiplas.",
                                    "Anote o número total de arestas para verificação posterior."
                                  ],
                                  "verification": "Lista manual de vértices e contagem de arestas bate com o grafo original.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Diagrama do grafo",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Comece pelos vértices de menor grau para sistematizar a contagem.",
                                  "learningObjective": "Compreender a estrutura básica de um grafo ponderado.",
                                  "commonMistakes": [
                                    "Ignorar arestas sem peso explícito",
                                    "Contar arestas direcionadas como bidirecionais",
                                    "Esquecer vértices isolados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar todas as arestas com seus vértices e pesos",
                                  "subSteps": [
                                    "Para cada aresta, anote os dois vértices conectados (u e v).",
                                    "Registre o peso w da aresta.",
                                    "Padronize u < v alfabeticamente ou numericamente para evitar duplicatas em grafos não-direcionados.",
                                    "Crie uma tabela temporária: coluna para u, v, w.",
                                    "Conte e confirme o número total de entradas."
                                  ],
                                  "verification": "Tabela contém todas as arestas sem omissões ou duplicatas.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Tabela em papel ou planilha (Excel/Google Sheets)",
                                    "Diagrama do grafo"
                                  ],
                                  "tips": "Use ordem crescente para u e v para facilitar a ordenação posterior.",
                                  "learningObjective": "Extrair informações precisas de representações gráficas de grafos.",
                                  "commonMistakes": [
                                    "Inverter u e v inconsistentemente",
                                    "Confundir pesos de arestas adjacentes",
                                    "Incluir auto-aresta inexistente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formatar a lista de arestas como tuplas (u, v, w)",
                                  "subSteps": [
                                    "Converta cada linha da tabela em tupla: (u, v, w).",
                                    "Use parênteses ou colchetes para delimitar cada tupla.",
                                    "Coloque todas as tuplas em uma lista única, separadas por vírgulas.",
                                    "Mantenha a ordem original de descoberta ou alfabética inicial.",
                                    "Escreva a lista completa em formato legível."
                                  ],
                                  "verification": "Cada elemento é uma tupla com exatamente 3 itens e formato correto.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de texto ou caderno",
                                    "Lista de arestas da tabela"
                                  ],
                                  "tips": "Teste copiando uma tupla para um interpretador Python para validar sintaxe.",
                                  "learningObjective": "Representar dados de grafos em formato estruturado para processamento algorítmico.",
                                  "commonMistakes": [
                                    "Esquecer vírgulas entre tuplas",
                                    "Usar formato errado como [u,v,w] em vez de (u,v,w)",
                                    "Trocar valores dentro da tupla"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e preparar a lista para ordenação",
                                  "subSteps": [
                                    "Conte o número de tuplas e compare com o grafo original.",
                                    "Verifique se todos os pesos estão corretos cruzando com o diagrama.",
                                    "Confirme que u < v em todas as tuplas para consistência.",
                                    "Simule uma ordenação manual por peso para testar usabilidade.",
                                    "Documente qualquer observação para iterações futuras."
                                  ],
                                  "verification": "Lista passa em checagem cruzada sem erros e está pronta para sort.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Lista formatada",
                                    "Diagrama do grafo",
                                    "Calculadora para simulação"
                                  ],
                                  "tips": "Ordene provisoriamente por peso para visualizar o impacto da representação.",
                                  "learningObjective": "Garantir integridade da representação para algoritmos como Kruskal.",
                                  "commonMistakes": [
                                    "Não padronizar u < v",
                                    "Erros de transcrição de pesos",
                                    "Lista vazia por omissão"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com vértices A, B, C, D. Arestas: A-B (peso 5), A-C (9), B-C (6), B-D (4), C-D (3). Lista de arestas: [(A,B,5), (A,C,9), (B,C,6), (B,D,4), (C,D,3)]. Essa lista facilita a ordenação por peso: [(C,D,3), (B,D,4), (A,B,5), (B,C,6), (A,C,9)].",
                              "finalVerifications": [
                                "Lista contém exatamente todas as arestas do grafo original.",
                                "Cada tupla segue o formato (u, v, w) com u < v.",
                                "Pesos estão corretos e sem erros de transcrição.",
                                "Não há duplicatas ou arestas fantasmas.",
                                "Lista é iterável sequencialmente para ordenação.",
                                "Número de tuplas equals ao número de arestas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de 100% das arestas e pesos.",
                                "Consistência no formato de tupla e padronização u < v.",
                                "Ausência de erros comuns como duplicatas ou omissões.",
                                "Preparação adequada para ordenação (facilita iteração).",
                                "Clareza e legibilidade da lista final.",
                                "Validação cruzada com grafo original demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e conjuntos ordenados.",
                                "Programação: Estruturas de dados (listas e tuplas em Python).",
                                "Engenharia de Software: Representação de dados para algoritmos eficientes.",
                                "Otimização: Preparação para problemas de mínimo custo.",
                                "Lógica: Padronização para evitar ambiguidades."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações, representa conexões entre cidades com custos de cabos para calcular a infraestrutura mínima (MST via Kruskal), otimizando investimentos em logística e energia."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.1.2",
                            "name": "Ordenar arestas por peso crescente",
                            "description": "Implementar ordenação estável das arestas usando algoritmo como quicksort ou mergesort, garantindo que arestas de menor peso sejam processadas primeiro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura de dados para arestas",
                                  "subSteps": [
                                    "Crie uma classe Edge usando dataclass ou namedtuple com atributos: origem (u), destino (v) e peso (weight).",
                                    "Implemente um método de comparação (__lt__) que compara apenas pelo peso, preservando ordem relativa para estabilidade.",
                                    "Gere uma lista de exemplo com 5-10 arestas desordenadas, incluindo algumas com pesos iguais.",
                                    "Teste a criação de instâncias imprimindo a lista para verificar atributos.",
                                    "Adicione um método str para visualização clara da aresta (ex: 'u-v:weight')."
                                  ],
                                  "verification": "Execute código para criar e imprimir lista de arestas sem erros; confirme atributos corretos via print.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VSCode ou PyCharm), Python 3.8+, ambiente Jupyter opcional",
                                  "tips": "Use from dataclasses import dataclass para simplicidade; priorize peso na comparação, mas retorne False se pesos iguais para estabilidade.",
                                  "learningObjective": "Representar grafos pesados de forma que suporte ordenação estável por peso.",
                                  "commonMistakes": "Comparar por u ou v acidentalmente; esquecer de lidar com pesos iguais preservando ordem original."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o algoritmo MergeSort genérico e estável",
                                  "subSteps": [
                                    "Defina função recursiva mergesort(lista): divida em left e right no meio.",
                                    "Implemente função merge(left, right): compare elementos usando chave personalizável (inicialmente por valor direto).",
                                    "Una listas ordenadas em merge, preservando ordem relativa para elementos iguais.",
                                    "Adicione tratamento de base case (lista vazia ou unitária retorna inalterada).",
                                    "Teste com lista simples de números: [5,2,8,1,9] deve virar [1,2,5,8,9]."
                                  ],
                                  "verification": "Aplique mergesort em lista de 10 números aleatórios; verifique se sorted(lista) == mergesort(lista).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Mesmo ambiente Python; listas de teste pré-definidas",
                                  "tips": "Use índices para evitar cópias desnecessárias; recursão máxima segura para n<1000.",
                                  "learningObjective": "Dominar mergesort recursivo estável com O(n log n) complexidade.",
                                  "commonMistakes": "Erro em merge ao não preservar ordem relativa; recursão infinita por falha em base case."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adaptar MergeSort para ordenar lista de arestas por peso",
                                  "subSteps": [
                                    "Modifique mergesort para aceitar chave de comparação (função que extrai peso).",
                                    "No merge, compare usando chave(aresta1.weight) vs chave(aresta2.weight).",
                                    "Integre com classe Edge: passe lambda x: x.weight como chave.",
                                    "Aplique à lista de arestas exemplo: edges_sorted = mergesort(edges, key=lambda e: e.weight).",
                                    "Imprima antes/depois para visual inspeção."
                                  ],
                                  "verification": "Confirme lista ordenada imprimindo pesos; todos crescentes e ordem relativa preservada para iguais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Lista de arestas do Step 1; debugger para inspecionar merge",
                                  "tips": "Teste com pesos duplicados (ex: duas arestas peso 3) para validar estabilidade.",
                                  "learningObjective": "Customizar algoritmo genérico para dados específicos como arestas grafos.",
                                  "commonMistakes": "Usar sorted() built-in em vez de implementação; ignorar estabilidade em merge."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar ordenação, estabilidade e integrar ao contexto Kruskal",
                                  "subSteps": [
                                    "Crie testes unitários: verifique for i in range(len(sorted_edges)-1): sorted_edges[i].weight <= sorted_edges[i+1].weight.",
                                    "Teste estabilidade: embaralhe arestas com pesos iguais e confirme ordem original relativa pós-ordenação.",
                                    "Meça tempo com timeit para n=1000 arestas; confirme O(n log n).",
                                    "Integre como pré-processamento em pseudocódigo Kruskal: edges = mergesort(edges, key=weight).",
                                    "Documente código com comentários sobre estabilidade."
                                  ],
                                  "verification": "Todos testes passam (100% assert); tempo < 1s para 1000 itens.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Biblioteca unittest ou pytest; timeit module",
                                  "tips": "Use random.shuffle em cópia para simular desordem; compare com Python's sorted(key=..., stable=True).",
                                  "learningObjective": "Validar implementação com testes rigorosos e preparar para uso em algoritmo guloso.",
                                  "commonMistakes": "Testes insuficientes para estabilidade; não medir performance."
                                }
                              ],
                              "practicalExample": "Grafo com vértices A,B,C,D,E. Arestas desordenadas: [(B,D,4), (A,C,3), (C,E,1), (A,B,5), (D,E,3)]. Após ordenação estável: [(C,E,1), (A,C,3), (D,E,3), (B,D,4), (A,B,5)]. Note que (A,C,3) precede (D,E,3) pois aparecia antes na lista original, preservando estabilidade.",
                              "finalVerifications": [
                                "Pesos das arestas estão em ordem estritamente crescente ou não-decrescente.",
                                "Ordem relativa de arestas com pesos iguais é preservada da entrada.",
                                "Nenhum erro de runtime em listas de até 1000 arestas.",
                                "Complexidade temporal confirmada via medição (O(n log n)).",
                                "Função funciona com arestas de pesos zero ou negativos.",
                                "Integração seamless como primeiro passo do Kruskal."
                              ],
                              "assessmentCriteria": [
                                "Correção total: 100% testes passam incluindo estabilidade.",
                                "Eficiência: tempo de execução proporcional a n log n.",
                                "Código limpo: comentários, nomes descritivos, sem código morto.",
                                "Estabilidade explícita no merge (preserva ordem relativa).",
                                "Modularidade: função genérica reutilizável com chave custom.",
                                "Robustez: lida com listas vazias, unitárias e edge cases."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações de ordem total e parcial, análise assintótica.",
                                "Engenharia de Software: Algoritmos recursivos e testes unitários.",
                                "Física/Química: Ordenação de partículas por energia em simulações.",
                                "Economia: Otimização de custos em cadeias de suprimentos."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações, ordenar links por custo (peso) para construir infraestrutura mínima custo com Kruskal, minimizando despesas em expansão de fibra ótica ou 5G."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.2",
                        "name": "Estrutura Union-Find para Detecção de Ciclos",
                        "description": "Implementação da estrutura de dados Union-Find (Disjoint Set Union - DSU) para rastrear componentes conectados e detectar se uma aresta forma um ciclo.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.2.1",
                            "name": "Inicializar Union-Find",
                            "description": "Criar arrays parent[] e rank[] para cada vértice, inicializando cada um como seu próprio pai com rank 0.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Determinar o número de vértices e alocar arrays parent e rank",
                                  "subSteps": [
                                    "Analise o grafo para identificar o número total de vértices n (de 0 a n-1).",
                                    "Declare e crie o array parent de tamanho n (ex: int parent[] = new int[n]; em Java).",
                                    "Declare e crie o array rank de tamanho n (ex: int rank[] = new int[n];).",
                                    "Garanta que os arrays sejam inicializados com valores padrão (zeros em linguagens como C++/Java).",
                                    "Confirme o tamanho dos arrays com uma impressão ou inspeção."
                                  ],
                                  "verification": "Verifique se parent.length == n e rank.length == n usando console.log ou print.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Linguagem de programação (Python, Java, C++)"
                                  ],
                                  "tips": "Use listas dinâmicas em Python (parent = [0] * n) para simplicidade.",
                                  "learningObjective": "Compreender a alocação de memória para representar conjuntos disjuntos em Union-Find.",
                                  "commonMistakes": [
                                    "Definir tamanho incorreto baseado em arestas em vez de vértices",
                                    "Esquecer de inicializar arrays com tamanho n",
                                    "Usar float em vez de int para rank"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar cada vértice como seu próprio pai no array parent",
                                  "subSteps": [
                                    "Percorra o array parent com um loop for de i = 0 até n-1.",
                                    "Atribua parent[i] = i para cada i.",
                                    "Evite loops infinitos ou condições erradas no for.",
                                    "Teste com um pequeno n=3 para validar: parent deve ser [0,1,2].",
                                    "Salve o estado atual do array para verificação posterior."
                                  ],
                                  "verification": "Imprima parent e confirme que parent[i] == i para todos i.",
                                  "estimatedTime": "7 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para depuração"
                                  ],
                                  "tips": "Use um loop simples for(int i=0; i<n; i++) parent[i]=i; para clareza.",
                                  "learningObjective": "Estabelecer a estrutura inicial onde cada vértice é um conjunto singleton.",
                                  "commonMistakes": [
                                    "Atribuir parent[i] = i+1 ou outro valor deslocado",
                                    "Pular iterações no loop",
                                    "Confundir índices começando de 1"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar o array rank com valor 0 para todos os vértices",
                                  "subSteps": [
                                    "Percorra o array rank com um loop for de i = 0 até n-1.",
                                    "Atribua rank[i] = 0 para cada i.",
                                    "Verifique se o array permanece zerado após o loop.",
                                    "Integre essa inicialização logo após a de parent para eficiência.",
                                    "Teste a função completa de inicialização com n=4."
                                  ],
                                  "verification": "Imprima rank e confirme que todos os elementos são 0.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo de grafo simples"
                                  ],
                                  "tips": "Em Python: rank = [0] * n cria o array já inicializado, otimizando o loop.",
                                  "learningObjective": "Entender o papel do rank na heurística de união por tamanho/rank para balanceamento.",
                                  "commonMistakes": [
                                    "Inicializar rank com 1 em vez de 0",
                                    "Esquecer o loop e deixar valores garbage",
                                    "Confundir rank com parent"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e encapsular a inicialização em uma função",
                                  "subSteps": [
                                    "Crie uma função initializeUnionFind(n) que retorne parent e rank.",
                                    "Adicione asserções ou testes unitários para validar parent[i]==i e rank[i]==0.",
                                    "Teste com diferentes valores de n (ex: 1, 5, 10).",
                                    "Documente a função com comentários explicativos.",
                                    "Integre em um exemplo de Kruskal para contexto."
                                  ],
                                  "verification": "Execute a função e testes: todos parent[i]==i e rank[i]==0 sem erros.",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Framework de testes (JUnit, pytest)",
                                    "Editor de código"
                                  ],
                                  "tips": "Retorne um par ou classe com parent e rank para facilitar uso.",
                                  "learningObjective": "Modularizar a inicialização para reutilização em algoritmos como Kruskal.",
                                  "commonMistakes": [
                                    "Não encapsular em função, dificultando manutenção",
                                    "Erros em testes unitários",
                                    "Ignorar casos edge como n=0 ou n=1"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um grafo com 4 vértices (0,1,2,3):\n- Crie parent = [0,1,2,3]\n- Crie rank = [0,0,0,0]\nCódigo Python: def init_uf(n): parent = list(range(n)); rank = [0]*n; return parent, rank\nResultado: parent[2] == 2 e rank[3] == 0, pronto para uniões em Kruskal.",
                              "finalVerifications": [
                                "Para todo vértice i (0 a n-1), parent[i] == i",
                                "Para todo vértice i, rank[i] == 0",
                                "Tempo de execução é O(n) linear",
                                "Não há referências cruzadas ou ciclos prematuros",
                                "Função lida corretamente com n=1 (grafo trivial)",
                                "Arrays são mutáveis para futuras operações find/union"
                              ],
                              "assessmentCriteria": [
                                "Correção: parent[i] == i e rank[i] == 0 para todos i",
                                "Eficiência: Inicialização em O(n) sem loops desnecessários",
                                "Robustez: Funciona para n=0,1 e valores grandes (até 10^5)",
                                "Clareza: Código legível com comentários e nomes descritivos",
                                "Modularidade: Encapsulado em função reutilizável",
                                "Testes: Inclui verificações unitárias básicas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Conjuntos Disjuntos e Partições",
                                "Ciência da Computação: Estruturas de Dados (Arrays e Heurísticas)",
                                "Algoritmos: Pré-requisito para Kruskal e MST",
                                "Lógica: Representação de Equivalências e Transitividade",
                                "Programação: Gerenciamento de Memória e Loops"
                              ],
                              "realWorldApplication": "Em redes de telecomunicações, inicializa componentes conectados para adicionar links mínimos sem ciclos (ex: planejamento de cabos em uma cidade, garantindo conectividade eficiente em Kruskal's algorithm)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.2",
                            "name": "Implementar operação Find com path compression",
                            "description": "Desenvolver função recursiva ou iterativa para encontrar raiz do conjunto, comprimindo caminhos para otimizar buscas futuras.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Estrutura Union-Find e Operação Find Básica",
                                  "subSteps": [
                                    "Defina a estrutura de dados parent[] para representar os pais de cada nó.",
                                    "Implemente a operação find simples (recursiva ou iterativa) sem compressão de caminho.",
                                    "Teste com um exemplo pequeno: 4 nós, unia 0-1 e 2-3.",
                                    "Meça a altura da árvore resultante para entender o problema de degeneração.",
                                    "Documente o código em pseudocódigo ou Python."
                                  ],
                                  "verification": "Execute find em todos os nós e imprima a árvore de pais; confirme que encontra raízes corretas sem compressão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Array de exemplo com 5-10 elementos"
                                  ],
                                  "tips": "Use print statements para visualizar chamadas recursivas e caminhos percorridos.",
                                  "learningObjective": "Compreender como o Find básico funciona e por que precisa de otimização.",
                                  "commonMistakes": [
                                    "Confundir índice do nó com valor",
                                    "Não tratar caso de nó raiz (parent[i] == i)",
                                    "Ignorar off-by-one em arrays"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender e Projetar Path Compression",
                                  "subSteps": [
                                    "Estude o conceito: durante find, defina parent de cada nó no caminho como raiz.",
                                    "Desenhe um exemplo gráfico: árvore degenerada (0->1->2->3), mostre compressão para todos apontarem para 3.",
                                    "Compare Find sem vs com compressão em termos de chamadas futuras.",
                                    "Escreva pseudocódigo recursivo para find_compression(i): if parent[i] != i, parent[i] = find_compression(parent[i]).",
                                    "Calcule complexidade: amortized O(α(n)) onde α é inversa de Ackermann."
                                  ],
                                  "verification": "Desenhe antes/depois da compressão em papel ou ferramenta como draw.io; explique redução de altura.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta ou draw.io",
                                    "Documentação Union-Find (Wikipedia ou CLRS)"
                                  ],
                                  "tips": "Pense recursivamente: a compressão acontece na volta da recursão.",
                                  "learningObjective": "Projetar a lógica de compressão de caminho para otimizar buscas repetidas.",
                                  "commonMistakes": [
                                    "Comprimir apenas o último nó",
                                    "Modificar parent durante subida sem recursão completa",
                                    "Não atualizar todos os nós no caminho"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Find Recursiva com Path Compression",
                                  "subSteps": [
                                    "Escreva função def find(parent, i): if parent[i] != i: parent[i] = find(parent, parent[i]); return parent[i].",
                                    "Integre em classe UnionFind com union por rank ou size (opcional para foco).",
                                    "Teste com Kruskal-like: nós 0-5, edges que formam cadeia longa, execute múltiplos finds.",
                                    "Meça tempo/depth antes/depois de compressão com timers e contadores de chamadas.",
                                    "Adicione asserts para verificar parent[i] == raiz após find."
                                  ],
                                  "verification": "Rode 100 finds repetidos; confirme que segunda chamada é O(1) para todos os nós comprimidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python ou C++",
                                    "Biblioteca timeit para benchmarks"
                                  ],
                                  "tips": "Use global counter para contar recursões e visualize redução.",
                                  "learningObjective": "Codificar a versão recursiva funcional e otimizada.",
                                  "commonMistakes": [
                                    "Erro de recursão infinita se parent[i] == i não checado primeiro",
                                    "Não retornar parent[i] após compressão",
                                    "Modificar parent incorretamente em linguagens com pass-by-value"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e Comparar Versão Iterativa com Path Compression",
                                  "subSteps": [
                                    "Converta para iterativa: encontre raiz primeiro, depois comprima caminho reverso.",
                                    "Código: raiz = i; while parent[raiz] != raiz: raiz = parent[raiz]; então for i to raiz, comprima.",
                                    "Melhore com 'two-pass': primeiro encontre raiz, segundo passe comprima.",
                                    "Teste equivalência com recursiva em casos edge: 1 nó, ciclo simulado, árvore balanceada.",
                                    "Benchmark 1000 unions + finds em grafo aleatório de 1000 nós."
                                  ],
                                  "verification": "Ambas versões produzem mesma árvore comprimida e tempos similares; sem stack overflow em recursiva para n=10^5.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Mesmos do step 3",
                                    "Gerador de grafos aleatórios (networkx opcional)"
                                  ],
                                  "tips": "Iterativa evita stack overflow em árvores profundas; use lista para caminho se necessário.",
                                  "learningObjective": "Dominar implementação iterativa robusta para produção.",
                                  "commonMistakes": [
                                    "Não comprimir todos nós no two-pass",
                                    "Loop infinito se raiz mal calculada",
                                    "Esquecer comprimir o próprio i"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Integrar em Contexto Kruskal",
                                  "subSteps": [
                                    "Integre find em Union-Find completo com union_by_rank.",
                                    "Simule Kruskal: edges ordenados, union se find(u) != find(v), detecte ciclos.",
                                    "Execute em grafo exemplo: 6 nós, edges para MST, verifique compressão pós-execução.",
                                    "Profile: compare tempo total com/sem compressão em 10 execuções.",
                                    "Escreva relatório: métricas de performance e visual da árvore final."
                                  ],
                                  "verification": "Kruskal produz MST correto; finds pós-compressão < 5 hops max.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Grafo exemplo JSON",
                                    "Matplotlib para visualizar árvore"
                                  ],
                                  "tips": "Sempre chame find antes de union para compressão incidental.",
                                  "learningObjective": "Aplicar em algoritmo real e validar otimizações.",
                                  "commonMistakes": [
                                    "Não ordenar edges em Kruskal",
                                    "Union sem check de ciclo",
                                    "Ignorar rank na union"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Kruskal para MST de rede de 5 cidades (nós 0-4), edges: (0,1:2), (1,2:3), (0,2:4), (3,4:1). Após unions 3-4 e 0-1, cadeia 0->1->2 requer 3 hops sem compressão; após find(2), todos apontam para raiz, próximo find O(1).",
                              "finalVerifications": [
                                "Função find retorna raiz correta para todos nós.",
                                "Após find em nó folha, todo caminho comprime para raiz (verifique parent[]).",
                                "Nenhuma recursão infinita ou stack overflow em n=10000.",
                                "Tempo amortized por operação < 5μs em benchmarks.",
                                "Equivalente a recursiva/iterativa em árvores pós-compressão.",
                                "Integra sem bugs em Union-Find completo para Kruskal."
                              ],
                              "assessmentCriteria": [
                                "Corretude: encontra raiz e comprime 100% dos caminhos.",
                                "Eficiência: reduz depth médio de O(n) para O(1) em chains.",
                                "Robustez: lida com n=1, árvores balanceadas, degeneradas.",
                                "Clareza: código comentado, funções modulares.",
                                "Performance: benchmark mostra speedup mensurável.",
                                "Testes: coverage >90% incluindo edges."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Complexidade Amortizada.",
                                "Algoritmos: Comparação com Halving/Full Compression.",
                                "Engenharia de Software: Refatoração Recursivo->Iterativo.",
                                "Análise de Dados: Detecção de Componentes Conectados.",
                                "Otimização: Aplicações em Machine Learning (clustering)."
                              ],
                              "realWorldApplication": "Em telecomunicações, Union-Find com path compression otimiza roteamento dinâmico em redes (ex: OSPF detecta loops); em ML, acelera clustering hierárquico em datasets massivos como imagens do ImageNet."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.2.3",
                            "name": "Implementar operação Union por rank",
                            "description": "Unir dois conjuntos ligando raiz de menor rank à de maior rank, atualizando rank se necessário para manter árvore balanceada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir estruturas de dados e função auxiliar find",
                                  "subSteps": [
                                    "Inicialize os arrays parent[] e rank[] com valores iniciais (parent[i] = i, rank[i] = 0).",
                                    "Implemente a função find(x) com compressão de caminho: enquanto parent[x] != x, faça x = parent[x], e compressão recursiva ou iterativa.",
                                    "Teste find em um nó isolado para retornar si mesmo.",
                                    "Teste find após uma ligação simples para verificar compressão.",
                                    "Garanta que find seja eficiente (quase O(1) com compressão)."
                                  ],
                                  "verification": "Execute find em vários nós e imprima a árvore para confirmar raízes corretas e compressão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Arrays de exemplo com 5-10 elementos"
                                  ],
                                  "tips": "Use recursão com memoização para compressão de caminho para simplicidade.",
                                  "learningObjective": "Compreender e implementar a busca de raiz com otimização para balanceamento.",
                                  "commonMistakes": [
                                    "Esquecer compressão de caminho, levando a árvores desbalanceadas.",
                                    "Não tratar caso parent[x] == x corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar verificação de raízes diferentes na função union",
                                  "subSteps": [
                                    "Na função union(x, y), chame rx = find(x) e ry = find(y).",
                                    "Se rx == ry, retorne sem fazer nada (já no mesmo conjunto).",
                                    "Registre ou imprima quando conjuntos são iguais para depuração.",
                                    "Teste com dois nós já unidos para confirmar que nada muda.",
                                    "Teste com nós em conjuntos diferentes para prosseguir."
                                  ],
                                  "verification": "Chame union em nós do mesmo conjunto e verifique que parent e rank não mudam.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código da Step 1",
                                    "Exemplos de grafos pequenos"
                                  ],
                                  "tips": "Sempre chame find antes de comparar para garantir raízes atualizadas.",
                                  "learningObjective": "Evitar uniões desnecessárias e detectar componentes conectados.",
                                  "commonMistakes": [
                                    "Comparar x e y diretamente sem find.",
                                    "Não retornar early se rx == ry."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar ranks e ligar raízes apropriadamente",
                                  "subSteps": [
                                    "Se rank[rx] < rank[ry], defina parent[rx] = ry.",
                                    "Se rank[rx] > rank[ry], defina parent[ry] = rx.",
                                    "Se rank[rx] == rank[ry], defina parent[rx] = ry e incremente rank[ry] += 1.",
                                    "Imprima as mudanças em parent e rank após cada ligação.",
                                    "Escolha arbitrariamente qual incrementar em caso de empate (ex: sempre rx para ry)."
                                  ],
                                  "verification": "Após union, execute find em ambos e confirme mesma raiz; verifique rank atualizado só em empate.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código anterior",
                                    "Casos de teste com ranks variados"
                                  ],
                                  "tips": "Sempre ligue menor ou igual rank à maior para manter balanceamento.",
                                  "learningObjective": "Aplicar heurística de rank para minimizar altura da árvore.",
                                  "commonMistakes": [
                                    "Ligar sempre rx a ry sem comparar ranks.",
                                    "Incrementar rank em todos os casos, não só empate."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a implementação completa",
                                  "subSteps": [
                                    "Crie um grafo exemplo com 5 nós e execute múltiplas unions simulando Kruskal.",
                                    "Verifique detecção de ciclos: union falha se já conectados.",
                                    "Meça altura da árvore após várias operações (deve ser baixa).",
                                    "Implemente uma função para imprimir a estrutura Union-Find.",
                                    "Compare com implementação sem rank para ver diferença em balanceamento."
                                  ],
                                  "verification": "Simule Kruskal em grafo completo e confirme MST sem ciclos; altura < log n.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo",
                                    "Grafo exemplo para MST"
                                  ],
                                  "tips": "Use asserts ou testes unitários para automação.",
                                  "learningObjective": "Validar corretude e eficiência da Union por rank.",
                                  "commonMistakes": [
                                    "Não testar casos de rank igual.",
                                    "Ignorar compressão levando a lentidão."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere 4 nós (0-3), parent=[0,1,2,3], rank=[0,0,0,0]. union(0,1): ranks=0==0, parent[0]=1, rank[1]=1. union(1,2): rank[1]=1>0, parent[2]=1. union(1,3): rank[1]=1>0, parent[3]=1. union(0,2): já mesma raiz (1), nada muda. Resultado: árvore balanceada com raiz 1.",
                              "finalVerifications": [
                                "Função union não altera estruturas se x e y já no mesmo conjunto.",
                                "Sempre liga raiz de menor rank à de maior rank.",
                                "Rank incrementado apenas quando ranks das raízes são iguais.",
                                "Após múltiplas unions, altura da árvore permanece baixa (≤ 2 para n=16).",
                                "find retorna raiz correta com compressão de caminho.",
                                "Detecção de ciclos funciona: union falha em arestas que formariam ciclo."
                              ],
                              "assessmentCriteria": [
                                "Correção: Ligações respeitam regra de rank em todos os casos.",
                                "Eficiência: Tempo quase constante por operação com path compression + union by rank.",
                                "Robustez: Trata casos edge (n=1, todos isolados, ranks variados).",
                                "Clareza: Código comentado com lógica de rank explicada.",
                                "Testes: Cobertura de cenários de empate, desigualdade e ciclos.",
                                "Balanceamento: Altura da árvore comprovadamente controlada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e árvores balanceadas.",
                                "Algoritmos: Integração com Kruskal para AGM.",
                                "Estruturas de Dados: Disjoint Set Union (DSU).",
                                "Engenharia de Software: Otimização assintótica (inverso de Ackermann).",
                                "Ciência de Dados: Clustering e componentes conectados."
                              ],
                              "realWorldApplication": "Em algoritmos como Kruskal para encontrar Árvore Geradora Mínima em redes de telecomunicações, detecção de comunidades em redes sociais, union de clusters em machine learning, e gerenciamento de recursos em sistemas distribuídos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.3.5.3",
                        "name": "Construção da Árvore Geradora Mínima com Kruskal",
                        "description": "Aplicação gulosa: iterar pelas arestas ordenadas, adicionar à AGM se não formarem ciclo usando Union-Find, até conectar todos os vértices.",
                        "specificSkills": [
                          {
                            "id": "10.1.3.5.3.1",
                            "name": "Verificar se aresta conecta componentes diferentes",
                            "description": "Usar Find(u) != Find(v) para decidir se adicionar aresta à AGM sem criar ciclo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Componentes Conectados com Union-Find",
                                  "subSteps": [
                                    "Revise a estrutura de dados Union-Find, focando no array 'parent' que rastreia o representante de cada componente.",
                                    "Inicialize o Union-Find para n vértices, definindo parent[i] = i para cada i.",
                                    "Entenda que vértices no mesmo componente têm o mesmo Find(u).",
                                    "Discuta por que detectar componentes diferentes evita ciclos na AGM.",
                                    "Desenhe um grafo simples com 3 vértices e mostre componentes iniciais."
                                  ],
                                  "verification": "Desenhe um grafo com 4 vértices desconectados e identifique os componentes iniciais corretamente.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Pseudocódigo de Union-Find",
                                    "Exemplo de grafo não conectado"
                                  ],
                                  "tips": [
                                    "Visualize o grafo como florestas de árvores para entender componentes."
                                  ],
                                  "learningObjective": "Explicar como Union-Find representa componentes conectados em um grafo.",
                                  "commonMistakes": [
                                    "Confundir componentes conectados com cliques completos.",
                                    "Esquecer de inicializar parent corretamente.",
                                    "Ignorar path compression na compreensão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Testar a Função Find",
                                  "subSteps": [
                                    "Escreva a função Find(u) com path compression: while parent[u] != u, u = parent[u].",
                                    "Teste Find em um array parent simples, como parent = [0,1,2,2] para u=3 (deve retornar 2).",
                                    "Implemente recursivamente ou iterativamente e compare resultados.",
                                    "Execute Find múltiplas vezes no mesmo conjunto para verificar compressão de caminho.",
                                    "Registre o representante encontrado para cada vértice em um grafo de exemplo."
                                  ],
                                  "verification": "Execute Find(u) e Find(v) em um grafo de teste e confirme que retorna o mesmo valor para vértices conectados.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor de código (Python ou pseudocódigo)",
                                    "Grafo de teste com 5 vértices",
                                    "Debugger ou print statements"
                                  ],
                                  "tips": [
                                    "Use path compression sempre para otimizar chamadas futuras de Find."
                                  ],
                                  "learningObjective": "Implementar Find corretamente, garantindo detecção precisa de representantes de componentes.",
                                  "commonMistakes": [
                                    "Loop infinito sem path compression.",
                                    "Não atualizar parent durante compressão.",
                                    "Confundir índice do vértice com valor do parent."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a Verificação Find(u) != Find(v)",
                                  "subSteps": [
                                    "Para uma aresta (u,v), compute Find(u) e Find(v).",
                                    "Se Find(u) == Find(v), a aresta forma ciclo: ignore-a.",
                                    "Se Find(u) != Find(v), a aresta conecta componentes diferentes: adicione à AGM.",
                                    "Registre a decisão para cada aresta em uma lista ordenada por peso.",
                                    "Simule em um grafo pequeno: liste arestas e marque decisões."
                                  ],
                                  "verification": "Em um grafo com 4 arestas candidatas, classifique corretamente quais conectam componentes diferentes.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de arestas ordenadas por peso",
                                    "Union-Find implementado do Step 2",
                                    "Planilha para simular"
                                  ],
                                  "tips": [
                                    "Sempre ordene arestas por peso crescente antes da verificação."
                                  ],
                                  "learningObjective": "Usar Find(u) != Find(v) para decidir inclusão de aresta sem criar ciclos.",
                                  "commonMistakes": [
                                    "Verificar u != v em vez de Find(u) != Find(v).",
                                    "Adicionar aresta mesmo com Find iguais.",
                                    "Esquecer de chamar Find antes da comparação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Verificação no Loop de Kruskal e Validar",
                                  "subSteps": [
                                    "No loop principal de Kruskal: para cada aresta ordenada, verifique Find(u) != Find(v).",
                                    "Se verdadeiro, adicione à AGM e chame Union(u,v).",
                                    "Conte o número de arestas adicionadas (deve ser n-1 para AGM).",
                                    "Valide que a AGM resultante é acíclica e conecta todos os vértices.",
                                    "Compare o custo total com o esperado."
                                  ],
                                  "verification": "Execute Kruskal completo em um grafo e confirme que nenhuma aresta cria ciclo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo de Kruskal",
                                    "Grafo de teste com pesos conhecidos",
                                    "Ferramenta de visualização de grafos"
                                  ],
                                  "tips": [
                                    "Monitore rank na Union para balanceamento de árvores."
                                  ],
                                  "learningObjective": "Integrar a verificação na construção completa da AGM usando Kruskal.",
                                  "commonMistakes": [
                                    "Chamar Union sem verificar Find primeiro.",
                                    "Não ordenar arestas corretamente.",
                                    "Parar antes de n-1 arestas."
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com 4 vértices A,B,C,D. Arestas ordenadas: (A,B:1), (C,D:2), (B,C:3), (A,D:4). Inicial: componentes {A},{B},{C},{D}. Adicione (A,B): Find(A)!=Find(B) → sim, Union. Agora {A,B},{C},{D}. Adicione (C,D): sim, Union → {A,B},{C,D}. (B,C): Find(B)!=Find(C) → sim, Union → {A,B,C,D}. Ignore (A,D) pois Find(A)==Find(D). AGM: A-B-C-D, custo 6.",
                              "finalVerifications": [
                                "Identifica corretamente componentes diferentes em 100% dos casos de teste.",
                                "Implementa Find com path compression funcionando.",
                                "Loop de Kruskal ignora arestas que formariam ciclos.",
                                "AGM final tem exatamente n-1 arestas e é conectada.",
                                "Custo total da AGM é mínimo para grafos de teste.",
                                "Nenhum ciclo detectado na AGM resultante."
                              ],
                              "assessmentCriteria": [
                                "Precisão da verificação Find(u) != Find(v): 100% em exemplos variados.",
                                "Eficiência: tempo O(α(n)) por operação com Union-Find otimizado.",
                                "Correção na integração com Union após verificação positiva.",
                                "Capacidade de debugar erros comuns como ciclos acidentais.",
                                "Explicação clara do porquê a verificação previne ciclos.",
                                "Aplicação consistente em grafos com 5-10 vértices."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Detecção de ciclos e conectividade.",
                                "Estruturas de Dados: Disjoint Set Union (DSU).",
                                "Algoritmos Gulosos: Critério de escolha local ótimo.",
                                "Matemática Discreta: Relações de equivalência e partições.",
                                "Programação Competitiva: Implementações eficientes de Kruskal."
                              ],
                              "realWorldApplication": "Em planejamento de redes elétricas ou telecomunicações, conecta subestações/cidades com cabos de mínimo custo total, evitando loops desnecessários que desperdiçariam recursos, como no algoritmo de Kruskal para infraestrutura de banda larga."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.2",
                            "name": "Implementar loop principal do algoritmo Kruskal",
                            "description": "Iterar lista ordenada de arestas, adicionar válidas à lista da AGM e executar Union, parando ao atingir n-1 arestas ou todas processadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar estruturas para o loop principal",
                                  "subSteps": [
                                    "Criar uma lista vazia para armazenar as arestas da AGM (Árvore Geradora Mínima).",
                                    "Inicializar um contador de arestas na AGM com valor 0.",
                                    "Garantir que a estrutura Union-Find esteja pronta com n componentes (um para cada vértice).",
                                    "Confirmar que a lista de arestas está ordenada por peso em ordem crescente.",
                                    "Definir a variável n como o número de vértices no grafo."
                                  ],
                                  "verification": "Verifique se a lista AGM está vazia, contador é 0 e Union-Find tem n componentes isolados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código ou papel para pseudocódigo",
                                    "Diagrama do grafo de exemplo"
                                  ],
                                  "tips": "Use nomes de variáveis claros como 'agm_edges', 'edge_count' e 'num_vertices' para facilitar depuração.",
                                  "learningObjective": "Preparar todas as variáveis necessárias para iniciar a iteração sem erros de inicialização.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar o contador em 0",
                                    "Não ordenar as arestas previamente",
                                    "Confundir n com o número de arestas totais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar iteração sobre a lista ordenada de arestas",
                                  "subSteps": [
                                    "Iniciar um loop for que percorre cada aresta na lista ordenada.",
                                    "Para cada aresta atual, extrair os vértices u e v.",
                                    "Chamar a função find(u) e find(v) para determinar os representantes dos componentes.",
                                    "Comparar se find(u) != find(v) para verificar se não formam ciclo.",
                                    "Preparar para adicionar a aresta se a condição for verdadeira."
                                  ],
                                  "verification": "Execute o loop manualmente em um grafo pequeno e confirme que todas as arestas são processadas na ordem correta.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Grafo de exemplo com 4-5 vértices"
                                  ],
                                  "tips": "Teste o loop com print statements para rastrear arestas processadas e seus finds.",
                                  "learningObjective": "Dominar a iteração sequencial e a consulta aos representantes Union-Find.",
                                  "commonMistakes": [
                                    "Usar loop while em vez de for para iteração finita",
                                    "Esquecer de extrair u e v corretamente",
                                    "Comparar u != v em vez de find(u) != find(v)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar aresta válida à AGM e executar Union",
                                  "subSteps": [
                                    "Se find(u) != find(v), adicionar a aresta atual à lista da AGM.",
                                    "Incrementar o contador de arestas na AGM.",
                                    "Executar union(u, v) para mesclar os componentes.",
                                    "Registrar o peso da aresta adicionada para cálculo posterior do custo total.",
                                    "Continuar para a próxima aresta."
                                  ],
                                  "verification": "Após simulação, confirme que apenas arestas sem ciclo foram adicionadas e union foi chamado corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Union-Find implementado previamente"
                                  ],
                                  "tips": "Adicione logs para mostrar 'Aresta adicionada: (u,v) peso w' para visualização.",
                                  "learningObjective": "Executar corretamente a adição condicional e a mesclagem de componentes.",
                                  "commonMistakes": [
                                    "Incrementar contador sem adicionar aresta",
                                    "Chamar union antes de verificar ciclo",
                                    "Não atualizar o custo total da AGM"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar condição de parada e finalizar o algoritmo",
                                  "subSteps": [
                                    "Verificar dentro do loop se o contador de arestas atingiu n-1; se sim, quebrar o loop.",
                                    "Após o loop, verificar se o grafo era conexo (contador == n-1).",
                                    "Calcular e retornar o custo total da AGM somando pesos das arestas adicionadas.",
                                    "Retornar a lista de arestas da AGM.",
                                    "Tratar caso de grafo não conexo (sem AGM completa)."
                                  ],
                                  "verification": "Teste com grafos conexos e não conexos; confirme parada precoce e resultado correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Múltiplos grafos de teste"
                                  ],
                                  "tips": "Use 'break' no loop for para parada condicional; sempre valide conectividade no final.",
                                  "learningObjective": "Garantir terminação correta do algoritmo com detecção de grafos desconexos.",
                                  "commonMistakes": [
                                    "Não parar ao atingir n-1 arestas",
                                    "Ignorar grafos desconexos",
                                    "Erro no cálculo do custo total"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo com 4 vértices (A,B,C,D) e arestas ordenadas: (A,B:1), (B,C:2), (A,C:3), (C,D:4). O loop adicionará (A,B), (B,C), (C,D), parando após 3 arestas (n-1=3), formando AGM com custo 7.",
                              "finalVerifications": [
                                "Lista AGM contém exatamente n-1 arestas para grafo conexo.",
                                "Nenhum ciclo detectado (todos unions em componentes diferentes).",
                                "Custo total é mínimo comparado a outras sequências.",
                                "Algoritmo para corretamente em grafos desconexos.",
                                "Union-Find reflete componentes corretos no final.",
                                "Todas arestas processadas na ordem de peso crescente."
                              ],
                              "assessmentCriteria": [
                                "Correção na detecção de ciclos via Union-Find.",
                                "Adição precisa de arestas apenas quando necessário.",
                                "Parada condicional ao atingir n-1 arestas.",
                                "Eficiência temporal O(E log E) mantida pelo loop.",
                                "Tratamento de casos edge (grafo vazio, n=1, desconexo).",
                                "Código limpo com comentários explicativos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Conjuntos Disjuntos.",
                                "Otimização: Algoritmos Gulosos e Prova de Otimalidade.",
                                "Ciência de Dados: Clustering e Análise de Redes.",
                                "Engenharia: Design de Redes de Comunicação.",
                                "Lógica: Estruturas Condicionais e Loops em Programação."
                              ],
                              "realWorldApplication": "Em telecomunicações, otimiza o layout de cabos para conectar cidades com custo mínimo sem loops desnecessários; em logística, constrói rotas eficientes para frotas de entrega."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.3.5.3.3",
                            "name": "Calcular e validar custo total da AGM",
                            "description": "Somar pesos das arestas selecionadas e verificar se o grafo é conexo (uma única componente) para confirmar AGM válida.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e listar as arestas selecionadas na AGM de Kruskal",
                                  "subSteps": [
                                    "Revise o processo de Kruskal: liste todas as arestas adicionadas à AGM sem formar ciclos.",
                                    "Registre cada aresta com seus vértices de origem e destino, e o peso correspondente.",
                                    "Confirme o número total de arestas: deve ser |V| - 1, onde |V| é o número de vértices.",
                                    "Anote o grafo original para referência futura.",
                                    "Crie uma tabela simples: colunas para aresta (u-v), peso."
                                  ],
                                  "verification": "Lista completa de arestas com pesos corresponde exatamente às usadas no Kruskal, e número de arestas é |V|-1.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e lápis ou editor de texto; representação do grafo original.",
                                  "tips": "Use Union-Find mentalmente para recordar por que cada aresta foi selecionada.",
                                  "learningObjective": "Dominar a extração precisa das arestas finais da AGM.",
                                  "commonMistakes": "Incluir arestas rejeitadas por ciclos ou esquecer arestas de união de componentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o custo total somando os pesos das arestas",
                                  "subSteps": [
                                    "Some os pesos de todas as arestas listadas, um por um.",
                                    "Use uma calculadora ou adição manual para evitar erros aritméticos.",
                                    "Registre somas parciais para rastrear o cálculo.",
                                    "Compare com o custo estimado durante Kruskal para consistência.",
                                    "Anote o custo total final em negrito ou destacado."
                                  ],
                                  "verification": "Soma manual recálculo confirma o total exato sem discrepâncias.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Calculadora opcional; lista de arestas do Step 1.",
                                  "tips": "Adicione pesos em ordem crescente para facilitar verificação.",
                                  "learningObjective": "Executar somatória precisa de pesos em contextos de otimização.",
                                  "commonMistakes": "Erros de adição simples ou duplicar/subtrair pesos por engano."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar se o subgrafo das arestas selecionadas é conexo",
                                  "subSteps": [
                                    "Aplique Union-Find: inicie cada vértice como componente separada.",
                                    "Una componentes para cada aresta selecionada e conte o número final de componentes.",
                                    "Alternativamente, execute DFS ou BFS a partir de um vértice e confirme que todos são visitados.",
                                    "Desenhe o subgrafo das arestas para visualização.",
                                    "Confirme: exatamente 1 componente conectada."
                                  ],
                                  "verification": "Número de componentes = 1; todos vértices alcançáveis de qualquer um.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel para desenhar subgrafo; tabela Union-Find.",
                                  "tips": "Comece Union-Find do zero, ignorando arestas não selecionadas.",
                                  "learningObjective": "Validar conectividade usando técnicas padrão de grafos.",
                                  "commonMistakes": "Confundir com o grafo original ou usar arestas rejeitadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar validade da AGM e documentar resultados",
                                  "subSteps": [
                                    "Verifique: |E| = |V|-1, conexo, sem ciclos (implícito em Kruskal).",
                                    "Compare custo total com AGM conhecida ou Prim para validação cruzada.",
                                    "Documente: custo total, confirmação de conectividade, qualquer observação.",
                                    "Teste remoção de uma aresta: deve desconectar o grafo.",
                                    "Salve resultados para portfólio ou relatório."
                                  ],
                                  "verification": "Todos critérios atendidos: custo calculado, conexo, |E|=|V|-1.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Resultados dos steps anteriores; software de grafos opcional (ex: Graphviz).",
                                  "tips": "Use teste de remoção de aresta para prova rápida de árvore.",
                                  "learningObjective": "Integrar todos os checks para validar AGM completa.",
                                  "commonMistakes": "Ignorar verificação de ciclos ou assumir conectividade sem prova."
                                }
                              ],
                              "practicalExample": "Grafo com 4 vértices A,B,C,D. Arestas: AB(1), CD(1), BC(2), AC(3), AD(4), BD(5). Kruskal seleciona AB(1), CD(1), BC(2). Custo total: 1+1+2=4. Verificação: 3 arestas (4-1), Union-Find une todos em 1 componente, DFS de A alcança B,C,D.",
                              "finalVerifications": [
                                "Custo total somado corretamente sem erros aritméticos.",
                                "Número de arestas exatamente |V|-1.",
                                "Subgrafo é conexo (1 componente).",
                                "Sem ciclos detectados (verificação visual ou algoritmo).",
                                "Custo mínimo comparado a outras árvores geradoras.",
                                "Documentação completa com lista de arestas."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo da soma de pesos (100% correto).",
                                "Correta identificação de todas arestas da AGM.",
                                "Validação de conectividade com método apropriado e sem erros.",
                                "Uso correto de |V|-1 como check de árvore.",
                                "Documentação clara e organizada dos passos.",
                                "Identificação de potenciais erros e sua prevenção."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Somatórias, teoria de grafos e conectividade.",
                                "Programação: Implementação de Union-Find ou DFS para automação.",
                                "Engenharia: Otimização de redes (ex: telecomunicações).",
                                "Estatística: Análise de custos em dados de redes sociais.",
                                "Economia: Minimização de custos em projetos de infraestrutura."
                              ],
                              "realWorldApplication": "Em planejamento de redes elétricas ou de telecomunicações, calcular o custo mínimo de cabos para conectar todas as cidades sem loops, validando conectividade para garantir serviço ininterrupto."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.4",
                "name": "Ordenação Topológica",
                "description": "Algoritmo para linearizar os vértices de um grafo acíclico dirigido, respeitando as dependências das arestas.",
                "totalSkills": 55,
                "atomicTopics": [
                  {
                    "id": "10.1.4.1",
                    "name": "Grafo Acíclico Direcionado (DAG)",
                    "description": "Grafo dirigido sem ciclos direcionados, pré-requisito para ordenação topológica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.1.1",
                        "name": "Grafo Dirigido",
                        "description": "Estrutura de dados composta por vértices e arestas direcionadas, onde cada aresta possui uma direção específica de um vértice origem para um vértice destino, modelando relações assimétricas como precedências ou dependências.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.1.1",
                            "name": "Definir Grafo Dirigido",
                            "description": "Explicar formalmente um grafo dirigido como G = (V, E), onde V é o conjunto de vértices e E ⊆ V × V é o conjunto de arestas ordenadas, diferenciando de grafos não direcionados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Grafos e Vértices",
                                  "subSteps": [
                                    "Estude a definição de um vértice como um nó ou entidade no grafo.",
                                    "Identifique exemplos reais de vértices, como cidades em um mapa ou tarefas em um projeto.",
                                    "Desenhe 3-5 vértices isolados em um papel para visualizar.",
                                    "Explique verbalmente ou por escrito o papel dos vértices em estruturas de rede.",
                                    "Compare vértices com objetos em programação (ex: classes ou variáveis)."
                                  ],
                                  "verification": "Desenhar e rotular um conjunto de 5 vértices isolados, confirmando compreensão básica.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Vídeo introdutório sobre grafos (ex: Khan Academy)"
                                  ],
                                  "tips": "Pense em vértices como 'pontos de parada' em uma jornada para facilitar a visualização.",
                                  "learningObjective": "Dominar o conceito de vértices como elementos fundamentais de qualquer grafo.",
                                  "commonMistakes": [
                                    "Confundir vértices com arestas",
                                    "Ignorar que vértices podem ter rótulos ou propriedades"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar Arestas e a Noção de Direção",
                                  "subSteps": [
                                    "Defina aresta como uma conexão entre dois vértices.",
                                    "Diferencie arestas não direcionadas (bidirecionais) de direcionadas (unidirecionais).",
                                    "Desenhe arestas não direcionadas entre vértices existentes.",
                                    "Adicione setas para transformar em direcionadas, notando a ordem.",
                                    "Liste 3 exemplos onde a direção importa (ex: ruas de mão única)."
                                  ],
                                  "verification": "Converter um grafo não direcionado simples em dirigido adicionando setas e explicando mudanças.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel, caneta e lápis de cor para setas",
                                    "Ferramenta online como draw.io"
                                  ],
                                  "tips": "Use setas grossas para direção para reforçar o conceito visualmente.",
                                  "learningObjective": "Entender arestas como relações ordenadas em grafos dirigidos.",
                                  "commonMistakes": [
                                    "Assumir que todas as arestas são bidirecionais",
                                    "Esquecer a ordenação em pares (u,v)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Formalizar a Definição de Grafo Dirigido G = (V, E)",
                                  "subSteps": [
                                    "Memorize a notação G = (V, E), onde V é o conjunto finito de vértices.",
                                    "Aprenda que E ⊆ V × V representa pares ordenados (u, v) para arestas direcionadas.",
                                    "Escreva exemplos: V = {1,2,3}, E = {(1,2), (2,3)}.",
                                    "Verifique se E contém apenas pares válidos de V.",
                                    "Pratique notação em um caderno com 2 grafos dirigidos diferentes."
                                  ],
                                  "verification": "Escrever a definição formal completa de um grafo dirigido com V e E específicos, sem erros.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Caderno de anotações",
                                    "Referência matemática: Wikipedia 'Directed Graph'"
                                  ],
                                  "tips": "Use parênteses para pares ordenados: (origem, destino) para clareza.",
                                  "learningObjective": "Aplicar a definição matemática precisa de grafo dirigido.",
                                  "commonMistakes": [
                                    "Escrever E como lista não ordenada",
                                    "Incluir pares inválidos fora de V × V"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diferenciar Grafos Dirigidos de Não Dirigidos",
                                  "subSteps": [
                                    "Compare: em não dirigido, (u,v) implica (v,u); em dirigido, não.",
                                    "Construa o mesmo grafo em ambas versões e destaque diferenças.",
                                    "Discuta implicações: ciclos, ordenação topológica só em dirigidos.",
                                    "Resolva exercício: dado um grafo, identifique se é dirigido ou não.",
                                    "Explique em uma frase curta a principal distinção."
                                  ],
                                  "verification": "Criar tabela comparativa com 4 diferenças chave entre grafos dirigidos e não dirigidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em papel ou Google Docs",
                                    "Exemplos de livros de algoritmos"
                                  ],
                                  "tips": "Pense em 'fluxo unidirecional' para grafos dirigidos vs. 'amizade mútua' para não dirigidos.",
                                  "learningObjective": "Distinguir formal e conceitualmente grafos dirigidos de não dirigidos.",
                                  "commonMistakes": [
                                    "Ignorar que arestas não dirigidas são simétricas",
                                    "Confundir com grafos ponderados"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar dependências de tarefas em um projeto: V = {TarefaA, TarefaB, TarefaC}, E = {(TarefaA, TarefaB), (TarefaB, TarefaC)}, onde a seta indica que A deve ser concluída antes de B.",
                              "finalVerifications": [
                                "Escrever corretamente G = (V, E) com V finito e E ⊆ V × V.",
                                "Explicar verbalmente a ordenação em arestas direcionadas.",
                                "Desenhar um grafo dirigido simples com 4 vértices e 3 arestas.",
                                "Identificar e corrigir um erro em uma definição formal fornecida.",
                                "Diferenciar um grafo dirigido de não dirigido em um exemplo dado.",
                                "Listar 2 propriedades únicas de grafos dirigidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal G = (V, E) (obrigatório).",
                                "Correta explicação de E como subconjunto de pares ordenados.",
                                "Uso consistente de setas em representações visuais.",
                                "Capacidade de diferenciar de grafos não dirigidos com exemplos.",
                                "Profundidade em exemplos práticos e verificações.",
                                "Ausência de erros comuns como pares não ordenados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Relações Binárias.",
                                "Programação: Implementação em linguagens como Python com bibliotecas NetworkX.",
                                "Engenharia de Software: Modelagem de dependências em pipelines CI/CD.",
                                "Física: Diagramas de forças direcionadas em sistemas dinâmicos."
                              ],
                              "realWorldApplication": "Em compiladores, grafos dirigidos modelam dependências de módulos (DAG para ordenação topológica); em redes sociais, seguimentos unidirecionais; em logística, rotas de entrega com restrições de direção."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.2",
                            "name": "Representar Grafo Dirigido",
                            "description": "Implementar representações matriciais (matriz de adjacência) e listas (lista de adjacência) para grafos dirigidos, analisando vantagens em termos de espaço e tempo de consulta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Grafos Dirigidos e Representações",
                                  "subSteps": [
                                    "Defina grafo dirigido (DG): vértices e arcos direcionados.",
                                    "Explique matriz de adjacência: matriz booleana ou numérica onde M[i][j] indica existência de arco de i para j.",
                                    "Descreva lista de adjacência: lista para cada vértice contendo vizinhos diretos.",
                                    "Discuta diferenças iniciais: matriz usa matriz 2D, lista usa estrutura de listas encadeadas.",
                                    "Crie um grafo simples de exemplo com 4 vértices e 5 arcos."
                                  ],
                                  "verification": "Desenhe manualmente a matriz e lista para um grafo exemplo e compare com definição.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para anotações",
                                    "Documentação de grafos (Wikipedia ou livro-texto)"
                                  ],
                                  "tips": "Use um grafo pequeno (3-5 vértices) para visualização clara; lembre-se que em DG, M[i][j] ≠ M[j][i].",
                                  "learningObjective": "Dominar definições e diferenças conceituais entre as representações.",
                                  "commonMistakes": [
                                    "Confundir grafo dirigido com não-dirigido (simetria na matriz)",
                                    "Ignorar auto-arcos (loops)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Matriz de Adjacência em Código",
                                  "subSteps": [
                                    "Escolha linguagem (ex: Python) e crie classe Grafo com matriz 2D (lista de listas).",
                                    "Implemente método adicionar_arco(v1, v2) atualizando matriz[v1][v2] = 1.",
                                    "Adicione métodos get_vizinhos(v) retornando lista de j onde matriz[v][j] == 1.",
                                    "Teste com grafo exemplo: adicione arcos e imprima matriz.",
                                    "Otimize para grafos esparsos usando dicionário de dicionários se aplicável."
                                  ],
                                  "verification": "Execute código com grafo teste e verifique se matriz reflete arcos corretamente.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Ambiente Python (Jupyter ou IDE)",
                                    "Exemplo de grafo pronto"
                                  ],
                                  "tips": "Inicialize matriz com zeros; use numpy para matrizes grandes e eficientes.",
                                  "learningObjective": "Implementar funcionalmente a representação matricial.",
                                  "commonMistakes": [
                                    "Índices fora de range (vértices de 0 a n-1)",
                                    "Não tratar vértices isolados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Lista de Adjacência em Código",
                                  "subSteps": [
                                    "Crie classe Grafo com dicionário: chave=vértice, valor=lista de vizinhos.",
                                    "Implemente adicionar_arco(v1, v2) appendando v2 na lista de v1.",
                                    "Adicione get_vizinhos(v) retornando a lista diretamente.",
                                    "Teste com mesmo grafo exemplo, imprimindo listas.",
                                    "Adicione remoção de arcos e verificação de existência."
                                  ],
                                  "verification": "Compare listas geradas com arcos manuais do grafo teste.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Ambiente Python",
                                    "Mesmo grafo teste da matriz"
                                  ],
                                  "tips": "Use defaultdict(list) para inicialização automática; ordene listas para depuração.",
                                  "learningObjective": "Implementar representação list-based de forma eficiente.",
                                  "commonMistakes": [
                                    "Duplicar vizinhos em adições múltiplas",
                                    "Não inicializar vértices vazios"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Vantagens em Espaço e Tempo de Consulta",
                                  "subSteps": [
                                    "Calcule espaço: Matriz O(V^2), Lista O(V + E).",
                                    "Tempo consulta vizinhos: Matriz O(V), Lista O(degree(v)).",
                                    "Tempo adicionar arco: Matriz O(1), Lista O(1).",
                                    "Compare com exemplos numéricos para V=100, E=500.",
                                    "Discuta cenários: denso (matriz boa), esparso (lista melhor)."
                                  ],
                                  "verification": "Crie tabela comparativa e aplique a grafos denso/esparso simulados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Planilha (Excel/Google Sheets)",
                                    "Códigos das Steps 2-3 para medições reais"
                                  ],
                                  "tips": "Meça tempo real com timeit em Python para validação empírica.",
                                  "learningObjective": "Avaliar trade-offs quantitativamente.",
                                  "commonMistakes": [
                                    "Confundir V com E na notação Big-O",
                                    "Ignorar constantes ocultas"
                                  ]
                                }
                              ],
                              "practicalExample": "Represente um grafo de dependências de tarefas em um projeto de software: T1 -> T2, T1 -> T3, T2 -> T4, T3 -> T4, T4 -> T5. Implemente ambas representações e consulte vizinhos de T1 para listar tarefas dependentes.",
                              "finalVerifications": [
                                "Implementar corretamente matriz e lista para grafo com 6 vértices e 10 arcos.",
                                "Consultar vizinhos em O(1) médio na lista e O(V) na matriz.",
                                "Calcular espaço exato: matriz 36 células, lista ~16 entradas.",
                                "Identificar cenário esparso onde lista usa 70% menos memória.",
                                "Converter entre representações sem perda de informação.",
                                "Depurar erro comum como arco bidirecional ausente em DG."
                              ],
                              "assessmentCriteria": [
                                "Correção na implementação: 30% (testes passam).",
                                "Eficiência analisada com Big-O correto: 25%.",
                                "Exemplos práticos funcionais: 20%.",
                                "Comparação quantitativa precisa: 15%.",
                                "Clareza no código e documentação: 10%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Álgebra Linear (operações matriciais).",
                                "Engenharia de Software: Modelagem de dependências em pipelines CI/CD.",
                                "Ciência de Dados: Grafos em redes neurais e PageRank.",
                                "Física: Modelagem de circuitos direcionais."
                              ],
                              "realWorldApplication": "Em planejamento de projetos (PERT/CPM para ordenação topológica), sistemas de recomendação (grafos de usuários/itens), compiladores (dependências de módulos) e redes de computadores (roteamento direcionado)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.1.3",
                            "name": "Identificar Arestas e Vértices em Grafos Dirigidos",
                            "description": "Dado um grafo dirigido, listar vértices de entrada (indegree), saída (outdegree) e identificar arestas incidentes, calculando graus direcionados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e Representar um Grafo Dirigido",
                                  "subSteps": [
                                    "Defina um grafo dirigido (digrafo) como um conjunto de vértices V e arestas direcionadas E, onde cada aresta tem direção de um vértice origem para destino.",
                                    "Desenhe ou liste a representação do grafo usando lista de adjacência ou matriz de adjacência.",
                                    "Identifique todos os vértices únicos no grafo.",
                                    "Liste todas as arestas com suas direções (ex: (u,v) significa aresta de u para v).",
                                    "Verifique se o grafo é simples (sem laços ou múltiplas arestas na mesma direção)."
                                  ],
                                  "verification": "Confirme que a representação lista corretamente todos vértices e arestas direcionadas sem erros de direção.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta de desenho como Draw.io ou Graphviz",
                                    "Exemplo de grafo dirigido impresso"
                                  ],
                                  "tips": "Sempre rotule arestas com setas para indicar direção; use cores diferentes para vértices de entrada e saída.",
                                  "learningObjective": "Compreender a estrutura básica de um grafo dirigido e representá-lo adequadamente.",
                                  "commonMistakes": [
                                    "Confundir direção das arestas",
                                    "Esquecer vértices isolados",
                                    "Ignorar múltiplas arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular Graus de Entrada (Indegree) para Cada Vértice",
                                  "subSteps": [
                                    "Para cada vértice, conte o número de arestas que apontam para ele (entrando).",
                                    "Inicialize um contador zero para cada vértice.",
                                    "Percorra todas as arestas e incremente o contador do vértice destino.",
                                    "Liste os vértices com indegree zero (fontes potenciais em DAGs).",
                                    "Registre os resultados em uma tabela: Vértice | Indegree."
                                  ],
                                  "verification": "Some todos os indegrees; deve igualar o número total de arestas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de arestas do grafo",
                                    "Planilha ou tabela em papel"
                                  ],
                                  "tips": "Use uma tabela para rastrear contadores; verifique duas vezes arestas múltiplas.",
                                  "learningObjective": "Calcular precisamente o indegree de vértices em grafos dirigidos.",
                                  "commonMistakes": [
                                    "Contar arestas de saída como entrada",
                                    "Esquecer arestas para vértices isolados",
                                    "Erros de contagem em arestas paralelas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Graus de Saída (Outdegree) e Identificar Arestas Incidentes",
                                  "subSteps": [
                                    "Para cada vértice, conte o número de arestas que saem dele (saindo).",
                                    "Inicialize contadores zero e percorra arestas incrementando o vértice origem.",
                                    "Para cada vértice, liste arestas incidentes de entrada (incoming) e saída (outgoing).",
                                    "Crie listas: para vértice u, incoming: [(v,u)], outgoing: [(u,w)].",
                                    "Compile graus direcionados: (indegree, outdegree) por vértice."
                                  ],
                                  "verification": "Some todos os outdegrees; deve igualar o número total de arestas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Representação do grafo",
                                    "Tabela de graus"
                                  ],
                                  "tips": "Diferencie incidentes por direção; use setas em diagramas para visualizar.",
                                  "learningObjective": "Determinar outdegree e mapear arestas incidentes direcionadas.",
                                  "commonMistakes": [
                                    "Confundir incoming com outgoing",
                                    "Listar arestas sem direção",
                                    "Omitir vértices com grau zero"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Sintetizar Resultados do Grafo",
                                  "subSteps": [
                                    "Compare indegree + outdegree totals com |E|.",
                                    "Identifique vértices com indegree=0 (fontes) e outdegree=0 (sumidouros).",
                                    "Liste completamente: vértices, graus (in,out), arestas incidentes.",
                                    "Teste com um grafo pequeno conhecido para validação cruzada.",
                                    "Documente em formato tabular ou diagrama final."
                                  ],
                                  "verification": "Todos totais de graus batem e listas estão completas sem duplicatas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resultados dos steps anteriores",
                                    "Software de grafos como Gephi"
                                  ],
                                  "tips": "Valide com algoritmo manual simples antes de código; procure simetrias.",
                                  "learningObjective": "Sintetizar e validar identificação de elementos em grafos dirigidos.",
                                  "commonMistakes": [
                                    "Inconsistências nos totais",
                                    "Esquecer validação cruzada",
                                    "Erros de transcrição"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo de dependências de tarefas: T1 -> T2, T1 -> T3, T2 -> T4. Vértices: T1(indegree=0,outdegree=2, outgoing:(T2,T3)), T2(1,1,(T1,T4)), T3(1,0,(T1)), T4(1,0,(T2)).",
                              "finalVerifications": [
                                "Todos vértices listados com graus corretos (in e out).",
                                "Soma de indegrees = soma de outdegrees = |E|.",
                                "Arestas incidentes mapeadas corretamente por direção.",
                                "Vértices isolados identificados (grau 0,0).",
                                "Fontes (indegree=0) e sumidouros (outdegree=0) destacados.",
                                "Representação visual/diagrama sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de indegree/outdegree (100% correto).",
                                "Completude na listagem de arestas incidentes direcionadas.",
                                "Validação matemática (somas iguais).",
                                "Clareza na apresentação tabular ou visual.",
                                "Identificação correta de graus zero.",
                                "Ausência de erros comuns como inversão de direção."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Álgebra Linear (matrizes de adjacência).",
                                "Programação: Implementação em Python (dicts/listas para adjacência, NetworkX).",
                                "Ciência da Computação: Pré-requisito para Ordenação Topológica e Algoritmos em DAGs.",
                                "Engenharia de Software: Modelagem de dependências em builds (Maven/Gradle)."
                              ],
                              "realWorldApplication": "Em gerenciamento de projetos (PERT/CPM para tarefas dependentes), análise de redes sociais (seguidores/seguindo), compiladores (dependências de módulos), e roteamento de pacotes em redes (tráfego direcionado)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.2",
                        "name": "Ciclo Direcionado",
                        "description": "Caminho fechado em um grafo dirigido que inicia e termina no mesmo vértice, seguindo estritamente a direção das arestas, o que impede certas ordenações lineares.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.2.1",
                            "name": "Definir Ciclo Direcionado",
                            "description": "Descrever um ciclo como uma sequência v1 → v2 → ... → vk → v1 onde todos os vi são distintos exceto o primeiro e último, e explicar implicações em algoritmos de ordenação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Grafos Direcionados Básicos",
                                  "subSteps": [
                                    "Revise a definição de grafo direcionado (digrafo): conjunto de vértices V e arcos E orientados de um vértice origem para destino.",
                                    "Aprenda a representar grafos usando listas de adjacência ou matriz de adjacência.",
                                    "Identifique diferenças entre grafos direcionados e não direcionados.",
                                    "Pratique desenhando um grafo direcionado simples com 4 vértices.",
                                    "Explore ferramentas online para visualização de grafos."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um grafo direcionado com pelo menos 3 arcos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta online como Graphviz ou Draw.io"
                                  ],
                                  "tips": "Sempre indique a direção das setas nos arcos para evitar confusões.",
                                  "learningObjective": "Diferenciar grafos direcionados de outros tipos e representá-los adequadamente.",
                                  "commonMistakes": [
                                    "Ignorar a direção dos arcos",
                                    "Confundir vértices com arcos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Conceituar Caminhos em Grafos Direcionados",
                                  "subSteps": [
                                    "Defina um caminho como uma sequência de vértices conectados por arcos na direção correta: v1 → v2 → ... → vk.",
                                    "Classifique caminhos como simples (vértices distintos) ou não simples.",
                                    "Identifique a existência de caminhos em um grafo dado.",
                                    "Pratique encontrando todos os caminhos entre dois vértices específicos.",
                                    "Diferencie caminho de ciclo (ainda não formalizado)."
                                  ],
                                  "verification": "Liste todos os caminhos de um vértice A para C em um grafo exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Grafo exemplo impresso ou digital",
                                    "Planilha para listar caminhos"
                                  ],
                                  "tips": "Siga apenas a direção dos arcos; volte apenas se formar ciclo.",
                                  "learningObjective": "Identificar e listar caminhos válidos em grafos direcionados.",
                                  "commonMistakes": [
                                    "Permitir movimento contra a direção do arco",
                                    "Repetir vértices em caminhos simples"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir Formalmente Ciclo Direcionado",
                                  "subSteps": [
                                    "Estude a definição: ciclo direcionado é um caminho v1 → v2 → ... → vk → v1 onde todos vi são distintos exceto v1 = vk+1.",
                                    "Confirme que k ≥ 2 (pelo menos um loop não trivial).",
                                    "Diferencie ciclo de caminho simples ou laço auto-referencial.",
                                    "Aplique a definição em um grafo exemplo para detectar ciclos.",
                                    "Escreva a definição em suas próprias palavras."
                                  ],
                                  "verification": "Identifique corretamente se um grafo possui ciclo direcionado e liste-o.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Grafo com ciclo exemplo",
                                    "Editor de texto para formalizar definição"
                                  ],
                                  "tips": "Verifique se o caminho retorna ao início sem repetir vértices intermediários.",
                                  "learningObjective": "Formular e aplicar a definição precisa de ciclo direcionado.",
                                  "commonMistakes": [
                                    "Considerar caminhos sem retorno como ciclos",
                                    "Permitir vértices repetidos no meio"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Implicações em Algoritmos de Ordenação",
                                  "subSteps": [
                                    "Explique ordenação topológica: linearização de DAG onde para todo arco u→v, u precede v.",
                                    "Discuta que ciclos impedem ordenação topológica (contradição na precedência).",
                                    "Relacione com detecção de ciclos em algoritmos como Kahn ou DFS.",
                                    "Simule um grafo com ciclo falhando em ordenação topológica.",
                                    "Conclua por que DAGs (sem ciclos) são pré-requisito para topo-sort."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que um ciclo quebra a ordenação topológica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de algoritmo topo-sort",
                                    "Simulador de grafos"
                                  ],
                                  "tips": "Pense em dependências: ciclo significa dependência circular irresolúvel.",
                                  "learningObjective": "Compreender impactos de ciclos em algoritmos de ordenação.",
                                  "commonMistakes": [
                                    "Achar que ciclos permitem múltiplas ordenações",
                                    "Confundir com ordenação por bolha"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo com vértices A, B, C e arcos A→B, B→C, C→A. Isso forma o ciclo A→B→C→A (todos distintos exceto início/fim). Em ordenação topológica, A deve preceder B, B preceder C, C preceder A — impossível devido ao ciclo.",
                              "finalVerifications": [
                                "Defina ciclo direcionado sem erros.",
                                "Detecte ciclo em um grafo dado.",
                                "Explique por que ciclos impedem topo-sort.",
                                "Diferencie DAG de grafo com ciclo.",
                                "Liste implicações práticas de ciclos.",
                                "Desenhe grafo com ciclo corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% dos elementos).",
                                "Correta identificação de ciclos em exemplos.",
                                "Explicação clara de implicações em ordenação.",
                                "Uso correto de terminologia (caminho, ciclo, DAG).",
                                "Exemplos práticos relevantes e sem erros.",
                                "Conexões lógicas entre conceitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria dos Grafos.",
                                "Programação: Implementação de detecção de ciclos em Python/Java.",
                                "Teoria da Computação: Autômatos e linguagens.",
                                "Engenharia de Software: Análise de dependências em projetos."
                              ],
                              "realWorldApplication": "Detecção de dependências circulares em compiladores (ex: makefiles), agendamento de tarefas (ex: cron jobs com loops), análise de redes sociais para comunidades cíclicas, ou prevenção de deadlocks em sistemas operacionais."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.1.2.2",
                            "name": "Detectar Ciclo Simplesmente",
                            "description": "Identificar visualmente ou por inspeção se um grafo dirigido contém ciclos, usando exemplos pequenos e justificando a presença ou ausência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Conceitos Fundamentais de Ciclos em Grafos Dirigidos",
                                  "subSteps": [
                                    "Defina um grafo dirigido (DG) como um conjunto de vértices e arestas direcionadas.",
                                    "Explique um ciclo dirigido: uma sequência de vértices distintos v1 → v2 → ... → vk → v1, onde vk = v1.",
                                    "Diferencie ciclo simples (sem vértices repetidos exceto início/fim) de caminhos acíclicos.",
                                    "Identifique por que ciclos impedem ordenação topológica em DAGs.",
                                    "Desenhe um exemplo mínimo de ciclo com 3 vértices."
                                  ],
                                  "verification": "Escreva e desenhe definições e um exemplo de ciclo em papel, confirmando com um colega ou recurso online.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta online como Graphviz ou Draw.io"
                                  ],
                                  "tips": "Sempre respeite a direção das setas; imagine-as como 'fluxo unidirecional'.",
                                  "learningObjective": "Dominar a definição precisa de ciclo dirigido e sua relevância em DAGs.",
                                  "commonMistakes": [
                                    "Confundir grafos dirigidos com não dirigidos",
                                    "Permitir repetição de vértices no meio do ciclo",
                                    "Ignorar que ciclos precisam fechar de volta ao início"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Técnica de Inspeção Visual para Detecção de Ciclos",
                                  "subSteps": [
                                    "Desenhe o grafo com vértices claros e arestas rotuladas.",
                                    "Para cada vértice inicial, trace todos os caminhos possíveis seguindo as direções.",
                                    "Marque vértices visitados para evitar caminhos infinitos em ciclos.",
                                    "Procure por qualquer caminho que retorne ao vértice inicial sem violar regras de ciclo simples.",
                                    "Registre caminhos que não fecham como evidência de aciclicidade."
                                  ],
                                  "verification": "Aplique a técnica em um grafo de 4 vértices e liste todos os caminhos encontrados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Marcadores coloridos para caminhos",
                                    "Lista de grafos exemplo impressa"
                                  ],
                                  "tips": "Use cores diferentes para cada caminho iniciado de um vértice para visualizar retornos.",
                                  "learningObjective": "Aplicar sistematicamente inspeção manual para rastrear caminhos em grafos pequenos.",
                                  "commonMistakes": [
                                    "Não marcar vértices visitados, levando a loops mentais",
                                    "Parar cedo em caminhos longos",
                                    "Confundir ramificações com ciclos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Praticar Detecção em Grafos Acíclicos (DAGs)",
                                  "subSteps": [
                                    "Selecione 3 grafos conhecidos como DAGs com 3-5 vértices.",
                                    "Inspecione visualmente e liste todos os caminhos possíveis.",
                                    "Confirme ausência de ciclos justificando que nenhum caminho retorna ao início.",
                                    "Tente ordenação topológica manual como verificação cruzada.",
                                    "Documente por que cada grafo é acíclico."
                                  ],
                                  "verification": "Crie uma tabela resumindo caminhos e conclusão 'sem ciclo' para cada grafo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de DAGs impressos ou digitais",
                                    "Planilha para tabela de caminhos"
                                  ],
                                  "tips": "Comece pelos vértices de entrada (sem arestas entrantes) para simplificar rastreamento.",
                                  "learningObjective": "Identificar confiavelmente grafos sem ciclos e justificar aciclicidade.",
                                  "commonMistakes": [
                                    "Falsos positivos de ciclo devido a caminhos paralelos",
                                    "Ignorar grafos com múltiplas saídas",
                                    "Não explorar todos os ramos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Detecção em Grafos Cíclicos e Justificar Resultados",
                                  "subSteps": [
                                    "Selecione 3 grafos com ciclos simples evidentes (3-6 vértices).",
                                    "Use inspeção para localizar e destacar o ciclo exato.",
                                    "Justifique a presença listando a sequência de vértices no ciclo.",
                                    "Remova o ciclo hipoteticamente e confirme que o grafo restante é DAG.",
                                    "Compare com contraexemplos acíclicos semelhantes."
                                  ],
                                  "verification": "Escreva uma justificativa de 2-3 frases por grafo, incluindo a sequência cíclica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de grafos cíclicos",
                                    "Ferramenta de desenho para editar grafos"
                                  ],
                                  "tips": "Procure ciclos curtos primeiro (triângulos), pois são comuns em exemplos pequenos.",
                                  "learningObjective": "Detectar e justificar precisamente ciclos em grafos dirigidos.",
                                  "commonMistakes": [
                                    "Perder ciclos embutidos em subgrafos",
                                    "Justificativas vagas sem sequência explícita",
                                    "Confundir auto-loops com ciclos simples"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com vértices A, B, C: arestas A→B, B→C, C→A. Inspeção: Inicie em A → B → C → A (retorna a A). Ciclo simples detectado: A-B-C-A. Justificativa: Sequência distinta fecha o loop. Sem ciclo: A→B, B→C (caminho linear sem retorno).",
                              "finalVerifications": [
                                "Detectar corretamente ciclos em 10 grafos pequenos (5 com ciclo, 5 sem).",
                                "Fornecer justificativa escrita para cada detecção.",
                                "Realizar ordenação topológica manual em DAGs confirmados.",
                                "Identificar o ciclo mais curto em grafos cíclicos.",
                                "Explicar verbalmente o processo para um par.",
                                "Editar um grafo cíclico para torná-lo acíclico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção (100% em exemplos pequenos).",
                                "Qualidade da justificativa (sequência explícita e lógica clara).",
                                "Eficiência da inspeção (menos de 2 minutos por grafo de 5 vértices).",
                                "Uso correto de marcações visuais em desenhos.",
                                "Capacidade de generalizar para novos grafos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Relações Parciais.",
                                "Programação: Implementação de DFS para detecção de ciclos.",
                                "Lógica e Raciocínio: Dedução em estruturas hierárquicas.",
                                "Engenharia de Software: Análise de dependências em projetos."
                              ],
                              "realWorldApplication": "Detectar dependências circulares em compiladores (ex: módulos que se referenciam mutuamente), agendamento de tarefas em projetos (impede ordenação), análise de redes de precedência em manufatura e detecção de loops em fluxos de trabalho de software."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.1.2.3",
                            "name": "Consequências de Ciclos",
                            "description": "Explicar por que ciclos direcionados invalidam ordenações topológicas, ilustrando com dependências circulares em tarefas ou compilação de software.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Ordenação Topológica e DAGs",
                                  "subSteps": [
                                    "Defina um Grafo Acíclico Direcionado (DAG) como um grafo direcionado sem ciclos.",
                                    "Explique ordenação topológica como uma linearização de vértices onde para toda aresta u→v, u vem antes de v.",
                                    "Discuta pré-requisitos: DAG deve existir para topo sort ser possível.",
                                    "Desenhe um exemplo simples de DAG e sua topo sort.",
                                    "Liste algoritmos comuns: Kahn's ou DFS-based."
                                  ],
                                  "verification": "Crie um diagrama de DAG simples e liste uma ordenação topológica válida.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho de grafos como draw.io",
                                    "Referência: Khan Academy ou CLRS capítulo de grafos"
                                  ],
                                  "tips": "Sempre comece visualizando o grafo para intuitivamente entender a ordem.",
                                  "learningObjective": "Compreender os requisitos de um DAG para ordenação topológica.",
                                  "commonMistakes": [
                                    "Confundir grafos direcionados com não-direcionados",
                                    "Ignorar a direção das arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Definir Ciclos Direcionados",
                                  "subSteps": [
                                    "Defina ciclo direcionado: sequência de vértices v1→v2→...→vn→v1.",
                                    "Diferencie de ciclos não-direcionados.",
                                    "Use DFS para detectar ciclos (back edge para ancestral).",
                                    "Implemente ou simule detecção de ciclo em um grafo pequeno.",
                                    "Pratique com 3 exemplos: um sem ciclo, um com ciclo simples, um complexo."
                                  ],
                                  "verification": "Detecte corretamente se um grafo dado contém um ciclo direcionado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código Python ou pseudocódigo",
                                    "Ferramenta NetworkX para Python"
                                  ],
                                  "tips": "Procure por 'back edges' durante DFS para detecção rápida.",
                                  "learningObjective": "Reconhecer ciclos direcionados em grafos.",
                                  "commonMistakes": [
                                    "Confundir caminhos com ciclos",
                                    "Ignorar auto-loops como ciclos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar Por Que Ciclos Invalidam Ordenação Topológica",
                                  "subSteps": [
                                    "Analise: em um ciclo A→B→C→A, nenhuma ordem linear satisfaz todas as precedências.",
                                    "Prove por contradição: assuma topo sort existe, leva a impossibilidade.",
                                    "Simule algoritmo de Kahn: graus de entrada nunca zeram completamente em ciclo.",
                                    "Compare com DFS: detecção de ciclo falha topo sort.",
                                    "Discuta implicações matemáticas: ordem parcial não linearizável."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que um ciclo específico quebra topo sort.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro branco ou ferramenta de slides",
                                    "Exemplos de grafos impressos"
                                  ],
                                  "tips": "Use a analogia de 'quem faz primeiro?' em dependências circulares.",
                                  "learningObjective": "Entender a invalidação teórica de topo sort por ciclos.",
                                  "commonMistakes": [
                                    "Pensar que ciclos só afetam ordem parcial, não total",
                                    "Confundir com ordenações não-topológicas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ilustrar com Exemplos Práticos de Dependências Circulares",
                                  "subSteps": [
                                    "Exemplo tarefas: Tarefa A requer B, B requer C, C requer A → impasse.",
                                    "Exemplo compilação: Módulo main.c inclui utils.h (de utils.c), utils.c inclui main.h → erro de build.",
                                    "Simule em código: crie grafo com ciclo e rode topo sort (deve falhar).",
                                    "Resolva quebrando ciclo: remover aresta ou reestruturar.",
                                    "Discuta detecção em ferramentas reais como Make ou Maven."
                                  ],
                                  "verification": "Construa um exemplo de grafo com ciclo e demonstre falha na topo sort.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Python com NetworkX e Matplotlib",
                                    "Exemplos de Makefiles ou build scripts"
                                  ],
                                  "tips": "Teste em código real para ver erros de runtime ou build.",
                                  "learningObjective": "Aplicar conceito a cenários reais de dependências.",
                                  "commonMistakes": [
                                    "Não simular o algoritmo até o fim",
                                    "Ignorar ciclos multi-vértices"
                                  ]
                                }
                              ],
                              "practicalExample": "Em compilação de software: Suponha três módulos A, B, C onde A depende de B (A→B), B de C (B→C), C de A (C→A). Qualquer ordem de compilação falhará porque cada um espera o outro estar pronto primeiro, causando loop infinito ou erro de build.",
                              "finalVerifications": [
                                "Explica corretamente por que ciclos invalidam topo sort usando prova por contradição.",
                                "Detecta ciclos em grafos de exemplo com precisão.",
                                "Simula falha de algoritmo Kahn ou DFS em grafo cíclico.",
                                "Identifica dependências circulares em cenários de tarefas ou software.",
                                "Propõe soluções como quebrar o ciclo.",
                                "Distingue DAG de grafo com ciclo."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual: definições corretas de DAG, ciclo e topo sort.",
                                "Profundidade de explicação: inclui prova e simulação algorítmica.",
                                "Clareza na ilustração: exemplos concretos e visuais.",
                                "Capacidade analítica: identifica e resolve ciclos.",
                                "Aplicação prática: relaciona a mundo real sem erros.",
                                "Completude: cobre todas as consequências."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Ordem Parcial e Grafos.",
                                "Gerenciamento de Projetos: Scheduling de tarefas com dependências (PERT/CPM).",
                                "Engenharia de Software: Gerenciamento de build systems e dependências de pacotes.",
                                "Sistemas Operacionais: Deadlocks em alocação de recursos."
                              ],
                              "realWorldApplication": "Em sistemas de build como Maven ou Cargo, detecção de ciclos previne builds infinitos; em pipelines CI/CD, garante ordem de execução; em planejamento de projetos, evita atrasos por dependências circulares."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.1.3",
                        "name": "Grafo Acíclico Direcionado (DAG)",
                        "description": "Grafo dirigido sem ciclos direcionados, permitindo uma ordenação topológica única ou múltipla das suas atividades ou vértices, fundamental para programação dinâmica e agendamento.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.1.3.1",
                            "name": "Definir DAG",
                            "description": "Definir formalmente um DAG como um grafo dirigido G = (V, E) onde não existe caminho direcionado de qualquer vértice para si mesmo, verificando propriedade acíclica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Grafos Dirigidos",
                                  "subSteps": [
                                    "Identifique os componentes fundamentais de um grafo: vértices (V) e arestas (E).",
                                    "Diferencie grafos não dirigidos de grafos dirigidos, focando na direção das arestas.",
                                    "Represente um grafo dirigido simples usando notação G = (V, E).",
                                    "Desenhe um exemplo básico de grafo dirigido com 3-4 vértices e arestas direcionadas.",
                                    "Explique o que significa um caminho direcionado em um grafo."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um grafo dirigido simples, identificando V e E.",
                                  "estimatedTime": "15-20 minutes",
                                  "materials": [
                                    "Papel e caneta ou software de desenho de grafos como Draw.io",
                                    "Referência: Livro de Teoria dos Grafos (capítulo inicial)"
                                  ],
                                  "tips": [
                                    "Comece com grafos pequenos para visualizar direções.",
                                    "Use setas claras para indicar direção das arestas.",
                                    "Pratique representando grafos de relações cotidianas, como 'depende de'."
                                  ],
                                  "learningObjective": "Compreender os elementos fundamentais de um grafo dirigido como base para DAG.",
                                  "commonMistakes": [
                                    "Confundir direção das arestas com não dirigidas.",
                                    "Esquecer de listar V e E explicitamente.",
                                    "Ignorar a ordem das arestas em E (ordenadas para direção)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Formalizar a Definição de um Grafo Dirigido",
                                  "subSteps": [
                                    "Escreva a notação formal G = (V, E), onde V é o conjunto de vértices finitos e E ⊆ V × V.",
                                    "Defina que cada aresta e ∈ E é uma tupla ordenada (u, v), indicando direção de u para v.",
                                    "Especifique que V e E são conjuntos finitos e não vazios (para fins educacionais).",
                                    "Crie uma representação matricial ou de lista de adjacência para um grafo dirigido exemplo.",
                                    "Valide a definição com um exemplo numérico: V = {1,2,3}, E = {(1,2),(2,3)}."
                                  ],
                                  "verification": "Escreva a definição formal correta e aplique-a a um exemplo dado.",
                                  "estimatedTime": "20-25 minutes",
                                  "materials": [
                                    "Editor de texto ou Jupyter Notebook",
                                    "Exemplos de grafos dirigidos impressos"
                                  ],
                                  "tips": [
                                    "Use parênteses para tuplas em E para clareza.",
                                    "Verifique se não há arestas duplicadas ou loops iniciais.",
                                    "Compare com pseudocódigo para implementação futura."
                                  ],
                                  "learningObjective": "Dominar a notação matemática precisa para grafos dirigidos.",
                                  "commonMistakes": [
                                    "Usar chaves {} para E em vez de pares ordenados.",
                                    "Permitir loops (v,v) nesta etapa.",
                                    "Confundir V finito com infinito."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a Propriedade Acíclica em DAGs",
                                  "subSteps": [
                                    "Defina aciclicidade: Não existe caminho direcionado de qualquer vértice u para si mesmo (u →* u).",
                                    "Explique o conceito de ciclo: sequência fechada de arestas u1 → u2 → ... → un → u1.",
                                    "Diferencie DAG de grafo dirigido com ciclo (DAGC).",
                                    "Identifique verbalmente por que ciclos violam ordenações lineares.",
                                    "Reescreva a definição completa de DAG: G = (V, E) dirigido sem ciclos direcionados."
                                  ],
                                  "verification": "Explique em palavras próprias a propriedade acíclica e dê um contraexemplo com ciclo.",
                                  "estimatedTime": "15-20 minutes",
                                  "materials": [
                                    "Quadro branco ou ferramenta digital para diagramas",
                                    "Vídeo curto sobre ciclos em grafos (YouTube: 'Graph Cycles')"
                                  ],
                                  "tips": [
                                    "Pense em 'caminho para si mesmo' como loop fechado.",
                                    "Use cores para destacar caminhos potenciais de ciclo.",
                                    "Relacione com intuição: tarefas que dependem de si mesmas são impossíveis."
                                  ],
                                  "learningObjective": "Entender conceitualmente o que torna um grafo um DAG pela ausência de ciclos.",
                                  "commonMistakes": [
                                    "Confundir ciclo com laço simples (loop).",
                                    "Achar que múltiplas arestas entre mesmos vértices criam ciclo.",
                                    "Ignorar caminhos longos (não só adjacentes)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar a Propriedade Acíclica em um Grafo",
                                  "subSteps": [
                                    "Aplique DFS (busca em profundidade) recursiva para detectar ciclos: marque visitando e visited.",
                                    "Implemente ou simule algoritmo de detecção de ciclo em pseudocódigo.",
                                    "Teste em grafos exemplo: um DAG válido e um com ciclo.",
                                    "Confirme que se não há back-edge para ancestral, é acíclico.",
                                    "Documente o resultado: 'G é DAG pois não detectado ciclo'."
                                  ],
                                  "verification": "Detecte corretamente ciclos em 2 grafos fornecidos (um DAG, um não).",
                                  "estimatedTime": "25-30 minutes",
                                  "materials": [
                                    "Python com NetworkX ou código manual",
                                    "Grafos de teste impressos"
                                  ],
                                  "tips": [
                                    "Use pilha de recursão para rastrear caminho atual.",
                                    "Comece por nós com indegree 0.",
                                    "Automatize com código simples para validação rápida."
                                  ],
                                  "learningObjective": "Saber verificar praticamente se um grafo é um DAG.",
                                  "commonMistakes": [
                                    "Parar em laços simples sem checar caminhos completos.",
                                    "Confundir visited global com caminho atual.",
                                    "Aplicar algoritmo errado (ex: BFS puro)."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de software, tarefas T1 (codificar), T2 (testar), T3 (deploy) formam G = ({T1,T2,T3}, {(T1,T2),(T2,T3)}). Não há caminho T1 →* T1, logo é DAG, permitindo ordenação topológica T1, T2, T3.",
                              "finalVerifications": [
                                "Define corretamente G = (V, E) com pares ordenados.",
                                "Explica aciclicidade sem ciclos direcionados.",
                                "Identifica ciclo em grafo exemplo com loop fechado.",
                                "Verifica aciclicidade usando método manual ou algoritmo simples.",
                                "Distingue DAG de grafo dirigido cíclico.",
                                "Aplica definição a exemplo prático sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação formal (100% correta).",
                                "Completude na explicação de aciclicidade (cobre caminhos e ciclos).",
                                "Capacidade de verificação prática (detecta ciclos corretamente em 90% dos casos).",
                                "Clareza na representação visual de grafos.",
                                "Integração de conceitos básicos com propriedade DAG.",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Relações Parciais.",
                                "Programação: Implementação de grafos em Python (NetworkX, adjacência).",
                                "Engenharia de Software: Gerenciamento de dependências em Makefiles ou CI/CD.",
                                "Inteligência Artificial: Redes Bayesianas e modelos causais acíclicos.",
                                "Economia: Modelos de precedência em cadeias de produção."
                              ],
                              "realWorldApplication": "DAGs são fundamentais em compiladores (dependências de módulos), agendamento de tarefas (projetos com precedências), blockchain (ordem de blocos sem ciclos) e machine learning (computational graphs em TensorFlow para evitar loops infinitos)."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1",
                              "10.1.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.2",
                            "name": "Propriedades de DAGs",
                            "description": "Listar propriedades como existência de pelo menos um vértice com indegree zero, ordenação topológica possível e aplicações em caminhos mais longos ou programação dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Definição e Características Básicas de um DAG",
                                  "subSteps": [
                                    "Revise a definição de grafo direcionado: vértices conectados por arcos com direção.",
                                    "Identifique a condição de aciclicidade: ausência de ciclos fechados em qualquer caminho.",
                                    "Calcule o indegree de cada vértice em um grafo exemplo.",
                                    "Desenhe um grafo simples direcionado e verifique se é acíclico.",
                                    "Compare com um grafo que possui ciclo para destacar diferenças."
                                  ],
                                  "verification": "Desenhe um DAG com 5 vértices e confirme que não há ciclos listando todos os caminhos possíveis.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis ou software de grafos como Graphviz",
                                    "Exemplos de grafos online"
                                  ],
                                  "tips": "Sempre comece calculando indegrees para identificar fontes potenciais.",
                                  "learningObjective": "Definir DAG e identificar suas características básicas.",
                                  "commonMistakes": [
                                    "Confundir direção dos arcos",
                                    "Ignorar caminhos indiretos que formam ciclos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Propriedades Fundamentais como Vértice com Indegree Zero",
                                  "subSteps": [
                                    "Prove que todo DAG possui pelo menos um vértice com indegree zero (fonte).",
                                    "Demonstre removendo fontes iterativamente até esvaziar o grafo.",
                                    "Calcule indegrees em múltiplos exemplos de DAGs variados.",
                                    "Explique por que grafos com ciclos não têm essa propriedade.",
                                    "Crie um contraexemplo inválido e corrija-o."
                                  ],
                                  "verification": "Em um DAG dado, liste todos os vértices com indegree zero e prove sua existência.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramenta de desenho de grafos",
                                    "Lista de exercícios de grafos"
                                  ],
                                  "tips": "Use indução para provar: assuma para n-1 vértices e estenda.",
                                  "learningObjective": "Listar e provar propriedades como existência de fontes.",
                                  "commonMistakes": [
                                    "Assumir múltiplas fontes sem verificar",
                                    "Confundir indegree com outdegree"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar a Possibilidade de Ordenação Topológica",
                                  "subSteps": [
                                    "Defina ordenação topológica: linearização respeitando direções de arcos.",
                                    "Implemente um algoritmo simples (ex: Kahn's) em pseudocódigo.",
                                    "Aplique em um DAG exemplo para gerar a ordenação.",
                                    "Verifique que toda ordenação topológica preserva precedências.",
                                    "Discuta unicidade: quando há múltiplas ordenações possíveis."
                                  ],
                                  "verification": "Gere pelo menos duas ordenações topológicas diferentes para um DAG com >3 vértices.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Pseudocódigo editor",
                                    "Vídeos tutoriais sobre Kahn's algorithm"
                                  ],
                                  "tips": "Comece com fila de fontes para eficiência.",
                                  "learningObjective": "Entender e demonstrar ordenação topológica em DAGs.",
                                  "commonMistakes": [
                                    "Produzir ordenação que viola precedências",
                                    "Aplicar em grafos cíclicos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Aplicações como Caminhos Mais Longos e Programação Dinâmica",
                                  "subSteps": [
                                    "Explique como DAGs permitem DP para caminhos mais longos sem ciclos.",
                                    "Implemente DP para longest path em pseudocódigo.",
                                    "Aplique em exemplo: grafo de tarefas com dependências.",
                                    "Compare com grafos gerais onde longest path é NP-hard.",
                                    "Discuta outras apps: scheduling, compiladores."
                                  ],
                                  "verification": "Resolva um problema de longest path em DAG usando DP e justifique.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Exercícios de DP em grafos",
                                    "Python ou pseudocódigo para simulação"
                                  ],
                                  "tips": "Memoize resultados por vértice para evitar recomputação.",
                                  "learningObjective": "Conectar propriedades de DAGs a aplicações práticas.",
                                  "commonMistakes": [
                                    "Ignorar ordem topológica em DP",
                                    "Confundir com shortest path"
                                  ]
                                }
                              ],
                              "practicalExample": "Construa um DAG representando dependências de tarefas de um projeto de software: Tarefa A -> B, A -> C, B -> D, C -> D. Liste propriedades: fontes (A), ordenação topológica possível (A,B,C,D ou A,C,B,D), compute longest path (A-B-D, comprimento 2).",
                              "finalVerifications": [
                                "Liste 5 propriedades principais de DAGs com justificativa.",
                                "Identifique fontes em 3 DAGs diferentes.",
                                "Gere ordenação topológica para um DAG com 6 vértices.",
                                "Prove ausência de ciclos em um grafo dado.",
                                "Aplique DP para longest path em exemplo prático.",
                                "Explique por que ordenação topológica falha em grafos cíclicos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de propriedades fundamentais (ex: fontes, aciclicidade).",
                                "Capacidade de provar propriedades usando indução ou remoção iterativa.",
                                "Correta geração de ordenações topológicas múltiplas.",
                                "Implementação correta de algoritmos relacionados (Kahn's, DP).",
                                "Conexão clara com aplicações reais sem erros conceituais.",
                                "Profundidade nos substeps com exemplos originais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e indução matemática.",
                                "Ciência da Computação: Algoritmos e Programação Dinâmica.",
                                "Engenharia de Software: Modelagem de dependências em builds.",
                                "Operações Research: Scheduling e otimização de projetos."
                              ],
                              "realWorldApplication": "Em compiladores, DAGs modelam dependências de módulos para ordenação topológica na geração de código; em gerenciamento de projetos (CPM/PERT), calculam caminhos críticos (longest paths) para estimar durações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.3",
                            "name": "Verificar se é DAG",
                            "description": "Dado um grafo dirigido pequeno, confirmar se é DAG contando indegrees, removendo fontes iterativamente ou simulando detecção de ciclo básica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de DAG e representar o grafo",
                                  "subSteps": [
                                    "Defina DAG como um grafo dirigido sem ciclos.",
                                    "Escolha uma representação: lista de adjacência ou matriz de adjacência.",
                                    "Desenhe ou codifique um grafo pequeno de exemplo com 4-6 nós.",
                                    "Identifique arestas direcionadas manualmente.",
                                    "Verifique visualmente se há ciclos óbvios."
                                  ],
                                  "verification": "Confirme que o grafo está corretamente representado comparando com a descrição original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para desenho manual",
                                    "Editor de código (Python ou pseudocódigo)"
                                  ],
                                  "tips": "Comece com grafos pequenos para evitar confusão; use dicionários em Python para listas de adjacência.",
                                  "learningObjective": "Entender a estrutura de um grafo dirigido e suas representações.",
                                  "commonMistakes": [
                                    "Confundir direção das arestas",
                                    "Ignorar nós isolados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os graus de entrada (indegrees) de todos os nós",
                                  "subSteps": [
                                    "Inicialize um array ou dicionário com indegree zero para cada nó.",
                                    "Para cada aresta u -> v, incremente indegree[v].",
                                    "Liste todos os nós com indegree zero (fontes).",
                                    "Valide o cálculo com contagem manual.",
                                    "Registre os valores em uma tabela."
                                  ],
                                  "verification": "Some todos os indegrees e compare com o número total de arestas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de adjacência do grafo",
                                    "Planilha ou código para contagem"
                                  ],
                                  "tips": "Use um loop duplo em código: para cada nó u, para cada vizinho v de u, indegree[v] += 1.",
                                  "learningObjective": "Dominar o cálculo de indegrees como base para detecção de ciclos.",
                                  "commonMistakes": [
                                    "Incrementar indegree do nó origem em vez do destino",
                                    "Esquecer nós sem arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar o algoritmo de Kahn para remoção iterativa de fontes",
                                  "subSteps": [
                                    "Use uma fila para enfileirar todos os nós com indegree zero.",
                                    "Enquanto a fila não estiver vazia: desinfileire u, reduza indegree de vizinhos; se indegree virar zero, enfileire.",
                                    "Conte o número de nós processados.",
                                    "Repita até esvaziar a fila ou detectar parada.",
                                    "Implemente em pseudocódigo ou código real."
                                  ],
                                  "verification": "Se o número de nós processados igualar o total de nós, é DAG.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código Python com collections.deque para fila",
                                    "Grafo de teste"
                                  ],
                                  "tips": "Simule manualmente no papel antes de codificar para entender o fluxo.",
                                  "learningObjective": "Implementar topological sort via Kahn's algorithm para detecção de DAG.",
                                  "commonMistakes": [
                                    "Não atualizar indegrees corretamente",
                                    "Processar nós com ciclo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar resultado e testar com casos de ciclo",
                                  "subSteps": [
                                    "Compare nós processados com total; se menor, há ciclo.",
                                    "Teste um grafo com ciclo conhecido (ex: A->B->C->A).",
                                    "Teste um DAG válido (ex: A->B, A->C, B->D).",
                                    "Analise o grafo restante para identificar ciclo.",
                                    "Documente os resultados."
                                  ],
                                  "verification": "Execute em pelo menos 3 grafos diferentes e confirme detecções.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Múltiplos grafos de teste",
                                    "Código do algoritmo"
                                  ],
                                  "tips": "Adicione prints no código para rastrear nós processados e fila.",
                                  "learningObjective": "Validar o algoritmo e interpretar resultados para confirmação de DAG.",
                                  "commonMistakes": [
                                    "Declarar DAG erroneamente em grafos com ciclo",
                                    "Ignorar grafos desconexos"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo: Nós A,B,C; Arestas A->B, B->C, C->A. Indegrees: A:1, B:1, C:1. Nenhuma fonte inicial, fila vazia imediatamente -> Não é DAG. Outro: A->B, B->C. Indegrees: A:0, B:1, C:1. Processa A (fila: A), reduz B para 0 (fila: B), reduz C para 0 (fila: C) -> 3 nós processados, é DAG.",
                              "finalVerifications": [
                                "Implemente o algoritmo em código e teste com 5 grafos variados.",
                                "Identifique corretamente ciclos em 100% dos casos com ciclo.",
                                "Confirme topological order em DAGs válidos.",
                                "Explique o papel dos indegrees na detecção.",
                                "Simule manualmente um grafo de 6 nós.",
                                "Compare com detecção de ciclo via DFS básica."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção: 100% correto em testes.",
                                "Eficiência: Tempo O(V+E) demonstrado.",
                                "Clareza no código: Bem comentado e legível.",
                                "Cobertura de casos: Inclui ciclos, DAGs, desconexos.",
                                "Explicação: Capacidade de justificar resultados.",
                                "Tempo de execução: Conclusão dentro do estimado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos grafos e relações parciais.",
                                "Programação: Estruturas de dados (filas, dicionários).",
                                "Engenharia de Software: Gerenciamento de dependências em builds.",
                                "Inteligência Artificial: Grafos em redes bayesianas.",
                                "Projetos: Agendamento em sistemas operacionais."
                              ],
                              "realWorldApplication": "Em compiladores para verificar dependências de módulos sem ciclos circulares; agendamento de tarefas em pipelines CI/CD; planejamento de projetos com precedências (ex: construção onde etapas dependem de anteriores); ML para computação em grafos acíclicos em redes neurais recorrentes sem loops infinitos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.1.2",
                              "10.1.4.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.1.3.4",
                            "name": "Aplicações Iniciais de DAGs",
                            "description": "Relacionar DAGs com problemas reais como agendamento de tarefas com precedências, representação de expressões matemáticas ou dependências em compiladores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Problemas Reais Modeláveis por DAGs",
                                  "subSteps": [
                                    "Pesquise exemplos clássicos de problemas com precedências, como agendamento de tarefas em projetos.",
                                    "Analise representação de expressões matemáticas, como (a + b) * c.",
                                    "Estude dependências em compiladores, como ordem de execução de módulos.",
                                    "Liste 3-5 problemas do dia a dia que envolvam ordem sem ciclos (ex: receitas de cozinha).",
                                    "Discuta por que ciclos invalidariam o modelo DAG."
                                  ],
                                  "verification": "Crie uma lista anotada de pelo menos 4 problemas reais e justifique por que são DAGs.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Acesso à internet para pesquisa",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Comece com exemplos simples para construir intuição antes de complexos.",
                                  "learningObjective": "Reconhecer padrões de precedência linear em problemas reais como passíveis de modelagem por DAGs.",
                                  "commonMistakes": [
                                    "Confundir com grafos cíclicos",
                                    "Ignorar a direção das arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar Agendamento de Tarefas com Precedências como DAG",
                                  "subSteps": [
                                    "Defina tarefas como nós (ex: T1: Fundação, T2: Paredes, T3: Telhado).",
                                    "Desenhe arestas direcionadas para precedências (T1 -> T2 -> T3).",
                                    "Valide aciclicidade removendo possíveis ciclos.",
                                    "Calcule ordenação topológica manualmente para ordem de execução.",
                                    "Simule atraso em uma tarefa e observe impacto downstream."
                                  ],
                                  "verification": "Desenhe o grafo e liste uma ordenação topológica válida.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Software de grafos como Graphviz ou Draw.io",
                                    "Exemplo de projeto real (ex: cronograma de construção)"
                                  ],
                                  "tips": "Use cores para diferenciar tarefas críticas de não críticas.",
                                  "learningObjective": "Construir e validar um DAG para otimizar agendamento com dependências.",
                                  "commonMistakes": [
                                    "Adicionar arestas bidirecionais acidentalmente",
                                    "Esquecer verificação de ciclos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Representar Expressões Matemáticas como DAGs",
                                  "subSteps": [
                                    "Converta uma expressão como (a + b) * (c - d) em nós para operandos e operadores.",
                                    "Crie arestas dos operandos para o operador pai (ex: a -> +, b -> +).",
                                    "Compartilhe sub-expressões comuns para otimizar (ex: DAG vs árvore).",
                                    "Avalie a expressão seguindo ordenação topológica.",
                                    "Compare eficiência de DAG versus árvore binária de expressão."
                                  ],
                                  "verification": "Construa o DAG para uma expressão dada e compute o resultado.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Calculadora ou Python para avaliação",
                                    "Papel para esboços"
                                  ],
                                  "tips": "Reutilize nós para sub-expressões idênticas para demonstrar economia.",
                                  "learningObjective": "Modelar estruturas hierárquicas matemáticas em DAGs para avaliação eficiente.",
                                  "commonMistakes": [
                                    "Criar árvores em vez de DAGs compartilhados",
                                    "Ignorar associatividade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Dependências em Compiladores com DAGs",
                                  "subSteps": [
                                    "Identifique módulos de código como nós (ex: parser -> optimizer -> codegen).",
                                    "Modele dependências de bibliotecas e headers como arestas.",
                                    "Aplique ordenação topológica para ordem de compilação.",
                                    "Simule build incremental detectando mudanças em nós upstream.",
                                    "Discuta paralelização de tarefas independentes."
                                  ],
                                  "verification": "Crie um DAG para um mini-projeto de compilador e liste ordem de build.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Exemplo de Makefile ou build script",
                                    "Ferramenta como Gephi para visualização"
                                  ],
                                  "tips": "Pense em ferramentas reais como Make ou Gradle que usam DAGs internamente.",
                                  "learningObjective": "Aplicar DAGs para gerenciar dependências em fluxos de compilação de software.",
                                  "commonMistakes": [
                                    "Assumir independência total entre módulos",
                                    "Não considerar dependências transitivas"
                                  ]
                                }
                              ],
                              "practicalExample": "Modelar o agendamento de construção de uma casa: Nós incluem 'Fundação' (T1), 'Paredes' (T2), 'Telhado' (T3), 'Elétrica' (T4). Arestas: T1 -> T2, T1 -> T4, T2 -> T3. Ordenação topológica: T1, T4/T2, T3 permite execução paralela de elétrica e paredes após fundação.",
                              "finalVerifications": [
                                "Explicar verbalmente como um DAG modela precedências sem ciclos.",
                                "Construir DAG para um novo problema real fornecido.",
                                "Listar ordenação topológica correta para exemplos dados.",
                                "Identificar e corrigir um grafo com ciclo proposto.",
                                "Comparar DAGs em agendamento vs expressões vs compiladores."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de nós e arestas (sem ciclos).",
                                "Correção da ordenação topológica gerada.",
                                "Profundidade na justificativa de modelagem real.",
                                "Criatividade em exemplos personalizados.",
                                "Clareza na visualização e explicação.",
                                "Integração de múltiplas aplicações em síntese."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Árvores de expressão e avaliação pós-ordem.",
                                "Gerenciamento de Projetos: Diagramas PERT/CPM para planejamento.",
                                "Engenharia de Software: Pipelines CI/CD e gerenciadores de dependências como npm/yarn.",
                                "Operações: Otimização de fluxos de produção em fábricas."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, DAGs gerenciam dependências de build em ferramentas como Bazel ou Buck, garantindo compilação eficiente e incremental; em gerenciamento de projetos, modelam tarefas em Microsoft Project ou Jira para evitar gargalos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.2",
                    "name": "Definição de Ordenação Topológica",
                    "description": "Ordenação linear dos vértices de um DAG onde, para toda aresta u→v, u aparece antes de v.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.2.1",
                        "name": "Grafo Acíclico Direcionado (DAG)",
                        "description": "Grafo direcionado que não contém ciclos direcionados, pré-requisito fundamental para a existência de ordenação topológica.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.1.1",
                            "name": "Definir um DAG",
                            "description": "Explicar formalmente que um DAG é um grafo G = (V, E) direcionado onde não existe um caminho direcionado que forme um ciclo, ou seja, nenhum vértice é alcançável a partir de si mesmo via arestas direcionadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de grafos",
                                  "subSteps": [
                                    "Defina um grafo como G = (V, E), onde V é o conjunto de vértices e E o conjunto de arestas.",
                                    "Explique que vértices representam entidades e arestas representam relações.",
                                    "Desenhe um grafo simples não direcionado com 4 vértices e 3 arestas para praticar.",
                                    "Liste exemplos reais de grafos, como redes sociais ou mapas de cidades.",
                                    "Anote a importância da representação formal em algoritmos."
                                  ],
                                  "verification": "Desenhe e rotule corretamente um grafo G = (V, E) com pelo menos 3 vértices.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta de desenho online como draw.io"
                                  ],
                                  "tips": [
                                    "Sempre use notação matemática precisa.",
                                    "Visualize grafos para melhor compreensão."
                                  ],
                                  "learningObjective": "Compreender a notação padrão G = (V, E) e seus componentes.",
                                  "commonMistakes": [
                                    "Confundir vértices com arestas.",
                                    "Omitir parênteses na notação formal."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender grafos direcionados",
                                  "subSteps": [
                                    "Explique que em grafos direcionados, arestas têm direção (setas).",
                                    "Compare com grafos não direcionados: aresta (u,v) ≠ (v,u).",
                                    "Desenhe um grafo direcionado simples com ciclo e sem ciclo.",
                                    "Defina caminho direcionado como sequência de arestas seguindo direções.",
                                    "Pratique representando um grafo direcionado em lista de adjacência."
                                  ],
                                  "verification": "Construa um grafo direcionado e identifique direções corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Python ou pseudocódigo para listas de adjacência"
                                  ],
                                  "tips": [
                                    "Use setas claras nos desenhos.",
                                    "Teste caminhos em ambas direções."
                                  ],
                                  "learningObjective": "Diferenciar grafos direcionados e compreender caminhos direcionados.",
                                  "commonMistakes": [
                                    "Ignorar a direção das arestas.",
                                    "Assumir simetria como em grafos não direcionados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar ciclos em grafos direcionados",
                                  "subSteps": [
                                    "Defina ciclo como caminho direcionado onde o vértice inicial é alcançável do final.",
                                    "Explique que um ciclo ocorre se um vértice é alcançável de si mesmo.",
                                    "Analise um grafo exemplo: trace caminhos e detecte ciclos.",
                                    "Diferencie ciclo de caminho simples (sem repetições).",
                                    "Pratique em 2 grafos: um com ciclo e um sem."
                                  ],
                                  "verification": "Detecte corretamente ciclos em dois grafos fornecidos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos de grafos impressos",
                                    "Ferramenta Graphviz ou draw.io"
                                  ],
                                  "tips": [
                                    "Siga todos os caminhos possíveis sistematicamente.",
                                    "Use DFS mental para rastrear."
                                  ],
                                  "learningObjective": "Reconhecer e definir ciclos em grafos direcionados.",
                                  "commonMistakes": [
                                    "Confundir ciclo com caminho de ida e volta.",
                                    "Parar rastreamento prematuramente."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a definição de DAG",
                                  "subSteps": [
                                    "Enuncie: DAG é grafo direcionado G = (V, E) sem ciclos direcionados.",
                                    "Reafirme: Nenhum vértice é alcançável de si mesmo via caminhos direcionados.",
                                    "Escreva a definição matemática completa.",
                                    "Valide com exemplos: grafo com ciclo (não DAG) vs. sem ciclo (DAG).",
                                    "Explique implicações para ordenação topológica."
                                  ],
                                  "verification": "Escreva a definição formal e classifique 3 grafos como DAG ou não.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de exercícios com grafos",
                                    "Notebook para anotações"
                                  ],
                                  "tips": [
                                    "Memorize a frase chave: 'sem caminho direcionado que forme ciclo'.",
                                    "Sempre teste com contraexemplos."
                                  ],
                                  "learningObjective": "Articular a definição precisa de um Grafo Acíclico Direcionado (DAG).",
                                  "commonMistakes": [
                                    "Omitir 'direcionado' na definição.",
                                    "Confundir com grafos acíclicos não direcionados."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de software, módulos A → B → C formam um DAG (sem ciclos), permitindo compilação em ordem topológica. Se adicionar C → A, cria ciclo e impede ordenação.",
                              "finalVerifications": [
                                "Explicar verbalmente a definição formal de DAG.",
                                "Identificar corretamente se um grafo dado é DAG.",
                                "Desenhar um DAG simples com 5 vértices.",
                                "Explicar por que ciclos invalidam um DAG.",
                                "Relacionar DAG com ordenação topológica.",
                                "Detectar ciclo em grafo complexo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na notação G = (V, E) e menção a 'direcionado acíclico'.",
                                "Capacidade de detectar ciclos em grafos variados.",
                                "Uso correto de terminologia (caminho, ciclo, alcançável).",
                                "Exemplos práticos relevantes e corretos.",
                                "Explicação clara sem ambiguidades.",
                                "Conexão com conceitos maiores como topológica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Relações Parciais.",
                                "Gerenciamento de Projetos: Modelagem de Dependências de Tarefas.",
                                "Engenharia de Software: Sistemas de Build e Pipelines CI/CD.",
                                "Inteligência Artificial: Grafos de Dependência em Redes Neurais."
                              ],
                              "realWorldApplication": "DAGs são essenciais em ferramentas como Git (histórico de commits), Make (dependências de build) e Kubernetes (orquestração de containers), garantindo execução sem deadlocks por ciclos de dependência."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.2",
                            "name": "Identificar um DAG em exemplos",
                            "description": "Analisar grafos direcionados fornecidos e determinar se são DAGs, justificando a presença ou ausência de ciclos através de caminhos direcionados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de grafos direcionados e DAGs",
                                  "subSteps": [
                                    "Defina um grafo direcionado (DG): vértices conectados por arcos com direção.",
                                    "Explique o que é um ciclo em um DG: caminho que retorna ao vértice inicial.",
                                    "Descreva um DAG: DG sem ciclos.",
                                    "Liste propriedades de DAGs: admite ordenação topológica.",
                                    "Diferencie DG com ciclo de DAG com exemplos simples."
                                  ],
                                  "verification": "Escreva definições em suas próprias palavras e compare com fontes confiáveis.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notas de aula, diagrama de grafo básico, lápis e papel.",
                                  "tips": "Use diagramas visuais para fixar conceitos; desenhe setas para direções.",
                                  "learningObjective": "Compreender precisamente os termos para análise posterior.",
                                  "commonMistakes": "Confundir direção das arestas ou ignorar auto-loops como ciclos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar o grafo fornecido de forma clara",
                                  "subSteps": [
                                    "Liste todos os vértices e arestas do grafo exemplo.",
                                    "Desenhe o grafo visualmente com setas indicando direções.",
                                    "Crie uma lista de adjacência ou matriz de adjacência.",
                                    "Identifique graus de entrada e saída de cada vértice.",
                                    "Marque vértices iniciais (sem entrada) e terminais (sem saída)."
                                  ],
                                  "verification": "Verifique se a representação corresponde exatamente ao grafo dado, sem arestas omitidas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, software como Draw.io ou Graphviz, calculadora.",
                                  "tips": "Use cores diferentes para vértices e arestas para melhor visualização.",
                                  "learningObjective": "Padronizar a representação para facilitar detecção de ciclos.",
                                  "commonMistakes": "Invertar direções das arestas ou duplicar vértices."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar ciclos traçando caminhos direcionados",
                                  "subSteps": [
                                    "Comece de cada vértice e trace todos os caminhos possíveis seguindo direções.",
                                    "Registre caminhos longos que se aproximem de loops.",
                                    "Procure por retornos a vértices visitados no mesmo caminho.",
                                    "Use marcação temporária (visitando, visitado) para simular DFS manual.",
                                    "Documente caminhos que formam ciclos ou provam aciclicidade."
                                  ],
                                  "verification": "Liste todos os caminhos encontrados; confirme se algum ciclo foi detectado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Folha de rastreamento de caminhos, timer para simular execução.",
                                  "tips": "Limite caminhos a comprimento máximo igual ao número de vértices para eficiência.",
                                  "learningObjective": "Desenvolver habilidade em inspeção manual de ciclos.",
                                  "commonMistakes": "Parar rastreamento prematuramente ou confundir caminhos bidirecionais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar conclusão e verificar com método alternativo",
                                  "subSteps": [
                                    "Declare se é DAG ou não, citando ciclos encontrados ou ausência.",
                                    "Justifique com caminhos específicos (ex: A->B->C->A é ciclo).",
                                    "Tente ordenação topológica manual: priorize vértices sem entrada.",
                                    "Se falhar na ordenação, confirme ciclo; senão, é DAG.",
                                    "Compare resultados com ferramenta online de detecção de ciclos."
                                  ],
                                  "verification": "Produza relatório escrito com justificativa e ordenação tentativa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Ferramenta online como NetworkX ou GeeksforGeeks cycle detector.",
                                  "tips": "Sempre justifique ausência de ciclos provando que todos caminhos terminam.",
                                  "learningObjective": "Consolidar análise com múltiplas validações.",
                                  "commonMistakes": "Assumir aciclicidade sem esgotar todos caminhos iniciais."
                                }
                              ],
                              "practicalExample": "Grafo 1 (com ciclo): Vértices A, B, C; Arestas A→B, B→C, C→A. Ciclo: A→B→C→A. Grafo 2 (DAG): Vértices X, Y, Z; Arestas X→Y, X→Z, Y→Z. Sem ciclos, ordenação possível: X, Y, Z.",
                              "finalVerifications": [
                                "Pode listar todos os caminhos no grafo sem omitir nenhum?",
                                "Identifica corretamente ciclos em grafos com 3-5 vértices?",
                                "Justifica ausência de ciclos com argumento de terminação de caminhos?",
                                "Realiza ordenação topológica manual em DAGs simples?",
                                "Detecta auto-loops e múltiplas arestas como ciclos?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de ciclos (100% correto em 3 exemplos).",
                                "Qualidade da justificativa: cita caminhos exatos.",
                                "Completude da representação gráfica/lista de adjacência.",
                                "Uso correto de métodos alternativos para verificação.",
                                "Clareza na documentação de passos e conclusões."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos grafos e relações parciais.",
                                "Programação: Implementação de DFS para detecção de ciclos.",
                                "Gestão de Projetos: Modelagem de dependências em tarefas.",
                                "Lógica: Raciocínio dedutivo em provas de ausência."
                              ],
                              "realWorldApplication": "Em gerenciamento de projetos (ex: tarefas com dependências sem loops para scheduling), compiladores (dependências de módulos), análise de dados (fluxos acíclicos em pipelines ETL)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.1.3",
                            "name": "Diferenciar DAG de grafos com ciclos",
                            "description": "Comparar DAGs com grafos direcionados cíclicos, identificando implicações como a impossibilidade de ordenação topológica em grafos com ciclos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Básicas de Grafos Direcionados",
                                  "subSteps": [
                                    "Defina um grafo direcionado (DG) como um par (V, E) onde V é o conjunto de vértices e E é o conjunto de arestas direcionadas.",
                                    "Explique a representação de grafos usando listas de adjacência ou matrizes de adjacência.",
                                    "Diferencie grafos direcionados de não direcionados com um exemplo simples.",
                                    "Identifique vértices, arestas e caminhos em um grafo direcionado de exemplo.",
                                    "Desenhe um grafo direcionado simples com 4 vértices."
                                  ],
                                  "verification": "Crie e rotule corretamente um grafo direcionado simples, confirmando que todas as arestas têm direção.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de desenho de grafos como Graphviz ou Draw.io"
                                  ],
                                  "tips": "Sempre indique a direção das arestas com setas para evitar confusão.",
                                  "learningObjective": "Compreender os fundamentos de grafos direcionados como base para DAGs.",
                                  "commonMistakes": [
                                    "Confundir direção das arestas",
                                    "Ignorar a distinção entre DG e grafos não direcionados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Ciclos em Grafos Direcionados",
                                  "subSteps": [
                                    "Defina um ciclo como um caminho fechado onde um vértice é alcançado novamente partindo dele mesmo.",
                                    "Identifique um ciclo em um grafo exemplo: A→B→C→A.",
                                    "Explique por que ciclos criam dependências circulares.",
                                    "Use DFS (busca em profundidade) básica para detectar ciclos manualmente.",
                                    "Compare um grafo com ciclo vs sem ciclo visualmente."
                                  ],
                                  "verification": "Detecte e destaque um ciclo em um grafo fornecido, listando os vértices no caminho cíclico.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de grafos impressos ou digitais",
                                    "Editor de texto para pseudocódigo"
                                  ],
                                  "tips": "Siga caminhos em profundidade e marque vértices visitados para rastrear retornos.",
                                  "learningObjective": "Reconhecer e definir ciclos em grafos direcionados.",
                                  "commonMistakes": [
                                    "Confundir caminhos simples com ciclos",
                                    "Não considerar direções ao rastrear caminhos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Identificar DAGs",
                                  "subSteps": [
                                    "Defina DAG como Directed Acyclic Graph: grafo direcionado sem ciclos.",
                                    "Verifique aciclicidade: nenhum caminho retorna ao vértice inicial.",
                                    "Construa um exemplo de DAG: tarefas de projeto A→B→C.",
                                    "Diferencie DAG de DG com ciclo através de comparação lado a lado.",
                                    "Implemente uma verificação manual de aciclicidade em um pequeno grafo."
                                  ],
                                  "verification": "Classifique corretamente 3 grafos como DAG ou não-DAG, justificando com caminhos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ferramentas de visualização de grafos",
                                    "Lista de grafos de teste"
                                  ],
                                  "tips": "Procure por loops fechados em todos os caminhos possíveis.",
                                  "learningObjective": "Distinguir DAGs de grafos com ciclos através de identificação precisa.",
                                  "commonMistakes": [
                                    "Ignorar ciclos longos ou indiretos",
                                    "Confundir ausência visual com aciclicidade"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Implicações, Focando em Ordenação Topológica",
                                  "subSteps": [
                                    "Explique ordenação topológica: linearização de DAG onde para toda aresta u→v, u vem antes de v.",
                                    "Demonstre impossibilidade em grafos com ciclos: dependências circulares quebram a ordem.",
                                    "Aplique conceito: em compilação de código, DAG permite ordenação de módulos.",
                                    "Discuta algoritmos como Kahn ou DFS para topo-sort apenas em DAGs.",
                                    "Resuma diferenças chave em uma tabela: DAG vs DG com ciclo."
                                  ],
                                  "verification": "Explique por que topo-sort falha em um grafo com ciclo e succeeds em DAG.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de topo-sort",
                                    "Exemplos de aplicações reais"
                                  ],
                                  "tips": "Use o algoritmo de Kahn: comece com nós sem entradas.",
                                  "learningObjective": "Compreender implicações práticas da aciclicidade, especialmente topo-sort.",
                                  "commonMistakes": [
                                    "Acreditar que topo-sort funciona em ciclos",
                                    "Não ligar ciclos a dependências circulares"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de software, tarefas como 'codificar módulo A → testar B → compilar C'. Se adicionar 'C → A', cria ciclo impedindo ordem de execução. DAG permite agendar sem loops.",
                              "finalVerifications": [
                                "Defina corretamente DAG e ciclo em grafos direcionados.",
                                "Identifique ciclos em grafos de 5-7 vértices.",
                                "Construa um DAG simples e prove sua aciclicidade.",
                                "Explique falha de topo-sort em grafo cíclico com exemplo.",
                                "Compare tabela de diferenças: propriedades, algoritmos aplicáveis.",
                                "Aplique conceito a um cenário de dependências de tarefas."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de DAG e ciclos (100% correto).",
                                "Capacidade de detectar ciclos corretamente em exemplos variados.",
                                "Exemplos práticos relevantes e sem erros.",
                                "Explicação clara de implicações para topo-sort.",
                                "Uso consistente de terminologia técnica.",
                                "Estrutura lógica em respostas escritas ou diagramas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos grafos e relações parciais.",
                                "Programação: Implementação de algoritmos de detecção de ciclos (DFS, Kahn).",
                                "Gestão de Projetos: Modelagem de dependências em Gantt ou PERT.",
                                "Compiladores: Análise de dependências em grafos de fluxo de controle."
                              ],
                              "realWorldApplication": "Em sistemas de build como Make ou Gradle, DAGs garantem ordem de compilação sem ciclos; detecção de ciclos previne erros em pipelines CI/CD."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.2",
                        "name": "Ordenação Linear de Vértices",
                        "description": "Arranjo sequencial único ou múltiplo dos vértices de um grafo em uma lista linear, respeitando as dependências direcionais.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.2.1",
                            "name": "Descrever ordenação linear",
                            "description": "Definir ordenação linear como uma permutação dos vértices V em uma sequência π = (v1, v2, ..., vn) onde todos os vértices são listados exatamente uma vez.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de permutação",
                                  "subSteps": [
                                    "Revise a definição formal de permutação como uma rearrumação biunívoca de elementos.",
                                    "Estude exemplos simples de permutações de conjuntos pequenos, como {A, B, C}.",
                                    "Identifique que uma permutação lista todos os elementos exatamente uma vez.",
                                    "Pratique listando todas as permutações de um conjunto com 3 elementos.",
                                    "Diferencie permutação de combinações ou subconjuntos."
                                  ],
                                  "verification": "Liste corretamente todas as permutações de um conjunto com 3 elementos sem repetições ou omissões.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora opcional para fatoriais"
                                  ],
                                  "tips": "Use setas para visualizar rearrumações e evite confundir ordem com seleção.",
                                  "learningObjective": "Dominar a noção de permutação como rearrumação exaustiva e única.",
                                  "commonMistakes": "Confundir permutação com repetição de elementos ou omissões."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contextualizar vértices em um grafo direcionado",
                                  "subSteps": [
                                    "Recapitule o que são vértices (V) em um grafo direcionado acíclico (DAG).",
                                    "Desenhe um grafo simples com 4-5 vértices e arestas direcionadas.",
                                    "Liste os vértices de forma arbitrária e observe que representam nós independentes.",
                                    "Explique por que vértices precisam ser ordenados em contextos topológicos.",
                                    "Verifique se o grafo é acíclico para validar o contexto de ordenação topológica."
                                  ],
                                  "verification": "Desenhe um DAG com vértices rotulados e liste V corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha"
                                  ],
                                  "tips": "Sempre verifique ciclos com uma busca em profundidade mental antes de prosseguir.",
                                  "learningObjective": "Entender vértices como elementos a serem permutados em grafos DAG.",
                                  "commonMistakes": "Ignorar a direção das arestas ou assumir grafos cíclicos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir a sequência de ordenação linear π",
                                  "subSteps": [
                                    "Escreva a notação formal: π = (v1, v2, ..., vn) onde V = {v1, ..., vn}.",
                                    "Explique que π é uma bijeção de {1..n} para V.",
                                    "Crie uma sequência exemplo para um grafo dado, garantindo unicidade.",
                                    "Discuta que qualquer permutação é uma ordenação linear, mas topológica impõe restrições adicionais.",
                                    "Compare com ordenações não-lineares ou parciais."
                                  ],
                                  "verification": "Escreva π para um grafo com 4 vértices, confirmando que é uma permutação válida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de texto ou papel",
                                    "Exemplo de grafo impresso"
                                  ],
                                  "tips": "Use índices subscritos consistentemente: v_1, v_2, etc., para clareza.",
                                  "learningObjective": "Formalizar a ordenação linear como permutação notacional de vértices.",
                                  "commonMistakes": "Usar notação incorreta ou permitir duplicatas na sequência."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar a descrição completa de ordenação linear",
                                  "subSteps": [
                                    "Combine conceitos: permutação + vértices + sequência exaustiva.",
                                    "Redija uma definição verbal e formal em parágrafo coeso.",
                                    "Teste a descrição em um exemplo prático de grafo.",
                                    "Diferencie ordenação linear de topológica (sem restrições de precedência aqui).",
                                    "Revise para precisão matemática e clareza pedagógica."
                                  ],
                                  "verification": "Forneça uma descrição escrita que um colega entenda e valide como correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Processador de texto simples"
                                  ],
                                  "tips": "Comece com 'Uma ordenação linear é...' para estrutura clara.",
                                  "learningObjective": "Capacitar-se a descrever ordenação linear de forma precisa e completa.",
                                  "commonMistakes": "Omitir 'exatamente uma vez' ou confundir com ordenação topológica restrita."
                                }
                              ],
                              "practicalExample": "Considere um grafo DAG com vértices V = {A, B, C, D} e arestas A→B, A→C, B→D. Uma ordenação linear possível é π = (A, B, C, D), onde cada vértice aparece exatamente uma vez, formando uma permutação total de V.",
                              "finalVerifications": [
                                "Pode listar permutações corretas de um conjunto pequeno de vértices?",
                                "Descreve π usando notação matemática precisa?",
                                "Confirma que todos os vértices estão presentes exatamente uma vez?",
                                "Diferencia ordenação linear de topológica?",
                                "Aplica o conceito a um grafo exemplo sem erros?",
                                "Redige uma definição verbal clara e concisa?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de permutação (obrigatória).",
                                "Uso correto de notação π = (v1, ..., vn).",
                                "Ênfase em 'todos os vértices exatamente uma vez'.",
                                "Contextualização em grafos direcionados acíclicos.",
                                "Clareza e coesão na descrição escrita.",
                                "Ausência de confusão com restrições topológicas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e funções bijetoras.",
                                "Algoritmos: Base para DFS e Kahn's algorithm em topológica.",
                                "Lógica: Precedência e ordenações parciais.",
                                "Programação: Representação de dependências em código."
                              ],
                              "realWorldApplication": "Em compiladores, ordenação linear de módulos resolve dependências de código; em gerenciamento de projetos, sequencia tarefas sem precedências implícitas; em pipelines de dados, organiza processamento de nós em fluxos DAG."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.2.2.2",
                            "name": "Reconhecer múltiplas ordenações lineares",
                            "description": "Explicar que em um DAG, pode haver zero, uma ou múltiplas ordenações lineares válidas, dependendo da estrutura do grafo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de DAG e Ordenação Topológica",
                                  "subSteps": [
                                    "Defina um Directed Acyclic Graph (DAG) e liste suas propriedades principais.",
                                    "Explique o que é uma ordenação topológica: uma ordenação linear dos vértices onde para toda aresta u→v, u vem antes de v.",
                                    "Discuta pré-requisitos: ausência de ciclos garante pelo menos uma topo sort.",
                                    "Identifique que topo sorts são lineares e respeitam todas as dependências.",
                                    "Diferencie ordenação topológica de ordenações lineares únicas como bubble sort."
                                  ],
                                  "verification": "Escreva definições curtas e um exemplo simples de DAG com sua topo sort.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhar grafos",
                                    "Referência: Notas sobre grafos direcionados"
                                  ],
                                  "tips": [
                                    "Use setas claras para direções das arestas ao desenhar.",
                                    "Lembre-se: ciclo impede topo sort (zero ordenações válidas)."
                                  ],
                                  "learningObjective": "Compreender os pilares de DAGs e topo sorts para contextualizar múltiplas ordenações.",
                                  "commonMistakes": [
                                    "Confundir DAG com grafos cíclicos.",
                                    "Ignorar a direção das arestas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Condições para Zero, Uma ou Múltiplas Topo Sorts",
                                  "subSteps": [
                                    "Examine grafos com ciclo: demonstre zero topo sorts válidas.",
                                    "Estude grafos lineares (cadeia única): apenas uma topo sort possível.",
                                    "Identifique grafos com vértices independentes (sem aresta entre eles): múltiplas topo sorts.",
                                    "Conte graus de entrada (indegree): múltiplas fontes iniciais indicam múltiplas opções.",
                                    "Compare estruturas: ramificações ou paralelos geram variações.",
                                    "Use algoritmo de Kahn para visualizar escolhas em cada iteração."
                                  ],
                                  "verification": "Classifique três grafos exemplo como 0, 1 ou múltiplas topo sorts, justificando.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho de grafos online (ex: draw.io)",
                                    "Lista de grafos de exemplo pré-definidos"
                                  ],
                                  "tips": [
                                    "Comece sempre calculando indegrees para identificar fontes múltiplas.",
                                    "Desenhe grafos pequenos (4-6 vértices) para clareza."
                                  ],
                                  "learningObjective": "Reconhecer padrões gráficos que determinam o número de topo sorts válidas.",
                                  "commonMistakes": [
                                    "Assumir sempre uma única topo sort em DAGs.",
                                    "Confundir dependências bidirecionais com independência."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar e Listar Múltiplas Ordenações Lineares em um DAG",
                                  "subSteps": [
                                    "Selecione um DAG com múltiplas fontes ou caminhos paralelos.",
                                    "Aplique DFS ou Kahn iterativamente, escolhendo diferentes fontes em cada ramificação.",
                                    "Liste todas as topo sorts possíveis manualmente para grafos pequenos.",
                                    "Use recursão conceitual: para cada escolha válida, gere sub-sequências.",
                                    "Valide cada ordenação: verifique se todas as arestas u→v têm u antes de v.",
                                    "Conte o número total de topo sorts usando conceitos de contagem em grafos."
                                  ],
                                  "verification": "Para um grafo dado, liste pelo menos duas topo sorts distintas e valide-as.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel quadriculado para listas",
                                    "Implementação simples em pseudocódigo"
                                  ],
                                  "tips": [
                                    "Priorize vértices com indegree zero em diferentes ordens.",
                                    "Use árvore de decisões para mapear ramificações."
                                  ],
                                  "learningObjective": "Praticar geração explícita de múltiplas topo sorts para internalizar o conceito.",
                                  "commonMistakes": [
                                    "Gerar sequências que violam dependências.",
                                    "Listar permutações totais em vez de apenas topo sorts válidas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Diferenciar Topo Sorts em Diferentes Estruturas",
                                  "subSteps": [
                                    "Construa um grafo com zero topo sorts adicionando um ciclo.",
                                    "Crie um com uma única topo sort (totalmente ordenado).",
                                    "Expanda para múltiplas e compare com as anteriores.",
                                    "Simule remoção de arestas para observar aumento no número de topo sorts.",
                                    "Discuta implicações: liberdade em agendamentos com dependências parciais.",
                                    "Teste com software: valide suas listas manualmente."
                                  ],
                                  "verification": "Crie e analise um grafo personalizado, reportando o número de topo sorts.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de grafos (ex: Graphviz ou Python NetworkX)",
                                    "Templates de grafos"
                                  ],
                                  "tips": [
                                    "Teste ciclos propositalmente para reforçar o caso zero.",
                                    "Documente mudanças na estrutura e impacto nas topo sorts."
                                  ],
                                  "learningObjective": "Aplicar o reconhecimento em variações para solidificar a compreensão.",
                                  "commonMistakes": [
                                    "Não detectar ciclos sutis.",
                                    "Subestimar o número de topo sorts em grafos complexos."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o DAG: A→C, B→C, B→D. Topo sorts válidas: A B C D, A B D C, B A C D, B A D C. Note que A e B são independentes, permitindo 4 ordenações.",
                              "finalVerifications": [
                                "Explica corretamente por que um DAG com ciclo tem zero topo sorts.",
                                "Identifica grafos com exatamente uma topo sort (cadeia linear).",
                                "Lista múltiplas topo sorts válidas para um grafo com dependências parciais.",
                                "Valida uma topo sort verificando todas as arestas.",
                                "Distingue topo sorts de permutações arbitrárias.",
                                "Calcula indegrees para prever múltiplas fontes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de condições para 0/1/múltiplas topo sorts (30%).",
                                "Capacidade de gerar e validar topo sorts manualmente (25%).",
                                "Uso correto de conceitos como indegree e dependências (20%).",
                                "Análise de exemplos variados sem erros comuns (15%).",
                                "Clareza na explicação escrita ou verbal (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Contagem de Permutações Parciais.",
                                "Programação: Implementação de Algoritmos de Topo Sort (DFS/Kahn).",
                                "Lógica: Raciocínio sobre Dependências e Ordem Parcial.",
                                "Gestão de Projetos: Agendamento de Tarefas com Pré-requisitos."
                              ],
                              "realWorldApplication": "Em compiladores, ordenação topológica gerencia dependências de módulos; múltiplas topo sorts permitem otimizações de build order em pipelines CI/CD com tarefas paralelizáveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.2.2.3",
                            "name": "Construir exemplo de ordenação linear simples",
                            "description": "Dado um DAG pequeno, listar uma ordenação linear válida dos vértices manualmente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar o DAG pequeno graficamente",
                                  "subSteps": [
                                    "Escolha um DAG pequeno com 4-6 vértices e poucas arestas direcionadas.",
                                    "Desenhe os vértices como círculos ou caixas numerados (ex: v1, v2,...).",
                                    "Adicione setas direcionadas indicando dependências (ex: v1 → v2 significa v1 antes de v2).",
                                    "Rótule as arestas se necessário para clareza.",
                                    "Confirme que não há ciclos (use inspeção visual)."
                                  ],
                                  "verification": "O grafo está desenhado sem ciclos e com direções corretas das arestas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ou ferramenta online como draw.io"
                                  ],
                                  "tips": "Use setas grossas para dependências críticas e mantenha espaçamento amplo.",
                                  "learningObjective": "Visualizar e representar aciclicamente um grafo direcionado pequeno.",
                                  "commonMistakes": "Criar ciclos acidentais ou inverter direções das arestas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular graus de entrada (indegrees) para cada vértice",
                                  "subSteps": [
                                    "Liste todos os vértices em uma tabela.",
                                    "Para cada vértice, conte o número de arestas apontando para ele (indegree).",
                                    "Inicialize uma fila ou lista com vértices de indegree 0.",
                                    "Marque os indegrees ao lado de cada vértice.",
                                    "Verifique a soma total de indegrees equals ao número de arestas."
                                  ],
                                  "verification": "Todos indegrees calculados corretamente e lista inicial de indegree 0 não vazia.",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Papel com tabela",
                                    "Gráfico do Step 1"
                                  ],
                                  "tips": "Conte duas vezes para evitar erros de contagem.",
                                  "learningObjective": "Entender e calcular dependências iniciais em um DAG.",
                                  "commonMistakes": "Contar outdegree em vez de indegree ou ignorar arestas múltiplas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a ordenação linear iterativamente",
                                  "subSteps": [
                                    "Pegue um vértice de indegree 0 da lista inicial e adicione ao início da sequência.",
                                    "Remova esse vértice e subtraia 1 do indegree de seus sucessores.",
                                    "Adicione novos vértices com indegree 0 à lista.",
                                    "Repita até todos os vértices estarem na sequência.",
                                    "Registre cada iteração em uma tabela de progresso."
                                  ],
                                  "verification": "Sequência tem todos os vértices e nenhum indegree negativo restante.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Tabela de indegrees atualizável",
                                    "Lista de sequência"
                                  ],
                                  "tips": "Escolha arbitrariamente se múltiplos indegree 0; anote escolhas.",
                                  "learningObjective": "Aplicar o algoritmo de Kahn manualmente para gerar ordenação topológica.",
                                  "commonMistakes": "Esquecer de atualizar indegrees ou processar vértices com indegree >0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a ordenação linear produzida",
                                  "subSteps": [
                                    "Para cada aresta u → v na sequência, confirme que u aparece antes de v.",
                                    "Verifique se todos vértices estão presentes exatamente uma vez.",
                                    "Simule o processo reverso para detectar violações.",
                                    "Compare com outra possível ordenação para entender não unicidade.",
                                    "Documente a validação em uma lista de checks."
                                  ],
                                  "verification": "Nenhuma violação de dependência encontrada na sequência.",
                                  "estimatedTime": "7 minutos",
                                  "materials": [
                                    "Sequência final",
                                    "Gráfico original"
                                  ],
                                  "tips": "Use highlighter para marcar posições na sequência durante checks.",
                                  "learningObjective": "Verificar corretude de uma ordenação topológica.",
                                  "commonMistakes": "Ignorar arestas ou permitir duplicatas na sequência."
                                }
                              ],
                              "practicalExample": "DAG: v1 → v2, v1 → v3, v2 → v4, v3 → v4. Indegrees iniciais: v1=0, v2=1, v3=1, v4=2. Sequência possível: v1, v2, v3, v4 (ou v1, v3, v2, v4). Validação: Todas arestas respeitam ordem.",
                              "finalVerifications": [
                                "Sequência inclui todos os vértices exatamente uma vez.",
                                "Para toda aresta u → v, posição(u) < posição(v).",
                                "Processo de Kahn esgotou todos vértices sem resíduos.",
                                "Nenhum ciclo detectado durante construção.",
                                "Múltiplas ordenações válidas reconhecidas se aplicável.",
                                "Documentação do processo está completa e legível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação e cálculo de indegrees (30%).",
                                "Correção iterativa na construção da sequência (30%).",
                                "Validação completa sem erros (20%).",
                                "Clareza na documentação e explicação (10%).",
                                "Identificação de escolhas arbitárias (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Relações Parciais.",
                                "Lógica e Raciocínio: Resolução de Dependências Sequenciais.",
                                "Programação: Pré-requisitos em Compiladores e Schedulers.",
                                "Gestão de Projetos: Ordenação de Tarefas com Dependências."
                              ],
                              "realWorldApplication": "Em sistemas de build como Apache Maven ou Make, onde módulos dependem uns dos outros (ex: compilar A antes de B); ou em pipelines de CI/CD para ordenar testes e deploys sem violações de dependências."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.2.3",
                        "name": "Propriedade de Precedência na Ordenação Topológica",
                        "description": "Condição essencial que garante a validade da ordenação: para toda aresta u → v, u precede v na sequência linear.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.2.3.1",
                            "name": "Enunciar a propriedade topológica",
                            "description": "Formalizar que uma ordenação topológica de um DAG é uma ordenação linear dos vértices tal que, para toda aresta direcionada u → v no grafo, u aparece antes de v na ordenação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Grafos Direcionados Acíclicos (DAG)",
                                  "subSteps": [
                                    "Defina um grafo direcionado: vértices conectados por arestas com direção.",
                                    "Explique o que torna um grafo acíclico (sem ciclos).",
                                    "Desenhe um exemplo simples de DAG com 4 vértices e 3 arestas.",
                                    "Identifique por que ciclos impediriam ordenações lineares.",
                                    "Liste propriedades chave de DAGs relevantes para ordenação topológica."
                                  ],
                                  "verification": "Desenhe um DAG correto e explique verbalmente por que ele é acíclico.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, lápis, acesso a um diagrama de DAG online ou livro de algoritmos.",
                                  "tips": "Use setas claras para direções e verifique ciclos traçando caminhos.",
                                  "learningObjective": "Compreender a estrutura de um DAG como pré-requisito para ordenação topológica.",
                                  "commonMistakes": "Confundir grafos direcionados com não-direcionados; ignorar a aciclicidade."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Compreender Ordenação Linear de Vértices",
                                  "subSteps": [
                                    "Defina ordenação linear: sequência única de todos os vértices sem repetições.",
                                    "Compare com ordenação parcial, destacando que linear é total.",
                                    "Liste vértices de um DAG exemplo em ordem linear arbitrária.",
                                    "Discuta restrições impostas pelas arestas direcionadas.",
                                    "Pratique reordenando vértices para diferentes sequências lineares válidas."
                                  ],
                                  "verification": "Gere 2 ordenações lineares diferentes para o mesmo DAG e justifique.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo DAG do step 1, quadro ou software de grafos como Graphviz.",
                                  "tips": "Pense em 'fila única' para visualizar linearidade.",
                                  "learningObjective": "Dominar o conceito de ordenação linear como base para a topológica.",
                                  "commonMistakes": "Permitir repetições ou omitir vértices; confundir com ordenação por grau."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Propriedade de Precedência (u antes de v para u → v)",
                                  "subSteps": [
                                    "Para cada aresta u → v, explique que u deve preceder v na ordenação.",
                                    "Marque todas as arestas em um DAG e trace precedências requeridas.",
                                    "Verifique se uma dada ordenação linear respeita todas as precedências.",
                                    "Identifique violações em uma ordenação inválida.",
                                    "Generalize: toda ordenação topológica preserva todas as precedências do grafo."
                                  ],
                                  "verification": "Valide 3 ordenações lineares contra precedências de um DAG exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "DAG exemplo impresso ou digital, marcadores coloridos para arestas.",
                                  "tips": "Use cores diferentes para cada aresta ao verificar precedências.",
                                  "learningObjective": "Internalizar a propriedade essencial de precedência na ordenação topológica.",
                                  "commonMistakes": "Inverter precedência (pensar v antes de u); ignorar arestas indiretas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar e Enunciar a Propriedade Topológica Completa",
                                  "subSteps": [
                                    "Escreva a definição: 'Ordenação topológica de um DAG é uma ordenação linear dos vértices tal que para toda aresta u → v, u aparece antes de v'.",
                                    "Recite a definição 5 vezes em voz alta, variando palavras sinônimas.",
                                    "Compare com definições de fontes confiáveis (ex: CLRS).",
                                    "Aplique a definição a um novo DAG, gerando uma ordenação topológica.",
                                    "Escreva a propriedade em notação formal: ∀ arestas (u,v) ∈ E, posição(u) < posição(v)."
                                  ],
                                  "verification": "Enuncie a propriedade corretamente por escrito e verbalmente sem consultar notas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha para escrita, gravador de áudio para auto-avaliação, referência de livro.",
                                  "tips": "Memorize usando mnemônicos como 'Direção implica precedência na Topo'.",
                                  "learningObjective": "Capacitar-se a enunciar precisamente a propriedade topológica.",
                                  "commonMistakes": "Omitir 'linear' ou 'DAG'; usar 'depois' em vez de 'antes'."
                                }
                              ],
                              "practicalExample": "Considere o DAG: vértices A, B, C com arestas A→B, A→C, B→C. Uma ordenação topológica válida é A, B, C (A antes de B e C; B antes de C). Verificação: Todas as arestas respeitam precedência.",
                              "finalVerifications": [
                                "Enuncie a definição completa sem erros em menos de 30 segundos.",
                                "Aplique a propriedade a um DAG novo e identifique ordenações válidas/inválidas.",
                                "Explique a propriedade para um parente ou colega sem usar notas.",
                                "Escreva a definição formal com notação matemática correta.",
                                "Gere 3 ordenações topológicas diferentes para um DAG com 5 vértices.",
                                "Diferencie ordenação topológica de DFS ou Kahn's algorithm."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição: inclui DAG, linear, precedência exata (100% match).",
                                "Compreensão conceitual: explica precedência para arestas diretas/indiretas.",
                                "Aplicação prática: valida corretamente ordenações em exemplos dados.",
                                "Formalização: usa linguagem matemática apropriada sem ambiguidades.",
                                "Fluência: enuncia sem hesitação ou consulta em avaliações orais.",
                                "Diferenciação: distingue de conceitos relacionados como ordenação parcial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações de ordem parcial e extensões lineares.",
                                "Programação: Gerenciamento de dependências em makefiles ou compiladores.",
                                "Gestão de Projetos: Agendamento de tarefas com precedências (PERT/CPM).",
                                "Lógica: Implicações em grafos de inferência."
                              ],
                              "realWorldApplication": "Em compiladores, ordenação topológica resolve dependências de módulos (ex: compilar A antes de B se A→B); em pipelines de CI/CD, garante execução sequencial de jobs dependentes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1",
                              "10.1.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.2",
                            "name": "Verificar propriedade em uma ordenação",
                            "description": "Dada uma ordenação linear e um DAG, verificar se satisfaz a propriedade topológica inspecionando todas as arestas u → v.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e representar o DAG e a ordenação linear",
                                  "subSteps": [
                                    "Identifique os vértices do DAG e liste-os claramente.",
                                    "Desenhe ou liste todas as arestas u → v do grafo.",
                                    "Anote a ordenação linear fornecida como uma sequência numerada de vértices.",
                                    "Atribua posições numéricas a cada vértice na ordenação (ex: posição 1, 2, 3...).",
                                    "Verifique se todos os vértices do DAG estão presentes na ordenação."
                                  ],
                                  "verification": "Confirme que o grafo e a ordenação estão representados corretamente sem erros de transcrição.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de desenho de grafos (ex: Graphviz, Draw.io)",
                                    "Lista do DAG e ordenação fornecida"
                                  ],
                                  "tips": "Use uma tabela para mapear vértices às suas posições na ordenação para facilitar consultas rápidas.",
                                  "learningObjective": "Representar visual e numericamente os dados de entrada para verificação topológica.",
                                  "commonMistakes": [
                                    "Ignorar vértices isolados",
                                    "Confundir direções das arestas",
                                    "Atribuir posições incorretas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair e listar todas as arestas do DAG",
                                  "subSteps": [
                                    "Percorra a representação do DAG e compile uma lista completa de todas as arestas u → v.",
                                    "Numere cada aresta para rastreamento (ex: aresta 1: u1 → v1).",
                                    "Confirme que não há arestas duplicadas ou ausentes.",
                                    "Para cada aresta, anote as posições preliminares de u e v da ordenação.",
                                    "Crie uma tabela com colunas: Aresta, u, pos(u), v, pos(v)."
                                  ],
                                  "verification": "A lista de arestas deve coincidir exatamente com o DAG original.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela em planilha ou papel com colunas para arestas e posições"
                                  ],
                                  "tips": "Ordene as arestas alfabeticamente ou por vértice para facilitar a inspeção.",
                                  "learningObjective": "Compilar sistematicamente todas as restrições de precedência do grafo.",
                                  "commonMistakes": [
                                    "Omitir arestas indiretas",
                                    "Inverter u e v",
                                    "Duplicar arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inspecionar cada aresta para verificar a propriedade de precedência",
                                  "subSteps": [
                                    "Para cada aresta u → v, compare pos(u) e pos(v).",
                                    "Se pos(u) < pos(v), marque como 'satisfeita'.",
                                    "Se pos(u) >= pos(v), marque como 'violada' e anote o motivo.",
                                    "Registre o resultado para todas as arestas em uma coluna de status.",
                                    "Conte o número de violações encontradas."
                                  ],
                                  "verification": "100% das arestas foram inspecionadas e marcadas com status correto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela atualizada da etapa anterior",
                                    "Marcadores coloridos para satisfeito/violado"
                                  ],
                                  "tips": "Use cores: verde para satisfeito, vermelho para violado, para visualização rápida.",
                                  "learningObjective": "Aplicar a regra pos(u) < pos(v) de forma consistente a todas as arestas.",
                                  "commonMistakes": [
                                    "Pular arestas",
                                    "Confundir < com >",
                                    "Usar índices 0-base incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Compilar resultados e concluir sobre a ordenação topológica",
                                  "subSteps": [
                                    "Verifique se o número de violações é zero.",
                                    "Se zero violações, conclua que é uma ordenação topológica válida.",
                                    "Se houver violações, liste as arestas problemáticas e declare inválida.",
                                    "Resuma os achados em uma declaração clara.",
                                    "Opcionalmente, sugira uma correção movendo vértices violadores."
                                  ],
                                  "verification": "Conclusão alinhada com inspeção: válida só se zero violações.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela final com status",
                                    "Relatório escrito ou verbal"
                                  ],
                                  "tips": "Escreva a conclusão em negrito: 'Válida' ou 'Inválida devido a [arestas]'",
                                  "learningObjective": "Sintetizar inspeções em uma decisão binária sobre validade topológica.",
                                  "commonMistakes": [
                                    "Declarar válida com violações",
                                    "Ignorar violações parciais",
                                    "Não listar evidências"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o DAG com vértices A, B, C, D e arestas A→B, A→C, B→D. Ordenação dada: A, B, C, D. Inspeção: A(1)→B(2): 1<2 ✓; A(1)→C(3):1<3 ✓; B(2)→D(4):2<4 ✓. Válida. Agora, ordenação A, C, B, D: A→B:1<3 ✓; A→C:1<2 ✓; B→D:3<4 ✓. Ainda válida. Teste inválida: B, A, C, D (B(1)→D(4):1<4 mas A→B violado pois A(2)>B(1)? A→B:2>1 ✗).",
                              "finalVerifications": [
                                "Todas as arestas u→v têm pos(u) < pos(v).",
                                "Nenhum vértice ausente ou extra na ordenação.",
                                "Lista de arestas completa e sem duplicatas.",
                                "Posições atribuídas corretamente (1-based ou consistente).",
                                "Conclusão documentada com evidências.",
                                "Nenhuma violação de precedência detectada."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todas as arestas inspecionadas.",
                                "Precisão: Correção na comparação de posições.",
                                "Sistematicidade: Uso de tabela ou lista organizada.",
                                "Clareza: Documentação legível dos resultados.",
                                "Eficiência: Tempo razoável sem erros desnecessários.",
                                "Validação: Conclusão lógica baseada em fatos."
                              ],
                              "crossCurricularConnections": [
                                "Lógica e Raciocínio Matemático: Verificação de propriedades em grafos.",
                                "Programação: Implementação em loops para checagem automatizada.",
                                "Gestão de Projetos: Verificação de dependências em cronogramas.",
                                "Análise de Dados: Inspeção de relações em conjuntos ordenados."
                              ],
                              "realWorldApplication": "Em compiladores de software, verificar se o ordem de compilação de módulos respeita dependências (DAG de módulos); em agendamento de tarefas, garantir que tarefas predecessoras sejam executadas antes das sucessoras em fluxos de trabalho industriais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1",
                              "10.1.4.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.2.3.3",
                            "name": "Relacionar com aplicações práticas",
                            "description": "Explicar como a propriedade modela dependências, como em agendamento de tarefas ou compilação de código com pré-requisitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a propriedade de precedência na ordenação topológica",
                                  "subSteps": [
                                    "Defina o que é ordenação topológica em um grafo direcionado acíclico (DAG).",
                                    "Explique a propriedade de precedência: para toda aresta u → v, u aparece antes de v na ordenação.",
                                    "Identifique pré-requisitos em um grafo simples com 4-5 nós e arestas.",
                                    "Desenhe um grafo exemplo e liste uma ordenação topológica válida.",
                                    "Verifique se todas as precedências são respeitadas na ordenação."
                                  ],
                                  "verification": "Construa um grafo simples e valide pelo menos duas ordenações topológicas corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho de grafos como draw.io",
                                    "Notebook com exemplos de DAGs"
                                  ],
                                  "tips": "Sempre verifique ciclos no grafo antes de aplicar ordenação topológica.",
                                  "learningObjective": "Compreender como a propriedade de precedência modela dependências obrigatórias.",
                                  "commonMistakes": "Confundir ordenação topológica com ordenação por tamanho ou alfabética."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar aplicações práticas comuns",
                                  "subSteps": [
                                    "Liste 3 aplicações onde dependências lineares ocorrem: agendamento de tarefas, compilação de código.",
                                    "Modele um agendamento de tarefas diárias como um DAG (ex: lavar louça antes de cozinhar nova refeição).",
                                    "Pesquise brevemente ferramentas reais que usam ordenação topológica (ex: Make, Gradle).",
                                    "Compare precedência com ordem parcial vs. total.",
                                    "Discuta por que ciclos invalidam o agendamento."
                                  ],
                                  "verification": "Crie uma lista de 4 aplicações reais com grafos de dependências descritos.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Internet para pesquisa rápida",
                                    "Editor de texto para listar aplicações"
                                  ],
                                  "tips": "Pense em sequências cotidianas para tornar as aplicações mais intuitivas.",
                                  "learningObjective": "Associar a propriedade de precedência a cenários reais de dependências.",
                                  "commonMistakes": "Ignorar que grafos com ciclos não admitem ordenação topológica."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplo prático: compilação de código",
                                  "subSteps": [
                                    "Crie um grafo de módulos de software: módulo A → B, A → C, B → D.",
                                    "Simule a compilação: compile A primeiro, depois B e C em paralelo, então D.",
                                    "Implemente um script simples em Python usando Kahn's algorithm para ordenação.",
                                    "Teste com entrada inválida (ciclo) e observe o erro.",
                                    "Explique como ferramentas como GCC ou Maven usam isso internamente."
                                  ],
                                  "verification": "Execute um código Python que gere uma ordenação topológica correta para o grafo.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python instalado com bibliotecas networkx e matplotlib",
                                    "Exemplos de código online"
                                  ],
                                  "tips": "Use networkx para visualizar o grafo e facilitar a compreensão.",
                                  "learningObjective": "Aplicar ordenação topológica a um problema de compilação real.",
                                  "commonMistakes": "Esquecer dependências paralelas que permitem execução simultânea."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Generalizar para outros domínios e sintetizar",
                                  "subSteps": [
                                    "Explore aplicações em gerenciamento de projetos (ex: Gantt charts com precedências).",
                                    "Discuta uso em jogos (ordem de missões) e biologia (sequência de reações químicas).",
                                    "Crie um mapa mental conectando ordenação topológica a 5 domínios diferentes.",
                                    "Avalie limitações: só para DAGs, sensível a ciclos.",
                                    "Proponha uma aplicação pessoal ou hipotética."
                                  ],
                                  "verification": "Produza um relatório curto com 5 aplicações, incluindo grafos simplificados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Ferramenta de mind mapping como MindMeister ou papel",
                                    "Documentos de referência"
                                  ],
                                  "tips": "Conecte com experiências pessoais para melhor retenção.",
                                  "learningObjective": "Relacionar a propriedade de precedência amplamente a contextos interdisciplinares.",
                                  "commonMistakes": "Superestimar aplicabilidade em grafos com ciclos frequentes."
                                }
                              ],
                              "practicalExample": "Em um sistema de build de software como o Make: módulos 'main.c' depende de 'utils.c', que depende de 'headers.h'. A ordenação topológica garante compilação de headers.h → utils.c → main.c, evitando erros de 'arquivo não encontrado'.",
                              "finalVerifications": [
                                "Pode modelar um grafo de dependências para uma tarefa real e listar ordenação topológica.",
                                "Explica corretamente 4 aplicações práticas sem erros conceituais.",
                                "Identifica ciclos em grafos e explica impactos na precedência.",
                                "Implementa ou simula ordenação em um exemplo de compilação.",
                                "Conecta a propriedade a pelo menos 3 domínios fora de CS.",
                                "Avalia limitações da ordenação topológica em cenários reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de dependências (100% das precedências respeitadas).",
                                "Diversidade e relevância das aplicações citadas (mínimo 4 únicas).",
                                "Capacidade de simular ou codificar ordenação topológica.",
                                "Profundidade na análise de exemplos (inclui grafos e verificações).",
                                "Criatividade em generalizações interdisciplinares.",
                                "Identificação correta de erros comuns e limitações."
                              ],
                              "crossCurricularConnections": [
                                "Gerenciamento de Projetos: Precedências em cronogramas PERT/CPM.",
                                "Biologia: Sequências de reações em vias metabólicas.",
                                "Economia: Cadeias de suprimentos com dependências de produção.",
                                "Engenharia Civil: Ordem de construção (fundações antes de paredes)."
                              ],
                              "realWorldApplication": "Usada em compiladores (GCC), sistemas de build (Maven, Gradle), agendadores de jobs (Kubernetes), e planejamento de projetos (Microsoft Project), otimizando execução respeitando dependências para eficiência e evitar falhas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.2.1",
                              "10.1.4.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.3",
                    "name": "Algoritmo de Kahn",
                    "description": "Método baseado em fila e contagem de graus de entrada para construir a ordenação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.3.1",
                        "name": "Cálculo dos Graus de Entrada",
                        "description": "Conceito fundamental do Algoritmo de Kahn que envolve a contagem do número de arestas entrantes em cada vértice de um grafo direcionado, essencial para identificar nós iniciais sem dependências.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.1.1",
                            "name": "Representar o grafo com listas de adjacência",
                            "description": "Implementar uma estrutura de dados para representar um grafo direcionado usando listas de adjacência, permitindo acesso eficiente às arestas saindo de cada vértice.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura básica de listas de adjacência",
                                  "subSteps": [
                                    "Escolha uma linguagem de programação (ex: Python com dicionário de listas).",
                                    "Crie uma classe ou estrutura para o grafo direcionado.",
                                    "Inicialize um dicionário ou array onde cada chave/índice é um vértice com lista vazia.",
                                    "Adicione um atributo para mapear nomes de vértices a índices, se necessário.",
                                    "Defina o número máximo de vértices ou use estrutura dinâmica."
                                  ],
                                  "verification": "Compile/executar o código sem erros e imprima a estrutura vazia confirmando listas vazias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Documentação de estruturas de dados em Python/C++"
                                  ],
                                  "tips": "Use dicionário em Python para flexibilidade com vértices rotulados; array em C++ para eficiência.",
                                  "learningObjective": "Compreender e implementar a representação básica de um grafo como coleção de listas por vértice.",
                                  "commonMistakes": [
                                    "Usar lista única em vez de por vértice",
                                    "Esquecer de inicializar listas vazias",
                                    "Confundir grafos direcionados com não-direcionados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar inserção de vértices e arestas",
                                  "subSteps": [
                                    "Crie método addVertex(v) para adicionar vértice e inicializar sua lista vazia.",
                                    "Crie método addEdge(origem, destino) para adicionar destino à lista de origem.",
                                    "Garanta que vértices inexistentes sejam criados automaticamente ao adicionar arestas.",
                                    "Trate casos de arestas múltiplas ou auto-loops, se aplicável.",
                                    "Teste inserção com 2-3 arestas simples."
                                  ],
                                  "verification": "Adicione vértices e arestas, imprima listas e confirme que as adjacências estão corretas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Ambiente de execução (Python interpreter ou compilador C++)"
                                  ],
                                  "tips": "Sempre verifique se o vértice origem existe antes de adicionar à sua lista.",
                                  "learningObjective": "Desenvolver funções para construir o grafo dinamicamente com eficiência O(1) por aresta.",
                                  "commonMistakes": [
                                    "Adicionar bidirecionalmente em grafo direcionado",
                                    "Não criar vértice destino",
                                    "Índices fora de bounds em arrays"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar acesso e iteração sobre adjacências",
                                  "subSteps": [
                                    "Crie método getNeighbors(vertice) que retorna a lista de adjacentes.",
                                    "Implemente iteração: para cada vértice, liste seus vizinhos.",
                                    "Adicione método para calcular grau de saída de um vértice (tamanho da lista).",
                                    "Integre com cálculo de graus de entrada percorrendo todas as listas.",
                                    "Otimize para acesso rápido O(1) à lista de um vértice."
                                  ],
                                  "verification": "Para um grafo de teste, liste todos os vizinhos e graus de entrada corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de grafos em papel"
                                  ],
                                  "tips": "Use for-loops para percorrer listas; evite recriação de estruturas.",
                                  "learningObjective": "Habilitar acesso eficiente às arestas de saída, base para algoritmos como Kahn.",
                                  "commonMistakes": [
                                    "Retornar grau de entrada em vez de saída",
                                    "Percorrer incorretamente para graus de entrada",
                                    "Acesso lento O(V+E) desnecessário"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a representação completa",
                                  "subSteps": [
                                    "Crie um grafo de exemplo com 5 vértices e 7 arestas.",
                                    "Execute inserções, acessos e cálculos de graus.",
                                    "Compare saídas com representação manual em papel.",
                                    "Teste casos edge: grafo vazio, isolado, ciclo.",
                                    "Meça tempo de construção e acesso para eficiência."
                                  ],
                                  "verification": "Todos testes passam; graus de entrada coincidem com contagem manual.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Papel e caneta para diagrama manual"
                                  ],
                                  "tips": "Use asserts ou printfs para validação automática.",
                                  "learningObjective": "Garantir robustez e corretude da estrutura para uso em ordenação topológica.",
                                  "commonMistakes": [
                                    "Ignorar vértices isolados",
                                    "Erro em contagem de graus de entrada",
                                    "Não testar grafos direcionados"
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um grafo direcionado com vértices 0,1,2,3: arestas 0->1, 0->2, 1->2, 1->3, 2->3. Listas: 0:[1,2], 1:[2,3], 2:[3], 3:[]; Graus entrada: 0:0, 1:1, 2:2, 3:2. Use para iniciar Algoritmo de Kahn.",
                              "finalVerifications": [
                                "Listas de adjacência refletem exatamente as arestas de saída.",
                                "Acesso a vizinhos de qualquer vértice é O(1).",
                                "Cálculo de graus de entrada é correto percorrendo todas as listas.",
                                "Estrutura suporta pelo menos 100 vértices sem perda de performance.",
                                "Nenhum erro em casos de vértices isolados ou grafo vazio.",
                                "Impressão ou serialização mostra estrutura clara."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Adjacências e graus exatos.",
                                "Eficiência: Inserção O(1), acesso O(1), construção O(V+E).",
                                "Robustez: Trata vértices não existentes e edge cases.",
                                "Clareza: Código legível com comentários.",
                                "Escalabilidade: Funciona para grafos médios (n=1000).",
                                "Integração: Pronto para uso em ordenação topológica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Matrizes de Adjacência.",
                                "Algoritmos: Pré-requisito para DFS/BFS e Ordenação Topológica.",
                                "Programação: Estruturas de Dados Avançadas (Hash Tables, Linked Lists).",
                                "Engenharia de Software: Design de Classes e Testes Unitários."
                              ],
                              "realWorldApplication": "Representação de dependências em sistemas de build (ex: Makefiles), redes de computadores para roteamento, análise de redes sociais para recomendações de amigos, e planejamento de tarefas em projetos com precedências (ex: Algoritmo de Kahn para agendamento)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.3.1.2",
                            "name": "Calcular o array de indegrees",
                            "description": "Percorrer todas as arestas do grafo e incrementar o contador de grau de entrada para cada vértice destino, criando um array que armazena os indegrees de todos os vértices.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar o Array de Indegrees",
                                  "subSteps": [
                                    "Identifique o número total de vértices (n) no grafo.",
                                    "Crie um array ou vetor de tamanho n, inicializando todos os elementos com 0.",
                                    "Rotule o array como 'indegrees' e associe cada índice ao vértice correspondente (ex: índice 0 para vértice 0).",
                                    "Confirme que o grafo está representado adequadamente (lista de adjacência ou lista de arestas).",
                                    "Anote o número total de arestas (m) para verificação posterior."
                                  ],
                                  "verification": "Verifique se o array tem tamanho n e todos os valores são 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Representação do grafo (lista de adjacência ou matriz)",
                                    "Editor de código ou papel e lápis"
                                  ],
                                  "tips": "Use uma linguagem como Python: indegrees = [0] * n",
                                  "learningObjective": "Entender a necessidade de inicialização zero para contagem precisa de graus de entrada.",
                                  "commonMistakes": [
                                    "Inicializar com valores errados (ex: 1 em vez de 0)",
                                    "Índices desalinhados com vértices"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Percorrer Todas as Arestas do Grafo",
                                  "subSteps": [
                                    "Acesse a lista de arestas ou itere sobre a lista de adjacência de cada vértice.",
                                    "Para cada aresta (u, v), identifique u como origem e v como destino.",
                                    "Ignore arestas auto-referenciadas ou inválidas.",
                                    "Mantenha um contador opcional de arestas processadas para depuração.",
                                    "Garanta que a iteração cubra todas as arestas exatamente uma vez."
                                  ],
                                  "verification": "Confirme que todas as arestas foram visitadas sem duplicatas ou omissões.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de arestas ou adjacência do grafo",
                                    "Pseudocódigo ou ambiente de programação"
                                  ],
                                  "tips": "Em Python, para graph in lista de adj: for v in graph[u]: ...",
                                  "learningObjective": "Dominar a iteração eficiente sobre estruturas de grafo para contagem.",
                                  "commonMistakes": [
                                    "Confundir origem e destino da aresta",
                                    "Processar arestas múltiplas vezes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Incrementar os Contadores de Indegrees",
                                  "subSteps": [
                                    "Para cada aresta (u, v) processada, incremente indegrees[v] em 1.",
                                    "Atualize o array imediatamente após identificar o destino.",
                                    "Registre mudanças para depuração (ex: print ou log).",
                                    "Após todas as arestas, revise o array para consistência.",
                                    "Calcule a soma dos indegrees e compare com o número de arestas (deve ser igual)."
                                  ],
                                  "verification": "A soma dos indegrees deve igualar o número total de arestas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Array de indegrees inicializado",
                                    "Ferramenta de depuração (print ou debugger)"
                                  ],
                                  "tips": "Use um loop duplo: for u in range(n): for v in adj[u]: indegrees[v] += 1",
                                  "learningObjective": "Aplicar incrementos precisos baseados em direções de arestas.",
                                  "commonMistakes": [
                                    "Incrementar o origem em vez do destino",
                                    "Índices fora de bounds"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Finalizar o Array de Indegrees",
                                  "subSteps": [
                                    "Verifique se todos os indegrees são não-negativos.",
                                    "Identifique vértices com indegree 0 (início para Kahn).",
                                    "Teste com um grafo pequeno manualmente.",
                                    "Implemente em código e execute com input de teste.",
                                    "Documente o array final com mapeamento vértice-indegree."
                                  ],
                                  "verification": "Execute testes unitários: soma(indegrees) == m e min(indegrees) >= 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Grafo de teste",
                                    "Ambiente de execução de código"
                                  ],
                                  "tips": "Adicione asserts: assert sum(indegrees) == num_edges",
                                  "learningObjective": "Garantir integridade e usabilidade do array para ordenação topológica.",
                                  "commonMistakes": [
                                    "Ignorar validação de soma",
                                    "Esquecer vértices isolados (indegree 0)"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo com 4 vértices (0,1,2,3) e arestas: 0->1, 0->2, 1->3, 2->3. Inicialize indegrees = [0,0,0,0]. Percorra: para 0->1: indegrees[1] +=1 → [0,1,0,0]; 0->2: [0,1,1,0]; 1->3: [0,1,1,1]; 2->3: [0,1,1,2]. Resultado final: [0,1,1,2].",
                              "finalVerifications": [
                                "O array tem exatamente n elementos.",
                                "Todos os valores são inteiros não-negativos.",
                                "A soma dos indegrees equals o número de arestas.",
                                "Vértices sem arestas de entrada têm indegree 0.",
                                "Vértices isolados têm indegree 0.",
                                "Teste com grafo vazio ou único vértice funciona."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Array reflete corretamente todas as arestas de entrada.",
                                "Eficiência: Tempo O(V + E), sem loops desnecessários.",
                                "Corretude: Passa em testes com grafos direcionados, cíclicos e acíclicos.",
                                "Clareza: Código comentado e legível.",
                                "Robustez: Trata casos edge (n=0, sem arestas, auto-loops).",
                                "Validação: Inclui verificações de soma e não-negatividade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de Grafos e propriedades de graus.",
                                "Programação: Estruturas de dados (arrays, listas de adjacência) e loops aninhados.",
                                "Gerenciamento de Projetos: Modelagem de dependências em tarefas.",
                                "Ciência da Computação: Pré-requisito para algoritmos de ordenação topológica."
                              ],
                              "realWorldApplication": "Em sistemas de build como Make ou Maven, calcula ordem de compilação baseada em dependências de módulos; em gerenciadores de pacotes como npm ou pip, determina sequência de instalação evitando ciclos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.1.3",
                            "name": "Identificar vértices com indegree zero",
                            "description": "Analisar o array de indegrees para encontrar e listar todos os vértices cujo grau de entrada é zero, preparando-os para inserção na fila.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Indegree Zero",
                                  "subSteps": [
                                    "Revise a definição de indegree: número de arestas entrantes em um vértice.",
                                    "Identifique que vértices com indegree zero não têm dependências prévias.",
                                    "Relacione isso ao Algoritmo de Kahn: esses vértices iniciam a ordenação topológica.",
                                    "Desenhe um grafo simples com 3-4 vértices para visualizar indegrees.",
                                    "Anote exemplos de vértices fontes (indegree 0) nesse grafo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que um vértice tem indegree zero em seu grafo de exemplo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou software de desenho de grafos como Draw.io",
                                  "tips": "Use setas para representar direções das arestas e conte-as manualmente.",
                                  "learningObjective": "Entender o papel semântico de vértices com indegree zero em grafos direcionados.",
                                  "commonMistakes": "Confundir indegree com outdegree ou ignorar a direção das arestas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preparar e Acessar o Array de Indegrees",
                                  "subSteps": [
                                    "Confirme que o array de indegrees está calculado corretamente (um valor por vértice).",
                                    "Rotule os índices do array com os nomes ou IDs dos vértices correspondentes.",
                                    "Verifique o comprimento do array (deve igualar o número de vértices).",
                                    "Copie o array para uma estrutura editável (lista ou fila temporária).",
                                    "Teste acessando valores específicos: indegrees[0], indegrees[1], etc."
                                  ],
                                  "verification": "Imprima ou liste o array com rótulos de vértices e confirme valores manuais.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Editor de código (Python, Java) ou planilha para simulação",
                                  "tips": "Use um dicionário auxiliar para mapear índice para nome do vértice se necessário.",
                                  "learningObjective": "Manipular arrays de indegrees de forma precisa e indexada.",
                                  "commonMistakes": "Índices off-by-one ou array não inicializado com zeros."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Iterar e Identificar Vértices com Indegree Zero",
                                  "subSteps": [
                                    "Inicie um loop for sobre todos os índices do array (0 a n-1).",
                                    "Para cada índice i, verifique se indegrees[i] == 0.",
                                    "Se verdadeiro, adicione i (ou nome do vértice) a uma lista de resultados.",
                                    "Continue a iteração até o final sem pular elementos.",
                                    "Registre o número total de vértices encontrados."
                                  ],
                                  "verification": "Execute o loop e imprima a lista resultante; compare com inspeção manual.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Código fonte com array de exemplo ou pseudocódigo",
                                  "tips": "Use uma lista vazia inicialmente e append() para adicionar vértices.",
                                  "learningObjective": "Implementar iteração condicional eficiente para filtrar indegree zero.",
                                  "commonMistakes": "Parar o loop cedo ou adicionar vértices com indegree > 0."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Listar e Preparar Vértices para a Fila",
                                  "subSteps": [
                                    "Ordene a lista de vértices por ID ou nome alfabeticamente se requerido.",
                                    "Converta a lista em uma fila (queue) usando deque ou fila nativa.",
                                    "Imprima a fila pronta para o próximo passo do algoritmo de Kahn.",
                                    "Valide que nenhum vértice duplicado existe na lista.",
                                    "Documente o processo em comentários de código."
                                  ],
                                  "verification": "A fila contém exatamente os vértices com indegree zero e está pronta para dequeue.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Estrutura de dados queue em linguagem de programação",
                                  "tips": "Em Python, use collections.deque() para fila eficiente.",
                                  "learningObjective": "Preparar dados identificados para integração no algoritmo principal.",
                                  "commonMistakes": "Duplicatas na lista ou falha em converter para fila."
                                }
                              ],
                              "practicalExample": "Em um grafo de tarefas: vértices A (indegree 0), B (indegree 1 de A), C (indegree 0), D (indegree 1 de C). Array indegrees = [0, 1, 0, 1]. Iteração identifica A e C, lista ['A', 'C'], enfileira para processar primeiro.",
                              "finalVerifications": [
                                "Lista contém todos e apenas vértices com indegree exatamente zero.",
                                "Ordem de iteração respeitada ou ordenada corretamente.",
                                "Fila criada sem erros de tipo ou duplicatas.",
                                "Valores do array original inalterados.",
                                "Tempo de execução O(n) confirmado para n vértices.",
                                "Teste com grafo vazio ou todos indegree >0 resulta em fila vazia."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos vértices corretos identificados.",
                                "Eficiência: Implementação linear sem loops desnecessários.",
                                "Clareza: Código comentado e lista rotulada.",
                                "Robustez: Trata casos edge (grafo vazio, todos indegree 0).",
                                "Integração: Fila pronta para próximo passo de Kahn.",
                                "Documentação: Explicação do processo em 2-3 frases."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e contagem de graus.",
                                "Programação: Estruturas de dados (arrays, queues) e loops.",
                                "Gestão de Projetos: Identificação de tarefas independentes.",
                                "Ciência da Computação: Pré-requisitos em compiladores e scheduling."
                              ],
                              "realWorldApplication": "No gerenciamento de dependências de software (ex: build systems como Make ou npm), identifica pacotes sem dependências para instalação inicial; em pipelines CI/CD, marca jobs prontos para execução paralela."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.2",
                        "name": "Inicialização e Processamento com Fila",
                        "description": "Uso de uma fila (queue) para gerenciar os vértices sem dependências pendentes, processando-os em ordem e removendo suas arestas de saída.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.2.1",
                            "name": "Inicializar a fila com nós de indegree zero",
                            "description": "Criar uma fila e enfileirar todos os vértices com indegree igual a zero, marcando o início do processo de ordenação topológica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as estruturas de dados necessárias",
                                  "subSteps": [
                                    "Revise o array ou mapa de indegrees calculado anteriormente para o grafo.",
                                    "Selecione a estrutura de fila apropriada (ex: queue ou deque em linguagens como Python, Java ou C++).",
                                    "Inicialize a fila como vazia.",
                                    "Garanta que o grafo (adjacência e indegrees) esteja acessível em memória.",
                                    "Defina variáveis auxiliares se necessário, como uma lista para a ordem topológica."
                                  ],
                                  "verification": "Verifique se a fila foi criada vazia e o mapa de indegrees está completo sem erros de indexação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Documentação de estruturas de fila da linguagem (ex: collections.deque em Python)",
                                    "Representação do grafo de exemplo"
                                  ],
                                  "tips": "Prefira filas baseadas em lista duplamente encadeada (deque) para eficiência em enfileiramento e desfileiramento.",
                                  "learningObjective": "Compreender a inicialização correta de filas para algoritmos de grafos e preparar dados para iteração.",
                                  "commonMistakes": [
                                    "Usar array simples em vez de fila, perdendo propriedades FIFO",
                                    "Esquecer de importar módulos de fila",
                                    "Não validar se indegrees foram calculados corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar todos os nós com indegree zero",
                                  "subSteps": [
                                    "Percorra todos os vértices do grafo usando um loop.",
                                    "Para cada vértice, verifique se seu indegree é igual a zero.",
                                    "Colete esses vértices em uma lista temporária ou diretamente prepare para enfileiramento.",
                                    "Registre o número de nós encontrados para fins de validação posterior.",
                                    "Trate casos especiais como grafo vazio ou todos nós com indegree zero."
                                  ],
                                  "verification": "Liste manualmente ou imprima os nós identificados e confirme que todos têm indegree 0 consultando o mapa.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis para grafo manual",
                                    "Código de exemplo com grafo representado como dict de listas",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Use um loop for simples sobre chaves do grafo para eficiência O(V), onde V é o número de vértices.",
                                  "learningObjective": "Dominar a iteração sobre grafos para filtrar nós iniciais baseados em indegree.",
                                  "commonMistakes": [
                                    "Incluir nós com indegree >0 por erro de comparação",
                                    "Ignorar nós isolados (indegree 0)",
                                    "Usar loop ineficiente como O(V^2)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Enfileirar os nós identificados",
                                  "subSteps": [
                                    "Para cada nó com indegree zero na lista temporária, execute a operação enqueue.",
                                    "Mantenha a ordem de descoberta ou alfabética se não especificado (FIFO garante ordem topológica válida).",
                                    "Atualize um contador de nós enfileirados.",
                                    "Imprima ou logue o estado da fila para inspeção.",
                                    "Confirme que a fila não excedeu o número esperado de nós iniciais."
                                  ],
                                  "verification": "Desenfileire e reinsira os nós para checar se a fila preserva a ordem e contém exatamente os nós corretos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código template do Algoritmo de Kahn",
                                    "Ferramentas de visualização de grafo (Graphviz, online tools)",
                                    "Console para prints de debug"
                                  ],
                                  "tips": "Enfileire em ordem de ID ou label para consistência em testes automatizados.",
                                  "learningObjective": "Aplicar operações de fila (enqueue) de forma correta em contexto de algoritmos grafos.",
                                  "commonMistakes": [
                                    "Enfileirar duplicatas",
                                    "Usar push/pop em vez de enqueue/dequeue",
                                    "Alterar indegrees prematuramente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a inicialização da fila",
                                  "subSteps": [
                                    "Conte o tamanho da fila e compare com o número esperado de indegree zero.",
                                    "Verifique aleatoriamente alguns nós na fila para confirmar indegree zero.",
                                    "Simule o próximo passo do algoritmo (desenfileirar) sem alterar dados.",
                                    "Teste com grafos de borda (vazio, único nó, ciclo detectado indiretamente).",
                                    "Documente o estado inicial para relatórios ou testes unitários."
                                  ],
                                  "verification": "Execute uma asserção ou teste unitário que falhe se fila não contiver apenas nós corretos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Framework de testes (pytest, JUnit)",
                                    "Grafo de teste múltiplos (JSON ou código)",
                                    "Calculadora para contagens manuais"
                                  ],
                                  "tips": "Implemente funções auxiliares como count_indegree_zero() para reutilização.",
                                  "learningObjective": "Desenvolver hábitos de validação em implementações de algoritmos para robustez.",
                                  "commonMistakes": [
                                    "Pular validação assumindo correção",
                                    "Não testar casos edge como grafo vazio",
                                    "Confundir fila com pilha"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo de dependências de software: Nós A (indegree 0), B->A (1), C->A (1), D->B,C (2). Após calcular indegrees, inicialize fila vazia e enfileire A. Fila: [A]. Isso inicia o processamento onde A pode ser 'compilada' primeiro.",
                              "finalVerifications": [
                                "Fila contém exatamente todos os nós com indegree zero do grafo.",
                                "Nenhum nó com indegree >0 está presente na fila.",
                                "A ordem na fila respeita FIFO e permite ordenação topológica válida.",
                                "Tamanho da fila é correto e não excede número de vértices.",
                                "Estrutura de fila é eficiente (O(1) enqueue/dequeue).",
                                "Validação passa em testes unitários com múltiplos grafos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de nós (100% corretos).",
                                "Eficiência temporal: O(V) para inicialização.",
                                "Correção da implementação de fila (sem overflow/underflow).",
                                "Tratamento de casos edge (grafo vazio, todos indegree 0).",
                                "Clareza do código com comentários e validações.",
                                "Robustez: funciona com grafos grandes (até 10^4 vértices)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos (Matemática Discreta): Conceitos de indegree e DAGs.",
                                "Estruturas de Dados (Programação): Implementação e uso de queues.",
                                "Análise de Algoritmos: Complexidade O(V+E) do Kahn.",
                                "Gerenciamento de Projetos: Modelagem de dependências como pré-requisitos."
                              ],
                              "realWorldApplication": "Em sistemas de build de software (ex: Make, Gradle), onde módulos sem dependências são compilados primeiro; ou em agendamento de tarefas em pipelines CI/CD, garantindo execução em ordem topológica sem ciclos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.3.2.2",
                            "name": "Processar vértices da fila",
                            "description": "Enquanto a fila não estiver vazia, desenfileirar um vértice, adicioná-lo à sequência topológica e processar suas arestas de saída.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar se a fila está vazia",
                                  "subSteps": [
                                    "Acesse a estrutura da fila utilizada no algoritmo (ex: queue em Python ou Java).",
                                    "Verifique o tamanho da fila ou use o método isEmpty() equivalente.",
                                    "Se a fila estiver vazia, saia do loop while.",
                                    "Caso contrário, prossiga para o próximo passo do processamento.",
                                    "Registre o estado atual da fila para depuração."
                                  ],
                                  "verification": "Confirme que o loop só continua se queue.size() > 0 e para quando vazia.",
                                  "estimatedTime": "3 minutos",
                                  "materials": "Código fonte do algoritmo de Kahn, debugger ou console para inspecionar fila.",
                                  "tips": "Use breakpoints no debugger para pausar e inspecionar a fila em cada iteração.",
                                  "learningObjective": "Entender a condição de parada do loop para evitar processamento infinito.",
                                  "commonMistakes": "Esquecer de verificar a condição vazia, causando loop infinito; inverter a lógica (while vazia)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Desenfileirar um vértice da fila",
                                  "subSteps": [
                                    "Chame o método dequeue() ou popleft() para remover o vértice da frente da fila.",
                                    "Armazene o vértice removido em uma variável temporária (ex: currentVertex).",
                                    "Atualize o contador de vértices processados se necessário.",
                                    "Imprima ou logue o vértice desenfileirado para rastreamento.",
                                    "Verifique se o vértice é válido (não nulo)."
                                  ],
                                  "verification": "O vértice foi removido corretamente da fila e está armazenado na variável.",
                                  "estimatedTime": "4 minutos",
                                  "materials": "Implementação da fila (Queue), grafo de exemplo com vértices iniciais.",
                                  "tips": "Sempre armazene o resultado do dequeue antes de usá-lo, pois a fila modifica o estado.",
                                  "learningObjective": "Dominar a operação de desenfileiramento em filas para acesso FIFO.",
                                  "commonMistakes": "Usar pop() em vez de popleft() em listas Python (violando FIFO); não armazenar o vértice."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar o vértice à sequência topológica",
                                  "subSteps": [
                                    "Acesse a lista ou array que armazena a ordem topológica (ex: topoOrder).",
                                    "Anexe o currentVertex ao final da sequência usando append() ou add().",
                                    "Atualize o índice ou tamanho da sequência se rastreado.",
                                    "Valide que a ordem mantém a precedência (sem ciclos detectados).",
                                    "Logue a adição para visualização da ordem parcial."
                                  ],
                                  "verification": "O vértice aparece na posição correta no final da lista topoOrder.",
                                  "estimatedTime": "3 minutos",
                                  "materials": "Lista para ordem topológica, console para imprimir a sequência atual.",
                                  "tips": "Mantenha a sequência como lista mutável para eficiência em appends repetidos.",
                                  "learningObjective": "Compreender como construir incrementalmente a ordenação topológica.",
                                  "commonMistakes": "Inserir no início em vez do final, violando a ordem; duplicar vértices."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Processar as arestas de saída do vértice",
                                  "subSteps": [
                                    "Obtenha a lista de vizinhos (arestas de saída) do currentVertex no grafo.",
                                    "Para cada vizinho, decrementar seu indegree em 1.",
                                    "Se o indegree do vizinho chegar a 0, enfileire-o na fila.",
                                    "Atualize o grafo ou mapa de indegrees após o processamento.",
                                    "Continue o loop voltando à verificação da fila."
                                  ],
                                  "verification": "Todos vizinhos tiveram indegree decrementado e novos zeros foram enfileirados.",
                                  "estimatedTime": "6 minutos",
                                  "materials": "Representação do grafo (adjacency list), mapa de indegrees.",
                                  "tips": "Use um loop for sobre as arestas de saída para processar todos vizinhos de uma vez.",
                                  "learningObjective": "Aplicar redução de dependências para liberar vértices subsequentes.",
                                  "commonMistakes": "Decrementar indegree errado (do vértice atual); esquecer de enfileirar quando zero."
                                }
                              ],
                              "practicalExample": "Considere um grafo de tarefas: A->B, A->C, B->D. Indegrees: A=0, B=1, C=1, D=1. Fila inicial: [A]. Iteração 1: Fila não vazia → Desenfileira A → Adiciona A à ordem → Processa B (indegree=0, enfileira), C (0, enfileira). Fila: [B,C]. Iteração 2: Desenfileira B → Adiciona B → Processa D (0, enfileira). E assim por diante até ordem: [A,B,C,D].",
                              "finalVerifications": [
                                "A fila está vazia ao final do processamento?",
                                "Todos vértices foram adicionados exatamente uma vez à sequência topológica?",
                                "Indegrees foram corretamente reduzidos apenas para vizinhos reais?",
                                "Novos vértices só foram enfileirados quando indegree=0?",
                                "A ordem topológica respeita todas as precedências do grafo?",
                                "Nenhum ciclo foi detectado (todos vértices processados)?"
                              ],
                              "assessmentCriteria": [
                                "Correção na condição while (fila não vazia).",
                                "Desenfileiramento e adição à ordem sem erros FIFO.",
                                "Processamento preciso de arestas: decremento e enfileiramento condicional.",
                                "Eficiência temporal O(V+E) mantida no loop.",
                                "Tratamento de casos edge: grafo vazio, único vértice, ciclos.",
                                "Código limpo com logs para depuração."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e indegrees/outdegrees.",
                                "Engenharia de Software: Gerenciamento de dependências em builds (Maven/Gradle).",
                                "Ciência da Computação: Filas e estruturas de dados lineares.",
                                "Gestão de Projetos: Scheduling de tarefas com precedências (PERT/CPM)."
                              ],
                              "realWorldApplication": "Em compiladores, ordena módulos com dependências para build eficiente; em gerenciamento de projetos, sequencia tarefas como 'instalar dependências antes de compilar'; em sistemas de recomendação, processa jobs paralelizáveis em pipelines de dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.3.3",
                        "name": "Atualização de Indegrees e Verificação de Ciclo",
                        "description": "Atualizar os graus de entrada dos vizinhos após remover um vértice e verificar se todos os vértices foram processados para detectar ciclos.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.3.3.1",
                            "name": "Atualizar indegrees dos vizinhos",
                            "description": "Para cada vizinho de um vértice processado, decrementar seu indegree e, se atingir zero, enfileirar o vizinho.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e acessar a lista de vizinhos do vértice processado",
                                  "subSteps": [
                                    "Localize o vértice atual removido da fila (ou pilha/processado).",
                                    "Acesse a representação do grafo (adjacency list) para obter a lista de vizinhos diretos (arestas de saída).",
                                    "Liste todos os vizinhos explicitamente para o passo atual.",
                                    "Confirme que apenas vizinhos diretos (sucessores) estão sendo considerados, ignorando predecessores.",
                                    "Registre o número de vizinhos para rastreamento."
                                  ],
                                  "verification": "Verifique se a lista de vizinhos corresponde exatamente às arestas de saída do vértice no grafo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Representação do grafo (adjacency list)",
                                    "Diagrama visual do grafo",
                                    "Pseudocódigo do algoritmo"
                                  ],
                                  "tips": "Use um dicionário ou mapa para adjacency list para acesso O(1).",
                                  "learningObjective": "Compreender como navegar na estrutura de dados do grafo para obter vizinhos.",
                                  "commonMistakes": [
                                    "Confundir vizinhos de entrada (predecessores) com de saída.",
                                    "Acessar vizinhos de vértices não processados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Decrementar o indegree de cada vizinho",
                                  "subSteps": [
                                    "Para cada vizinho na lista, localize seu valor atual de indegree em uma estrutura auxiliar (array ou mapa).",
                                    "Subtraia 1 do indegree do vizinho.",
                                    "Atualize o valor no armazenamento de indegrees.",
                                    "Registre o novo valor de indegree para depuração.",
                                    "Garanta que o decremento ocorra apenas uma vez por aresta (evite loops paralelos)."
                                  ],
                                  "verification": "Confira que cada vizinho teve seu indegree reduzido exatamente em 1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mapa ou array de indegrees",
                                    "Exemplo de grafo com valores iniciais",
                                    "Editor de código para simulação"
                                  ],
                                  "tips": "Mantenha indegrees em um array indexado por ID do vértice para eficiência.",
                                  "learningObjective": "Dominar a atualização precisa de contadores de dependências em grafos.",
                                  "commonMistakes": [
                                    "Decrementar múltiplas vezes para a mesma aresta.",
                                    "Usar outdegree em vez de indegree."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar se indegree chegou a zero e enfileirar vizinhos prontos",
                                  "subSteps": [
                                    "Após decremento, cheque se o novo indegree do vizinho é igual a zero.",
                                    "Se zero, adicione o vizinho à fila (queue) de processamento.",
                                    "Se não zero, ignore e prossiga para o próximo vizinho.",
                                    "Repita para todos os vizinhos do vértice atual.",
                                    "Confirme que a fila não tem duplicatas (use set se necessário)."
                                  ],
                                  "verification": "Simule o passo e veja se vizinhos com todas dependências resolvidas foram enfileirados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Fila (queue) estrutura de dados",
                                    "Pseudocódigo com loop for-each",
                                    "Ferramenta de visualização de grafo como Graphviz"
                                  ],
                                  "tips": "Use uma queue FIFO para manter a ordem topológica.",
                                  "learningObjective": "Aplicar condição de prontidão (indegree zero) para escalonamento.",
                                  "commonMistakes": [
                                    "Enfileirar vizinhos com indegree >0.",
                                    "Esquecer de enfileirar quando chega a zero."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a atualização no contexto do algoritmo completo",
                                  "subSteps": [
                                    "Execute o passo para todos vizinhos e avance para o próximo vértice da fila.",
                                    "Monitore o total de vértices processados vs. totais no grafo.",
                                    "Registre logs de mudanças em indegrees e fila.",
                                    "Prepare para detecção de ciclo (se nem todos processados).",
                                    "Teste com grafo de exemplo completo."
                                  ],
                                  "verification": "O número de vértices na fila reflete corretamente as atualizações.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Grafo de teste completo",
                                    "Código implementado ou simulador",
                                    "Papel para tracing manual"
                                  ],
                                  "tips": "Trace manualmente em papel antes de codificar para visualizar fluxo.",
                                  "learningObjective": "Integrar a atualização em um loop iterativo do algoritmo de Kahn.",
                                  "commonMistakes": [
                                    "Processar vértices múltiplas vezes.",
                                    "Ignorar detecção de ciclo pós-atualização."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo DAG: A->B, A->C, B->D, C->D. Indegrees iniciais: A:0, B:1, C:1, D:2. Processe A (fila vazia após): vizinhos B e C. Decremente B para 0 (enfileire), C para 0 (enfileire). Fila agora: B,C. Processe B: vizinho D decrementa para 1 (não enfileira). Processe C: D decrementa para 0 (enfileira).",
                              "finalVerifications": [
                                "Todos vizinhos do vértice processado tiveram indegree decrementado exatamente uma vez.",
                                "Vizinhos com indegree zero foram adicionados à fila sem duplicatas.",
                                "Indegrees negativos não ocorrem em nenhum vértice.",
                                "A fila reflete apenas vértices prontos (indegree=0).",
                                "O passo preserva a propriedade de ordenação topológica.",
                                "Nenhum vizinho predecessor foi alterado incorretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão no decremento: 100% dos vizinhos atualizados corretamente.",
                                "Lógica de enfileiramento: Enfileira apenas quando indegree==0.",
                                "Eficiência: Tempo O(degree do vértice), sem loops desnecessários.",
                                "Tratamento de erros: Evita underflow ou overflow em indegrees.",
                                "Integração: Funciona em loop completo do algoritmo sem quebrar.",
                                "Depuração: Logs ou traces mostram mudanças claras."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e contagem de graus direcionados.",
                                "Programação: Estruturas de dados (queues, maps) e iteração.",
                                "Engenharia de Software: Gerenciamento de dependências em builds.",
                                "Análise de Algoritmos: Complexidade O(V+E) no contexto topológico."
                              ],
                              "realWorldApplication": "Em sistemas de build como Make ou Gradle, atualiza dependências de tarefas após compilação de pré-requisitos; em compiladores, ordena módulos para linkagem evitando ciclos; em pipelines CI/CD, escalona jobs paralelizáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.2",
                            "name": "Construir a sequência topológica",
                            "description": "Manter uma lista que acumula os vértices na ordem em que são desenfileirados, formando a ordenação topológica final.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar a lista de sequência topológica",
                                  "subSteps": [
                                    "Criar uma lista vazia (array ou linked list) para armazenar a ordenação topológica final.",
                                    "Definir o nome da lista, como 'topologicalOrder' ou 'resultado'.",
                                    "Garantir que a lista suporte inserções no final de forma eficiente (O(1) tempo).",
                                    "Inicializar contadores auxiliares, como 'numVerticesProcessados = 0'.",
                                    "Verificar se a lista foi criada corretamente com um teste unitário simples."
                                  ],
                                  "verification": "Executar um teste que verifica se a lista está vazia antes de iniciar o algoritmo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Biblioteca de grafos (ex: NetworkX em Python ou implementação customizada)"
                                  ],
                                  "tips": "Use uma estrutura de dados como ArrayList em Java ou lista em Python para simplicidade e eficiência.",
                                  "learningObjective": "Compreender a importância de uma estrutura auxiliar para acumular a ordem topológica.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar a lista, causando erros de referência nula.",
                                    "Usar uma fila em vez de lista para acumulação, confundindo com a fila de Kahn."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Integrar adição à lista no loop principal do algoritmo de Kahn",
                                  "subSteps": [
                                    "No loop while da fila não estiver vazia: desenfileirar o vértice atual.",
                                    "Adicionar o vértice desenfileirado ao final da lista de sequência topológica.",
                                    "Incrementar o contador de vértices processados.",
                                    "Atualizar os indegrees dos vizinhos adjacentes (remover arestas).",
                                    "Enfileirar vizinhos com indegree zero na fila principal."
                                  ],
                                  "verification": "Inserir prints ou logs para confirmar que cada vértice desenfileirado é adicionado à lista na ordem correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Grafo de exemplo representado como dicionário de adjacência e array de indegrees",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Sempre adicione após desenfileirar, antes de processar vizinhos, para manter a ordem correta.",
                                  "learningObjective": "Implementar a acumulação dinâmica da sequência durante o processamento BFS.",
                                  "commonMistakes": [
                                    "Adicionar vértices antes de desenfileirar, violando a ordem topológica.",
                                    "Duplicar vértices na lista por erro no loop."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar completude da sequência e detectar ciclos",
                                  "subSteps": [
                                    "Após o loop while, comparar o número de vértices processados com o total de vértices no grafo.",
                                    "Se numVerticesProcessados < totalVertices, detectar ciclo e retornar lista vazia ou sinalizar erro.",
                                    "Caso contrário, a lista está completa e representa a ordenação topológica válida.",
                                    "Opcionalmente, validar a ordem: para cada aresta u->v, u aparece antes de v na lista.",
                                    "Documentar o resultado em um log ou retorno de função."
                                  ],
                                  "verification": "Testar com grafo acíclico (deve processar todos) e cíclico (deve detectar incompleto).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Grafos de teste: um DAG simples e um com ciclo",
                                    "Ferramenta de testes unitários (JUnit ou pytest)"
                                  ],
                                  "tips": "Use uma flag booleana para indicar detecção de ciclo, facilitando o tratamento de erros.",
                                  "learningObjective": "Garantir que a sequência seja válida apenas em grafos acíclicos.",
                                  "commonMistakes": [
                                    "Ignorar a verificação de completude, retornando ordenação parcial em grafos cíclicos.",
                                    "Comparar errado o contador, causando falsos positivos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar e retornar a sequência topológica",
                                  "subSteps": [
                                    "Converter a lista em formato de saída desejado (array, string ou objeto).",
                                    "Implementar função de retorno que inclui a lista e status (válida ou ciclo detectado).",
                                    "Adicionar comentários explicando o propósito de cada parte do código.",
                                    "Executar testes completos com múltiplos grafos.",
                                    "Otimizar se necessário (ex: evitar cópias desnecessárias da lista)."
                                  ],
                                  "verification": "Chamar a função e inspecionar se a lista retornada respeita todas as dependências do grafo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código fonte completo do algoritmo de Kahn",
                                    "Exemplos de grafos variados"
                                  ],
                                  "tips": "Retorne um objeto com lista e booleano de validade para uso flexível.",
                                  "learningObjective": "Encapsular a construção da sequência em uma função reutilizável e robusta.",
                                  "commonMistakes": [
                                    "Retornar lista vazia sem indicar ciclo, confundindo o chamador.",
                                    "Não otimizar inserções, impactando performance em grafos grandes."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo de dependências de tarefas de software: Tarefa A (compilar src), B (testar), C (empacotar). Indegrees iniciais: A=0, B=1 (dep de A), C=1 (dep de B). Fila inicial: [A]. Desenfileira A → lista=[A], atualiza B indegree=0 → fila=[B]. Desenfileira B → lista=[A,B], atualiza C=0 → fila=[C]. Desenfileira C → lista=[A,B,C]. Todos processados: sequência válida [A,B,C].",
                              "finalVerifications": [
                                "A lista contém exatamente o número total de vértices do grafo.",
                                "Nenhum vértice é duplicado na sequência.",
                                "Para toda aresta u→v, índice de u < índice de v na lista.",
                                "O contador de processados equals total de vértices.",
                                "Função retorna erro apropriado em grafos com ciclo.",
                                "Performance é O(V+E) com inserções eficientes."
                              ],
                              "assessmentCriteria": [
                                "Correção: Sequência respeita todas as dependências topológicas.",
                                "Robustez: Detecta e sinaliza grafos cíclicos corretamente.",
                                "Eficiência: Usa estruturas O(1) para inserções e verificações.",
                                "Clareza: Código bem comentado com nomes de variáveis intuitivos.",
                                "Testabilidade: Inclui validação interna e exemplos de uso.",
                                "Modularidade: Fácil integração em algoritmo maior de Kahn."
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Modelagem de dependências em cronogramas (PERT/CPM).",
                                "Compilação de Software: Ordem de build de módulos com dependências.",
                                "Inteligência Artificial: Ordenação de tarefas em planejamento de ações.",
                                "Matemática Discreta: Conceitos de grafos direcionados e acíclicos."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, usado em sistemas de build como Make ou Gradle para determinar ordem de compilação de arquivos com dependências, evitando erros de 'arquivo não encontrado'; em pipelines CI/CD para execução sequencial de testes e deploys."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.3",
                            "name": "Detectar ciclo no grafo",
                            "description": "Comparar o número de vértices processados com o total de vértices; se menor, indicar a presença de um ciclo no grafo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar o contador de vértices processados",
                                  "subSteps": [
                                    "Declare uma variável 'processedCount' ou similar e inicialize-a com 0.",
                                    "Identifique o ponto no algoritmo de Kahn onde isso deve ocorrer: antes do loop principal da fila.",
                                    "Certifique-se de que o total de vértices (|V|) esteja acessível, como de um atributo do grafo.",
                                    "Adicione um comentário explicando o propósito: 'Contador para detecção de ciclo'.",
                                    "Teste a inicialização com um grafo simples para verificar valor zero."
                                  ],
                                  "verification": "Execute o código com um grafo vazio ou trivial e confirme que processedCount inicia em 0 via depuração ou print.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Exemplo de grafo representado como adjacência ou lista",
                                    "Debugger ou console para prints"
                                  ],
                                  "tips": "Use nomes de variáveis descritivos como 'verticesProcessed' para clareza no código.",
                                  "learningObjective": "Compreender a necessidade de rastrear vértices visitados para detecção de ciclo em ordenação topológica.",
                                  "commonMistakes": [
                                    "Inicializar contador dentro do loop (reinicia a cada iteração)",
                                    "Confundir com contador de arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Incrementar o contador durante o processamento da fila",
                                  "subSteps": [
                                    "Localize o loop while da fila no algoritmo de Kahn.",
                                    "Após remover um vértice da fila (dequeue), incremente processedCount++ imediatamente.",
                                    "Continue com a atualização de indegrees dos vizinhos, mas garanta que o incremento ocorra só uma vez por vértice.",
                                    "Adicione um print opcional para depuração: 'Processando vértice X, total processados: Y'.",
                                    "Verifique em um grafo acíclico que o contador aumenta corretamente a cada remoção."
                                  ],
                                  "verification": "Simule ou execute com um grafo acíclico linear (ex: A→B→C) e confirme que processedCount == |V| ao final do loop.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Grafo de teste acíclico desenhado no papel",
                                    "Ferramenta de visualização de grafos como Graphviz (opcional)"
                                  ],
                                  "tips": "Coloque o incremento logo após o dequeue para evitar contagens duplicadas em casos de múltiplas entradas na fila.",
                                  "learningObjective": "Integrar o rastreamento de processamento no fluxo principal do algoritmo de Kahn.",
                                  "commonMistakes": [
                                    "Incrementar antes do dequeue (pode contar entradas múltiplas)",
                                    "Incrementar dentro do loop de vizinhos (duplica por aresta)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar contador com total de vértices após o loop",
                                  "subSteps": [
                                    "Após o loop while (fila vazia), adicione uma condição if (processedCount < totalVertices).",
                                    "Se verdadeiro, defina uma flag 'hasCycle = true' ou retorne 'Ciclo detectado'.",
                                    "Caso contrário, 'hasCycle = false' ou 'DAG confirmado'.",
                                    "Registre o valor de processedCount para depuração.",
                                    "Teste com grafos cíclicos e acíclicos para validar a lógica."
                                  ],
                                  "verification": "Rode testes unitários: grafo com ciclo deve retornar true; sem ciclo, false. Verifique processedCount.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código com testes unitários (Jest ou similar)",
                                    "Dois grafos de teste: um cíclico, um acíclico"
                                  ],
                                  "tips": "Use |V| como graph.vertices.length para dinamismo, evitando hardcode.",
                                  "learningObjective": "Aplicar comparação simples para inferir propriedades globais do grafo (presença de ciclo).",
                                  "commonMistakes": [
                                    "Comparar dentro do loop (detecta prematuramente)",
                                    "Usar == em vez de < (ignora grafos desconexos)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar detecção de ciclo na função completa e reportar resultado",
                                  "subSteps": [
                                    "Encapsule a lógica em uma função como detectCycleKahn(graph).",
                                    "Retorne boolean ou objeto {hasCycle: bool, processed: int}.",
                                    "Adicione tratamento de grafos vazios ou com 0 arestas.",
                                    "Documente a função com JSDoc ou comentários.",
                                    "Execute em múltiplos exemplos e valide saídas."
                                  ],
                                  "verification": "Chame a função em 5 grafos variados (cíclico, acíclico, desconexo) e confirme resultados via asserts.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Suite de testes",
                                    "Papel para desenhar grafos de teste"
                                  ],
                                  "tips": "Para grafos desconexos, o algoritmo ainda funciona se todos componentes forem DAGs.",
                                  "learningObjective": "Construir uma detecção robusta de ciclo integrada ao algoritmo de ordenação topológica.",
                                  "commonMistakes": [
                                    "Esquecer grafos com múltiplos componentes",
                                    "Não tratar |V|=0"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo direcionado: vértices [0,1,2], arestas [0→1, 1→2, 2→0]. Indegrees iniciais: [0:1,1:1,2:1]. Fila inicial vazia. Loop não executa, processedCount=0 < 3 → ciclo detectado. Em contraste, grafo [0→1,1→2]: processedCount=3 ==3 → sem ciclo.",
                              "finalVerifications": [
                                "processedCount é inicializado corretamente em 0 antes do loop.",
                                "processedCount incrementa exatamente uma vez por vértice removido da fila.",
                                "Após loop, comparação processedCount < |V| é precisa.",
                                "Função retorna true para grafos cíclicos e false para DAGs.",
                                "Funciona em grafos desconexos sem ciclos.",
                                "Depuração mostra valores corretos em prints opcionais."
                              ],
                              "assessmentCriteria": [
                                "Correção: Detecta ciclos em 100% dos casos de teste.",
                                "Eficiência: O(n) tempo, sem overhead desnecessário.",
                                "Clareza: Código legível com comentários e nomes descritivos.",
                                "Robustez: Trata bordas (grafo vazio, isolados).",
                                "Integração: Funciona seamless no algoritmo de Kahn completo.",
                                "Testabilidade: Inclui ou permite testes unitários fáceis."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e propriedades de DAGs.",
                                "Lógica e Programação: Condicionais e contadores em algoritmos.",
                                "Ciência da Computação: Análise de complexidade e detecção de propriedades.",
                                "Engenharia de Software: Detecção de dependências circulares."
                              ],
                              "realWorldApplication": "Em compiladores e build systems (ex: Maven, npm) para detectar dependências circulares em pacotes; em agendamento de tarefas (ex: Makefiles, pipelines CI/CD) para evitar loops infinitos; em análise de redes sociais para ciclos de influência."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.3.3.4",
                            "name": "Implementar o algoritmo completo",
                            "description": "Integrar todos os passos em uma função que recebe um grafo e retorna a ordenação topológica ou detecta ciclo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a assinatura da função e inicializar estruturas de dados",
                                  "subSteps": [
                                    "Criar a função `topologicalSort(grafo)` que recebe uma lista de adjacência representando o grafo direcionado.",
                                    "Inicializar um dicionário `indegrees` com todos os nós tendo valor 0.",
                                    "Criar uma fila (queue) vazia usando `collections.deque()`.",
                                    "Inicializar uma lista vazia `resultado` para armazenar a ordenação.",
                                    "Obter a lista completa de nós únicos do grafo."
                                  ],
                                  "verification": "Verificar se todas as estruturas foram criadas sem erros e contêm os dados iniciais corretos (imprimir ou depurar).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de código (VS Code ou PyCharm), biblioteca `collections` do Python, grafo de exemplo simples.",
                                  "tips": "Use `defaultdict(int)` para `indegrees` para evitar KeyError em nós sem entradas.",
                                  "learningObjective": "Compreender os componentes necessários para o algoritmo de Kahn e preparar o ambiente de execução.",
                                  "commonMistakes": "Esquecer de incluir nós isolados (sem arestas) na lista de nós ou no cálculo de indegrees."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular os graus de entrada (indegrees) de todos os nós",
                                  "subSteps": [
                                    "Percorrer todos os nós e definir `indegrees[no] = 0` inicialmente.",
                                    "Para cada nó `u` no grafo, para cada vizinho `v` em `grafo[u]`, incrementar `indegrees[v] += 1`.",
                                    "Verificar se todos os nós foram processados corretamente.",
                                    "Tratar nós sem vizinhos explicitamente.",
                                    "Imprimir os indegrees para validação inicial."
                                  ],
                                  "verification": "Os valores de indegrees devem corresponder ao número de arestas entrantes em cada nó (comparar manualmente com grafo desenhado).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo editor de código, papel e lápis para desenhar o grafo e validar indegrees.",
                                  "tips": "Evite modificar o grafo original; trabalhe com cópia se necessário.",
                                  "learningObjective": "Dominar o cálculo preciso de graus de entrada como pré-requisito para identificar nós iniciais.",
                                  "commonMistakes": "Incrementar indegree do próprio nó `u` em vez do vizinho `v`, ou duplicar contagens em grafos com múltiplas arestas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Enfileirar todos os nós com indegree zero",
                                  "subSteps": [
                                    "Percorrer todos os nós e verificar se `indegrees[no] == 0`.",
                                    "Se sim, adicionar o nó à fila `queue.append(no)`.",
                                    "Confirmar que a fila contém apenas nós sem dependências iniciais.",
                                    "Registrar o número inicial de nós na fila para depuração.",
                                    "Testar com um grafo simples para validar."
                                  ],
                                  "verification": "A fila deve conter exatamente os nós sem arestas entrantes (verificar tamanho e conteúdo).",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Editor de código, debugger ou prints para inspecionar a fila.",
                                  "tips": "Use `from collections import deque` para fila eficiente (O(1) popleft).",
                                  "learningObjective": "Identificar e priorizar nós independentes para iniciar a ordenação.",
                                  "commonMistakes": "Adicionar nós com indegree >0 ou pular nós isolados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar o loop principal de processamento da fila",
                                  "subSteps": [
                                    "Enquanto a fila não estiver vazia: `u = queue.popleft()`.",
                                    "Adicionar `u` à lista `resultado`.",
                                    "Para cada vizinho `v` em `grafo[u]`: decrementar `indegrees[v] -= 1`.",
                                    "Se `indegrees[v] == 0`, enfileirar `v`.",
                                    "Continuar até esgotar a fila."
                                  ],
                                  "verification": "Simular passo a passo com prints: cada nó processado deve liberar dependentes corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor com breakpoints, grafo de teste com 5-6 nós.",
                                  "tips": "Use `popleft()` para FIFO; evite lista comum que é O(n) para remoção.",
                                  "learningObjective": "Implementar a propagação de liberação de dependências dinamicamente.",
                                  "commonMistakes": "Decrementar indegree incorreto ou não enfileirar quando chega a zero; loop infinito em grafos acíclicos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar detecção de ciclo e retornar o resultado",
                                  "subSteps": [
                                    "Contar o número total de nós `num_nos = len(nos)`.",
                                    "Se `len(resultado) == num_nos`, retornar `resultado`.",
                                    "Senão, retornar `None` ou mensagem `'Ciclo detectado'`.",
                                    "Adicionar tratamento para grafos vazios ou com um nó.",
                                    "Testar a função completa com exemplos."
                                  ],
                                  "verification": "Executar função em DAG (sucesso) e grafo com ciclo (falha correta).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Função de teste unitário (pytest ou asserts manuais), exemplos de grafos DAG e cíclico.",
                                  "tips": "Sempre compare com número exato de nós para precisão.",
                                  "learningObjective": "Garantir robustez na detecção de ciclos e output correto.",
                                  "commonMistakes": "Retornar ordenação parcial em caso de ciclo ou falhar em grafos vazios."
                                }
                              ],
                              "practicalExample": "Considere o grafo: {0: [1,2], 1: [3], 2: [3]}. Indegrees: {0:0,1:1,2:1,3:2}. Fila inicial: [0]. Processamento: 0 libera 1 e 2 (fila:[1,2]), 1 libera 3 (fila:[2,3] após 2), resulta em [0,1,2,3] ou [0,2,1,3]. Com ciclo {0:[1],1:[0]}: fila inicial vazia após cálculo, detecta ciclo.",
                              "finalVerifications": [
                                "A função executa sem exceções em grafos válidos.",
                                "Retorna ordenação completa e válida para DAGs (verificar se u antes de v se u->v).",
                                "Detecta corretamente ciclos retornando None ou mensagem.",
                                "Funciona com grafos vazios, um nó ou nós isolados.",
                                "Processa todos os nós exatamente uma vez.",
                                "Tempo de execução é O(V + E) em testes empíricos."
                              ],
                              "assessmentCriteria": [
                                "Correção funcional total (50%)",
                                "Detecção precisa de ciclos (20%)",
                                "Tratamento de casos edge (15%)",
                                "Legibilidade e comentários no código (10%)",
                                "Eficiência das estruturas de dados (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Aciclicidade",
                                "Gerenciamento de Projetos: Análise de Dependências de Tarefas",
                                "Engenharia de Software: Build Systems e Compiladores",
                                "Inteligência Artificial: Ordenação de Pré-requisitos em Planejamento"
                              ],
                              "realWorldApplication": "Implementado em compiladores (ex: ordenar módulos em GCC), sistemas de build (Make, Gradle para dependências), pipelines de CI/CD (Jenkins para jobs sequenciais), e análise de precedências em gerenciamento de projetos (Microsoft Project)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.3.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.4",
                    "name": "Algoritmo baseado em DFS",
                    "description": "Utiliza busca em profundidade e ordem reversa de finalização para obter a ordenação.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.4.1",
                        "name": "Busca em Profundidade (DFS) em Grafos Direcionados",
                        "description": "Fundamentos da busca em profundidade aplicada a grafos direcionados, incluindo representação adjacente e travessia recursiva.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.1.1",
                            "name": "Representar grafo direcionado com listas de adjacência",
                            "description": "Implementar estrutura de dados para grafo direcionado usando listas de adjacência em linguagem de programação como Python ou C++, garantindo acesso eficiente aos vizinhos de cada vértice.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Grafos Direcionados e Listas de Adjacência",
                                  "subSteps": [
                                    "Defina grafo direcionado: conjunto de vértices V e arestas E, onde arestas têm direção.",
                                    "Explique listas de adjacência: para cada vértice, uma lista dos vértices vizinhos (saída).",
                                    "Compare com matriz de adjacência: liste vantagens (espaço O(V+E) vs O(V²), eficiência para grafos esparsos).",
                                    "Discuta acesso eficiente: O(1) para verificar vizinho com hash, O(deg) para listar.",
                                    "Estude exemplo simples: grafo com vértices A->B, B->C."
                                  ],
                                  "verification": "Resuma em um parágrafo os conceitos e desenhe um grafo de 3 vértices com suas listas de adjacência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Documentação de grafos (Wikipedia ou livro-texto)"
                                  ],
                                  "tips": "Use diagramas visuais para fixar; foque em direção das arestas.",
                                  "learningObjective": "Compreender a representação de grafos direcionados via listas de adjacência e suas vantagens.",
                                  "commonMistakes": [
                                    "Confundir direção (aresta A->B não implica B->A)",
                                    "Ignorar grafos esparsos vs densos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Estrutura de Dados Básica em Python",
                                  "subSteps": [
                                    "Crie uma classe DirectedGraph com um dicionário adj_list = {} para mapear vértice: lista de vizinhos.",
                                    "Implemente método __init__ para inicializar adj_list vazio.",
                                    "Adicione método add_vertex(v) que garante v em adj_list com lista vazia se não existir.",
                                    "Teste básico: crie grafo, adicione vértice 'A', verifique adj_list['A'] == [].",
                                    "Garanta que vértices sejam strings ou ints mutáveis."
                                  ],
                                  "verification": "Execute código e imprima adj_list após adicionar um vértice; deve mostrar {'A': []}.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor Python (VS Code, Jupyter)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Use defaultdict(list) para simplificar inserções.",
                                  "learningObjective": "Implementar a base da estrutura para representar vértices e suas listas vazias.",
                                  "commonMistakes": [
                                    "Não tratar vértices inexistentes",
                                    "Usar lista fixa em vez de dict dinâmica"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Adição de Arestas e Acesso a Vizinhos",
                                  "subSteps": [
                                    "Crie método add_edge(u, v) que appenda v à adj_list[u] se u existir, senão crie.",
                                    "Implemente get_neighbors(u): retorne adj_list[u] se u existir, senão lista vazia.",
                                    "Adicione método has_edge(u, v): verifique se v está em adj_list[u].",
                                    "Teste: adicione A->B, A->C, B->C; verifique neighbors de A == ['B','C'].",
                                    "Otimize para múltiplas arestas: decida se permite duplicatas (use set se não)."
                                  ],
                                  "verification": "Adicione arestas e chame get_neighbors; compare com representação manual.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Python IDE",
                                    "Exemplos de grafos escritos"
                                  ],
                                  "tips": "Mantenha ordem de inserção com list; use 'in' para has_edge (O(deg)).",
                                  "learningObjective": "Adicionar arestas direcionadas e acessar vizinhos eficientemente.",
                                  "commonMistakes": [
                                    "Adicionar aresta reversa acidentalmente",
                                    "Não verificar existência de u antes de append"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Testar a Representação Completa",
                                  "subSteps": [
                                    "Crie método print_graph() para visualizar adj_list.",
                                    "Teste grafo completo: vértices A,B,C,D; arestas A->B, A->C, B->D, C->D.",
                                    "Verifique: neighbors(A) = ['B','C'], degree_out(A)=2.",
                                    "Implemente remove_edge(u,v) e teste remoção.",
                                    "Execute testes unitários com assert para vizinhos corretos."
                                  ],
                                  "verification": "Rode print_graph e confirme matches com diagrama manual; todos asserts passam.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Python com unittest ou pytest",
                                    "Diagrama do grafo de teste"
                                  ],
                                  "tips": "Use pytest para automação; desenhe grafo primeiro.",
                                  "learningObjective": "Garantir corretude e robustez da implementação via testes.",
                                  "commonMistakes": [
                                    "Índices off-by-one em listas",
                                    "Não tratar auto-loops ou arestas múltiplas"
                                  ]
                                }
                              ],
                              "practicalExample": "Represente um grafo de dependências de tarefas: T1 -> T2, T1 -> T3, T2 -> T4. adj_list = {'T1': ['T2','T3'], 'T2': ['T4'], 'T3': [], 'T4': []}. Acesse neighbors('T1') para tarefas bloqueadas por T1.",
                              "finalVerifications": [
                                "adj_list possui entrada para cada vértice adicionado com lista de vizinhos corretos.",
                                "Adicionar aresta u->v appenda v à lista de u sem duplicatas.",
                                "get_neighbors(u) retorna lista exata dos vizinhos de saída.",
                                "has_edge(u,v) retorna True apenas para arestas existentes.",
                                "Estrutura usa O(V+E) espaço e O(1) médio para add_edge/get_neighbor.",
                                "Testes com 5+ arestas passam sem erros."
                              ],
                              "assessmentCriteria": [
                                "Eficiência: Acesso a vizinhos em O(deg(u)) ou melhor.",
                                "Corretude: Todas arestas direcionadas preservadas sem perdas.",
                                "Robustez: Trata vértices/arestas inexistentes graciosamente.",
                                "Clareza: Código legível com docstrings e comentários.",
                                "Escalabilidade: Funciona para 100+ vértices sem lentidão.",
                                "Testes: Cobertura de 80%+ com casos edge (loops, vazios)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos, Matrizes e Relações Binárias.",
                                "Algoritmos: Pré-requisito para DFS, Topological Sort e Cycle Detection.",
                                "Ciência de Dados: Representação de redes sociais ou web graphs.",
                                "Engenharia de Software: Modelagem de dependências em builds (Maven/Gradle).",
                                "Física: Modelos de redes de fluxo ou cadeias de Markov."
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento de projetos (ex: Jira), representa dependências de tarefas para ordenação topológica; em compiladores, modela dependências de módulos; em redes sociais, modela 'segue' direcionado para recomendações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.4.1.2",
                            "name": "Implementar DFS recursivo básico",
                            "description": "Codificar função recursiva de DFS que visita todos os vizinhos de um vértice, marcando vértices visitados para evitar ciclos infinitos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a representação do grafo e estruturas auxiliares",
                                  "subSteps": [
                                    "Represente o grafo direcionado como um dicionário onde chaves são vértices (strings ou ints) e valores são listas de vizinhos.",
                                    "Crie um grafo de exemplo com pelo menos 4 vértices e 5 arestas direcionadas, sem ciclos inicialmente.",
                                    "Inicialize um conjunto vazio 'visited' para rastrear vértices visitados (use set()).",
                                    "Defina uma lista 'order' vazia para coletar vértices na ordem de finalização (pós-ordem reversa para topo sort).",
                                    "Escreva uma função auxiliar para adicionar arestas ao grafo."
                                  ],
                                  "verification": "Execute print(grafo) e print(visited); confirme que grafo é dict de lists, visited é set vazio e order é lista vazia.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Python 3.x",
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Documentação de dict e set no Python"
                                  ],
                                  "tips": "Use collections.defaultdict(list) para o grafo para evitar KeyError ao adicionar arestas.",
                                  "learningObjective": "Dominar a representação adjacência de grafos direcionados e estruturas para controle de estado em DFS.",
                                  "commonMistakes": [
                                    "Usar lista em vez de dict para grafo, causando indexação incorreta.",
                                    "Inicializar visited como lista, levando a verificações O(n) lentas.",
                                    "Esquecer de importar collections para defaultdict."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a assinatura e parâmetros da função DFS recursiva",
                                  "subSteps": [
                                    "Defina def dfs(node, grafo, visited, order): como função recursiva.",
                                    "Adicione verificação inicial: if node in visited: return",
                                    "Marque o nó atual como visitado: visited.add(node)",
                                    "Planeje o loop sobre vizinhos: for neighbor in grafo[node]:",
                                    "Adicione chamada recursiva dfs(neighbor, grafo, visited, order)"
                                  ],
                                  "verification": "Escreva o esqueleto da função e teste chamando com nó inválido; confirme que retorna sem erro e sem recursão.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Mesmo ambiente do Step 1",
                                    "Exemplos de funções recursivas em Python (docs.python.org)"
                                  ],
                                  "tips": "Passar visited e order como parâmetros mutáveis permite compartilhamento de estado entre chamadas recursivas.",
                                  "learningObjective": "Entender parâmetros globais em recursão para evitar cópias desnecessárias e manter estado.",
                                  "commonMistakes": [
                                    "Definir função sem parâmetros mutáveis, causando reinicialização a cada chamada.",
                                    "Usar == para checar visited, em vez de 'in'.",
                                    "Esquecer de passar grafo como parâmetro."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a lógica completa de recursão e pós-processamento",
                                  "subSteps": [
                                    "Implemente o loop for neighbor in grafo.get(node, []): dfs(neighbor, grafo, visited, order)",
                                    "Após o loop de vizinhos, adicione order.append(node) para capturar ordem de finalização.",
                                    "Garanta que get(node, []) evite KeyError em nós sem vizinhos.",
                                    "Adicione print opcionais para depuração: print(f'Visitando {node}')",
                                    "Retorne nada (função void), mas modifique order in-place."
                                  ],
                                  "verification": "Chame dfs em um nó raiz; inspecione visited (todos acessíveis marcados) e order (nós em pós-ordem).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Debugger do editor (pdb ou breakpoints)",
                                    "Grafo de teste com caminhos múltiplos"
                                  ],
                                  "tips": "Use grafo.get(node, []) para robustez; teste com nó folha primeiro.",
                                  "learningObjective": "Implementar recursão em profundidade com marcação e coleta de ordem pós-recursiva.",
                                  "commonMistakes": [
                                    "Recursar antes de marcar visited, causando stack overflow em ciclos.",
                                    "Append node antes do loop, violando pós-ordem.",
                                    "Loop infinito por esquecer 'if node in visited: return'."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar, testar e validar a função DFS em grafos completos",
                                  "subSteps": [
                                    "Crie função principal def topological_sort(grafo): que itera sobre todos nós e chama dfs se não visitado.",
                                    "Teste com grafo acíclico: verifique se order reversa é topo válida (sem antecessores após sucessores).",
                                    "Introduza um ciclo e teste: função deve visitar sem infinito, mas topo falhará (detecção futura).",
                                    "Execute com múltiplos componentes: confirme todos visitados.",
                                    "Otimize: reverta order ao final para ordem topológica."
                                  ],
                                  "verification": "Para grafo exemplo, imprima order[::-1]; confirme ordem topológica manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Grafos de teste prontos (cíclico e acíclico)",
                                    "Ferramenta de visualização como Graphviz (opcional)"
                                  ],
                                  "tips": "Sempre teste com grafo pequeno: 4 nós, visualize mentalmente a pilha de recursão.",
                                  "learningObjective": "Aplicar DFS em grafos completos, lidando com múltiplas componentes e validação.",
                                  "commonMistakes": [
                                    "Não iterar sobre todos nós, perdendo componentes desconectados.",
                                    "Reverter order incorretamente.",
                                    "Ignorar nós sem saída, que vão para o início da topo order."
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo de dependências de tarefas: {'T1': ['T2', 'T3'], 'T2': ['T4'], 'T3': [], 'T4': []}. Chame dfs('T1', grafo, visited, order). Esperado: visited={'T1','T2','T3','T4'}, order=['T4','T2','T3','T1'] (reverso: T1,T3,T2,T4 - ordem topológica válida).",
                              "finalVerifications": [
                                "Função marca todos vértices acessíveis sem duplicatas em visited.",
                                "Ordem de finalização captura pós-ordem correta (folhas primeiro).",
                                "Nenhuma recursão infinita mesmo com ciclos (devido a visited).",
                                "Funciona com nós isolados ou sem vizinhos.",
                                "Integração em topological_sort visita todo o grafo.",
                                "Reverso de order forma sequência topológica válida."
                              ],
                              "assessmentCriteria": [
                                "Código executa sem erros de runtime ou recursão infinita.",
                                "Visited previne re-visitas corretamente (O(1) checagem).",
                                "Loop sobre vizinhos usa iteração exaustiva sem skips.",
                                "Append em order ocorre pós-recursão de todos filhos.",
                                "Função principal lida com grafo multi-componente.",
                                "Testes com exemplos acíclicos/cíclicos passam.",
                                "Código é limpo, com comentários em pontos chave."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Relações Parciais (Ordenação Topológica).",
                                "Programação: Conceitos de Recursão e Backtracking.",
                                "Engenharia de Software: Análise de Dependências em Builds (Maven/Gradle).",
                                "Ciência da Computação: Algoritmos de Busca e Traversal.",
                                "Lógica: Evitar Ciclos e Estados Infinitos."
                              ],
                              "realWorldApplication": "Em sistemas de build como npm ou Docker Compose, DFS detecta ciclos em dependências de pacotes/tarefas, permitindo ordenação topológica para compilação eficiente; também em agendamento de jobs em pipelines CI/CD ou análise de pré-requisitos em MOOCs."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.1.3",
                            "name": "Executar DFS a partir de múltiplos vértices",
                            "description": "Adaptar DFS para percorrer grafos desconexos, iterando sobre todos os vértices e iniciando DFS em não visitados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a representação do grafo e estruturas de controle",
                                  "subSteps": [
                                    "Represente o grafo direcionado como uma lista de adjacência (dicionário ou array de listas).",
                                    "Inicialize um array ou conjunto 'visited' com todos os vértices marcados como falso.",
                                    "Identifique todos os vértices do grafo para o loop de iteração.",
                                    "Defina uma pilha ou use recursão para simular DFS.",
                                    "Prepare uma lista para registrar a ordem de visita."
                                  ],
                                  "verification": "Verifique se a lista de adjacência está correta e o array 'visited' tem todos os vértices como falso.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Papel e lápis para esboçar o grafo",
                                    "Exemplo de grafo desconexo"
                                  ],
                                  "tips": "Use chaves de dicionário para vértices em Python para facilitar acesso rápido.",
                                  "learningObjective": "Compreender as estruturas de dados essenciais para rastrear visitas em grafos desconexos.",
                                  "commonMistakes": [
                                    "Inicializar 'visited' vazio em vez de com todos os vértices",
                                    "Usar lista de adjacência incorreta para grafos direcionados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função DFS para um único vértice",
                                  "subSteps": [
                                    "Crie a função DFS(vértice) que marca o vértice atual como visitado.",
                                    "Adicione o vértice à lista de ordem de visita (pós-ordem para topológica).",
                                    "Para cada vizinho não visitado, chame recursivamente DFS(vizinho).",
                                    "Teste a função isoladamente em um vértice conectado.",
                                    "Trate casos de vértices sem vizinhos (folhas)."
                                  ],
                                  "verification": "Execute DFS em um vértice e confirme que todos os vértices alcançáveis foram visitados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Use recursão para simplicidade, mas monitore profundidade para grafos grandes.",
                                  "learningObjective": "Dominar a implementação básica de DFS recursivo em grafos direcionados.",
                                  "commonMistakes": [
                                    "Chamar recursão antes de marcar visitado (causa loops)",
                                    "Esquecer de marcar visitado no início"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar o loop principal para múltiplos vértices",
                                  "subSteps": [
                                    "Itere sobre todos os vértices em ordem arbitrária.",
                                    "Para cada vértice não visitado, inicie a chamada DFS(vértice).",
                                    "Registre a ordem global de visitas após todas as chamadas.",
                                    "Inverta a lista de ordem se necessário para ordenação topológica.",
                                    "Adicione tratamento para grafos com ciclos (opcional, mas detecte)."
                                  ],
                                  "verification": "Confirme que após o loop, todos os vértices estão marcados como visitados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código dos Steps 1 e 2",
                                    "Exemplo de grafo com componentes desconexos"
                                  ],
                                  "tips": "Ordene a iteração de vértices em ordem reversa para topológica correta em DAGs.",
                                  "learningObjective": "Adaptar DFS para cobrir grafos desconexos iniciando de múltiplos pontos.",
                                  "commonMistakes": [
                                    "Iterar apenas sobre vizinhos em vez de todos vértices",
                                    "Marcar visitado antes do loop"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a execução completa",
                                  "subSteps": [
                                    "Crie um grafo de teste desconexo com 2-3 componentes.",
                                    "Execute o algoritmo e imprima ordem de visita e visited.",
                                    "Verifique cobertura total e ausência de duplicatas.",
                                    "Teste casos edge: grafo vazio, vértice isolado, grafo conectado.",
                                    "Meça tempo de execução para eficiência."
                                  ],
                                  "verification": "100% dos vértices visitados sem erros ou loops infinitos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo",
                                    "Ferramentas de teste unitário (pytest)"
                                  ],
                                  "tips": "Use asserts para verificações automáticas em testes.",
                                  "learningObjective": "Validar a robustez do algoritmo em cenários reais.",
                                  "commonMistakes": [
                                    "Ignorar vértices isolados",
                                    "Erro na inversão da ordem topológica"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo direcionado: A->B, B->C, D->E (componentes desconexos). Inicie loop: DFS(A) visita A,B,C; DFS(D) visita D,E. Ordem final (invertida): C,B,A,E,D. Todos visitados.",
                              "finalVerifications": [
                                "Todos os vértices estão marcados como visitados.",
                                "A ordem de visita respeita a recursão DFS (profundidade primeiro).",
                                "Não há visitas duplicadas ou loops infinitos.",
                                "Para DAGs, a ordem invertida é topologicamente válida.",
                                "Algoritmo lida com vértices isolados.",
                                "Tempo de execução é O(V + E)."
                              ],
                              "assessmentCriteria": [
                                "Correção: Cobertura completa do grafo.",
                                "Eficiência: Complexidade O(V + E) confirmada.",
                                "Robustez: Funciona em grafos desconexos e edges cases.",
                                "Clareza: Código legível com comentários.",
                                "Testes: Pelo menos 3 casos de teste passando.",
                                "Adaptação: Integração com ordenação topológica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos grafos e componentes fortemente conexos.",
                                "Programação: Recursão e estruturas de dados avançadas.",
                                "Engenharia de Software: Análise de dependências em projetos.",
                                "Ciência de Dados: Descoberta de comunidades em redes.",
                                "Inteligência Artificial: Planejamento em grafos de busca."
                              ],
                              "realWorldApplication": "Detectar componentes conectados em redes sociais para segmentação de usuários; ordenação topológica em compiladores para resolução de dependências de módulos; análise de fluxos de tarefas em gerenciamento de projetos com precedências."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.2",
                        "name": "Atribuição de Tempos de Descoberta e Finalização",
                        "description": "Uso de mecanismo de cores (branco, cinza, preto) e contadores de tempo para registrar descoberta e finalização de vértices durante DFS.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.2.1",
                            "name": "Implementar sistema de cores para estados de vértices",
                            "description": "Definir array de cores (branco: não visitado, cinza: em processamento, preto: finalizado) para rastrear o estado de cada vértice na pilha de recursão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o esquema de cores para estados dos vértices",
                                  "subSteps": [
                                    "Estude os estados padrão em DFS recursivo: branco (não visitado), cinza (em processamento), preto (finalizado).",
                                    "Atribua valores numéricos ou strings às cores: ex. 0 para branco, 1 para cinza, 2 para preto.",
                                    "Crie uma constante ou enum no código para representar as cores de forma legível.",
                                    "Documente o esquema em comentários ou um README, explicando o propósito de cada cor na pilha de recursão.",
                                    "Verifique compatibilidade com a representação do grafo (array ou mapa)."
                                  ],
                                  "verification": "Esquema de cores definido e documentado em código com comentários claros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de algoritmos DFS (Wikipedia ou CLRS), editor de código.",
                                  "tips": "Use enums em linguagens como JavaScript (Object.freeze) ou Python (Enum) para evitar erros de digitação.",
                                  "learningObjective": "Compreender os três estados fundamentais do DFS recursivo e seu mapeamento para cores.",
                                  "commonMistakes": "Usar strings em vez de números para performance em grafos grandes; confundir cinza (processando) com preto (finalizado)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar o array de cores no algoritmo",
                                  "subSteps": [
                                    "Crie um array 'colors' com tamanho igual ao número de vértices (n).",
                                    "Inicialize todos os elementos para branco (0).",
                                    "Integre a inicialização dentro da função principal de ordenação topológica.",
                                    "Garanta que o array seja passado por referência para a função DFS recursiva.",
                                    "Adicione logs ou prints iniciais para visualizar o estado inicial."
                                  ],
                                  "verification": "Array de cores criado e todos vértices inicializados como branco; confirmado via console.log ou debugger.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código com debugger (VS Code), grafo de teste simples.",
                                  "tips": "Use Array(n).fill(0) em JavaScript ou [0] * n em Python para inicialização rápida.",
                                  "learningObjective": "Implementar estrutura de dados para rastreamento de estados de forma eficiente.",
                                  "commonMistakes": "Inicializar com tamanho errado (ex. n-1); esquecer de passar o array para DFS."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar atualizações de cores durante o DFS recursivo",
                                  "subSteps": [
                                    "No início da função DFS para um vértice u: verifique se é branco, senão retorne; defina como cinza (1).",
                                    "Após processar vizinhos recursivamente, defina u como preto (2) e adicione à lista topológica.",
                                    "Implemente verificações para evitar reprocessamento: se cinza, ciclo detectado; se preto, ignorar.",
                                    "Teste a sequência em um grafo pequeno manualmente simulando chamadas recursivas.",
                                    "Adicione condicionais para detecção de ciclo usando cor cinza."
                                  ],
                                  "verification": "Durante execução, vértices mudam de branco -> cinza -> preto corretamente; sem reentradas em cinza.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Grafo de teste com 4-5 vértices e arestas, debugger stepwise.",
                                  "tips": "Coloque a mudança para cinza logo após a verificação inicial para capturar pilha recursiva.",
                                  "learningObjective": "Aplicar mudanças de cor para gerenciar pilha de recursão e detectar ciclos.",
                                  "commonMistakes": "Definir preto antes de processar vizinhos; não detectar ciclos em cinza."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar o sistema de cores na ordenação topológica",
                                  "subSteps": [
                                    "Execute o algoritmo em grafos DAGs variados (pequeno, médio).",
                                    "Verifique se a ordem topológica respeita dependências e cores finalizam em preto.",
                                    "Teste grafo com ciclo: confirme detecção via cor cinza persistente.",
                                    "Meça performance e compare com DFS sem cores.",
                                    "Refatore código para legibilidade e adicione testes unitários."
                                  ],
                                  "verification": "Testes passam: ordem correta, todos pretos em DAGs, ciclo detectado; 100% cobertura de estados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Suite de testes (Jest/Pytest), grafos de exemplo prontos.",
                                  "tips": "Use asserts para checar cores pós-execução: todos devem ser preto em DAGs válidos.",
                                  "learningObjective": "Validar robustez do sistema de cores em cenários reais de ordenação topológica.",
                                  "commonMistakes": "Ignorar ciclos; não testar grafos com múltiplos componentes."
                                }
                              ],
                              "practicalExample": "Em um grafo de dependências de tarefas de software (T1 -> T2 -> T3, T4 independente): Inicialmente todos brancos. DFS em T1: cinza T1, recursão T2 (cinza), T3 (cinza -> preto), T2 preto, T1 preto. Ordem: T3, T2, T1, T4. Cores rastreiam para evitar loops.",
                              "finalVerifications": [
                                "Todos vértices começam como branco (0).",
                                "Vértices em processamento são cinza (1) apenas durante recursão ativa.",
                                "Todos vértices terminam como preto (2) em DAGs sem ciclos.",
                                "Detecção de ciclo ocorre quando vizinho é cinza.",
                                "Ordem topológica gerada respeita as cores de finalização.",
                                "Array de cores mantém integridade (sem valores inválidos)."
                              ],
                              "assessmentCriteria": [
                                "Código implementa corretamente as 3 mudanças de cor no fluxo DFS.",
                                "Inicialização e passagem do array sem erros de escopo.",
                                "Testes unitários cobrem DAGs, ciclos e múltiplos componentes.",
                                "Detecção de ciclo funcional via cor cinza.",
                                "Documentação clara do esquema de cores e lógica.",
                                "Eficiência mantida (O(V+E) tempo)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de grafos e estados em travessias.",
                                "Programação: Gerenciamento de estado em recursão e detecção de ciclos.",
                                "Análise de Algoritmos: Complexidade e otimizações em DFS.",
                                "Engenharia de Software: Modelagem de dependências em builds (ex. Makefiles)."
                              ],
                              "realWorldApplication": "Em compiladores (GCC/Clang) para ordenar módulos com dependências; em gerenciadores de tarefas (Airflow) para scheduling de jobs DAGs; em sistemas de build (Maven) para resolver dependências sem ciclos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.2",
                            "name": "Atribuir tempos de descoberta e finalização",
                            "description": "Usar contador global para atribuir tempo de descoberta ao entrar em DFS e tempo de finalização ao sair, atualizando após visitar todos os vizinhos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar o contador global e estruturas auxiliares",
                                  "subSteps": [
                                    "Crie uma variável global 'contador' inicializada em 1.",
                                    "Prepare arrays ou mapas para armazenar tempoDeDescoberta e tempoDeFinalizacao para cada nó.",
                                    "Defina estados dos nós: não visitado (0), visitando (1), visitado (2).",
                                    "Garanta que o grafo esteja representado como lista de adjacência.",
                                    "Teste a inicialização com um grafo pequeno."
                                  ],
                                  "verification": "Verifique se contador inicia em 1 e arrays estão vazios ou zerados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou similar), grafo de exemplo em Python ou pseudocódigo.",
                                  "tips": "Use um dicionário para tempos se os nós não forem indexados numericamente.",
                                  "learningObjective": "Compreender a necessidade de um contador compartilhado para timestamps únicos.",
                                  "commonMistakes": "Iniciar contador em 0, causando confusão em comparações; esquecer de resetar entre execuções."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Atribuir tempo de descoberta ao entrar no nó via DFS",
                                  "subSteps": [
                                    "No início da função DFS para um nó u, verifique se já foi visitado; se não, marque como visitando (estado 1).",
                                    "Atribua tempoDeDescoberta[u] = contador e incremente contador.",
                                    "Registre o timestamp no array ou mapa correspondente.",
                                    "Prossiga para recursão apenas após atribuição.",
                                    "Adicione log ou print para depuração dos tempos de descoberta."
                                  ],
                                  "verification": "Execute DFS em um nó raiz e confirme que tempoDeDescoberta é atribuído corretamente no primeiro acesso.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código do passo 1, debugger ou prints para timestamps.",
                                  "tips": "Sempre incremente contador APÓS a atribuição para evitar reutilização.",
                                  "learningObjective": "Implementar marcação de entrada em DFS para evitar recursões infinitas.",
                                  "commonMistakes": "Atribuir tempo antes de marcar como visitando, permitindo reentradas; não incrementar contador."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Recorrer vizinhos e atribuir tempo de finalização",
                                  "subSteps": [
                                    "Após marcar descoberta, itere sobre todos os vizinhos de u.",
                                    "Para cada vizinho v não visitado, chame DFS recursivo em v.",
                                    "Após todos os vizinhos processados, marque u como visitado (estado 2).",
                                    "Atribua tempoDeFinalizacao[u] = contador e incremente contador.",
                                    "Adicione à pilha de ordenação topológica se necessário (push u)."
                                  ],
                                  "verification": "Confirme que tempoDeFinalizacao é atribuído apenas após retorno de todas recursões.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código dos passos anteriores, grafo com múltiplos nós e arestas.",
                                  "tips": "Use uma pilha para ordenação topológica: adicione nó após finalização.",
                                  "learningObjective": "Garantir que finalização ocorra pós-processamento completo de subgrafo.",
                                  "commonMistakes": "Atribuir finalização antes de recursões, invertendo ordem; esquecer de marcar estado final."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e testar o algoritmo completo",
                                  "subSteps": [
                                    "Chame DFS para todos os nós não visitados em ordem qualquer.",
                                    "Colete todos os tempos e verifique se todos os nós têm descoberta < finalizacao.",
                                    "Valide que para toda aresta u->v, finalizacao[u] > finalizacao[v].",
                                    "Teste com grafo de exemplo e detecte ciclos se necessário.",
                                    "Otimize código e remova prints de depuração."
                                  ],
                                  "verification": "Execute em grafo completo e liste todos os tempos; confirme propriedades de DFS.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Grafo de teste completo (ex: tarefas A->B->C), ferramenta de visualização de grafos.",
                                  "tips": "Ordene nós por tempo de finalização decrescente para topológica.",
                                  "learningObjective": "Aplicar timestamps para ordenação topológica e detecção de ciclos.",
                                  "commonMistakes": "Não chamar DFS em todos nós, deixando componentes desconectados; ignorar ciclos (descoberta > finalizacao em back edge)."
                                }
                              ],
                              "practicalExample": "Em um grafo de dependências de tarefas: Tarefa A (descoberta=1, final=6) -> B (2,5) -> C (3,4); D (7,8). Execução: Visita A (desc=1), B(2), C(3,fin=4), B fin=5, A fin=6, D desc=7 fin=8. Ordem topológica: D, A, B, C.",
                              "finalVerifications": [
                                "Todos os nós têm tempoDeDescoberta < tempoDeFinalizacao.",
                                "Para toda aresta u->v, tempoDeFinalizacao[u] > tempoDeFinalizacao[v].",
                                "Contador final equals número total de timestamps atribuídos (2 por nó).",
                                "Nenhum nó tem estado 'visitando' ao final (detecta ciclo).",
                                "Ordenação por finalização decrescente é válida topologicamente.",
                                "Teste com grafo acíclico e cíclico para validação."
                              ],
                              "assessmentCriteria": [
                                "Correta inicialização e incremento do contador global.",
                                "Atribuição precisa de tempos em entry/exit de DFS.",
                                "Manuseio correto de recursões e estados de visita.",
                                "Validação das propriedades de timestamps em exemplos.",
                                "Integração sem erros em algoritmo de ordenação topológica.",
                                "Código limpo, comentado e testado com casos variados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e relações parciais.",
                                "Gestão de Projetos: Agendamento de tarefas com dependências (PERT/CPM).",
                                "Engenharia de Software: Análise de dependências em compiladores.",
                                "Ciência de Dados: Processamento de grafos em redes sociais."
                              ],
                              "realWorldApplication": "Em sistemas de build como Make ou Gradle, atribui ordem de compilação de módulos baseados em dependências; em pipelines CI/CD para execução sequencial de jobs; planejamento de cursos universitários com pré-requisitos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.2.3",
                            "name": "Detectar ciclos usando estados cinza",
                            "description": "Identificar back edges para vértices cinza durante DFS, sinalizando a presença de ciclos no grafo (essencial para validar DAG).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os estados de vértices em DFS para detecção de ciclos",
                                  "subSteps": [
                                    "Revise os três estados: white (não visitado), gray (em processo de exploração), black (exploração concluída).",
                                    "Desenhe um grafo simples e anote os estados iniciais de todos os vértices como white.",
                                    "Explique verbalmente ou por escrito por que o estado gray é crucial para detectar recursão.",
                                    "Compare com uma árvore de chamadas recursivas para visualizar transições de estado."
                                  ],
                                  "verification": "Crie um diagrama de um grafo com 4 vértices mostrando transições white -> gray -> black sem ciclos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, diagrama de grafo de exemplo (impresso ou digital).",
                                  "tips": "Use cores diferentes para cada estado para visualização rápida.",
                                  "learningObjective": "Compreender as transições de estados em DFS e seu papel na detecção de ciclos.",
                                  "commonMistakes": "Confundir gray com black, achando que black indica ciclo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar back edges para vértices gray durante DFS",
                                  "subSteps": [
                                    "Inicie DFS em um vértice raiz e marque-o como gray ao entrar.",
                                    "Para cada vizinho, se o vizinho for gray, sinalize um back edge e ciclo detectado.",
                                    "Continue a exploração, marcando vértices como black ao finalizar recursão.",
                                    "Registre o caminho de back edge em um log simples.",
                                    "Repita para múltiplos componentes conectados."
                                  ],
                                  "verification": "Simule manualmente DFS em um grafo com back edge e anote o momento da detecção.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Pseudocódigo de DFS com estados, grafo impresso com arestas direcionadas.",
                                  "tips": "Siga a ordem exata de vizinhos para reproduzir resultados consistentes.",
                                  "learningObjective": "Reconhecer e sinalizar back edges como indicador de ciclos em grafos direcionados.",
                                  "commonMistakes": "Ignorar back edges para vértices white ou black, focando só em gray."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular detecção de ciclos em grafos com e sem ciclos",
                                  "subSteps": [
                                    "Escolha um grafo com ciclo (ex: A->B->C->A) e execute DFS passo a passo.",
                                    "Confirme detecção ao encontrar back edge C->A (A gray).",
                                    "Execute DFS em um DAG (ex: A->B->C) e verifique ausência de back edges.",
                                    "Compare pilha de recursão em ambos os casos.",
                                    "Documente diferenças nos estados finais."
                                  ],
                                  "verification": "Produza tabelas de estados para ambos os grafos mostrando detecção correta.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Ferramenta de desenho de grafos (ex: draw.io), tabelas de rastreamento de estados.",
                                  "tips": "Use setas numeradas para simular chamadas recursivas.",
                                  "learningObjective": "Aplicar a lógica de estados gray para validar DAGs através de simulação.",
                                  "commonMistakes": "Marcar vértice como black prematuramente, perdendo detecção de back edge."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar detecção de ciclos em código",
                                  "subSteps": [
                                    "Escreva pseudocódigo ou código em Python/Java com array de cores (white=0, gray=1, black=2).",
                                    "Implemente função recursiva DFS que retorna true se ciclo encontrado.",
                                    "Teste com grafos de exemplo: um com ciclo e um DAG.",
                                    "Adicione prints para rastrear estados e back edges.",
                                    "Refatore para eficiência, evitando overflow de pilha."
                                  ],
                                  "verification": "Execute código em 3 grafos diferentes e confirme saídas: ciclo sim/não.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Editor de código (VS Code), representações de grafos como adj list.",
                                  "tips": "Use dicionário para cores e lista para pilha de recursão.",
                                  "learningObjective": "Codificar a detecção de ciclos usando estados gray de forma funcional.",
                                  "commonMistakes": "Não resetar estados entre testes, causando falsos positivos."
                                }
                              ],
                              "practicalExample": "Considere o grafo: A→B, B→C, C→A, D→B. Iniciando DFS em A: A gray → B gray → C gray → A (gray, back edge detectado, ciclo ABC). D inicia novo DFS, confirma sem ciclo adicional.",
                              "finalVerifications": [
                                "Explique a diferença entre forward/cross/back edges em termos de estados.",
                                "Simule DFS manualmente em um grafo desconhecido e detecte ciclo corretamente.",
                                "Identifique por que estados gray capturam ciclos em grafos direcionados.",
                                "Modifique um código funcional para adicionar logging de back edges.",
                                "Diferencie detecção de ciclos em DFS vs BFS.",
                                "Valide um DAG real (ex: dependências de tarefas) sem falsos positivos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de back edges apenas para vértices gray (100% correto).",
                                "Simulações manuais completas com diagramas e tabelas de estados.",
                                "Código funcional que detecta ciclos em <5s para grafos de 100 vértices.",
                                "Explicação clara de por que gray indica ancestrais no caminho atual.",
                                "Tratamento correto de múltiplos componentes conectados.",
                                "Ausência de erros comuns como detecção em tree edges."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Reconhecimento de linguagens regulares via autômatos (estados semelhantes).",
                                "Programação Orientada a Objetos: Gerenciamento de estado em máquinas de estado finitas.",
                                "Análise de Dependências: Em build systems como Make ou Gradle.",
                                "Ciência de Dados: Detecção de loops em redes sociais ou fluxos de dados."
                              ],
                              "realWorldApplication": "Em compiladores para detectar dependências circulares em módulos; em sistemas de agendamento de tarefas (ex: Kubernetes jobs) para evitar loops infinitos; validação de pré-requisitos em currículos educacionais ou pipelines CI/CD."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.4.3",
                        "name": "Geração da Ordenação Topológica via Ordem Reversa de Finalização",
                        "description": "Coleta de vértices na ordem reversa de seus tempos de finalização para produzir uma ordenação topológica válida em DAGs.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.4.3.1",
                            "name": "Manter pilha de finalização durante DFS",
                            "description": "Adicionar vértice à uma lista (ou pilha) imediatamente após sua finalização, garantindo ordem reversa cronológica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Finalização em DFS e a Necessidade da Pilha",
                                  "subSteps": [
                                    "Revise o algoritmo DFS padrão e identifique os momentos de 'início' e 'fim' de processamento de um vértice.",
                                    "Explique por que adicionar vértices na finalização garante ordem reversa cronológica para ordenação topológica.",
                                    "Desenhe um grafo simples acíclico (DAG) com 4 vértices e simule manualmente a ordem de finalização.",
                                    "Crie uma pilha vazia e liste os vértices na ordem de finalização simulada.",
                                    "Compare a ordem da pilha com a ordenação topológica esperada."
                                  ],
                                  "verification": "Desenhe o grafo e anote a pilha final; verifique se a ordem é topologicamente válida (sem predecessores após sucessores).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para pseudocódigo",
                                    "Diagrama de grafo simples (DAG com 4-5 nós)"
                                  ],
                                  "tips": "Use cores diferentes para marcar início e fim de cada vértice durante a simulação manual.",
                                  "learningObjective": "Entender o timing exato da finalização em DFS e seu papel na ordenação topológica.",
                                  "commonMistakes": [
                                    "Confundir finalização com descoberta (início do vértice)",
                                    "Adicionar vértices na ordem de descoberta em vez de finalização"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modificar o Algoritmo DFS para Incluir a Pilha de Finalização",
                                  "subSteps": [
                                    "Escreva o pseudocódigo do DFS recursivo padrão com estados visitado/in-progress/finalizado.",
                                    "Adicione uma pilha global (ou lista) e insira 'push(vértice)' logo após processar todos os adjacentes (pós-ordem).",
                                    "Implemente uma função auxiliar para adicionar à pilha apenas na finalização.",
                                    "Teste o pseudocódigo manualmente no grafo do Step 1.",
                                    "Converta o pseudocódigo para código em Python ou linguagem preferida."
                                  ],
                                  "verification": "Execute o código modificado no grafo exemplo e imprima a pilha; inverta-a para obter ordenação topológica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Jupyter Notebook)",
                                    "Biblioteca NetworkX para grafos (opcional)"
                                  ],
                                  "tips": "Use print statements para rastrear quando cada vértice é adicionado à pilha.",
                                  "learningObjective": "Implementar a inserção atômica na pilha imediatamente após finalização de cada vértice.",
                                  "commonMistakes": [
                                    "Esquecer de marcar vértice como finalizado antes do push",
                                    "Push durante a recursão de adjacentes em vez de após"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar e Testar com um Grafo de Exemplo Prático",
                                  "subSteps": [
                                    "Crie um grafo DAG representando dependências de tarefas (ex: T1 -> T2 -> T3, T1 -> T4).",
                                    "Implemente o DFS completo com pilha e execute a partir de todos os vértices não visitados.",
                                    "Colete a pilha e reverta para obter a ordenação topológica.",
                                    "Valide manualmente se a ordem respeita todas as arestas (predecessor antes do sucessor).",
                                    "Adicione logging para mostrar ordem de finalização."
                                  ],
                                  "verification": "A ordenação reversa da pilha deve ser uma ordenação topológica válida sem violações de arestas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código Python com lista como pilha",
                                    "Ferramenta de visualização de grafos (Graphviz ou NetworkX)"
                                  ],
                                  "tips": "Inicie DFS de múltiplos componentes para grafos desconexos.",
                                  "learningObjective": "Aplicar a pilha de finalização em um grafo real e validar resultados.",
                                  "commonMistakes": [
                                    "Não tratar múltiplas chamadas DFS para todos vértices",
                                    "Reverter a pilha incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e Otimizar para Casos Complexos",
                                  "subSteps": [
                                    "Teste com um grafo maior (6-8 vértices) com múltiplas ramificações.",
                                    "Meça o tempo de execução e compare com ordenação topológica via Kahn.",
                                    "Identifique e corrija recursão profunda (limite de pilha).",
                                    "Adicione tratamento para grafos com ciclos (detectar via estado in-progress).",
                                    "Documente a pilha final e explique a ordem cronológica reversa."
                                  ],
                                  "verification": "Execute em grafo complexo; confirme ordenação topológica com verificador automático de arestas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Grafo de teste maior",
                                    "Biblioteca para detecção de ciclos (NetworkX)"
                                  ],
                                  "tips": "Use iterativo DFS com pilha explícita se recursão falhar em grafos grandes.",
                                  "learningObjective": "Garantir robustez da pilha de finalização em cenários reais e escaláveis.",
                                  "commonMistakes": [
                                    "Ignorar ciclos, causando loops infinitos",
                                    "Push prematuro em grafos com back-edges"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de software com dependências: Tarefa A (design) -> B (codificação) -> C (testes). Durante DFS, A finaliza por último após B e C; pilha: [C, B, A]. Reversa: A, B, C – ordem topológica correta para execução.",
                              "finalVerifications": [
                                "Simule manualmente DFS em um DAG e construa a pilha corretamente.",
                                "Implemente código que produz pilha com ordem reversa de finalização.",
                                "Valide que inverter a pilha gera ordenação topológica sem violações.",
                                "Detecte e evite adições incorretas em grafos com ciclos.",
                                "Explique verbalmente o timing exato do push na finalização.",
                                "Teste em grafo desconexo com múltiplas chamadas DFS."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inserção pós-finalização (100% dos vértices na ordem correta).",
                                "Código funcional sem erros de recursão ou ciclos.",
                                "Validação automática de ordenação topológica (todas arestas respeitadas).",
                                "Eficiência temporal O(V+E) mantida.",
                                "Documentação clara de passos e pilha intermediária.",
                                "Robustez em grafos variados (pequenos/grandes, desconexos)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Relações Parciais (Ordenação Topológica).",
                                "Programação: Estruturas de Dados (Pilhas, Recursão vs Iteração).",
                                "Engenharia de Software: Gerenciamento de Dependências em Builds (Maven/Gradle).",
                                "Ciência da Computação: Análise de Complexidade e Detecção de Ciclos.",
                                "Gestão de Projetos: Agendamento de Tarefas com Precedências."
                              ],
                              "realWorldApplication": "Em compiladores (GCC/Clang), ordena módulos por dependências; em sistemas de build (Make), agenda tarefas; em pipelines CI/CD (Jenkins), executa jobs em ordem topológica para evitar falhas por dependências não resolvidas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.2.3"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.2",
                            "name": "Gerar ordenação topológica a partir da pilha",
                            "description": "Inverter a pilha de finalização ou ler em ordem reversa para obter a sequência linearizada onde para toda aresta u->v, u precede v.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a pilha de finalização gerada pelo DFS",
                                  "subSteps": [
                                    "Identifique o grafo direcionado acíclico (DAG) e a ordem de finalização dos nós durante a execução do DFS.",
                                    "Liste todos os nós na pilha na ordem em que foram empilhados (do fundo ao topo).",
                                    "Confirme que a pilha representa a ordem pós-ordem reversa: nós terminam após seus sucessores.",
                                    "Anote o topo da pilha, que será o primeiro nó na ordenação topológica.",
                                    "Verifique se todos os nós do grafo estão na pilha."
                                  ],
                                  "verification": "A pilha contém todos os nós do grafo na ordem correta de finalização, com sucessores abaixo dos predecessores.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Grafo representado como lista de adjacência, pilha de finalização do DFS anterior.",
                                  "tips": "Use uma representação visual do grafo para mapear a pilha.",
                                  "learningObjective": "Compreender como a pilha captura a ordem de finalização pós-DFS.",
                                  "commonMistakes": "Confundir ordem de empilhamento com ordem de visita inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair nós da pilha em ordem reversa",
                                  "subSteps": [
                                    "Inicialize uma lista vazia para a ordenação topológica.",
                                    "Enquanto a pilha não estiver vazia, remova (pop) o nó do topo e adicione ao início da lista ou use uma pilha auxiliar para inverter.",
                                    "Registre cada pop: o topo sempre é um nó sem dependências pendentes.",
                                    "Continue até esvaziar a pilha completamente.",
                                    "Ajuste índices se necessário para uma lista 1-indexada."
                                  ],
                                  "verification": "A lista resultante tem os nós na ordem onde predecessores vêm antes de sucessores.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Pilha de finalização, lista vazia para output.",
                                  "tips": "Simule com papel e lápis para pequenos grafos antes de codificar.",
                                  "learningObjective": "Implementar a inversão da pilha para obter a linearização topológica.",
                                  "commonMistakes": "Popar da base em vez do topo, invertendo incorretamente a ordem."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e representar a sequência linearizada",
                                  "subSteps": [
                                    "Concatene os nós extraídos em uma sequência única: [n1, n2, ..., nn].",
                                    "Atribua posições na sequência (ex: posição 1 para primeiro nó).",
                                    "Gere uma representação string ou array da ordenação final.",
                                    "Compare com o grafo original para garantir precedência.",
                                    "Documente a sequência com justificativa baseada nas arestas."
                                  ],
                                  "verification": "Para toda aresta u->v, posição(u) < posição(v) na sequência.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Lista de nós extraídos, grafo original.",
                                  "tips": "Use pseudocódigo para clareza antes da implementação real.",
                                  "learningObjective": "Gerar a ordenação topológica final como uma lista ordenada.",
                                  "commonMistakes": "Ignorar ciclos (mas assuma DAG); adicionar nós duplicados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a ordenação topológica gerada",
                                  "subSteps": [
                                    "Para cada aresta u->v no grafo, verifique se u aparece antes de v na sequência.",
                                    "Confirme que todos os nós estão presentes exatamente uma vez.",
                                    "Teste com uma aresta removida para ver impacto na ordem.",
                                    "Execute uma simulação de execução na ordem proposta.",
                                    "Registre qualquer violação e corrija a pilha/DFS se necessário."
                                  ],
                                  "verification": "100% das arestas respeitam a precedência na sequência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Sequência gerada, lista completa de arestas do grafo.",
                                  "tips": "Automatize a verificação com um loop simples sobre arestas.",
                                  "learningObjective": "Validar corretude da ordenação topológica.",
                                  "commonMistakes": "Não verificar todas as arestas; assumir validade sem teste."
                                }
                              ],
                              "practicalExample": "Considere um DAG de tarefas de compilação: A->B, A->C, B->D (A precede B e C, B precede D). DFS empilha: D (topo), B, C, A (fundo). Popando: A, C, B, D. Sequência: [A, C, B, D]. Verificação: A antes B, A antes C, B antes D.",
                              "finalVerifications": [
                                "Sequência contém todos os nós exatamente uma vez.",
                                "Para toda aresta u->v, u precede v na sequência.",
                                "Ordem é consistente com múltiplas execuções DFS válidas.",
                                "Nenhum ciclo é induzido pela ordem.",
                                "Pilha de finalização foi completamente esvaziada."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inversão da pilha (100% correto).",
                                "Validação completa de todas as arestas.",
                                "Eficiência temporal O(V) para extração.",
                                "Clareza na documentação da sequência.",
                                "Tratamento edge-case: grafo com 1 nó ou isolados.",
                                "Correção de erros comuns identificados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações de ordem parcial e linearização.",
                                "Gerenciamento de Projetos: Agendamento de tarefas com dependências.",
                                "Compiladores: Ordem de build de módulos.",
                                "Teoria dos Grafos: Propriedades de DAGs."
                              ],
                              "realWorldApplication": "Em compiladores, determina ordem de compilação de arquivos com dependências (#include); em pipelines CI/CD, ordena jobs de build; em gerenciamento de projetos, sequencia tarefas sem ciclos para cronogramas eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.4.3.3",
                            "name": "Validar e testar o algoritmo completo",
                            "description": "Implementar função principal que executa DFS em todos vértices, gera ordenação e verifica ausência de ciclos, testando com exemplos de DAGs e grafos cíclicos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a estrutura do grafo e esboçar a função principal",
                                  "subSteps": [
                                    "Represente o grafo usando dicionário de adjacência em Python.",
                                    "Defina variáveis globais ou de instância para rastrear ordem de finalização e estado de visitação (visitando, visitado).",
                                    "Esboce a função principal topologicalSort() que itera sobre todos os vértices e chama DFS se não visitado.",
                                    "Inclua retorno de ordenação ou None se ciclo detectado.",
                                    "Adicione detecção de ciclo via flag durante recursão."
                                  ],
                                  "verification": "Função esboçada compila sem erros e estrutura de dados está correta ao printar grafo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (VS Code ou Jupyter), Python 3+",
                                  "tips": "Use listas ou stacks para ordem de finalização para eficiência O(1) append/pop.",
                                  "learningObjective": "Entender a necessidade de visitar todos os vértices para grafos desconexos.",
                                  "commonMistakes": "Esquecer de tratar múltiplos componentes conectados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar DFS recursivo com detecção de ciclo e coleta de finalização",
                                  "subSteps": [
                                    "Defina DFS(v) que marca v como 'visitando'.",
                                    "Para cada vizinho, se não visitado chame DFS recursivo; se visitando, detecte ciclo.",
                                    "Após processar vizinhos, marque como 'visitado' e adicione v à frente da lista de finalização.",
                                    "Implemente backtracking para propagar detecção de ciclo.",
                                    "Teste unitário simples em DFS isolado."
                                  ],
                                  "verification": "Chame DFS em nó único e verifique ordem de finalização e ausência de ciclo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, biblioteca networkx opcional para visualização",
                                  "tips": "Use três estados: 0=não visitado, 1=visitando, 2=visitado para precisão.",
                                  "learningObjective": "Dominar detecção de ciclo em DFS e captura de tempo de finalização.",
                                  "commonMistakes": "Confundir 'visitando' com 'visitado' levando a falsos negativos em ciclos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerar ordenação topológica e integrar verificação de aciclicidade",
                                  "subSteps": [
                                    "Na função principal, colete lista de finalização e reverta para ordenação topológica.",
                                    "Se ciclo detectado durante DFS, retorne mensagem de erro ou None.",
                                    "Valide que todos vértices foram incluídos na ordenação.",
                                    "Implemente função auxiliar para verificar se a ordenação respeita todas as arestas.",
                                    "Adicione logging para depuração de ordem gerada."
                                  ],
                                  "verification": "Execute em grafo pequeno DAG e confirme ordenação manualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, exemplos de grafos impressos",
                                  "tips": "Reverter lista no final garante O(V+E) tempo total.",
                                  "learningObjective": "Conectar ordem de finalização reversa à ordenação topológica válida.",
                                  "commonMistakes": "Não reverter a lista, resultando em ordem incorreta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Criar e executar testes com DAGs e grafos cíclicos",
                                  "subSteps": [
                                    "Crie grafo DAG exemplo: tarefas A->B->C, D->C.",
                                    "Crie grafo cíclico: A->B->C->A.",
                                    "Execute algoritmo em ambos e capture saídas.",
                                    "Compare com ordenações esperadas e detecte ciclo corretamente.",
                                    "Adicione 2-3 casos edge: grafo vazio, nó único, desconexo."
                                  ],
                                  "verification": "Todos testes passam: DAG ordena corretamente, cíclico detecta ciclo.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Editor de código, unittest ou pytest para automação",
                                  "tips": "Use assert para validar: len(ordem) == num_vertices e sem ciclos.",
                                  "learningObjective": "Aplicar TDD para validar robustez do algoritmo.",
                                  "commonMistakes": "Testes insuficientes falhando em casos edge como grafos vazios."
                                }
                              ],
                              "practicalExample": "Grafo DAG: vértices [0,1,2,3], arestas [[0,1],[0,2],[1,3],[2,3]]. Ordenação esperada: [0,1,2,3] ou [0,2,1,3]. Grafo cíclico: adicione [3,0], deve detectar ciclo.",
                              "finalVerifications": [
                                "Algoritmo gera ordenação correta para DAGs múltiplos.",
                                "Detecta e reporta ciclos em todos cenários.",
                                "Tempo de execução O(V+E) confirmado via profiling simples.",
                                "Funciona para grafos desconexos.",
                                "Nenhum crash em entradas inválidas (ex: vértices negativos).",
                                "Ordenação respeita todas as arestas (verificação auxiliar passa)."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% testes passam incluindo edges.",
                                "Eficiência: Complexidade O(V+E) sem loops desnecessários.",
                                "Robustez: Trata ciclos, desconexos e entradas vazias.",
                                "Clareza: Código comentado, variáveis intuitivas.",
                                "Validação: Verificador auxiliar confirma ordenação.",
                                "Documentação: Exemplos e README com casos de uso."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e relações parciais.",
                                "Programação: Recursão, backtracking e estruturas de dados.",
                                "Engenharia de Software: Testes unitários e TDD.",
                                "Análise de Sistemas: Modelagem de dependências em projetos."
                              ],
                              "realWorldApplication": "Em compiladores para ordenar módulos com dependências; em gerenciamento de projetos (CPM/PERT) para sequenciar tarefas; em pipelines de CI/CD para builds dependentes."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.4.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.5",
                    "name": "Detecção de Ciclos",
                    "description": "Verificação da completude da ordenação para identificar ciclos no grafo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.5.1",
                        "name": "Conceitos Básicos de Ciclos em Grafos Direcionados",
                        "description": "Entender o que é um ciclo em um grafo direcionado e sua relação com a ordenação topológica, incluindo a verificação de completude.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.1.1",
                            "name": "Definir ciclo em grafo direcionado",
                            "description": "Identificar e descrever um ciclo como uma sequência de vértices onde existe um caminho de volta ao inicial, impedindo ordenação topológica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos de Grafos Direcionados",
                                  "subSteps": [
                                    "Aprender a definição de grafo direcionado: conjunto de vértices e arestas com direção",
                                    "Estudar representações comuns: lista de adjacência e matriz de adjacência",
                                    "Praticar desenhando grafos direcionados simples com 3-5 vértices",
                                    "Identificar diferenças entre grafos direcionados e não direcionados",
                                    "Listar exemplos cotidianos de relações direcionadas, como 'segue' em redes sociais"
                                  ],
                                  "verification": "Desenhar um grafo direcionado com 4 vértices e 5 arestas, rotulando corretamente direções e listando a lista de adjacência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta online como draw.io ou Graphviz"
                                  ],
                                  "tips": [
                                    "Sempre use setas para indicar direção; comece com grafos pequenos para evitar confusão."
                                  ],
                                  "learningObjective": "Dominar a estrutura básica de grafos direcionados para basear conceitos avançados.",
                                  "commonMistakes": [
                                    "Ignorar a direção das arestas",
                                    "Confundir vértices com arestas",
                                    "Desenhar grafos simétricos como não direcionados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Explorar o Conceito de Caminho em Grafos Direcionados",
                                  "subSteps": [
                                    "Definir caminho: sequência de vértices v1 -> v2 -> ... -> vk com arestas direcionadas",
                                    "Diferenciar caminho simples (sem vértices repetidos) de caminho com loops",
                                    "Encontrar todos os caminhos entre dois vértices em um grafo exemplo",
                                    "Praticar traçando caminhos em um grafo com 5 vértices",
                                    "Explicar por que a direção importa para a existência de caminhos"
                                  ],
                                  "verification": "Em um grafo fornecido, listar pelo menos 3 caminhos válidos de um vértice origem a destino.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Grafo exemplo impresso ou digital",
                                    "Calculadora para contar caminhos curtos"
                                  ],
                                  "tips": [
                                    "Siga apenas as setas; marque vértices visitados para evitar repetições desnecessárias."
                                  ],
                                  "learningObjective": "Identificar e descrever caminhos como pré-requisito para ciclos.",
                                  "commonMistakes": [
                                    "Permitir movimento contra a direção da seta",
                                    "Considerar vértices repetidos como inválidos em caminhos não-simples",
                                    "Confundir comprimento de caminho com número de arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Identificar Ciclos em Grafos Direcionados",
                                  "subSteps": [
                                    "Definir ciclo: caminho onde o vértice final é igual ao inicial (vk = v1) e k >= 2",
                                    "Explicar ciclo simples: sem repetições de vértices intermediários",
                                    "Analisar um grafo exemplo e detectar ciclos manualmente",
                                    "Diferenciar ciclos de caminhos sem retorno ou com retornos inválidos",
                                    "Descrever formalmente: sequência v1 -> v2 -> ... -> v1 com direções corretas"
                                  ],
                                  "verification": "Identificar corretamente se um grafo dado contém um ciclo e descrevê-lo explicitamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Grafos de exemplo com e sem ciclos",
                                    "Ferramenta de desenho de grafos"
                                  ],
                                  "tips": [
                                    "Procure por 'loops de volta' seguindo setas; teste partindo de cada vértice."
                                  ],
                                  "learningObjective": "Capacitar a definição precisa e identificação visual de ciclos.",
                                  "commonMistakes": [
                                    "Considerar arestas reversas como ciclo",
                                    "Ignorar ciclos de comprimento 2 (A->B->A)",
                                    "Confundir múltiplos caminhos com ciclo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar Ciclos com Ordenação Topológica",
                                  "subSteps": [
                                    "Definir ordenação topológica: linearização de vértices respeitando direções de arestas",
                                    "Explicar por que ciclos impedem topo-sort: violação de precedência (A antes de A impossível)",
                                    "Simular tentativa de topo-sort em grafo com ciclo e observar falha",
                                    "Comparar grafo acíclico (DAG) com cíclico",
                                    "Descrever teorema: grafo tem topo-sort iff é acíclico"
                                  ],
                                  "verification": "Explicar em uma frase por que o ciclo A->B->A impede ordenação topológica.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de DAGs e grafos cíclicos",
                                    "Algoritmo Kahn ou DFS pseudocódigo"
                                  ],
                                  "tips": [
                                    "Pense em dependências: ciclo significa tarefa depende de si mesma."
                                  ],
                                  "learningObjective": "Compreender o impacto prático de ciclos no contexto de algoritmos.",
                                  "commonMistakes": [
                                    "Achar que topo-sort funciona em qualquer grafo direcionado",
                                    "Confundir ausência de ciclo com conectividade",
                                    "Ignorar que topo-sort requer aciclicidade estrita"
                                  ]
                                }
                              ],
                              "practicalExample": "No grafo com vértices A, B, C e arestas A→B, B→C, C→A, há um ciclo A→B→C→A, pois existe um caminho de A de volta a A seguindo as direções. Isso impede ordenação topológica, pois não se pode ordenar A antes de si mesmo.",
                              "finalVerifications": [
                                "Definir ciclo corretamente em termos de sequência de vértices e caminhos",
                                "Identificar ciclo em um grafo com 6 vértices manualmente",
                                "Explicar por que ciclos bloqueiam ordenação topológica",
                                "Diferenciar ciclo de caminho simples sem retorno",
                                "Fornecer contra-exemplo de grafo sem ciclo",
                                "Descrever formalmente um ciclo simples"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de ciclo (deve incluir retorno ao vértice inicial)",
                                "Capacidade de detectar ciclos em grafos médios (até 8 vértices)",
                                "Correta ligação com impossibilidade de topo-sort",
                                "Uso correto de terminologia (caminho, vértice, aresta direcionada)",
                                "Fornecimento de exemplos e contra-exemplos claros",
                                "Clareza na descrição escrita ou visual"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Álgebra Linear (matrizes de adjacência)",
                                "Programação: Implementação de DFS para detecção de ciclos",
                                "Engenharia de Software: Gerenciamento de dependências em builds (Maven/Gradle)",
                                "Ciências Sociais: Análise de redes de influência ou causalidade",
                                "Inteligência Artificial: Grafos em planejamento de caminhos (ex: jogos)"
                              ],
                              "realWorldApplication": "Em compiladores de software, detectar ciclos em grafos de dependências de módulos previne builds infinitos; em gerenciamento de projetos, identifica tarefas circulares como 'Tarefa A requer B, B requer C, C requer A', evitando agendamentos impossíveis."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.2",
                            "name": "Importância da aciclicidade para ordenação topológica",
                            "description": "Explicar por que grafos com ciclos (não-DAGs) não admitem ordenação topológica completa e como detectar via verificação de nós processados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Fundamentos da Ordenação Topológica e Aciclicidade",
                                  "subSteps": [
                                    "Defina ordenação topológica como uma ordenação linear de vértices em um grafo direcionado acíclico (DAG) respeitando todas as arestas.",
                                    "Explique que um DAG é um grafo direcionado sem ciclos.",
                                    "Ilustre com um exemplo simples de DAG: tarefas A → B → C, ordenação possível: A, B, C.",
                                    "Discuta o conceito de relação de precedência implícita nas arestas."
                                  ],
                                  "verification": "Crie um diagrama de um DAG simples e liste uma ordenação topológica válida.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Ferramenta online como draw.io ou Graphviz"
                                  ],
                                  "tips": "Sempre desenhe o grafo para visualizar direções das arestas.",
                                  "learningObjective": "Entender a definição e requisito básico de aciclicidade para ordenação topológica.",
                                  "commonMistakes": "Confundir grafos direcionados com não-direcionados, ignorando direções das arestas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Impacto de Ciclos na Ordenação Topológica",
                                  "subSteps": [
                                    "Construa um grafo com ciclo: A → B → C → A.",
                                    "Tente listar uma ordenação linear respeitando todas as precedências e observe a impossibilidade.",
                                    "Explique que ciclos criam dependências circulares, violando a propriedade de precedência total.",
                                    "Compare com DAG: no ciclo, nenhum nó pode ser último na ordenação."
                                  ],
                                  "verification": "Demonstre em papel por que nenhuma ordenação topológica completa existe para o grafo com ciclo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplos impressos de grafos"
                                  ],
                                  "tips": "Pense em termos de 'quem deve vir antes de quem' – ciclos criam paradoxos.",
                                  "learningObjective": "Identificar conceitualmente por que não-DAGs não admitem ordenação topológica completa.",
                                  "commonMistakes": "Acreditar que ciclos podem ser 'quebrados' ignorando uma aresta; todas devem ser respeitadas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aprender Detecção de Ciclos via Verificação de Nós Processados (Algoritmo de Kahn)",
                                  "subSteps": [
                                    "Calcule o grau de entrada (indegree) para cada nó: número de arestas entrantes.",
                                    "Inicialize uma fila com todos os nós de indegree 0.",
                                    "Processe a fila: para cada nó removido, reduza indegree dos sucessores e adicione à fila se indegree virar 0.",
                                    "Após processar, verifique se todos os nós foram processados; se não, há ciclo."
                                  ],
                                  "verification": "Aplique o algoritmo manualmente a um grafo com e sem ciclo, contando nós processados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Planilha ou Python simples com dicionários para indegrees",
                                    "Biblioteca NetworkX para Python (opcional)"
                                  ],
                                  "tips": "Use uma tabela para rastrear indegrees durante o processamento.",
                                  "learningObjective": "Dominar o método de detecção de ciclos verificando nós processados no algoritmo de Kahn.",
                                  "commonMistakes": "Esquecer de atualizar indegrees dos sucessores ou iniciar fila incorretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e Sintetizar o Conceito",
                                  "subSteps": [
                                    "Crie dois grafos: um DAG e um com ciclo oculto.",
                                    "Aplique detecção em ambos e explique resultados.",
                                    "Resuma: aciclicidade é essencial pois garante que todos os nós sejam processados em OT.",
                                    "Discuta limitações: método detecta existência, não localiza o ciclo."
                                  ],
                                  "verification": "Gere relatório curto comparando processamento em DAG vs. não-DAG.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Software de grafos ou código Python",
                                    "Templates de relatório"
                                  ],
                                  "tips": "Teste com grafos maiores para ganhar confiança.",
                                  "learningObjective": "Aplicar integralmente o conceito de aciclicidade e detecção em cenários variados.",
                                  "commonMistakes": "Parar processamento prematuramente sem verificar todos os nós no final."
                                }
                              ],
                              "practicalExample": "Em um grafo de dependências de software: Módulo A requer B, B requer C, C requer A (ciclo). Calculando indegrees: todos 1. Fila inicial vazia. Nenhum nó processado → ciclo detectado, impedindo build ordenado.",
                              "finalVerifications": [
                                "Explica corretamente por que ciclos impedem ordenação topológica completa.",
                                "Aplica algoritmo de Kahn para detectar ciclo em grafo dado.",
                                "Identifica nós não processados como evidência de ciclo.",
                                "Lista ordenação topológica válida apenas para DAGs confirmados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na explicação conceitual (ciclos criam dependências irresolúveis).",
                                "Correção no cálculo de indegrees e processamento da fila.",
                                "Capacidade de verificar todos os nós processados.",
                                "Clareza em exemplos práticos e detecção.",
                                "Profundidade na discussão de implicações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de ordem parcial e relações transitivas.",
                                "Programação: Gerenciamento de dependências em pacotes (npm, Maven).",
                                "Engenharia de Software: Análise de build systems e compiladores.",
                                "Lógica: Detecção de inconsistências em regras de precedência."
                              ],
                              "realWorldApplication": "Na compilação de código com dependências modulares (ex: Make, Gradle), detectar ciclos impede builds infinitos ou incorretos; em agendamento de tarefas (ex: construção de projetos com pré-requisitos)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.5.1.3",
                            "name": "Verificação de completude da ordenação",
                            "description": "Analisar se todos os vértices foram ordenados em uma tentativa de topo-sort para inferir a presença de ciclos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a representação do grafo direcionado",
                                  "subSteps": [
                                    "Liste todos os vértices do grafo.",
                                    "Identifique e liste todas as arestas direcionadas.",
                                    "Calcule o grau de entrada (in-degree) para cada vértice.",
                                    "Crie uma fila ou pilha inicial com vértices de grau de entrada zero.",
                                    "Verifique se o número total de vértices é conhecido e correto."
                                  ],
                                  "verification": "Confirme que a lista de vértices, arestas e graus de entrada está completa e sem erros através de uma inspeção visual ou soma de graus.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel e caneta ou editor de texto/planilha para listar vértices e arestas; grafo exemplo impresso ou digital.",
                                  "tips": "Use uma tabela para organizar vértices e seus graus de entrada para visualização rápida.",
                                  "learningObjective": "Compreender a estrutura do grafo e preparar dados para o algoritmo de Kahn.",
                                  "commonMistakes": "Esquecer arestas bidirecionais ou confundir grau de entrada com saída."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar o algoritmo de ordenação topológica (Kahn's)",
                                  "subSteps": [
                                    "Inicialize uma lista vazia para a ordem topológica.",
                                    "Enquanto a fila não estiver vazia, remova um vértice e adicione à ordem.",
                                    "Para cada vizinho do vértice removido, decremente o grau de entrada.",
                                    "Se o grau de um vizinho chegar a zero, adicione à fila.",
                                    "Continue até a fila esvaziar."
                                  ],
                                  "verification": "Registre o tamanho da lista de ordem topológica e compare com o número total de vértices durante a execução.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Mesmos da etapa 1; simulador de grafo online como Graphviz ou código Python simples para Kahn's.",
                                  "tips": "Simule manualmente em papel para grafos pequenos antes de codificar.",
                                  "learningObjective": "Executar corretamente o algoritmo de Kahn para gerar uma ordem parcial ou completa.",
                                  "commonMistakes": "Não atualizar corretamente os graus de entrada ou processar vértices múltiplas vezes."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a completude da ordenação",
                                  "subSteps": [
                                    "Conte o número de vértices na lista de ordem topológica gerada.",
                                    "Compare esse número com o total de vértices no grafo original.",
                                    "Se igual, a ordenação está completa (sem ciclos).",
                                    "Se menor, identifique vértices restantes com grau de entrada >0.",
                                    "Registre a conclusão: presença de ciclo se incompleta."
                                  ],
                                  "verification": "A lista de ordem tem tamanho igual ao número de vértices? Liste vértices não ordenados se aplicável.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Lista da ordem topológica do passo anterior; contador simples.",
                                  "tips": "Sempre anote o comprimento da lista após cada iteração para rastrear progresso.",
                                  "learningObjective": "Detectar incompletude como indicador direto de ciclos.",
                                  "commonMistakes": "Confundir ordenação incompleta com erro de execução do algoritmo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar e documentar implicações de ciclos",
                                  "subSteps": [
                                    "Liste vértices não ordenados e seus graus de entrada restantes.",
                                    "Trace caminhos que levam a ciclos potenciais entre esses vértices.",
                                    "Compare com execução em grafo acíclico para contrastar.",
                                    "Documente o relatório: 'Ordenação incompleta indica ciclo'.",
                                    "Teste com variação do grafo para validar."
                                  ],
                                  "verification": "Produza um relatório escrito confirmando presença/ausência de ciclo com evidências numéricas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Relatório em texto; grafo acíclico de comparação.",
                                  "tips": "Use cores para destacar vértices cíclicos em desenhos manuais.",
                                  "learningObjective": "Inferir e justificar a presença de ciclos a partir da verificação.",
                                  "commonMistakes": "Assumir ciclo sem verificar contagem exata de vértices."
                                }
                              ],
                              "practicalExample": "Considere o grafo com vértices A, B, C e arestas A->B, B->C, C->A. Executando Kahn's: nenhum vértice inicial grau 0, ordem vazia (0/3), incompleta → ciclo detectado. Compare com A->B->C: ordem A,B,C (3/3), completa → acíclico.",
                              "finalVerifications": [
                                "Número de vértices na ordem topológica equals total de vértices?",
                                "Todos graus de entrada foram corretamente atualizados?",
                                "Vértices restantes têm grau >0 confirmados?",
                                "Relatório escrito explica inferência de ciclo corretamente?",
                                "Teste em grafo acíclico contrasta com o cíclico?",
                                "Sem erros na lista de arestas ou vértices iniciais?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de vértices ordenados vs total (100% correto).",
                                "Execução impecável do algoritmo Kahn sem falhas lógicas.",
                                "Inferência correta de ciclo baseada em incompletude.",
                                "Documentação clara com evidências numéricas e visuais.",
                                "Identificação de pelo menos um caminho cíclico em casos incompletos.",
                                "Tempo de execução dentro do estimado com eficiência."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e relações parciais.",
                                "Programação: Implementação de filas e algoritmos em Python/Java.",
                                "Lógica: Raciocínio dedutivo para detecção de inconsistências.",
                                "Gestão de Projetos: Detecção de dependências circulares em tarefas."
                              ],
                              "realWorldApplication": "Em gerenciamento de dependências de software (ex: compiladores detectam ciclos em Makefiles), agendamento de tarefas (ex: evitar loops em fluxos de trabalho industriais) e análise de redes sociais (detectar comunidades cíclicas de influência)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.2",
                        "name": "Detecção de Ciclos com DFS",
                        "description": "Implementar detecção de ciclos usando Depth-First Search com rastreamento de estados de visita.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.2.1",
                            "name": "Estados de cor em DFS para detecção",
                            "description": "Utilizar cores branco (não visitado), cinza (visitando) e preto (visitado) para identificar arestas de retorno que indicam ciclos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Estados de Cor em DFS para Detecção de Ciclos",
                                  "subSteps": [
                                    "Estude o significado das cores: branco (não visitado), cinza (visitando/atualmente na pilha de recursão), preto (visitado e processamento concluído).",
                                    "Analise como a cor cinza indica nós ativos na pilha recursiva, permitindo detectar dependências pendentes.",
                                    "Entenda que arestas de retorno são detectadas quando uma aresta aponta para um nó cinza, sinalizando um ciclo.",
                                    "Revise o algoritmo DFS padrão e visualize a transição de cores em um diagrama de grafo simples.",
                                    "Compare com detecção de ciclos sem cores para destacar a vantagem da coloração."
                                  ],
                                  "verification": "Explique em um diagrama ou texto curto o fluxo de cores para um nó com ciclo e sem ciclo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Tutorial online sobre DFS colorido (ex: GeeksforGeeks)",
                                    "Grafo de exemplo impresso"
                                  ],
                                  "tips": "Use cores reais (canetas coloridas) no diagrama para fixar visualmente os estados.",
                                  "learningObjective": "Dominar o significado e o propósito das três cores no contexto de detecção de ciclos via DFS.",
                                  "commonMistakes": [
                                    "Confundir cinza (na pilha) com preto (finalizado)",
                                    "Achar que qualquer aresta para visitado indica ciclo, ignorando apenas cinza"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Atribuição de Cores na Função DFS",
                                  "subSteps": [
                                    "Inicialize um array ou mapa de cores com todos os nós em branco (ex: 0 para branco, 1 para cinza, 2 para preto).",
                                    "Na função DFS, ao entrar em um nó, mude sua cor para cinza e marque como visitando.",
                                    "Para cada vizinho: se branco, chame DFS recursivamente; se cinza, detecte ciclo; se preto, ignore.",
                                    "Ao final da recursão do nó (após processar todos vizinhos), mude para preto.",
                                    "Implemente uma função wrapper para iniciar DFS em nós não visitados."
                                  ],
                                  "verification": "Execute DFS em um grafo acíclico e confirme que todos os nós terminam pretos sem detecção de ciclo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Biblioteca de grafos (ex: Python dict para adjacência)",
                                    "Grafo de teste acíclico hardcoded"
                                  ],
                                  "tips": "Use print statements para rastrear mudanças de cor durante a execução.",
                                  "learningObjective": "Implementar corretamente as transições de cor durante a execução recursiva de DFS.",
                                  "commonMistakes": [
                                    "Esquecer de pintar de cinza ao entrar",
                                    "Não pintar de preto após recursão, causando detecções erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar e Tratar Arestas de Retorno com Cores",
                                  "subSteps": [
                                    "No loop de vizinhos, adicione verificação: se cor[vizinho] == cinza, retorne true para ciclo.",
                                    "Diferencie tipos de arestas: árvore (branco), retorno (cinza), cross/forward (preto).",
                                    "Registre o ciclo encontrado (ex: par nó-vizinho) para depuração.",
                                    "Teste com grafo contendo ciclo simples (ex: A->B->C->A).",
                                    "Garanta que a detecção pare a recursão ao encontrar ciclo, se desejado."
                                  ],
                                  "verification": "Em um grafo com ciclo, a função retorna true e identifica corretamente a aresta de retorno.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Grafos de teste com e sem ciclo (JSON ou código)",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Comece com grafos pequenos (3-5 nós) para simular manualmente antes de codificar.",
                                  "learningObjective": "Identificar precisamente arestas de retorno usando cor cinza e sinalizar ciclos.",
                                  "commonMistakes": [
                                    "Detectar ciclo em arestas para preto",
                                    "Não verificar vizinhos após encontrar ciclo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar a Detecção Completa de Ciclos",
                                  "subSteps": [
                                    "Crie conjunto de testes: grafos acíclicos (DAG), com ciclo único, com múltiplos ciclos.",
                                    "Execute e verifique estados finais de cores e detecções.",
                                    "Analise complexidade: O(V + E) e confirme ausência de recursão infinita.",
                                    "Adicione tratamento para grafos desconexos (chame DFS em todos nós brancos).",
                                    "Documente o código com comentários sobre uso de cores."
                                  ],
                                  "verification": "Todos os testes passam: ciclos detectados corretamente, sem falsos positivos/negativos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Suite de testes unitários (ex: pytest em Python)",
                                    "Múltiplos grafos de teste",
                                    "Ferramenta de visualização de grafos (ex: Graphviz)"
                                  ],
                                  "tips": "Use asserts para automatizar verificações de cores pós-execução.",
                                  "learningObjective": "Validar robustez da implementação em cenários variados.",
                                  "commonMistakes": [
                                    "Ignorar componentes desconexos",
                                    "Recursão infinita em ciclos não detectados cedo"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo direcionado: A -> B, B -> C, C -> A (ciclo). Inicie DFS em A: pinte A cinza, visite B (cinza), visite C (cinza), de C para A (cinza) -> detecte ciclo! Pinte C preto, B preto, A preto. Sem ciclo: A -> B -> C, todos terminam pretos sem detecção.",
                              "finalVerifications": [
                                "Todos nós brancos inicializam corretamente e transitam para cinza/preto.",
                                "Arestas para cinza são identificadas como retorno e sinalizam ciclo.",
                                "Grafos acíclicos terminam sem detecção e todos pretos.",
                                "Grafos com ciclos detectam pelo menos uma aresta de retorno.",
                                "Componentes desconexos são processados completamente.",
                                "Não há recursão infinita ou stack overflow."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Detecta ciclos corretamente em 100% dos casos de teste.",
                                "Correção das transições de cor: Cinza apenas durante processamento ativo.",
                                "Eficiência: Tempo O(V + E), sem visitas redundantes.",
                                "Robustez: Trata grafos vazios, isolados e desconexos.",
                                "Clareza: Código comentado explicando uso de cores.",
                                "Depuração: Prints ou logs mostram estados de cor durante execução."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Classificação de arestas em DFS (tree, back, forward, cross).",
                                "Programação Recursiva: Gerenciamento de pilha e detecção de overflow.",
                                "Análise de Algoritmos: Pré-requisito para ordenação topológica em DAGs.",
                                "Estruturas de Dados: Representação de grafos via adjacência.",
                                "Matemática Discreta: Propriedades de grafos acíclicos direcionados (DAGs)."
                              ],
                              "realWorldApplication": "Em compiladores e sistemas de build (ex: Make, Gradle), detecta dependências circulares em projetos de software; em análise de redes sociais, identifica grupos com interações cíclicas; em planejamento de tarefas (ex: Microsoft Project), previne loops infinitos em cronogramas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.2",
                            "name": "Implementar DFS recursivo para ciclos",
                            "description": "Codificar uma função DFS que detecta ciclos recursivamente, marcando nós cinza durante a recursão e verificando back edges.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar representação do grafo e estados dos nós",
                                  "subSteps": [
                                    "Represente o grafo dirigido como uma lista de adjacência usando um dicionário ou array de listas.",
                                    "Crie um array ou dicionário para rastrear o estado dos nós: branco (0 - não visitado), cinza (1 - visitando), preto (2 - visitado).",
                                    "Inicialize todos os nós como brancos.",
                                    "Defina uma função auxiliar para verificar se um nó é cinza (indicando back edge).",
                                    "Prepare uma variável global ou de retorno para sinalizar a detecção de ciclo."
                                  ],
                                  "verification": "Verifique se a lista de adjacência está corretamente populada e todos os estados iniciais são brancos ao inspecionar o código e imprimir os dados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Linguagem de programação (Python ou JavaScript)"
                                  ],
                                  "tips": "Use chaves de dicionário para nós em grafos esparsos para eficiência de memória.",
                                  "learningObjective": "Entender e implementar estruturas de dados fundamentais para rastreamento de estados em DFS.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar estados para todos os nós",
                                    "Confundir lista de adjacência com matriz",
                                    "Usar índices inválidos para nós"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função DFS recursiva básica",
                                  "subSteps": [
                                    "Defina a função DFS(no) que marca o nó atual como cinza.",
                                    "Para cada vizinho do nó atual, se o vizinho for branco, chame DFS recursivamente nele.",
                                    "Após processar todos os vizinhos, marque o nó como preto.",
                                    "Implemente tratamento de base da recursão para nós folha.",
                                    "Adicione prints opcionais para depuração do caminho de recursão."
                                  ],
                                  "verification": "Execute DFS em um grafo acíclico simples e confirme que todos os nós são marcados como pretos sem erros de pilha.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console para depuração"
                                  ],
                                  "tips": "Aumente o limite de recursão se necessário em Python com sys.setrecursionlimit().",
                                  "learningObjective": "Dominar a recursão em DFS para travessia de grafos.",
                                  "commonMistakes": [
                                    "Não marcar como cinza no início, causando loops infinitos",
                                    "Chamar recursão em vizinhos pretos desnecessariamente",
                                    "Stack overflow por grafos profundos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar lógica de detecção de ciclos com back edges",
                                  "subSteps": [
                                    "Na recursão para vizinhos, se o vizinho for cinza, detecte um back edge e sinalize ciclo.",
                                    "Se ciclo detectado em recursão, propague o sinal de volta para a função chamadora.",
                                    "Mantenha o sinal de ciclo como uma referência mutável ou retorno booleano.",
                                    "Teste com um grafo contendo ciclo simples (ex: A->B->C->A).",
                                    "Garanta que ciclos não propaguem falsos positivos em componentes separadas."
                                  ],
                                  "verification": "Insira um ciclo conhecido e confirme que a função retorna true para ciclo; teste grafo acíclico retorna false.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Grafos de teste pré-definidos"
                                  ],
                                  "tips": "Use uma lista ou flag global para sinal de ciclo para simplicidade em recursão.",
                                  "learningObjective": "Identificar e implementar detecção precisa de back edges em DFS.",
                                  "commonMistakes": [
                                    "Marcar cinza após recursão em vez de antes",
                                    "Detectar back edges para nós pretos",
                                    "Não propagar detecção de ciclo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar DFS completo no grafo e validar",
                                  "subSteps": [
                                    "Crie função principal que itera sobre todos os nós e chama DFS se branco.",
                                    "Retorne true se qualquer DFS detectar ciclo.",
                                    "Adicione testes unitários para grafos com e sem ciclos.",
                                    "Meça complexidade e otimize acessos a adjacência.",
                                    "Documente o código com comentários sobre estados e lógica."
                                  ],
                                  "verification": "Rode testes em múltiplos grafos: confirme detecção correta em 100% dos casos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Framework de testes (unittest em Python)",
                                    "Editor de código"
                                  ],
                                  "tips": "Comece iteração pelos nós em ordem numérica para previsibilidade.",
                                  "learningObjective": "Integrar DFS em uma solução completa para detecção de ciclos em grafos direcionados.",
                                  "commonMistakes": [
                                    "Esquecer de chamar DFS em componentes desconectadas",
                                    "Ignorar nós isolados",
                                    "Falsos negativos em grafos multi-componentes"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo dirigido: nós [0,1,2], arestas 0->1, 1->2, 2->0. A função deve detectar ciclo ao encontrar back edge 2->0 enquanto 0 está cinza.",
                              "finalVerifications": [
                                "Função detecta corretamente ciclos em grafos com back edges.",
                                "Não reporta falsos positivos em grafos acíclicos (DAGs).",
                                "Todos os nós são visitados em grafos multi-componentes.",
                                "Estados são corretamente atualizados (branco -> cinza -> preto).",
                                "Código roda sem stack overflow em grafos profundos.",
                                "Tempo de execução é O(V + E)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de ciclos (100% em testes).",
                                "Correta implementação de estados de cor.",
                                "Eficiência: O(V + E) sem loops desnecessários.",
                                "Código limpo, comentado e modular.",
                                "Tratamento de casos edge (grafo vazio, nó isolado).",
                                "Uso apropriado de recursão sem mutações globais excessivas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Ordenação Topológica.",
                                "Programação: Técnicas Recursivas e Backtracking.",
                                "Engenharia de Software: Análise de Dependências em Projetos.",
                                "Ciência da Computação: Algoritmos de Travessia de Grafos."
                              ],
                              "realWorldApplication": "Detecção de ciclos em grafos de dependências de tarefas para agendamento de jobs (ex: build systems como Make), compiladores para ordem de declaração de variáveis, e análise de redes para evitar loops em roteamento."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.2.3",
                            "name": "Análise de complexidade do DFS para ciclos",
                            "description": "Calcular tempo O(V+E) e espaço O(V) do algoritmo DFS para detecção de ciclos em grafos direcionados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o pseudocódigo do DFS para detecção de ciclos em grafos direcionados",
                                  "subSteps": [
                                    "Identifique os componentes principais: visited array, recursion stack (recStack), e a função DFS recursiva.",
                                    "Analise a inicialização: crie visited de tamanho V (número de vértices) e recStack.",
                                    "Descreva o fluxo: para cada vértice não visitado, chame DFS(u); marque como visitado; empilhe em recStack; visite vizinhos.",
                                    "Explique detecção de ciclo: se vizinho visitado e em recStack, ciclo detectado; desempilhe após recursão.",
                                    "Confirme que o algoritmo explora todo o grafo via chamadas múltiplas."
                                  ],
                                  "verification": "Escreva o pseudocódigo completo e identifique corretamente visited, recStack e condições de ciclo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Editor de texto para pseudocódigo",
                                    "Exemplo de grafo direcionado simples"
                                  ],
                                  "tips": "Use setas para representar chamadas recursivas em um diagrama de grafo pequeno para visualizar o fluxo.",
                                  "learningObjective": "Compreender a estrutura exata do algoritmo DFS para detecção de ciclos, preparando para contagem de operações.",
                                  "commonMistakes": [
                                    "Confundir visited com recStack",
                                    "Ignorar chamadas DFS para todos os vértices",
                                    "Esquecer de desempilhar recStack"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a complexidade temporal: Contar visitas a vértices e arestas",
                                  "subSteps": [
                                    "Conte inicializações: O(V) para visited e recStack.",
                                    "Analise loop principal: para cada vértice (V iterações), chama DFS(u) uma vez por vértice.",
                                    "No DFS: para cada aresta de u (total E arestas no grafo), verifica vizinho: O(1) por aresta.",
                                    "Operações recursivas: cada vértice processado uma vez, total O(V + E).",
                                    "Some todas: inicializações O(V) + explorações O(V + E) = O(V + E)."
                                  ],
                                  "verification": "Liste todas as operações lineares em V ou E e justifique por que não há quadráticas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Grafo exemplo com V=5, E=7",
                                    "Tabela para contar operações por linha de código"
                                  ],
                                  "tips": "Pense em termos de 'cada vértice visitado exatamente uma vez' e 'cada aresta examinada exatamente uma vez'.",
                                  "learningObjective": "Dominar a contagem precisa de operações para derivar O(V + E) no tempo de execução.",
                                  "commonMistakes": [
                                    "Contar recursões como O(V^2)",
                                    "Ignorar que arestas são E no total",
                                    "Esquecer loop principal"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a complexidade espacial: Avaliar uso de memória",
                                  "subSteps": [
                                    "Identifique arrays: visited O(V), recStack O(V), representação do grafo O(V + E).",
                                    "Analise pilha de recursão: pior caso é cadeia de V vértices, profundidade O(V).",
                                    "Confirme que variáveis locais são O(1) por chamada, mas pilha total O(V).",
                                    "Ignore grafo se dado: foco em auxiliares O(V); se construir adj list, O(V + E) mas dominante O(V + E).",
                                    "Conclua espaço auxiliar O(V), assumindo grafo dado."
                                  ],
                                  "verification": "Desenhe pilha de recursão para grafo em linha e confirme uso máximo de O(V) frames.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de pilha de chamadas",
                                    "Grafo em cadeia para pior caso espacial"
                                  ],
                                  "tips": "Visualize a pilha crescendo em um caminho longo; desempilha após backtrack.",
                                  "learningObjective": "Explicar por que espaço é O(V) devido à recursão máxima, não O(V + E).",
                                  "commonMistakes": [
                                    "Confundir com espaço do grafo",
                                    "Pensar pilha como O(E)",
                                    "Ignorar recStack como O(V)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e generalizar a análise com exemplo prático",
                                  "subSteps": [
                                    "Escolha grafo com V=4, E=5 (incluindo ciclo); execute DFS manualmente contando operações.",
                                    "Registre contadores: visitas a vértices (4), arestas (5), empilhamentos (4).",
                                    "Calcule tempo: ~9 operações = O(4+5); espaço: pilha max 3 + arrays 4 = O(4).",
                                    "Generalize: para grafos esparsos/densos, confirme assintótico O(V + E) tempo, O(V) espaço.",
                                    "Discuta otimizações: iterativo reduziria pilha, mas complexidade similar."
                                  ],
                                  "verification": "Para grafo dado, calcule exatamente e prove escala com V+E.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Grafo específico desenhado",
                                    "Planilha para contadores de execução"
                                  ],
                                  "tips": "Use um grafo com ciclo para testar detecção sem afetar contagens.",
                                  "learningObjective": "Aplicar análise teórica a exemplo concreto e validar notação Big O.",
                                  "commonMistakes": [
                                    "Contar apenas melhor caso",
                                    "Não considerar pior caso para espaço",
                                    "Erros aritméticos em contagem"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo direcionado com V=5 vértices (0-4) e E=7 arestas: 0->1, 1->2, 2->0 (ciclo), 3->4, 4->3 (ciclo), 2->4. Execute DFS: visita 0 (empilha),1,2 (detecta ciclo em 0), desempilha; depois 3,4 (ciclo). Total: 5 vértices + 7 arestas processados = O(12) tempo; pilha max ~3 + O(5) arrays = O(5) espaço. Escala linearmente.",
                              "finalVerifications": [
                                "Pode derivar O(V + E) tempo listando operações por vértice/aresta.",
                                "Explica O(V) espaço justificando pilha recursiva máxima.",
                                "Executa análise em grafo exemplo sem erros de contagem.",
                                "Distingue tempo vs. espaço corretamente para grafos direcionados.",
                                "Identifica que análise vale para acíclico/cíclico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de operações: 100% das linhas cobertas por O(V+E).",
                                "Correção espacial: identifica todos componentes O(V) sem exageros.",
                                "Uso correto de notação assintótica: ignora constantes, foca dominantes.",
                                "Generalização: aplica a qualquer grafo direcionado representável por lista adj.",
                                "Clareza na justificativa: usa argumentos de 'uma vez por vértice/aresta'.",
                                "Tratamento de casos: pior caso temporal/especial explicitado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Notação Big O e análise assintótica.",
                                "Teoria dos Grafos: Propriedades de DFS em grafos direcionados.",
                                "Programação: Recursão e gerenciamento de pilha em linguagens como Python/Java.",
                                "Engenharia de Software: Detecção de ciclos em dependências de projetos.",
                                "Algoritmos: Comparação com BFS ou Kahn para ordenação topológica."
                              ],
                              "realWorldApplication": "Em sistemas de build como Maven/Gradle, detecta ciclos de dependências em projetos Java (O(V+E) eficiente para milhares de módulos); compiladores usam para ordem de avaliação de expressões; schedulers de tarefas evitam deadlocks em workflows DAG."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.5.3",
                        "name": "Detecção de Ciclos com Algoritmo de Kahn",
                        "description": "Usar o algoritmo de Kahn para topo-sort e verificar completude para detectar ciclos via graus de entrada.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.5.3.1",
                            "name": "Calcular graus de entrada",
                            "description": "Computar o número de arestas entrantes para cada vértice como pré-requisito para o algoritmo de Kahn.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar o grafo direcionado usando lista de adjacência",
                                  "subSteps": [
                                    "Identifique todos os vértices do grafo e numere-os sequencialmente (ex: 0 a n-1).",
                                    "Crie uma lista de adjacência onde cada vértice aponta para seus vizinhos de saída (arestas que saem dele).",
                                    "Liste todas as arestas do grafo no formato (u, v), onde u -> v.",
                                    "Verifique se não há arestas duplicadas ou auto-loops, a menos que especificado.",
                                    "Anote o número total de vértices (V) e arestas (E)."
                                  ],
                                  "verification": "Confirme que a lista de adjacência reproduz corretamente todas as arestas ao percorrê-la.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e lápis ou editor de código (Python/Jupyter Notebook) com listas vazias para adjacência.",
                                  "tips": "Use dicionários em Python para listas de adjacência se os vértices forem rotulados por strings.",
                                  "learningObjective": "Compreender e implementar a representação padrão de grafos direcionados para análise de arestas.",
                                  "commonMistakes": "Confundir direção das arestas (saída vs. entrada); esquecer vértices isolados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar o array de graus de entrada",
                                  "subSteps": [
                                    "Crie um array ou lista de tamanho V (número de vértices), inicializando todos os elementos com 0.",
                                    "Associe cada índice do array a um vértice específico (índice i para vértice i).",
                                    "Nomeie o array como 'inDegrees' ou similar para clareza.",
                                    "Verifique o tamanho do array e confirme que todos os valores são zero.",
                                    "Considere casos especiais como grafos vazios (V=0)."
                                  ],
                                  "verification": "Imprima ou liste o array inicial e confirme que todos os valores são 0.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Array/lista vazia em Python ou planilha para simulação manual.",
                                  "tips": "Use [0] * V em Python para inicialização rápida.",
                                  "learningObjective": "Preparar uma estrutura de dados eficiente para acumular contagens de arestas entrantes.",
                                  "commonMistakes": "Inicializar com valores errados ou tamanho incorreto; confundir com out-degrees."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular graus de entrada iterando pelas arestas",
                                  "subSteps": [
                                    "Para cada vértice u na lista de adjacência:",
                                    "  Para cada vizinho v em adj[u]:",
                                    "    Incremente inDegrees[v] por 1.",
                                    "Repita para todas as arestas, garantindo que cada aresta seja contada exatamente uma vez.",
                                    "Registre o progresso para grafos grandes, contando iterações.",
                                    "Trate múltiplas arestas entre o mesmo par (u,v) somando corretamente."
                                  ],
                                  "verification": "Percorra o array final e confirme incrementos manuais para 2-3 arestas aleatórias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código Python com loops duplos ou cálculo manual em papel para grafos pequenos.",
                                  "tips": "Implemente como for u in range(V): for v in adj[u]: inDegrees[v] += 1 para eficiência.",
                                  "learningObjective": "Aplicar iteração sobre estruturas de grafos para computar propriedades locais como in-degrees.",
                                  "commonMistakes": "Incrementar inDegrees[u] em vez de inDegrees[v]; pular vértices sem arestas de saída."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e exibir os graus de entrada calculados",
                                  "subSteps": [
                                    "Some todos os valores no array inDegrees e compare com o número total de arestas E.",
                                    "Identifique vértices com grau 0 (sem arestas entrantes).",
                                    "Verifique vértices isolados (grau 0 e sem saídas).",
                                    "Exiba o resultado como um mapeamento vértice -> grau.",
                                    "Teste com um grafo alterado para confirmar robustez."
                                  ],
                                  "verification": "Soma dos in-degrees == E e graus coerentes com a estrutura visual do grafo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Função soma() em Python ou calculadora para verificação manual.",
                                  "tips": "Visualize o grafo desenhado à mão para validação intuitiva.",
                                  "learningObjective": "Garantir a correção do cálculo através de propriedades invariantes dos grafos.",
                                  "commonMistakes": "Ignorar a soma total; erro em off-by-one no indexação de vértices."
                                }
                              ],
                              "practicalExample": "Considere o grafo direcionado com vértices 0,1,2,3 e arestas: 0->1, 0->2, 1->2, 2->3. Lista de adjacência: adj[0]=[1,2], adj[1]=[2], adj[2]=[3], adj[3]=[]. Após cálculo: inDegrees = [0, 1, 2, 1]. Verificação: soma=4 (igual a E=4).",
                              "finalVerifications": [
                                "Soma de todos os graus de entrada equals o número total de arestas.",
                                "Todos os vértices sem arestas entrantes têm grau exatamente 0.",
                                "Vértices isolados têm grau 0.",
                                "Para cada aresta u->v, inDegrees[v] foi incrementado corretamente.",
                                "O array cobre todos os V vértices sem índices faltantes ou extras.",
                                "Teste com grafo vazio ou único vértice resulta em [0]."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Todos os graus calculados corretamente sem erros de contagem.",
                                "Eficiência: Algoritmo roda em O(V + E) tempo, sem loops desnecessários.",
                                "Robustez: Funciona para grafos com auto-loops, múltiplas arestas e isolados.",
                                "Clareza: Código ou representação bem comentada e legível.",
                                "Validação: Inclui pelo menos uma verificação de soma e casos edge.",
                                "Escalabilidade: Testado com grafo de pelo menos 5 vértices."
                              ],
                              "crossCurricularConnections": [
                                "Teoria de Grafos (Matemática Discreta): Propriedades de graus em digrafos.",
                                "Programação (Ciência da Computação): Loops aninhados e estruturas de dados.",
                                "Gestão de Projetos: Análise de dependências em cronogramas de tarefas.",
                                "Engenharia de Software: Ordenação de build em sistemas com dependências."
                              ],
                              "realWorldApplication": "No desenvolvimento de software, calcular graus de entrada identifica módulos independentes para compilação paralela (ex: em ferramentas como Maven ou npm); em gerenciamento de projetos, determina tarefas prontas para início baseadas em pré-requisitos completados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.1.3"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.2",
                            "name": "Implementar fila de nós com grau zero",
                            "description": "Usar uma fila para processar nós sem entradas pendentes, atualizando graus e construindo a ordenação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Calcular graus de entrada e inicializar a fila com nós de grau zero",
                                  "subSteps": [
                                    "Represente o grafo usando lista de adjacência (dicionário onde chaves são nós e valores são listas de vizinhos).",
                                    "Crie um dicionário ou array para armazenar o grau de entrada de cada nó, inicializando todos com 0.",
                                    "Para cada aresta (u, v) no grafo, incremente o grau de entrada de v.",
                                    "Crie uma fila vazia (use deque para eficiência FIFO).",
                                    "Percorra todos os nós e enfileire aqueles com grau de entrada igual a 0.",
                                    "Inicialize uma lista vazia para armazenar a ordenação topológica."
                                  ],
                                  "verification": "Verifique se a fila contém exatamente todos os nós com grau de entrada zero e se os graus foram calculados corretamente comparando com o grafo manualmente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de adjacência do grafo",
                                    "Linguagem de programação (ex: Python com collections.deque)",
                                    "Editor de código"
                                  ],
                                  "tips": "Use um conjunto de todos os nós para garantir que nenhum seja esquecido nos graus iniciais.",
                                  "learningObjective": "Compreender como identificar nós independentes iniciais em um grafo direcionado.",
                                  "commonMistakes": [
                                    "Inicializar graus sem percorrer todas as arestas",
                                    "Usar lista comum em vez de fila para perda de ordem FIFO",
                                    "Esquecer nós isolados (grau 0)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o loop principal de processamento da fila",
                                  "subSteps": [
                                    "Inicie um loop while enquanto a fila não estiver vazia.",
                                    "Remova o nó da frente da fila (dequeue).",
                                    "Adicione esse nó à lista de ordenação topológica.",
                                    "Para cada vizinho v do nó atual u, decremente o grau de entrada de v.",
                                    "Se o grau de entrada de v se tornar 0 após decremento, enfileire v.",
                                    "Continue o loop até a fila esvaziar."
                                  ],
                                  "verification": "Execute com um grafo pequeno e confirme que a ordenação produzida respeita todas as dependências (nenhum nó aparece antes de seus predecessores).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do passo 1",
                                    "Exemplos de grafos acíclicos",
                                    "Debugger ou print statements"
                                  ],
                                  "tips": "Adicione prints temporários para rastrear enfileiramentos e dequeue para depuração visual.",
                                  "learningObjective": "Dominar o processamento iterativo que libera nós dependentes progressivamente.",
                                  "commonMistakes": [
                                    "Decrementar grau do nó errado (vizinho em vez de destino)",
                                    "Enfileirar nós com grau >0",
                                    "Usar append/pop em lista (não FIFO)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar completude da ordenação e detectar presença de ciclos",
                                  "subSteps": [
                                    "Após o loop principal, compare o comprimento da lista de ordenação com o número total de nós.",
                                    "Se o comprimento for igual ao número de nós, retorne a lista como ordenação topológica válida.",
                                    "Caso contrário, indique detecção de ciclo (ex: retorne None ou mensagem de erro).",
                                    "Teste a função com um grafo acíclico e um com ciclo (ex: A->B->C->A).",
                                    "Otimize o código removendo prints e adicionando docstrings.",
                                    "Implemente como função reutilizável com parâmetros grafo e num_nos."
                                  ],
                                  "verification": "Teste com grafos conhecidos: acíclico deve retornar ordem completa; cíclico deve detectar falha corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo dos passos anteriores",
                                    "Grafos de teste (acíclico e cíclico)",
                                    "Ferramentas de teste unitário como pytest"
                                  ],
                                  "tips": "Conte o número de nós percorrendo as chaves da lista de adjacência para automação.",
                                  "learningObjective": "Aprender a usar contagem de nós processados para inferir aciclicidade.",
                                  "commonMistakes": [
                                    "Contar nós errados (incluir duplicatas)",
                                    "Não tratar grafos vazios ou com nó único",
                                    "Ignorar ciclos em subgrafos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e refatorar a implementação completa do algoritmo de Kahn",
                                  "subSteps": [
                                    "Encapsule todo o código em uma função KahnTopologicalSort(grafo).",
                                    "Adicione tratamento de erros (ex: grafo inválido, nós sem arestas).",
                                    "Meça complexidade: confirme O(V + E) com análise simples.",
                                    "Crie visualização opcional (ex: imprimir grafo e ordem).",
                                    "Execute benchmarks com grafos de tamanhos variados.",
                                    "Documente o código com comentários explicando cada seção."
                                  ],
                                  "verification": "A função deve passar em 5+ testes variados, incluindo casos edge (grafo vazio, ciclo simples, DAG complexo).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código refatorado",
                                    "Suite de testes",
                                    "Ferramenta de profiling (opcional)"
                                  ],
                                  "tips": "Use assert para validações rápidas durante desenvolvimento.",
                                  "learningObjective": "Consolidar a implementação em código production-ready e analisável.",
                                  "commonMistakes": [
                                    "Função não idempotente (modifica grafo original)",
                                    "Falta de retorno claro em casos de ciclo",
                                    "Código não escalável para grandes grafos"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo: {1: [2,3], 2:[4], 3:[4], 4:[]}. Graus iniciais: 1:0,2:1,3:1,4:2. Fila inicial: [1]. Dequeue 1 -> decrementa 2 e 3 para 0 -> enfileira 2,3. Dequeue 2 -> decrementa 4 para 1. Dequeue 3 -> decrementa 4 para 0 -> enfileira 4. Dequeue 4. Ordem: [1,2,3,4]. Com ciclo (adicione 4:[1]): fila esvazia após [1,2,3], len=3 <4 -> ciclo detectado.",
                              "finalVerifications": [
                                "Fila inicial contém todos nós com indegree 0.",
                                "Cada dequeue libera corretamente vizinhos para indegree 0.",
                                "Ordem topológica respeita precedências (nenhum predecessor após sucessor).",
                                "Detecção de ciclo falha corretamente quando len(ordem) < num_nós.",
                                "Função lida com grafos vazios, isolados e edge cases.",
                                "Execução em O(V+E) confirmada empiricamente."
                              ],
                              "assessmentCriteria": [
                                "Correção: passa em todos testes acíclicos e detecta ciclos.",
                                "Eficiência: usa fila O(1) operações, total O(V+E).",
                                "Clareza: código legível com nomes descritivos e comentários.",
                                "Robustez: trata entradas inválidas sem crash.",
                                "Modularidade: função autônoma e reutilizável.",
                                "Documentação: inclui docstring explicando parâmetros e retornos."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos (Matemática): Conceitos de indegree e aciclicidade.",
                                "Estruturas de Dados: Fila (Queue) e Dicionários para representação.",
                                "Programação Competitiva: Aplicação em problemas de ordenação de tarefas.",
                                "Gerência de Projetos: Modelagem de dependências em cronogramas.",
                                "Compiladores: Análise de dependências em grafos de módulos."
                              ],
                              "realWorldApplication": "No sistema de build Make ou Gradle para ordenar compilação de módulos dependentes; em compiladores para ordenar passes de otimização; em agendamento de tarefas em pipelines CI/CD; detecção de deadlocks em sistemas distribuídos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.1"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.3",
                            "name": "Verificar ciclo pela contagem de nós processados",
                            "description": "Comparar o número de nós na ordenação resultante com o total de vértices para detectar ciclos se incompleto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Executar o Algoritmo de Kahn e Registrar Nós Processados",
                                  "subSteps": [
                                    "Implemente ou simule a fila inicial com nós de indegree 0.",
                                    "Itere removendo nós da fila, adicionando-os à lista de ordenação topológica e atualizando indegrees dos vizinhos.",
                                    "Continue até a fila estar vazia, registrando cada nó adicionado à lista.",
                                    "Mantenha um contador incremental para cada nó processado.",
                                    "Pare quando nenhum nó mais puder ser processado."
                                  ],
                                  "verification": "Verifique se a lista de ordenação topológica foi populada corretamente e o contador reflete o número de entradas adicionadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo do Algoritmo de Kahn",
                                    "Representação do grafo (lista de adjacência e array de indegrees)",
                                    "Editor de código ou papel para simulação"
                                  ],
                                  "tips": "Use uma lista ou array para rastrear a ordenação e incremente o contador apenas ao adicionar um nó.",
                                  "learningObjective": "Compreender a mecânica de remoção progressiva de nós sem dependências pendentes.",
                                  "commonMistakes": "Esquecer de atualizar indegrees dos vizinhos ou adicionar nós com indegree >0 à fila."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Contar o Número Total de Nós Processados",
                                  "subSteps": [
                                    "Inspecione a lista de ordenação topológica gerada.",
                                    "Conte o tamanho da lista ou o valor final do contador de nós processados.",
                                    "Registre esse valor como 'nósProcessados'.",
                                    "Confirme que nenhum nó foi contado mais de uma vez.",
                                    "Anote o valor para comparação posterior."
                                  ],
                                  "verification": "O contador ou tamanho da lista corresponde exatamente ao número de nós únicos adicionados durante a execução.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista de ordenação topológica do Step 1",
                                    "Calculadora ou contador manual"
                                  ],
                                  "tips": "Se implementando em código, use len(ordenacao) ou um contador simples como 'count += 1'.",
                                  "learningObjective": "Desenvolver precisão na contagem de elementos processados em uma estrutura de dados.",
                                  "commonMistakes": "Contar nós não processados ou duplicar contagens acidentais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Obter o Número Total de Vértices no Grafo",
                                  "subSteps": [
                                    "Identifique o conjunto completo de vértices no grafo original.",
                                    "Conte todos os vértices únicos, independentemente de conexões.",
                                    "Registre como 'totalVertices'.",
                                    "Verifique se todos os vértices estão representados na lista de adjacência ou matriz.",
                                    "Compare rapidamente com o tamanho conhecido do grafo."
                                  ],
                                  "verification": "A contagem total de vértices bate com a definição inicial do grafo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Definição original do grafo",
                                    "Lista de adjacência ou matriz de adjacência"
                                  ],
                                  "tips": "Em código, use o tamanho do array de vértices; evite confundir com número de arestas.",
                                  "learningObjective": "Diferenciar entre nós processados e o conjunto total de vértices.",
                                  "commonMistakes": "Confundir total de vértices com total de arestas ou nós isolados não contados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Contagens e Detectar Ciclo",
                                  "subSteps": [
                                    "Compare 'nósProcessados' com 'totalVertices'.",
                                    "Se nósProcessados == totalVertices, conclua que não há ciclo (grafo DAG).",
                                    "Se nósProcessados < totalVertices, conclua que há ciclo (nós restantes em ciclo).",
                                    "Explique o porquê: nós não processados indicam dependências circulares.",
                                    "Documente a conclusão com evidências das contagens."
                                  ],
                                  "verification": "A conclusão está correta baseada na igualdade das contagens e justificada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Valores de nósProcessados e totalVertices dos steps anteriores",
                                    "Papel para anotar conclusão"
                                  ],
                                  "tips": "Lembre-se: ciclo existe se e somente se nem todos os nós foram processados.",
                                  "learningObjective": "Aplicar lógica condicional para inferir presença de ciclos a partir de contagens.",
                                  "commonMistakes": "Invertar a condição (pensar que mais nós processados indica ciclo)."
                                }
                              ],
                              "practicalExample": "Grafo com 4 vértices: A->B, B->C, C->D (DAG). Kahn processa A,B,C,D (4 nós). totalVertices=4 → Sem ciclo. Agora adicione D->B (ciclo). Kahn processa só A (1 nó), pois B,C,D ficam com indegree >0 → 1 < 4 → Ciclo detectado.",
                              "finalVerifications": [
                                "Lista de ordenação tem exatamente o número de nós processados.",
                                "Contador final bate com tamanho da lista.",
                                "Comparação correta: igualdade indica DAG, desigualdade indica ciclo.",
                                "Explicação inclui razão pela detecção (nós restantes presos em ciclo).",
                                "Teste em grafo conhecido sem ciclo confirma 100% processados.",
                                "Teste em grafo com ciclo confirma <100% processados."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução do Kahn (sem erros em indegrees).",
                                "Contagem correta de nós processados vs. total.",
                                "Conclusão lógica e justificada pela comparação.",
                                "Identificação de pelo menos um grafo de teste com ciclo e sem.",
                                "Explicação clara do mecanismo de detecção.",
                                "Ausência de erros comuns como contagem dupla."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e propriedades de DAGs.",
                                "Programação: Estruturas de dados (filas, listas) e algoritmos de grafo.",
                                "Lógica Computacional: Inferência baseada em contagens e condições.",
                                "Engenharia de Software: Detecção de dependências circulares em builds."
                              ],
                              "realWorldApplication": "Em sistemas de gerenciamento de dependências como Maven ou npm, detectar ciclos em grafos de pacotes evita builds infinitos; em agendamento de tarefas (ex: compilação paralela), garante ordem viável sem loops."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.3.2"
                            ]
                          },
                          {
                            "id": "10.1.4.5.3.4",
                            "name": "Comparar DFS e Kahn para detecção",
                            "description": "Discutir vantagens: DFS detecta ciclo diretamente, Kahn via completude, ambos O(V+E).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Detecção de Ciclo com DFS",
                                  "subSteps": [
                                    "Explicar os três estados dos nós: branco (não visitado), cinza (em processamento), preto (processado).",
                                    "Identificar detecção de ciclo via back edge para nó cinza.",
                                    "Escrever pseudocódigo básico para DFS com detecção de ciclo em grafo direcionado.",
                                    "Simular em um grafo simples sem ciclo.",
                                    "Calcular complexidade temporal e espacial."
                                  ],
                                  "verification": "Implemente DFS em pseudocódigo e teste em um grafo com ciclo conhecido, confirmando detecção.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para grafos",
                                    "Pseudocódigo de referência (ex: GeeksforGeeks DFS cycle detection)"
                                  ],
                                  "tips": "Use recursão para simplicidade, mas monitore pilha para grafos grandes.",
                                  "learningObjective": "Compreender o mecanismo direto de detecção de ciclos via back edges em DFS.",
                                  "commonMistakes": [
                                    "Confundir back edge com forward edge.",
                                    "Esquecer de marcar nós como cinza durante recursão."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Revisar Detecção de Ciclo com Algoritmo de Kahn",
                                  "subSteps": [
                                    "Calcular graus de entrada para todos os nós.",
                                    "Inicializar fila com nós de grau zero.",
                                    "Processar fila, reduzindo graus de vizinhos e adicionando zeros à fila.",
                                    "Contar nós processados; se menor que V, há ciclo.",
                                    "Calcular complexidade temporal e espacial."
                                  ],
                                  "verification": "Simule Kahn em um grafo com ciclo e verifique se count < V.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis para graus de entrada",
                                    "Pseudocódigo de Kahn's algorithm"
                                  ],
                                  "tips": "Use uma fila ou deque para eficiência.",
                                  "learningObjective": "Dominar detecção indireta de ciclos via completude da ordenação topológica.",
                                  "commonMistakes": [
                                    "Erro ao atualizar graus de entrada incorretamente.",
                                    "Ignorar múltiplas componentes conectadas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Mecanismos de Detecção",
                                  "subSteps": [
                                    "Contrastar detecção direta (DFS: back edge) vs indireta (Kahn: count incompleto).",
                                    "Discutir vantagens de DFS: detecta ciclo imediatamente sem processar todo grafo.",
                                    "Analisar vantagens de Kahn: não recursivo, produz ordenação parcial se DAG.",
                                    "Identificar cenários onde DFS é preferível (ex: encontrar ciclo específico).",
                                    "Listar desvantagens: DFS risco de stack overflow, Kahn precisa de in-degrees."
                                  ],
                                  "verification": "Crie uma tabela comparativa com pelo menos 5 diferenças chave.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela em papel ou planilha",
                                    "Exemplos de grafos"
                                  ],
                                  "tips": "Use tabelas para visualização clara de prós e contras.",
                                  "learningObjective": "Diferenciar abordagens qualitativas de detecção de ciclos.",
                                  "commonMistakes": [
                                    "Afirmar que um é sempre melhor sem contexto.",
                                    "Confundir ordenação topológica com detecção."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Complexidade e Requisitos Práticos",
                                  "subSteps": [
                                    "Confirmar ambas O(V+E) temporal e O(V) espacial.",
                                    "Comparar pré-requisitos: DFS só adj list, Kahn precisa in-degrees extras.",
                                    "Discutir implementações: DFS recursivo vs iterativo, Kahn com fila.",
                                    "Avaliar em termos de código: linhas de código e legibilidade.",
                                    "Recomendar uso baseado em contexto (ex: Kahn para ordenação + detecção)."
                                  ],
                                  "verification": "Escreva snippets comparativos e analise tempo/espaço em um exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para código",
                                    "Grafos de teste"
                                  ],
                                  "tips": "Meça tempo real em implementações pequenas.",
                                  "learningObjective": "Analisar eficiência quantitativa e requisitos para escolha informada.",
                                  "commonMistakes": [
                                    "Ignorar custo de calcular in-degrees em Kahn.",
                                    "Superestimar diferenças de complexidade."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo: A→B, B→C, C→A, D→B (V=4, ciclo ABC). DFS detecta back edge C→A imediatamente. Kahn: in-degrees [0,1,1,0] (A=0,D=0), processa A (B=0), D (sem mudança), B (C=0), processa C? Não, count=3 <4 → ciclo.",
                              "finalVerifications": [
                                "Explique detecção direta em DFS com back edge.",
                                "Simule Kahn mostrando count incompleto.",
                                "Liste 3 vantagens de cada método.",
                                "Compare complexidades com justificativa.",
                                "Identifique quando preferir um sobre o outro."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição de mecanismos (direto vs indireto).",
                                "Correção na análise de complexidade O(V+E).",
                                "Profundidade em vantagens/desvantagens com exemplos.",
                                "Uso correto de terminologia (back edge, in-degree, etc.).",
                                "Capacidade de aplicar em grafo exemplo.",
                                "Clareza na tabela ou comparação escrita.",
                                "Recomendações contextuais realistas."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos (Matemática Discreta)",
                                "Análise de Algoritmos e Complexidade",
                                "Programação Estruturada e Recursão",
                                "Engenharia de Software (Dependências)",
                                "Inteligência Artificial (Redes Bayesianas)"
                              ],
                              "realWorldApplication": "Em compiladores para detectar ciclos em dependências de módulos; gerenciadores de pacotes (npm/yarn) evitam instalações infinitas; agendamento de tarefas em pipelines CI/CD onde tarefas circulares bloqueiam builds."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.4.5.2.3",
                              "10.1.4.5.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.4.6",
                    "name": "Aplicações da Ordenação Topológica",
                    "description": "Uso em agendamento de tarefas, programação dinâmica e resolução de dependências.",
                    "individualConcepts": [
                      {
                        "id": "10.1.4.6.1",
                        "name": "Agendamento de Tarefas",
                        "description": "Aplicação da ordenação topológica para determinar a ordem de execução de tarefas com dependências, modeladas como um grafo acíclico direcionado (DAG), garantindo que tarefas precedentes sejam concluídas antes das dependentes.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.6.1.1",
                            "name": "Modelar problemas de agendamento como grafos DAG",
                            "description": "Construir um grafo direcionado onde vértices representam tarefas e arestas indicam dependências, verificando ausência de ciclos para aplicar ordenação topológica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar o problema de agendamento e identificar tarefas e dependências",
                                  "subSteps": [
                                    "Leia a descrição do problema e liste todas as tarefas individuais.",
                                    "Identifique explicitamente as dependências entre tarefas (qual deve preceder qual).",
                                    "Crie uma tabela ou lista com tarefas e suas dependências diretas.",
                                    "Valide se todas as dependências foram capturadas sem ambiguidades.",
                                    "Documente tarefas independentes (sem dependências de entrada)."
                                  ],
                                  "verification": "Verifique se a lista de tarefas e dependências está completa e sem duplicatas, com cada dependência mapeada corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Descrição do problema de agendamento"
                                  ],
                                  "tips": "Comece pelas tarefas de nível superior (sem dependências) para facilitar a visualização.",
                                  "learningObjective": "Compreender e extrair dependências de problemas reais de agendamento.",
                                  "commonMistakes": [
                                    "Ignorar dependências transitivas iniciais",
                                    "Confundir ordem com duração de tarefas",
                                    "Listar tarefas ambíguas ou não atômicas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir o grafo direcionado representando tarefas e dependências",
                                  "subSteps": [
                                    "Atribua um vértice único a cada tarefa da lista.",
                                    "Desenhe uma aresta direcionada de tarefa A para B se B depende de A (A → B significa A antes de B).",
                                    "Rotule vértices com nomes de tarefas e arestas com descrições opcionais de dependências.",
                                    "Desenhe o grafo manualmente ou use uma ferramenta de visualização.",
                                    "Confirme que o grafo captura todas as dependências listadas."
                                  ],
                                  "verification": "Inspecione visualmente se cada dependência tem uma aresta correspondente e vértices são unívocos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel gráfico ou software como Draw.io, Graphviz ou Python com NetworkX"
                                  ],
                                  "tips": "Use setas claras para direção e agrupe tarefas independentes para melhor legibilidade.",
                                  "learningObjective": "Mapear problemas de agendamento para representação gráfica como grafo direcionado.",
                                  "commonMistakes": [
                                    "Invertendo direção das arestas (dependência errada)",
                                    "Criando múltiplos vértices para a mesma tarefa",
                                    "Omitindo arestas de dependências implícitas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a ausência de ciclos no grafo (confirmar que é um DAG)",
                                  "subSteps": [
                                    "Execute uma busca em profundidade (DFS) manual ou programática para detectar ciclos.",
                                    "Marque vértices como visitados, em pilha e finalizados durante a DFS.",
                                    "Se encontrar um vértice em pilha durante recursão, declare ciclo.",
                                    "Repita para todos os vértices não visitados.",
                                    "Registre o caminho do ciclo se detectado e analise como resolvê-lo."
                                  ],
                                  "verification": "Confirme que nenhuma recursão encontra vértice em pilha, ou use algoritmo de topo sort preliminar sem falha.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de DFS para detecção de ciclo",
                                    "Python com NetworkX (networkx.is_directed_acyclic_graph) para validação"
                                  ],
                                  "tips": "Comece DFS de vértices com entrada zero para eficiência; teste com grafos pequenos conhecidos.",
                                  "learningObjective": "Aplicar detecção de ciclos para validar grafos como DAGs.",
                                  "commonMistakes": [
                                    "Confundir caminhos simples com ciclos",
                                    "Não reiniciar marcas de visita entre componentes",
                                    "Ignorar ciclos em subgrafos desconectados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preparar o grafo DAG para ordenação topológica",
                                  "subSteps": [
                                    "Liste os vértices com grau de entrada zero (tarefas iniciais).",
                                    "Simule um passo de Kahn's algorithm removendo-os e atualizando graus.",
                                    "Continue até esvaziar o grafo ou detectar ciclo restante.",
                                    "Gere uma ordem topológica parcial ou completa.",
                                    "Valide se a ordem respeita todas as dependências originais."
                                  ],
                                  "verification": "A ordem topológica deve permitir execução sem violar dependências, com todos vértices incluídos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de graus de entrada calculados",
                                    "Ferramenta de grafo para simulação"
                                  ],
                                  "tips": "Mantenha uma fila de tarefas prontas; priorize por critérios como duração se aplicável.",
                                  "learningObjective": "Conectar modelagem DAG à aplicação prática de ordenação topológica em agendamento.",
                                  "commonMistakes": [
                                    "Não atualizar graus corretamente após remoção",
                                    "Aceitar ordens que violam dependências",
                                    "Parar prematuramente em grafos com múltiplas soluções"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto de desenvolvimento de software: Tarefa A (Codificar módulo base), B (Implementar UI, depende de A), C (Testes unitários, depende de A), D (Integração, depende de B e C). Construa grafo A→B, A→C, B→D, C→D. Verifique sem ciclos e aplique topo sort: A, B/C, D.",
                              "finalVerifications": [
                                "Grafo possui exatamente um vértice por tarefa única.",
                                "Todas as dependências do problema são representadas por arestas direcionadas corretas.",
                                "Detecção de ciclo confirma ausência de loops (DAG válido).",
                                "Simulação de ordenação topológica processa todos os vértices.",
                                "Ordem gerada respeita 100% das dependências.",
                                "Representação é clara e rotulada adequadamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de tarefas e dependências (20%)",
                                "Correção na construção do grafo direcionado (25%)",
                                "Efetividade na detecção de ciclos (25%)",
                                "Validação da ordem topológica (20%)",
                                "Clareza e documentação do modelo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Gestão de Projetos: Modelagem de WBS e dependências em ferramentas como MS Project.",
                                "Engenharia de Software: Pipelines CI/CD e build graphs em Jenkins ou GitHub Actions.",
                                "Operações Research: Planejamento de produção e sequenciamento de jobs.",
                                "Ciência de Dados: Workflows em Apache Airflow ou Kubeflow."
                              ],
                              "realWorldApplication": "Modelagem de dependências em sistemas de compilação (Make, Bazel), agendamento de tarefas em sistemas operacionais, orquestração de workflows em ferramentas como Apache Airflow, e planejamento de projetos em indústrias como construção e manufatura para otimizar sequências sem atrasos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.1.2",
                            "name": "Aplicar ordenação topológica para gerar cronograma",
                            "description": "Implementar algoritmos como Kahn ou DFS para obter uma ordenação linear das tarefas, permitindo o agendamento ótimo sem violações de dependências.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o problema de agendamento como um Grafo Direcionado Acíclico (DAG)",
                                  "subSteps": [
                                    "Identificar todas as tarefas únicas do projeto e numerá-las como nós (ex: T1, T2).",
                                    "Listar todas as dependências: para cada tarefa, especifique quais devem ser completadas antes (ex: T2 depende de T1).",
                                    "Construir a lista de adjacência: para cada nó, liste os nós dependentes dele.",
                                    "Calcular o grau de entrada (in-degree) para cada nó: número de dependências pendentes.",
                                    "Verificar ausência de ciclos usando uma busca em profundidade simples ou ferramenta de detecção."
                                  ],
                                  "verification": "Grafo representado com listas de adjacência corretas, graus de entrada calculados e confirmado acíclico.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel/caneta para esboço manual",
                                    "Editor de código (Python/Java) com bibliotecas como NetworkX (opcional)",
                                    "Ferramenta Graphviz para visualização"
                                  ],
                                  "tips": "Desenhe o grafo visualmente primeiro para identificar dependências intuitivamente.",
                                  "learningObjective": "Transformar um problema de agendamento real em uma representação gráfica precisa para análise algorítmica.",
                                  "commonMistakes": [
                                    "Ignorar dependências transitivas (ex: T3 dep T2 e T2 dep T1).",
                                    "Confundir direção das arestas (de dependente para predecessor).",
                                    "Não calcular graus de entrada corretamente."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o Algoritmo de Kahn para Ordenação Topológica",
                                  "subSteps": [
                                    "Inicializar uma fila (queue) com todos os nós de grau de entrada zero (tarefas sem dependências).",
                                    "Criar uma lista vazia para a sequência topológica.",
                                    "Enquanto a fila não estiver vazia: remover um nó da fila, adicioná-lo à sequência, reduzir o grau de entrada dos seus vizinhos e adicionar à fila aqueles que chegam a zero.",
                                    "Contar o número de nós processados; se menor que total, detectar ciclo."
                                  ],
                                  "verification": "Código implementado executa sem erros e produz sequência parcial ou completa.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de código com suporte a filas (Python: collections.deque, Java: Queue)",
                                    "Exemplo de grafo de teste hardcoded"
                                  ],
                                  "tips": "Use uma fila para simular processamento paralelo de tarefas independentes.",
                                  "learningObjective": "Implementar eficientemente o algoritmo de Kahn, compreendendo sua base em eliminação de fontes.",
                                  "commonMistakes": [
                                    "Esquecer de reduzir graus de entrada após processar um nó.",
                                    "Processar nós com grau >0 prematuramente.",
                                    "Não detectar ciclos quando nem todos os nós são processados."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a ordenação e gerar a sequência linear de tarefas",
                                  "subSteps": [
                                    "Executar o algoritmo de Kahn no grafo modelado, capturando a ordem de remoção da fila.",
                                    "Registrar a sequência topológica obtida (ex: [T1, T3, T2, T4]).",
                                    "Simular a execução passo a passo manualmente para validar a ordem.",
                                    "Anotar qualquer ciclo detectado e propor resoluções (ex: remover dependência circular)."
                                  ],
                                  "verification": "Sequência topológica gerada onde para toda aresta u->v, u aparece antes de v na lista.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do Step 2",
                                    "Ferramenta de depuração (print statements ou debugger)"
                                  ],
                                  "tips": "Teste com grafos pequenos primeiro para validar a implementação.",
                                  "learningObjective": "Aplicar o algoritmo para obter uma ordenação válida e identificar problemas como ciclos.",
                                  "commonMistakes": [
                                    "Assumir grafo acíclico sem verificação.",
                                    "Ignorar múltiplas ordens possíveis em grafos com independências paralelas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar e validar o cronograma final",
                                  "subSteps": [
                                    "Atribuir durações estimadas às tarefas na sequência topológica.",
                                    "Calcular tempos de início/fim cumulativos respeitando dependências (earliest start time).",
                                    "Criar uma tabela ou Gantt chart simples mostrando a linha do tempo.",
                                    "Validar: nenhuma tarefa inicia antes de suas dependências completas; tempo total mínimo.",
                                    "Otimizar se possível (ex: alocação paralela para tarefas independentes)."
                                  ],
                                  "verification": "Cronograma tabular ou visual gerado sem violações de dependências e tempo total calculado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Planilha (Excel/Google Sheets) ou biblioteca matplotlib para Gantt",
                                    "Código para automação de cálculos"
                                  ],
                                  "tips": "Considere durações realistas baseadas em estimativas históricas.",
                                  "learningObjective": "Converter ordenação topológica em um cronograma acionável e otimizado.",
                                  "commonMistakes": [
                                    "Não acumular tempos corretamente em caminhos críticos.",
                                    "Superestimar paralelismo ignorando recursos limitados."
                                  ]
                                }
                              ],
                              "practicalExample": "Projeto de construção de site: T1: Planejar wireframe (0 dep, 2h), T2: Desenhar UI (dep T1, 4h), T3: Codificar frontend (dep T2, 6h), T4: Configurar backend (dep T1, 3h), T5: Integrar API (dep T3,T4, 2h). Sequência: T1, T2/T4, T3, T5. Cronograma: T1(0-2), T2(2-6)/T4(2-5), T3(6-12), T5(12-14).",
                              "finalVerifications": [
                                "Grafo DAG modelado corretamente com graus de entrada precisos.",
                                "Algoritmo de Kahn implementado e executado produz sequência válida.",
                                "Cronograma respeita todas dependências sem sobreposições inválidas.",
                                "Ciclo detectado e resolvido se presente.",
                                "Tempo total do projeto calculado como mínimo possível."
                              ],
                              "assessmentCriteria": [
                                "Correção: Sequência topológica válida (O(V+E) eficiência).",
                                "Completude: Todos nós incluídos sem ciclos.",
                                "Validação: Verificação manual de dependências na ordem final.",
                                "Otimização: Identificação de paralelismos possíveis.",
                                "Clareza: Representação visual do grafo e cronograma.",
                                "Tratamento de erros: Detecção e manejo de ciclos.",
                                "Escalabilidade: Funciona para grafos com 10+ nós."
                              ],
                              "crossCurricularConnections": [
                                "Gerenciamento de Projetos (CPM/PERT para caminhos críticos).",
                                "Compiladores (dependências de módulos em build systems como Make).",
                                "Operações Industriais (sequenciamento de jobs em linhas de produção).",
                                "Inteligência Artificial (agendamento de tarefas em pipelines de ML)."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software para ordenar compilação de módulos dependentes; em manufatura para agendar montagem de produtos complexos; em gerenciamento de eventos para sequenciar preparações com restrições; em DevOps para pipelines CI/CD."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.1.3",
                            "name": "Analisar cenários com múltiplos processadores",
                            "description": "Estender a ordenação topológica para agendamento paralelo, atribuindo tarefas a processadores respeitando dependências e minimizando tempo total de execução.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o problema como grafo DAG e calcular ordenação topológica",
                                  "subSteps": [
                                    "Identifique as tarefas e suas dependências, representando-as como vértices e arestas em um grafo direcionado acíclico (DAG).",
                                    "Verifique se o grafo é acíclico usando detecção de ciclos (ex: DFS).",
                                    "Aplique algoritmo de ordenação topológica (Kahn ou DFS) para obter uma sequência linear de tarefas.",
                                    "Anote os tempos de execução de cada tarefa.",
                                    "Visualize o grafo usando ferramentas como Graphviz ou desenhando manualmente."
                                  ],
                                  "verification": "Confirme que todas as tarefas estão em uma ordem onde dependências precedem tarefas dependentes; valide com simulação manual.",
                                  "estimatedTime": "1h",
                                  "materials": "Papel e lápis, software Graphviz ou Python com NetworkX",
                                  "tips": "Comece com grafos pequenos para praticar; use filas para o algoritmo de Kahn.",
                                  "learningObjective": "Compreender como representar problemas de agendamento como DAGs e obter ordens topológicas viáveis.",
                                  "commonMistakes": "Ignorar ciclos no grafo ou produzir ordens que violam dependências."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir configuração de processadores e lista de tarefas prontas",
                                  "subSteps": [
                                    "Especifique o número de processadores idênticos (ex: P=2) e assuma tempos unitários ou variados por tarefa.",
                                    "Crie uma lista de tarefas prontas (ready list) inicial: tarefas sem predecessores.",
                                    "Para cada processador, mantenha um estado de disponibilidade (tempo atual livre).",
                                    "Priorize tarefas na ready list por critérios como tamanho ou nível crítico.",
                                    "Simule o tempo inicial t=0 para todos processadores."
                                  ],
                                  "verification": "Verifique se a ready list contém apenas tarefas independentes e processadores estão prontos.",
                                  "estimatedTime": "0.5h",
                                  "materials": "Planilha Excel ou Python para listas dinâmicas",
                                  "tips": "Use heaps para priorizar tarefas longas primeiro (Largest Processing Time).",
                                  "learningObjective": "Preparar estruturas de dados para simulação de agendamento paralelo respeitando dependências.",
                                  "commonMistakes": "Incluir tarefas com dependências não resolvidas na ready list."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar agendamento usando List Scheduling",
                                  "subSteps": [
                                    "No tempo atual mínimo dos processadores livres, atribua a tarefa prioritária da ready list ao processador livre mais cedo.",
                                    "Atualize o tempo de finalização da tarefa e do processador (tempo livre + duração da tarefa).",
                                    "Adicione sucessoras da tarefa agendada à ready list se todas dependências estiverem completas.",
                                    "Repita até que todas tarefas sejam agendadas.",
                                    "Registre o Gantt chart para visualização."
                                  ],
                                  "verification": "Simule passo a passo e confirme que nenhuma dependência é violada e todos processadores são usados eficientemente.",
                                  "estimatedTime": "1.5h",
                                  "materials": "Python com bibliotecas matplotlib para Gantt chart",
                                  "tips": "Implemente em código para cenários complexos; pause simulação em cada iteração.",
                                  "learningObjective": "Aplicar algoritmo greedy de list scheduling para multiprocessadores com precedências.",
                                  "commonMistakes": "Atribuir tarefas a processadores antes de dependências estarem prontas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular makespan e analisar cenários alternativos",
                                  "subSteps": [
                                    "Calcule o makespan como o tempo máximo de finalização entre processadores.",
                                    "Teste variações: mude número de processadores, prioridades ou tempos de tarefas.",
                                    "Compare makespans e identifique gargalos (tarefas críticas).",
                                    "Calcule lower bound (comprimento do caminho crítico dividido por P).",
                                    "Otimize manualmente se possível (ex: trocar tarefas)."
                                  ],
                                  "verification": "Makespan bate com simulação e lower bound não é excedido desnecessariamente.",
                                  "estimatedTime": "1h",
                                  "materials": "Calculadora ou script Python para métricas",
                                  "tips": "Foquem em caminhos críticos para minimizar makespan.",
                                  "learningObjective": "Avaliar eficiência do agendamento e explorar trade-offs em cenários multi-processador.",
                                  "commonMistakes": "Confundir makespan com soma total de tempos de tarefas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e documentar a análise",
                                  "subSteps": [
                                    "Verifique todas dependências no Gantt chart final.",
                                    "Documente suposições, algoritmo usado e resultados numéricos.",
                                    "Discuta limitações (ex: NP-hard para otimização exata).",
                                    "Gere relatório com gráficos e tabelas.",
                                    "Teste com input diferente para generalização."
                                  ],
                                  "verification": "Relatório cobre todos aspectos e simulações são reproduzíveis.",
                                  "estimatedTime": "0.5h",
                                  "materials": "Editor de texto ou Jupyter Notebook",
                                  "tips": "Use templates para relatórios consistentes.",
                                  "learningObjective": "Sintetizar análise em formato profissional e identificando insights.",
                                  "commonMistakes": "Omitir verificações de dependências no output final."
                                }
                              ],
                              "practicalExample": "Considere 4 tarefas: A(2 unidades tempo), B(3), C(1), D(4). Dependências: A→B, A→C, B→D, C→D. 2 processadores. Ordenação topo: A, B/C, D. Agendamento: P1: A(0-2), D(5-9); P2: C(2-3), B(3-6). Makespan=9. Com 3 processadores, makespan cai para 6.",
                              "finalVerifications": [
                                "Todas dependências são respeitadas no Gantt chart.",
                                "Makespan é calculado corretamente como max tempo de processadores.",
                                "Ready list é atualizada corretamente após cada agendamento.",
                                "Lower bound (caminho crítico / P) é considerado.",
                                "Simulação é reproduzível com os mesmos inputs."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do DAG e ordenação topológica (30%).",
                                "Correta implementação do list scheduling sem violações (30%).",
                                "Análise precisa de makespan e variações (20%).",
                                "Qualidade da documentação e visualizações (10%).",
                                "Identificação de gargalos e otimizações (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Caminhos Críticos.",
                                "Gerenciamento de Projetos: Agendamento em PERT/CPM.",
                                "Engenharia de Software: Paralelismo em compiladores e pipelines.",
                                "Física/Engenharia: Simulação de fluxos paralelos em manufatura."
                              ],
                              "realWorldApplication": "Em compiladores, agendamento de instruções em pipelines multi-core; em cloud computing, alocação de jobs em clusters Kubernetes respeitando dependências para minimizar latência; em manufatura, linhas de produção paralelas otimizando throughput."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.6.2",
                        "name": "Programação Dinâmica com Ordenação Topológica",
                        "description": "Uso da ordenação topológica em grafos DAG para resolver problemas de otimização via programação dinâmica, processando subproblemas em ordem que garante disponibilidade de soluções precedentes.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.6.2.1",
                            "name": "Definir ordem topológica para computação DP em DAG",
                            "description": "Ordenar vértices topologicamente e computar valores dinâmicos de cada vértice baseado nos predecessores, como em caminhos mais longos ou problemas de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender Fundamentos de DAG e Ordenação Topológica",
                                  "subSteps": [
                                    "Defina um Directed Acyclic Graph (DAG): grafo direcionado sem ciclos.",
                                    "Explique por que ciclos impedem ordenação topológica.",
                                    "Descreva ordenação topológica: linearização onde para todo arco u→v, u vem antes de v.",
                                    "Identifique pré-requisitos para DP em DAGs: dependências unidirecionais.",
                                    "Represente um DAG simples com 4-5 vértices e adicione rótulos."
                                  ],
                                  "verification": "Desenhe um DAG pequeno e liste uma possível ordenação topológica manualmente.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho de grafos como Graphviz",
                                    "Leitura: Khan Academy ou CLRS capítulo sobre grafos"
                                  ],
                                  "tips": "Sempre verifique ciclos primeiro usando DFS ou contagem de graus de entrada.",
                                  "learningObjective": "Compreender a estrutura de DAGs e o propósito da ordenação topológica para DP.",
                                  "commonMistakes": [
                                    "Confundir DAG com grafos gerais que têm ciclos",
                                    "Ignorar direção das arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Algoritmo de Ordenação Topológica",
                                  "subSteps": [
                                    "Estude o algoritmo de Kahn: use fila para nós com grau de entrada 0.",
                                    "Implemente DFS-based: pós-ordem reversa para ordenação.",
                                    "Codifique em Python usando adjacência lista e detecção de ciclos.",
                                    "Teste com DAG exemplo: adicione graus de entrada e processe fila.",
                                    "Compare resultados de ambos algoritmos em um grafo de 6 vértices."
                                  ],
                                  "verification": "Execute código em um DAG de teste e confirme que a ordem respeita todas as dependências.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Python IDE (VS Code ou Jupyter)",
                                    "Biblioteca NetworkX para visualização opcional"
                                  ],
                                  "tips": "Mantenha uma lista de visitados para evitar recursão infinita em DFS.",
                                  "learningObjective": "Dominar pelo menos um algoritmo para gerar ordem topológica em DAGs.",
                                  "commonMistakes": [
                                    "Esquecer de remover arestas ao processar nó em Kahn",
                                    "Não reverter pós-ordem em DFS"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Ordenação Topológica com Programação Dinâmica",
                                  "subSteps": [
                                    "Defina DP em DAG: dp[v] = f(dp[predecessores de v]) + custo(v).",
                                    "Use ordem topológica para iterar vértices: compute dp em sequência.",
                                    "Escolha problema exemplo: longest path onde dp[v] = max(dp[u] + peso(u,v) para u→v) + 0.",
                                    "Modifique código: após topo-sort, itere ordem para preencher dp array.",
                                    "Analise complexidade: O(V+E) para topo-sort + O(V+E) para DP."
                                  ],
                                  "verification": "Calcule manualmente dp para um DAG pequeno e compare com código automatizado.",
                                  "estimatedTime": "2.5 horas",
                                  "materials": [
                                    "Código do Step 2",
                                    "Exemplos de problemas LeetCode como 'Longest Path in DAG'"
                                  ],
                                  "tips": "Inicialize dp[fontes] = 0 ou valor base antes de iterar.",
                                  "learningObjective": "Aplicar ordem topológica para resolver dependências em computação DP.",
                                  "commonMistakes": [
                                    "Iterar na ordem errada causando valores indefinidos",
                                    "Não tratar múltiplas fontes"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Aplicar em Problema Real",
                                  "subSteps": [
                                    "Implemente longest path completo em DAG com pesos nas arestas.",
                                    "Adicione detecção de ciclos: retorne erro se ciclo detectado.",
                                    "Teste edge cases: DAG vazio, único nó, linha reta, grafo denso.",
                                    "Otimize para grandes grafos: use heap para max se necessário.",
                                    "Documente código com comentários sobre ordem topológica."
                                  ],
                                  "verification": "Resolva um problema de 10+ vértices e valide contra solução BFS/DFS manual.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Datasets de grafos teste (gerados ou de Kaggle)",
                                    "Debugger Python"
                                  ],
                                  "tips": "Visualize grafo antes e após topo-sort para intuição.",
                                  "learningObjective": "Implementar solução robusta de DP usando topo-sort em DAGs.",
                                  "commonMistakes": [
                                    "Overflow em pesos negativos sem cuidado",
                                    "Índices errados em representação de grafo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um DAG representando tarefas de projeto (nós: tarefas, arestas: dependências), use topo-sort para ordenar execução e compute tempo total mínimo via DP onde dp[tarefa] = max(dp[dependências]) + duração(tarefa). Exemplo: T1(2h)->T2(3h), T3(1h)->T2, resulta em ordem T1,T3,T2 com dp[T2]=5h.",
                              "finalVerifications": [
                                "Gere topo-sort correto para DAG arbitrário sem ciclos.",
                                "Compute DP values iterando na ordem topológica sem erros de dependência.",
                                "Detecte e reporte ciclos em grafos inválidos.",
                                "Valide longest path contra verificação exaustiva em DAG pequeno.",
                                "Explique tempo/espaço O(V+E) da solução.",
                                "Aplique a múltiplos problemas como critical path ou fluxo máximo."
                              ],
                              "assessmentCriteria": [
                                "Correção: Topo-sort respeita todas as arestas (100% acerto em testes).",
                                "Eficiência: Tempo dentro de O(V+E), sem loops desnecessários.",
                                "Robustez: Trata ciclos, grafos vazios e múltiplas componentes.",
                                "Clareza: Código comentado e ordem topológica explicada.",
                                "Generalidade: Funciona para longest path e variantes similares.",
                                "Validação: Resultados batem com cálculos manuais em exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Relações Parciais (Ordenação Linear de Posets).",
                                "Engenharia de Software: Análise de Dependências em Builds (Maven/Gradle).",
                                "Operações Research: Programação Linear e Scheduling de Projetos (PERT/CPM).",
                                "Inteligência Artificial: Topo-sort em Redes Bayesianas ou Planejamento.",
                                "Economia: Modelagem de Fluxos em Cadeias de Suprimento Acíclicas."
                              ],
                              "realWorldApplication": "Em compiladores, topo-sort ordena módulos para linkagem; em gerenciamento de projetos (Microsoft Project), calcula caminhos críticos; em machine learning, resolve dependências de features em pipelines DAGs como Airflow; em logística, otimiza rotas acíclicas para entregas com pré-requisitos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.2.2",
                            "name": "Implementar DP otimizada em grafos DAG",
                            "description": "Desenvolver pseudocódigo ou código para problemas como o menor caminho em DAG, utilizando ordenação topológica para evitar recursão com memoização desnecessária.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar o Grafo DAG e Definir o Problema",
                                  "subSteps": [
                                    "Identifique os vértices e arestas do grafo, garantindo que seja um DAG (sem ciclos).",
                                    "Defina o problema específico, como encontrar o menor caminho de uma fonte 's' para um alvo 't'.",
                                    "Atribua pesos às arestas e inicialize distâncias com infinito, exceto dist[s] = 0.",
                                    "Represente o grafo usando listas de adjacência com pesos.",
                                    "Verifique a aciclicidade básica com uma inspeção visual ou ciclo detector simples."
                                  ],
                                  "verification": "Grafo representado corretamente em estrutura de dados; distâncias inicializadas e ausência de ciclos confirmada.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Papel e lápis para esboço",
                                    "Biblioteca NetworkX (opcional para Python)"
                                  ],
                                  "tips": "Use dicionários em Python para adjacência: graph[u] = [(v, w)] para vértice v com peso w.",
                                  "learningObjective": "Compreender a representação de grafos ponderados DAG e setup inicial para DP.",
                                  "commonMistakes": "Esquecer de inicializar distâncias como infinito ou incluir pesos negativos sem cuidado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Ordenação Topológica",
                                  "subSteps": [
                                    "Escolha um método: DFS com pós-ordem ou Algoritmo de Kahn (BFS com graus de entrada).",
                                    "Para DFS: realize DFS recursivo, adicionando vértices à lista topo após visitar todos os filhos.",
                                    "Para Kahn: compute graus de entrada, use fila para nós com grau 0, reduza graus dos vizinhos.",
                                    "Colete a ordem topológica em uma lista.",
                                    "Valide que todos os vértices foram incluídos (DAG detectado se |topo| == n)."
                                  ],
                                  "verification": "Lista de ordenação topológica gerada; todos vértices incluídos e ordem respeita dependências.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Pseudocódigo de topo sort de Cormen (CLRS)",
                                    "Implementação em Python ou pseudocódigo"
                                  ],
                                  "tips": "Prefira Kahn para depuração visual; DFS para eficiência em grafos grandes.",
                                  "learningObjective": "Dominar ordenação topológica como pré-requisito para DP linear em DAGs.",
                                  "commonMistakes": "Inverter a ordem em DFS (adicionar no início da recursão em vez de fim)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir e Inicializar a Tabela DP",
                                  "subSteps": [
                                    "Defina dp[u] como o menor custo para alcançar u da fonte s.",
                                    "Inicialize dp[s] = 0 e dp[outros] = infinito.",
                                    "Garanta que a iteração siga a ordem topológica para computar dp[u] após todos os predecessores.",
                                    "Crie uma estrutura para rastrear predecessores se reconstrução do caminho for necessária.",
                                    "Teste inicialização com um grafo pequeno manualmente."
                                  ],
                                  "verification": "Tabela DP inicializada corretamente; valores infinitos onde apropriado.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplo de grafo DAG impresso",
                                    "Calculadora para verificação manual"
                                  ],
                                  "tips": "Use float('inf') em Python para infinito; considere módulo para grandes números.",
                                  "learningObjective": "Estabelecer recorrência DP: dp[u] = min(dp[v] + w(v,u)) para v predecessors de u.",
                                  "commonMistakes": "Não processar na ordem topo, levando a valores incorretos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Preencher a Tabela DP e Reconstruir Solução",
                                  "subSteps": [
                                    "Itere pela ordem topológica: para cada u, atualize dp[v] = min(dp[v], dp[u] + w(u,v)) para vizinhos v.",
                                    "Registre predecessor[ v ] = u quando atualizar.",
                                    "Após preenchimento, reconstrua caminho de t retrocedendo predecessores até s.",
                                    "Implemente função para output: custo mínimo e caminho.",
                                    "Adicione tratamento para grafo desconectado (dp[t] infinito)."
                                  ],
                                  "verification": "Tabela DP preenchida; caminho reconstruído corretamente em exemplo teste.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Grafo de teste com solução conhecida",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Imprima dp após cada iteração para depuração.",
                                  "learningObjective": "Implementar iteração linear O(V+E) para DP otimizada em DAG.",
                                  "commonMistakes": "Atualizar dp[u] múltiplas vezes sem min; esquecer de relaxar todas as arestas."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e Otimizar a Implementação",
                                  "subSteps": [
                                    "Crie casos teste: grafo simples, com múltiplos caminhos, fonte/alvo únicos.",
                                    "Execute e compare com solução esperada.",
                                    "Meça complexidade: confirme O(V+E) com profiling.",
                                    "Otimize para código limpo: funções modulares para topo_sort e dp_fill.",
                                    "Documente o código com comentários."
                                  ],
                                  "verification": "Todos testes passam; tempo de execução aceitável para grafos médios.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Suite de testes unitários (pytest)",
                                    "Gerador de grafos aleatórios DAG"
                                  ],
                                  "tips": "Use asserts para verificação automática.",
                                  "learningObjective": "Validar corretude e eficiência da DP otimizada.",
                                  "commonMistakes": "Testes insuficientes, falhando em casos com caminhos zero ou infinitos."
                                }
                              ],
                              "practicalExample": "Em um grafo DAG com 5 nós (0->1 peso 3, 0->2 peso 6, 1->3 peso 1, 2->3 peso 4, 2->4 peso 2, 3->4 peso 5), encontre menor caminho de 0 a 4. Ordenação topo: [0,1,2,3,4]. DP resulta em dp[4]=7 via 0-1-3-4.",
                              "finalVerifications": [
                                "Código computa ordenação topológica correta.",
                                "Tabela DP preenchida sem erros de dependência.",
                                "Menor custo e caminho reconstruídos precisamente.",
                                "Funciona para grafos com 0, 1 ou múltiplos caminhos.",
                                "Detecção de inacessibilidade (infinito).",
                                "Complexidade O(V+E) confirmada empiricamente."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Soluções exatas em todos casos teste.",
                                "Eficiência: Tempo linear O(V+E), sem recursão desnecessária.",
                                "Clareza: Código modular, comentado e legível.",
                                "Robustez: Trata grafos vazios, desconectados e sem ciclos.",
                                "Documentação: Explicação da recorrência DP.",
                                "Testes: Cobertura de bordas e casos normais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e otimização linear.",
                                "Ciência da Computação: Algoritmos de scheduling e dependências.",
                                "Engenharia de Software: Modularidade e testes unitários.",
                                "Economia: Modelagem de custos em redes de suprimentos."
                              ],
                              "realWorldApplication": "Otimização de tarefas em projetos com dependências (ex: build systems como Make), roteamento em redes sem ciclos, análise de dependências em compiladores ou pipelines de ML onde ordem topológica garante processamento eficiente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.4.6.3",
                        "name": "Resolução de Dependências",
                        "description": "Aplicação da ordenação topológica para gerenciar e resolver dependências em sistemas como compiladores, sistemas de build ou gerenciamento de pacotes, detectando ciclos e ordenando execução.",
                        "specificSkills": [
                          {
                            "id": "10.1.4.6.3.1",
                            "name": "Modelar dependências como grafo e detectar ciclos",
                            "description": "Representar bibliotecas, módulos ou pacotes como vértices com arestas de dependência, usando ordenação topológica para validar aciclicidade e gerar ordem de instalação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir o Grafo de Dependências",
                                  "subSteps": [
                                    "Identifique todos os módulos, bibliotecas ou pacotes envolvidos.",
                                    "Crie vértices para cada item único.",
                                    "Adicione arestas direcionadas de um pacote para suas dependências (ex: A -> B se A depende de B).",
                                    "Represente o grafo usando dicionários ou listas de adjacência em uma linguagem de programação.",
                                    "Valide a estrutura do grafo imprimindo vértices e arestas."
                                  ],
                                  "verification": "Execute um script para imprimir o grafo e confirme que vértices e arestas correspondem às dependências declaradas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código (VS Code), Python ou JavaScript, diagramação de grafos (opcional: Graphviz).",
                                  "tips": "Use representações adjacentes para eficiência em grafos esparsos.",
                                  "learningObjective": "Representar dependências reais como um grafo direcionado.",
                                  "commonMistakes": "Confundir direção das arestas (dependente aponta para dependência, não o inverso)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Detecção de Ciclos",
                                  "subSteps": [
                                    "Implemente DFS (busca em profundidade) com rastreamento de estados (visitando, visitado, finalizado).",
                                    "Para cada vértice não visitado, inicie DFS e marque como 'visitando'.",
                                    "Durante recursão, se encontrar um nó 'visitando', detecte ciclo.",
                                    "Marque nós como 'finalizado' após processar vizinhos.",
                                    "Registre caminhos de ciclos para depuração."
                                  ],
                                  "verification": "Teste com grafos conhecidos: um com ciclo (detectar true) e um acíclico (false).",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Mesmos do step 1, exemplos de grafos de teste.",
                                  "tips": "Use três estados para evitar falsos positivos em caminhos múltiplos.",
                                  "learningObjective": "Detectar ciclos em grafos direcionados usando DFS.",
                                  "commonMistakes": "Esquecer de resetar estados entre chamadas DFS ou usar apenas dois estados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar Ordenação Topológica",
                                  "subSteps": [
                                    "Se nenhum ciclo detectado, inicialize uma pilha vazia e contadores de grau de entrada para cada nó.",
                                    "Use Kahn's algorithm: fila com nós de grau zero, remova e atualize graus vizinhos.",
                                    "Adicione à pilha/resultado após processar.",
                                    "Continue até fila vazia; verifique se todos nós foram processados.",
                                    "Implemente alternativa com DFS pós-ordem se preferir."
                                  ],
                                  "verification": "A ordem topológica deve respeitar todas as dependências (nenhum predecessor após sucessor).",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código anterior, testes unitários para ordem.",
                                  "tips": "Kahn's é intuitivo para dependências; DFS para grafos densos.",
                                  "learningObjective": "Gerar uma ordenação linear válida para DAGs.",
                                  "commonMistakes": "Não atualizar graus corretamente ou processar nós com grau >0 cedo."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Gerar Ordem de Instalação e Validar",
                                  "subSteps": [
                                    " Inverta a ordem topológica para obter sequência de instalação (dependências primeiro).",
                                    "Simule instalação: verifique se dependências estão instaladas antes de cada pacote.",
                                    "Reporte erros se ciclo ou ordem inválida.",
                                    "Integre em um script de gerenciador simulado.",
                                    "Teste com conjunto maior de dependências."
                                  ],
                                  "verification": "Simulação completa sem violações de dependências e alertas de ciclo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código completo, dataset de dependências reais (ex: npm lockfile simplificado).",
                                  "tips": "Automatize testes com asserts para cada dependência.",
                                  "learningObjective": "Aplicar ordenação para resolver dependências práticas.",
                                  "commonMistakes": "Inverter incorretamente a ordem ou ignorar ciclos na validação final."
                                }
                              ],
                              "practicalExample": "Considere pacotes: A depende de B e C; B depende de D; C depende de D; D depende de A (ciclo). Construa grafo, detecte ciclo em D->A, pare. Novo grafo sem ciclo D->A: ordem topológica possível D, B/C, A; instalação: D primeiro, depois B e C, A por último.",
                              "finalVerifications": [
                                "Grafo modela corretamente todas dependências declaradas.",
                                "Detecção de ciclo identifica todos ciclos com caminhos reportados.",
                                "Ordenação topológica produz sequência válida sem violações.",
                                "Simulação de instalação completa sem erros.",
                                "Eficiência: O(n + m) para n vértices e m arestas.",
                                "Testes passam em casos edge (grafo vazio, único nó, cadeia linear)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem do grafo (100% arestas corretas).",
                                "Correção na detecção de ciclos (taxa 100% em testes).",
                                "Validade da ordenação topológica (verificação de precedência).",
                                "Eficiência temporal e espacial do algoritmo.",
                                "Clareza e documentação do código.",
                                "Tratamento robusto de entradas inválidas."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Álgebra Linear (matrizes de adjacência).",
                                "Programação: Estruturas de Dados (grafos, filas, pilhas).",
                                "Gerenciamento de Projetos: Análise de tarefas com precedências (PERT/CPM).",
                                "Sistemas Operacionais: Gerenciamento de processos com dependências."
                              ],
                              "realWorldApplication": "Em gerenciadores de pacotes como npm, pip ou Maven, modela dependências para detectar conflitos (ciclos) e gerar ordem de instalação segura, evitando instalações parciais ou crashes em builds de software."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.3.2",
                            "name": "Gerar ordem de resolução em ferramentas reais",
                            "description": "Simular cenários de compiladores (ex: makefiles) ou gerenciadores de pacotes (ex: npm, apt), aplicando ordenação para compilar ou instalar componentes na sequência correta.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Modelar dependências como grafo direcionado",
                                  "subSteps": [
                                    "Identifique os componentes (nós) envolvidos, como arquivos fonte em um makefile ou pacotes em npm.",
                                    "Liste as dependências entre componentes (arestas direcionadas), garantindo que A depende de B signifique A -> B.",
                                    "Desenhe o grafo em papel ou ferramenta visual como Graphviz para visualizar conexões.",
                                    "Verifique ausência inicial de ciclos usando inspeção visual ou algoritmo simples.",
                                    "Documente o grafo em formato textual para referência."
                                  ],
                                  "verification": "Grafo desenhado e documentado sem erros lógicos nas dependências.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou Graphviz online",
                                    "Editor de texto"
                                  ],
                                  "tips": "Comece com poucos nós (3-5) para simplicidade inicial.",
                                  "learningObjective": "Compreender representação gráfica de dependências para ordenação topológica.",
                                  "commonMistakes": [
                                    "Confundir direção das arestas (dependente aponta para dependido)",
                                    "Ignorar dependências transitivas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar ambiente de ferramenta real (makefile ou npm)",
                                  "subSteps": [
                                    "Crie um diretório de projeto vazio.",
                                    "Para makefile: escreva regras básicas com alvos e pré-requisitos simulando dependências.",
                                    "Para npm: crie package.json com dependências e scripts de instalação simulados.",
                                    "Adicione pelo menos 4-6 componentes com dependências cíclicas potenciais para teste.",
                                    "Teste execução manual para identificar ordem intuitiva."
                                  ],
                                  "verification": "Ambiente configurado e executável sem erros de sintaxe.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Terminal",
                                    "Node.js (para npm)",
                                    "Make instalado"
                                  ],
                                  "tips": "Use comentários no arquivo para anotar dependências esperadas.",
                                  "learningObjective": "Mapear grafo conceitual para sintaxe prática de ferramentas reais.",
                                  "commonMistakes": [
                                    "Erros de sintaxe no package.json ou makefile",
                                    "Dependências circulares não intencionais"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar ordenação topológica no grafo",
                                  "subSteps": [
                                    "Implemente ou use algoritmo Kahn (fila com graus de entrada zero).",
                                    "Calcule graus de entrada para cada nó.",
                                    "Processe nós sem dependências pendentes, atualizando graus.",
                                    "Gere lista ordenada e valide completude (todos nós incluídos).",
                                    "Detecte ciclos se sobrar nós não processados."
                                  ],
                                  "verification": "Lista de ordem gerada corresponde a todas dependências resolvidas.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Python ou JavaScript para script de ordenação",
                                    "Grafo do Step 1"
                                  ],
                                  "tips": "Implemente em código para reutilização; teste com input hardcoded.",
                                  "learningObjective": "Executar ordenação topológica programaticamente em dependências reais.",
                                  "commonMistakes": [
                                    "Erro no cálculo de graus de entrada",
                                    "Não detectar ciclos corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular execução na ferramenta e validar ordem",
                                  "subSteps": [
                                    "Ajuste makefile ou npm para forçar ordem topológica gerada.",
                                    "Execute build/instalação e observe sequência real.",
                                    "Compare logs de execução com ordem esperada.",
                                    "Introduza ciclo artificial, detecte falha e corrija.",
                                    "Otimize ordem para paralelismo onde possível (graus zero simultâneos)."
                                  ],
                                  "verification": "Build/instalação completa sem erros de dependência.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Terminal",
                                    "Arquivos do Step 2",
                                    "Ordem do Step 3"
                                  ],
                                  "tips": "Use verbose mode (make -n ou npm --loglevel=verbose) para inspecionar ordem.",
                                  "learningObjective": "Integrar ordenação topológica em fluxos de ferramentas reais.",
                                  "commonMistakes": [
                                    "Ignorar ordem paralela possível",
                                    "Não validar contra falhas cíclicas"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar cenários complexos",
                                  "subSteps": [
                                    "Adicione mais nós e dependências transitivas.",
                                    "Simule falha em dependência e ajuste ordem.",
                                    "Compare com ferramentas reais (npm install --dry-run).",
                                    "Documente lições aprendidas em relatório.",
                                    "Automatize script para gerar ordem em novos grafos."
                                  ],
                                  "verification": "Cenários complexos resolvidos com ordem correta e sem ciclos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Scripts anteriores",
                                    "Editor de código"
                                  ],
                                  "tips": "Versione mudanças com Git para rastrear evoluções.",
                                  "learningObjective": "Lidar com robustez em aplicações reais de ordenação topológica.",
                                  "commonMistakes": [
                                    "Sobrecarregar grafo inicial",
                                    "Não automatizar para escalabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um projeto Node.js com pacotes A (depende de B e C), B (depende de D), C (depende de D): Grafo A->B->D, A->C->D. Ordenação topológica: D, B/C (paralelo), A. No package.json, npm install segue essa ordem; simule com make targets equivalentes.",
                              "finalVerifications": [
                                "Grafo modelado corretamente identifica todas dependências.",
                                "Ordem topológica gerada resolve build sem erros.",
                                "Ciclo introduzido é detectado e reportado.",
                                "Simulação em makefile/npm produz logs consistentes com ordem.",
                                "Script automatizado funciona em grafo novo.",
                                "Paralelismo é considerado onde possível."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem de grafos (sem arestas invertidas).",
                                "Correção do algoritmo topológico (detecta ciclos, ordem válida).",
                                "Integração efetiva com ferramentas reais (make/npm).",
                                "Eficiência: tempo de execução e paralelismo.",
                                "Documentação clara de processo e lições.",
                                "Robustez contra cenários edge-case."
                              ],
                              "crossCurricularConnections": [
                                "Gerenciamento de Projetos: Sequenciamento de tarefas em Gantt/PERT.",
                                "Sistemas Operacionais: Gerenciamento de processos e escalonamento.",
                                "Engenharia de Software: Build systems e CI/CD pipelines.",
                                "Matemática Discreta: Teoria de grafos e relações parciais.",
                                "Administração: Cadeia de suprimentos e logística."
                              ],
                              "realWorldApplication": "Em desenvolvimento de software, garante compilação correta em makefiles para grandes projetos C++; em DevOps, resolve dependências em Docker Compose ou Kubernetes; npm/yarn usa internamente para instalações eficientes, evitando erros em equipes distribuídas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.4.6.3.3",
                            "name": "Tratar exceções em grafos com ciclos",
                            "description": "Identificar ciclos durante a ordenação topológica e propor soluções como remoção de dependências circulares ou feedback vertex set para resolução aproximada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Detectar Ciclos durante a Ordenação Topológica",
                                  "subSteps": [
                                    "Revisar o algoritmo de ordenação topológica usando DFS, focando nos estados de nó: não visitado, visitando (visiting) e visitado (visited).",
                                    "Implementar uma função de DFS que rastreie o estado 'visiting' para detectar back edges (arestas que apontam para ancestrais no caminho atual).",
                                    "Modificar o algoritmo para retornar 'ciclo detectado' ao encontrar uma back edge para um nó 'visiting'.",
                                    "Testar o algoritmo em grafos acíclicos (DAGs) e grafos com ciclos simples (ex: A->B->A).",
                                    "Usar uma pilha de recursão ou caminho atual para registrar o ciclo quando detectado."
                                  ],
                                  "verification": "Execute o código em um grafo conhecido com ciclo (ex: 3 nós em triângulo) e confirme que retorna 'ciclo detectado' com o caminho do ciclo.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Editor de código (Python ou Java)",
                                    "Biblioteca NetworkX para visualização de grafos (opcional)",
                                    "Papel e lápis para desenhar grafos de teste"
                                  ],
                                  "tips": "Use representações adjacentes para grafos direcionados e sempre inicialize estados como 0 (não visitado), 1 (visiting), 2 (visited).",
                                  "learningObjective": "Implementar detecção de ciclos integrada à ordenação topológica usando DFS.",
                                  "commonMistakes": [
                                    "Confundir 'visited' com 'visiting', levando a falsos negativos.",
                                    "Não limpar estados entre chamadas DFS para componentes desconectados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar e Extrair Nós e Arestas do Ciclo",
                                  "subSteps": [
                                    "Ao detectar um back edge (u -> v), onde v está 'visiting', rastrear o caminho da recursão para extrair o ciclo completo.",
                                    "Manter uma pilha ou lista de caminho atual durante DFS para reconstruir o ciclo (do nó v de volta a u).",
                                    "Validar o ciclo extraído simulando a travessia das arestas no subgrafo.",
                                    "Visualizar ou imprimir o ciclo para confirmação (ex: nós A-B-C-A).",
                                    "Tratar múltiplos ciclos em grafos complexos, priorizando o primeiro detectado."
                                  ],
                                  "verification": "Para um grafo com ciclo conhecido, o algoritmo deve outputar a sequência exata de nós no ciclo (ex: [A, B, C, A]).",
                                  "estimatedTime": "1 hour",
                                  "materials": [
                                    "Mesmos do Step 1",
                                    "Ferramenta de visualização como Graphviz ou Matplotlib"
                                  ],
                                  "tips": "Armazene o caminho em uma lista global ou passe por referência na recursão.",
                                  "learningObjective": "Extrair precisamente o subgrafo cíclico para análise posterior.",
                                  "commonMistakes": [
                                    "Perder o ciclo em grafos com múltiplos caminhos.",
                                    "Incluir nós irrelevantes ao reconstruir o caminho."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Resolver Ciclos Removendo Dependências Circulares",
                                  "subSteps": [
                                    "Analisar o ciclo extraído e identificar dependências redundantes ou não essenciais (ex: remover a aresta que fecha o ciclo).",
                                    "Implementar uma heurística simples: remover a aresta com menor peso ou menor grau de entrada.",
                                    "Reexecutar ordenação topológica após remoção e verificar se o grafo agora é acíclico.",
                                    "Documentar as mudanças: quais dependências foram quebradas e por quê.",
                                    "Testar em cenários reais como dependências de software (ex: módulos circulares)."
                                  ],
                                  "verification": "Após remoção, o algoritmo de topo sort deve produzir uma ordenação válida sem erros de ciclo.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Exemplos de grafos de dependências (JSON ou CSV)"
                                  ],
                                  "tips": "Priorize remover arestas que representam dependências opcionais para minimizar impacto.",
                                  "learningObjective": "Aplicar resolução exata de ciclos via remoção mínima de arestas.",
                                  "commonMistakes": [
                                    "Remover nós críticos em vez de arestas.",
                                    "Não retestar após modificação, assumindo sucesso."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Feedback Vertex Set (FVS) para Resolução Aproximada",
                                  "subSteps": [
                                    "Entender FVS: encontrar conjunto mínimo de vértices cuja remoção torna o grafo acíclico.",
                                    "Implementar uma aproximação greedy: iterativamente remover nó com mais back edges no ciclo atual.",
                                    "Comparar com remoção de arestas: FVS remove nós (útil quando dependências são em módulos inteiros).",
                                    "Usar bibliotecas como NetworkX para FVS aproximado e validar resultados.",
                                    "Avaliar trade-offs: custo computacional vs. qualidade da solução."
                                  ],
                                  "verification": "Implementar FVS em grafo cíclico e confirmar que o grafo restante permite topo sort.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "NetworkX ou implementação manual",
                                    "Documentação de algoritmos de aproximação para FVS"
                                  ],
                                  "tips": "Para FVS greedy, priorize nós com alto grau de entrada/saída no subgrafo cíclico.",
                                  "learningObjective": "Aplicar técnicas de otimização combinatória aproximada para problemas NP-difíceis em grafos.",
                                  "commonMistakes": [
                                    "Confundir FVS (remover vértices) com feedback arc set (remover arestas).",
                                    "Ignorar que FVS é NP-hard e testar apenas em grafos pequenos."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Integrar e Testar Soluções Completas",
                                  "subSteps": [
                                    "Combinar detecção, extração, remoção de arestas e FVS em um pipeline unificado.",
                                    "Criar casos de teste: grafos sem ciclo, com ciclo simples, múltiplos ciclos, grandes grafos.",
                                    "Medir métricas: tempo de execução, tamanho do conjunto removido, sucesso da topo sort final.",
                                    "Otimizar para performance (ex: evitar re-DFS completo após remoções).",
                                    "Documentar relatório com exemplos e lições aprendidas."
                                  ],
                                  "verification": "Pipeline processa 10 grafos de teste variados, produzindo topo sort válida em todos os casos cíclicos resolvidos.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Suite de testes automatizados (Pytest ou JUnit)",
                                    "Grafos de benchmark (ex: de repositórios GitHub de dependências)"
                                  ],
                                  "tips": "Use logging para rastrear decisões de remoção.",
                                  "learningObjective": "Construir um sistema robusto para tratar exceções em ordenação topológica.",
                                  "commonMistakes": [
                                    "Sobrecarga computacional em grafos densos.",
                                    "Não considerar impactos colaterais em dependências downstream."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um sistema de build como Maven ou npm, módulos A depende de B, B de C, C de A. Detectar ciclo A-B-C-A, propor remover dependência C->A (redundante), ou FVS removendo nó C (se for o mais problemático), permitindo build ordenado.",
                              "finalVerifications": [
                                "Detecta corretamente ciclos em grafos de até 100 nós.",
                                "Extrai e lista nós/arestas do ciclo com precisão 100%.",
                                "Resolve ciclo via remoção de aresta, produzindo DAG válido.",
                                "Implementa FVS aproximado com tamanho do conjunto ≤ 20% dos nós.",
                                "Pipeline completo processa dependências reais sem falhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de ciclos (taxa de falsos positivos <1%).",
                                "Eficiência: tempo < O(V+E) por iteração.",
                                "Qualidade da resolução: minimiza remoções (≤ mínimo possível).",
                                "Correção na extração de ciclos (match exato com esperado).",
                                "Capacidade de explicar trade-offs entre métodos exatos e aproximados."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: conceitos de ciclos e aciclicidade.",
                                "Engenharia de Software: gerenciamento de dependências e build systems.",
                                "Otimização Combinatória: problemas NP-hard e heurísticas.",
                                "Ciência da Computação: análise de complexidade e algoritmos de grafos.",
                                "Sistemas Operacionais: detecção de deadlocks em grafos de recursos."
                              ],
                              "realWorldApplication": "Resolução de dependências circulares em ferramentas como npm, Docker Compose, ou Kubernetes para evitar falhas em builds/deployments; agendamento de tarefas em pipelines CI/CD; análise de cadeias de suprimentos com loops de feedback."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.5",
                "name": "Manipulação de Cadeias de Caracteres",
                "description": "Técnicas e algoritmos para processamento eficiente de strings, incluindo busca, correspondência e edição.",
                "totalSkills": 37,
                "atomicTopics": [
                  {
                    "id": "10.1.5.1",
                    "name": "Algoritmo de Knuth-Morris-Pratt (KMP)",
                    "description": "Algoritmo eficiente para busca exata de substrings utilizando a função de falha pré-computada.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.1.1",
                        "name": "Prefixos e Sufixos Próprios",
                        "description": "Conceitos fundamentais de prefixos e sufixos próprios em cadeias de caracteres, que servem de base para a função de falha no algoritmo KMP, permitindo identificar bordas da string padrão.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.1.1",
                            "name": "Identificar prefixos e sufixos próprios",
                            "description": "Dado uma string padrão, listar todos os prefixos e sufixos próprios e determinar o maior prefixo que é também sufixo (borda).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos básicos de prefixo e sufixo em strings",
                                  "subSteps": [
                                    "Defina prefixo como qualquer substring inicial da string S[1..k] para k de 1 a n.",
                                    "Defina sufixo como qualquer substring final da string S[n-k+1..n] para k de 1 a n.",
                                    "Diferencie prefixo/sufixo de substrings arbitrárias, que podem estar em qualquer posição.",
                                    "Analise uma string simples como 'aba' e liste todos os prefixos e sufixos (incluindo a string inteira).",
                                    "Discuta a importância desses conceitos em algoritmos de manipulação de strings."
                                  ],
                                  "verification": "Liste corretamente todos os prefixos e sufixos de uma string exemplo como 'aba', incluindo distinção entre próprios e totais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto ou quadro branco"
                                  ],
                                  "tips": "Use índices baseados em 1 para facilitar a visualização (ex: S[1] é o primeiro caractere).",
                                  "learningObjective": "Dominar as definições formais de prefixo e sufixo e identificá-los em strings curtas.",
                                  "commonMistakes": "Confundir prefixos com substrings no meio da string ou incluir/excluir a string inteira incorretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Diferenciar prefixos e sufixos próprios da string inteira",
                                  "subSteps": [
                                    "Explique que prefixos/sufixos próprios excluem a string inteira (tamanhos de 1 a n-1).",
                                    "Para uma string S de comprimento n, liste prefixos próprios: S[1..k] para k=1 até n-1.",
                                    "Liste sufixos próprios: S[n-k+1..n] para k=1 até n-1.",
                                    "Exemplo com 'mississippi': identifique alguns prefixos e sufixos próprios manualmente.",
                                    "Verifique se uma substring é prefixo ou sufixo próprio comparando posições."
                                  ],
                                  "verification": "Para a string 'aba', liste apenas os prefixos próprios ('a', 'ab') e sufixos próprios ('a', 'ba').",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Calculadora para comprimentos longos"
                                  ],
                                  "tips": "Sempre anote o comprimento n primeiro para limitar k de 1 a n-1.",
                                  "learningObjective": "Identificar com precisão prefixos e sufixos próprios, excluindo trivialidades.",
                                  "commonMistakes": "Incluir a string inteira como próprio ou confundir ordem de caracteres."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Listar todos os prefixos e sufixos próprios de uma string dada",
                                  "subSteps": [
                                    "Receba uma string padrão e compute seu comprimento n.",
                                    "Gere sistematicamente a lista de prefixos próprios, escrevendo cada um.",
                                    "Gere a lista de sufixos próprios de forma similar.",
                                    "Organize as listas em ordem crescente de tamanho para facilitar comparações.",
                                    "Valide a lista contando o número de itens (deve ser n-1 para cada)."
                                  ],
                                  "verification": "Para 'abcabca', liste prefixos próprios ['a','ab','abc','abca','abcab','abcabc'] e sufixos próprios ['a','ca','bca','abca','cabca','bcabca'].",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para strings longas"
                                  ],
                                  "tips": "Escreva a string repetidamente em linhas para visualizar sufixos facilmente.",
                                  "learningObjective": "Gerar listas completas e precisas de prefixos e sufixos próprios.",
                                  "commonMistakes": "Erros de indexação (off-by-one) ou duplicatas acidentais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a borda: maior prefixo próprio que é também sufixo próprio",
                                  "subSteps": [
                                    "Compare prefixos próprios com sufixos próprios de mesmo comprimento, do maior para o menor.",
                                    "Para cada tamanho k decrescente (n-1 até 1), verifique se prefixo de k == sufixo de k.",
                                    "Registre o maior k onde há coincidência; essa string é a borda.",
                                    "Se não houver, a borda é vazia.",
                                    "Explique o papel da borda no contexto do KMP (pré-processamento da tabela pi)."
                                  ],
                                  "verification": "Para 'abcabca', identifique a borda 'abca' (tamanho 4).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Lista de prefixos/sufixos do passo anterior"
                                  ],
                                  "tips": "Comece pelo maior k para eficiência; pare ao encontrar o primeiro match.",
                                  "learningObjective": "Calcular a borda corretamente e relacioná-la ao algoritmo KMP.",
                                  "commonMistakes": "Comparar tamanhos errados ou ignorar ordem decrescente."
                                }
                              ],
                              "practicalExample": "Para a string 'abcabca' (n=7):\n- Prefixos próprios: 'a', 'ab', 'abc', 'abca', 'abcab', 'abcabc'\n- Sufixos próprios: 'a', 'ca', 'bca', 'abca', 'cabca', 'bcabca'\n- Borda: 'abca' (maior prefixo igual a sufixo, tamanho 4).",
                              "finalVerifications": [
                                "Listas de prefixos e sufixos próprios estão completas e sem a string inteira.",
                                "Todas as entradas têm tamanhos de 1 a n-1.",
                                "Borda identificada é o maior match exato entre prefixo e sufixo.",
                                "Nenhuma duplicata ou erro de indexação nas listas.",
                                "Explicação escrita do processo de comparação.",
                                "Teste com string adicional confirma consistência."
                              ],
                              "assessmentCriteria": [
                                "Precisão na geração de listas (100% corretas).",
                                "Correta identificação da borda com justificativa.",
                                "Eficiência no método de comparação (decrescente).",
                                "Clareza na apresentação das listas e borda.",
                                "Compreensão contextual no KMP demonstrada.",
                                "Ausência de erros comuns como off-by-one."
                              ],
                              "crossCurricularConnections": [
                                "Linguística: Análise de morfemas e raízes em palavras.",
                                "Biologia: Identificação de padrões em sequências de DNA/RNA.",
                                "Matemática: Teoria de linguagens formais e autômatos.",
                                "Física: Padrões periódicos em sinais e ondas."
                              ],
                              "realWorldApplication": "Essencial no pré-processamento do Algoritmo KMP para busca eficiente de padrões em textos grandes, usado em editores de texto, busca genomic, detecção de plágio e compressão de dados."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.2",
                            "name": "Calcular o comprimento da borda de uma string",
                            "description": "Para uma dada string, computar manualmente o comprimento do maior prefixo próprio que é também sufixo, essencial para inicializar a tabela π.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de prefixo próprio e sufixo próprio",
                                  "subSteps": [
                                    "Defina prefixo próprio: substring inicial da string excluindo a string inteira.",
                                    "Defina sufixo próprio: substring final da string excluindo a string inteira.",
                                    "Explique que a borda é o maior prefixo próprio que coincide exatamente com um sufixo próprio.",
                                    "Diferencie prefixo/sufixo próprios de prefixo/sufixo totais.",
                                    "Forneça exemplos simples como 'aa' (prefixo 'a', sufixo 'a')."
                                  ],
                                  "verification": "Escreva definições claras e exemplos corretos em um papel.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "String de exemplo curta"
                                  ],
                                  "tips": "Lembre-se: próprios excluem a string completa para evitar trivialidade.",
                                  "learningObjective": "Dominar definições fundamentais para cálculo de bordas.",
                                  "commonMistakes": [
                                    "Confundir prefixo próprio com qualquer substring inicial",
                                    "Incluir a string inteira como prefixo/sufixo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Listar todos os prefixos e sufixos próprios da string",
                                  "subSteps": [
                                    "Escreva a string dada (ex: 'abacaba').",
                                    "Gere prefixos próprios: corte do início, tamanhos 1 a n-1 (a, ab, aba, abac, abaca, abacab).",
                                    "Gere sufixos próprios: corte do final, tamanhos 1 a n-1 (a, ba, aba, caba, acaba, bacaba).",
                                    "Anote-os em colunas separadas para visualização clara.",
                                    "Conte os caracteres para confirmar comprimentos."
                                  ],
                                  "verification": "Lista completa de prefixos e sufixos com comprimentos corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "String exemplo 'abacaba'"
                                  ],
                                  "tips": "Use numeração para tamanhos para facilitar comparação posterior.",
                                  "learningObjective": "Gerar sistematicamente todas as substrings candidatas.",
                                  "commonMistakes": [
                                    "Esquecer prefixos/sufixos de certos tamanhos",
                                    "Erros de digitação na cópia da string"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar prefixos e sufixos de mesmo comprimento",
                                  "subSteps": [
                                    "Comece pelo maior tamanho possível (n-1) e desça para 1.",
                                    "Para cada tamanho k, compare prefixo[1..k] com sufixo[n-k+1..n].",
                                    "Marque matches onde strings são idênticas caractere por caractere.",
                                    "Registre o maior k com match (ex: k=3 para 'aba' em 'abacaba').",
                                    "Pare ao encontrar o primeiro (maior) match, mas verifique menores se necessário."
                                  ],
                                  "verification": "Tabela de comparações mostrando matches e o maior k identificado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista do passo 2",
                                    "Marcadores para destacar matches"
                                  ],
                                  "tips": "Compare caractere por caractere para evitar ilusões ópticas.",
                                  "learningObjective": "Identificar coincidências exatas eficientemente.",
                                  "commonMistakes": [
                                    "Comparar comprimentos errados",
                                    "Ignorar diferenças sutis em caracteres"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar o comprimento da borda e documentar",
                                  "subSteps": [
                                    "Afirme o comprimento da borda como o maior k encontrado.",
                                    "Reverifique o match do prefixo e sufixo para k máximo.",
                                    "Explique por que tamanhos maiores não funcionam.",
                                    "Registre o resultado final (ex: comprimento 3 para 'abacaba').",
                                    "Discuta uso na tabela π do KMP (π[n-1] = k)."
                                  ],
                                  "verification": "Declaração final com k, strings matching e justificativa.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Resultados anteriores",
                                    "Folha de resumo"
                                  ],
                                  "tips": "Sempre reverifique o maior candidato para precisão.",
                                  "learningObjective": "Validar e contextualizar o resultado no algoritmo KMP.",
                                  "commonMistakes": [
                                    "Selecionar k menor que o máximo possível",
                                    "Confundir com menor border"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar com variação para reforço",
                                  "subSteps": [
                                    "Escolha uma nova string (ex: 'abab').",
                                    "Repita listagem, comparação e cálculo.",
                                    "Calcule borders para 'abab' (k=2, 'ab').",
                                    "Compare com original para padrões comuns.",
                                    "Anote diferenças e semelhanças."
                                  ],
                                  "verification": "Cálculo correto para string de prática (k=2).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Nova string de exemplo"
                                  ],
                                  "tips": "Escolha strings com padrões óbvios para confiança.",
                                  "learningObjective": "Generalizar o método para strings arbitrárias.",
                                  "commonMistakes": [
                                    "Aplicar método inconsistente",
                                    "Subestimar tempo para prática"
                                  ]
                                }
                              ],
                              "practicalExample": "Para a string 'abacaba': prefixos próprios incluem 'aba' (len 3), sufixos incluem 'aba' (len 3). Comparação mostra match exato em 'aba'=='aba', sem matches maiores (ex: 'abac' != 'caba'). Assim, comprimento da borda é 3, usado para π[6]=3 na tabela KMP.",
                              "finalVerifications": [
                                "Prefixo de comprimento k coincide exatamente com sufixo de k.",
                                "Nenhum prefixo/sufixo maior que k coincide.",
                                "k < comprimento total da string.",
                                "Verificação caractere por caractere sem erros.",
                                "Resultado consistente com definição de border em KMP.",
                                "Teste com substring extraída confirma igualdade.",
                                "Documentação inclui todos os passos seguidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação do maior k (100% match).",
                                "Completude da lista de prefixos/sufixos (todos tamanhos).",
                                "Eficiência na comparação (inicia pelo maior).",
                                "Clareza na documentação e verificações.",
                                "Capacidade de explicar erros comuns evitados.",
                                "Generalização para novas strings.",
                                "Tempo respeitado com qualidade mantida."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de conjuntos e funções de falha em autômatos.",
                                "Programação: Implementação da função π no algoritmo KMP em código.",
                                "Linguística: Análise de padrões morfológicos em palavras.",
                                "Bioinformática: Busca de padrões em sequências de DNA/proteínas.",
                                "Ciência da Computação: Complexidade O(n) vs métodos ingênuos O(n²)."
                              ],
                              "realWorldApplication": "No algoritmo KMP para busca de padrões em textos grandes (ex: motores de busca, editores de texto como grep, análise genômica para encontrar subsequências em DNA), o comprimento da borda inicializa a tabela de falhas π, permitindo buscas eficientes sem recomeços desnecessários, economizando tempo em big data."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.1.1.3",
                            "name": "Aplicar recursão em bordas",
                            "description": "Dada uma borda de comprimento k em uma string de tamanho m, encontrar a borda da borda (borda de k), simulando o processo iterativo do KMP.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a borda dada e inicializar estruturas",
                                  "subSteps": [
                                    "Identifique a string original s de tamanho m e o comprimento k da borda fornecida.",
                                    "Extraia a substring b = s[m-k:m] (usando indexação 0-based: b[0..k-1]).",
                                    "Verifique manualmente que b é prefixo e sufixo próprio de s[0..m-1].",
                                    "Inicialize o array pi_b de tamanho k com pi_b[0] = 0.",
                                    "Defina variáveis: i = 1 (próxima posição), len = 0 (comprimento da borda candidata)."
                                  ],
                                  "verification": "Confirme que b tem exatos k caracteres e que s[0:k] == s[m-k:m] == b.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplo de string s impressa ou copiada"
                                  ],
                                  "tips": [
                                    "Use indexação 0-based para alinhar com implementações padrão de KMP.",
                                    "Desenhe a string b verticalmente para visualizar prefixos/sufixos."
                                  ],
                                  "learningObjective": "Isolar corretamente a borda e preparar o ambiente para computação iterativa do pi array.",
                                  "commonMistakes": [
                                    "Erro em slicing da substring (ex: incluir caractere extra).",
                                    "Confundir prefixo com sufixo ao verificar borda inicial."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar iterações iniciais do algoritmo KMP na borda b",
                                  "subSteps": [
                                    "Inicie o loop com i=1 e len=0.",
                                    "Para cada i de 1 a k-1:",
                                    "  - Enquanto len > 0 e b[i] != b[len], defina len = pi_b[len-1].",
                                    "  - Se b[i] == b[len], incremente len = len + 1.",
                                    "  - Atribua pi_b[i] = len."
                                  ],
                                  "verification": "Preencha pi_b manualmente para as primeiras posições e verifique consistência (ex: pi_b[i] <= i).",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Tabela pi_b desenhada em grid",
                                    "Marcadores coloridos para matches/mismatches"
                                  ],
                                  "tips": [
                                    "Simule passo a passo, anotando len antes/depois de cada while/if.",
                                    "Pare e verifique após cada i para evitar erros cumulativos."
                                  ],
                                  "learningObjective": "Dominar a lógica de backtrack (while) e avanço (if) no pré-processamento KMP.",
                                  "commonMistakes": [
                                    "Esquecer de atualizar len no while recursivo.",
                                    "Incrementar len sem checar match (b[i] == b[len])."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Completar o pi array e identificar a borda da borda",
                                  "subSteps": [
                                    "Continue o loop até i = k-1, preenchendo todo pi_b.",
                                    "Identifique a borda da borda como border_k = pi_b[k-1].",
                                    "Verifique que border_k é o maior l < k tal que b[0:l] == b[k-l:k].",
                                    "Se border_k > 0, anote a substring da borda da borda para recursão futura.",
                                    "Registre o caminho de bordas: k -> border_k -> ... até 0."
                                  ],
                                  "verification": "Confirme manualmente que b[0:border_k] == b[k-border_k:k] e não existe maior.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Gráfico de bordas encadeadas",
                                    "Calculadora para contagens se k grande"
                                  ],
                                  "tips": [
                                    "Desenhe setas de bordas para visualizar recursão: k -> pi[k-1] -> pi[pi[k-1]-1].",
                                    "Teste com k pequeno primeiro."
                                  ],
                                  "learningObjective": "Extrair e validar a border recursiva simulando o iterativo KMP.",
                                  "commonMistakes": [
                                    "Parar o loop cedo (antes de i=k-1).",
                                    "Assumir border_k=0 sem computar pi completo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar recursão completa e simular aplicação",
                                  "subSteps": [
                                    "Aplique recursão: compute border de border_k se >0, até chegar a 0.",
                                    "Simule um mismatch no KMP original: ao falhar match, pule para border.",
                                    "Compare com implementação manual para múltiplas bordas.",
                                    "Documente o chain de bordas e seu uso em falhas de pattern matching.",
                                    "Teste com variação da string para robustez."
                                  ],
                                  "verification": "O chain termina em 0 e cada border é válida prefixo/sufixo.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Cadeia de bordas anotada",
                                    "Exemplo de pattern search com mismatch"
                                  ],
                                  "tips": [
                                    "Pense em termos de 'fail function' do KMP: border links para estados.",
                                    "Automatize mentalmente para chains longas."
                                  ],
                                  "learningObjective": "Simular recursão em bordas para otimização de busca KMP.",
                                  "commonMistakes": [
                                    "Ignorar bordas intermediárias no chain.",
                                    "Confundir border de s com border de b."
                                  ]
                                }
                              ],
                              "practicalExample": "Para s = 'ababa' (m=5), borda k=3 (b='aba'): pi_b = [0,0,1], border_k = pi_b[2]=1 ('a' é prefixo/sufixo de 'aba'). Recursão: 3 -> 1 -> 0. No KMP, ao mismatch em posição 4, volte para len=1.",
                              "finalVerifications": [
                                "A border_k < k e b[0:border_k] == b[k-border_k:k].",
                                "Não existe border maior que border_k válida.",
                                "O pi_b[i] é corretamente <= i para todo i.",
                                "Simulação de mismatch usa corretamente border_k como próximo len.",
                                "Chain recursivo termina em 0 sem loops."
                              ],
                              "assessmentCriteria": [
                                "Precisão na extração e verificação inicial da borda (100% match).",
                                "Correta implementação do loop KMP sem erros de index/len (erro <5%).",
                                "Validação manual da border_k e chain recursivo.",
                                "Eficiência na simulação de backtrack (tempo dentro do estimado).",
                                "Explicação clara do papel na otimização KMP.",
                                "Tratamento edge cases (k=1, todas iguais)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Relações recursivas e funções definidas por si (sequências).",
                                "Lógica e Programação: Loops aninhados com condições de fallback.",
                                "Teoria da Computação: Autômatos finitos e transições de falha.",
                                "Análise de Algoritmos: Complexidade O(k) do pré-processamento."
                              ],
                              "realWorldApplication": "Em buscas de padrões em DNA sequences ou logs de sistemas, o chain de bordas permite pular seções grandes em mismatches, acelerando matching em textos gigantes como genomas ou corpora linguísticos."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.2",
                        "name": "Construção da Tabela de Falha (Função π)",
                        "description": "Algoritmo para pré-computar a função de falha π (ou tabela de prefixos), que armazena para cada posição i o comprimento da maior borda da substring padrão[0..i].",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.2.1",
                            "name": "Implementar o pré-processamento da tabela π",
                            "description": "Escrever pseudocódigo ou código para construir a tabela π do padrão, utilizando o ponteiro de falha e verificação de caracteres iguais/desiguais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar a tabela π e variáveis auxiliares",
                                  "subSteps": [
                                    "Criar um array π de tamanho igual ao comprimento do padrão (pattern), inicializando todos os elementos com 0.",
                                    "Definir π[0] = 0 explicitamente, pois o prefixo de um caractere único é vazio.",
                                    "Inicializar variáveis: i = 1 (índice atual no padrão), len = 0 (comprimento do prefixo-sufixo atual).",
                                    "Escrever o esqueleto da função em pseudocódigo ou código (ex: def compute_pi(pattern): ).",
                                    "Adicionar comentários explicando o propósito da inicialização."
                                  ],
                                  "verification": "Verificar se π[0] == 0 e variáveis i e len estão corretamente inicializadas antes do loop principal.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Jupyter Notebook)",
                                    "Documentação do algoritmo KMP",
                                    "Papel e caneta para esboçar"
                                  ],
                                  "tips": "Sempre inicialize π como lista de zeros para evitar índices inválidos; use len(pattern) para o tamanho.",
                                  "learningObjective": "Compreender a base da função π e preparar estruturas de dados para o algoritmo.",
                                  "commonMistakes": [
                                    "Esquecer de setar π[0] = 0",
                                    "Inicializar i=0 em vez de 1",
                                    "Usar tamanho errado para o array π"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o avanço no loop principal para caracteres iguais",
                                  "subSteps": [
                                    "Iniciar o loop while i < len(pattern):",
                                    "Verificar se pattern[i] == pattern[len]:",
                                    "Se igual, incrementar len por 1.",
                                    "Atribuir π[i] = len.",
                                    "Incrementar i por 1.",
                                    "Adicionar indentação correta e comentários para o caso de match."
                                  ],
                                  "verification": "Simular manualmente com i=1 no exemplo 'aabaab': deve setar π[1]=1 após match.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo de padrão: 'aabaab'",
                                    "Debugger ou print statements"
                                  ],
                                  "tips": "Use prints temporários para rastrear valores de i e len durante matches.",
                                  "learningObjective": "Codificar o crescimento do prefixo-sufixo quando caracteres coincidem.",
                                  "commonMistakes": [
                                    "Incrementar len sem checar igualdade",
                                    "Esquecer de setar π[i] = len",
                                    "Incrementar i dentro do if sem condição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o tratamento de falha (mismatch) com ponteiro de falha",
                                  "subSteps": [
                                    "No else do if (pattern[i] != pattern[len]):",
                                    "Verificar se len != 0, se sim, setar len = π[len - 1] (backtrack).",
                                    "Se len == 0, setar π[i] = 0 e incrementar i.",
                                    "Garantir que o backtrack seja recursivo via π[len-1], sem incrementar i no backtrack.",
                                    "Testar com mismatch no exemplo: em i=2 ('b' != 'a'), backtrack len para 0."
                                  ],
                                  "verification": "Executar com 'aabaab': em i=2, deve backtrack len=1 -> 0, setar π[2]=0, i=3.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo 'aabaab'",
                                    "Ferramenta de debug passo a passo"
                                  ],
                                  "tips": "Lembre-se: no mismatch, NÃO incremente i até resolver o backtrack ou len=0.",
                                  "learningObjective": "Dominar o mecanismo de falha que permite eficiência O(m) no pré-processamento.",
                                  "commonMistakes": [
                                    "Incrementar i no backtrack",
                                    "Usar len em vez de π[len-1]",
                                    "Loop infinito em backtracks"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar a função, testar e validar a tabela π",
                                  "subSteps": [
                                    "Retornar o array π completo da função.",
                                    "Testar com padrão 'aabaab', esperado π = [0,1,0,1,2,3].",
                                    "Adicionar validação: checar se π[i] < i para todo i (propriedade de prefixo próprio).",
                                    "Debugar erros comuns usando prints ou debugger.",
                                    "Escrever um teste unitário simples para múltiplos padrões."
                                  ],
                                  "verification": "Rodar a função e comparar π com valores esperados; deve coincidir exatamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Lista de padrões de teste (ex: 'aabaab', 'aaaa', 'abc')",
                                    "Calculadora manual de π"
                                  ],
                                  "tips": "Sempre teste com casos edge: padrão vazio, todos iguais, sem matches.",
                                  "learningObjective": "Integrar e validar a implementação completa da tabela π.",
                                  "commonMistakes": [
                                    "Índices off-by-one em Python (0-based)",
                                    "Retornar cópia errada de π",
                                    "Ignorar casos onde len não zera"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o padrão 'aabaab':\nπ = [0, 1, 0, 1, 2, 3]\n- Posição 1: 'a' == 'a' → len=1\n- Posição 2: 'b' != 'a' → backtrack len=π[0]=0, 'b'!='a' → π[2]=0\n- Posição 3: 'a'=='a' → len=1\nImplemente e execute para obter exatamente essa tabela.",
                              "finalVerifications": [
                                "A função retorna π correta para 'aabaab': [0,1,0,1,2,3].",
                                "Tempo de execução é O(m) para padrões longos (sem timeouts).",
                                "π[i] <= i para todo i, e π[0]=0.",
                                "Funciona para edge cases: padrão 'a' → [0]; 'aaaa' → [0,1,2,3]; 'abc' → [0,0,0].",
                                "Pseudocódigo/código explica backtrack corretamente em comentários.",
                                "Nenhum erro de índice ou loop infinito em testes."
                              ],
                              "assessmentCriteria": [
                                "Correção: π exata para exemplos dados (100% match).",
                                "Eficiência: Implementa backtrack via π[len-1], não comparações lineares.",
                                "Clareza: Código comentado, variáveis bem nomeadas (ex: pattern_length, failure_len).",
                                "Robustez: Lida com padrões vazios ou unitários sem crash.",
                                "Testes: Inclui pelo menos 3 casos de teste com saídas verificadas.",
                                "Explicação: Descreve verbalmente o papel do ponteiro de falha."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Conceitos de prefixos e sufixos em sequências.",
                                "Estruturas de Dados: Arrays e funções de falha como automatos finitos.",
                                "Programação Geral: Controle de loops aninhados e recursão implícita.",
                                "Análise de Algoritmos: Complexidade O(m) vs. abordagens ingênuas O(m²).",
                                "Ciência de Dados: Pré-processamento em matching de padrões em textos/DNA."
                              ],
                              "realWorldApplication": "No algoritmo KMP completo para busca de padrões em textos longos (ex: Ctrl+F em editores como VS Code, busca em genomas para sequências de DNA, detecção de plágio em documentos, ou filtros de spam em e-mails), onde a tabela π permite skips eficientes, reduzindo tempo de busca de O(n*m) para O(n+m)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.2",
                            "name": "Simular a construção da tabela π passo a passo",
                            "description": "Para um padrão exemplo como 'ABABABC', executar manualmente o algoritmo de construção da tabela π, anotando valores de i, len e π[i].",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar a tabela π e variáveis para o padrão 'ABABABC'",
                                  "subSteps": [
                                    "Escreva o padrão P = 'ABABABC' com índices de 0 a 6.",
                                    "Crie uma tabela π de tamanho 7, inicializando π[0] = 0.",
                                    "Defina i = 1 (próxima posição a processar) e len = 0 (comprimento do prefixo-sufixo atual).",
                                    "Anote o estado inicial: i=1, len=0, π = [0, ?, ?, ?, ?, ?, ?].",
                                    "Revise o algoritmo: enquanto len > 0 e P[i] != P[len], len = π[len-1]; se P[i] == P[len], len++; π[i] = len."
                                  ],
                                  "verification": "Confirme que π[0]=0, i=1, len=0 e o padrão está anotado corretamente sem erros tipográficos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha, pseudocódigo do algoritmo KMP impresso.",
                                  "tips": "Use cores diferentes para P, π, i e len para visualização clara.",
                                  "learningObjective": "Compreender a configuração inicial e o papel de cada variável no algoritmo.",
                                  "commonMistakes": "Esquecer de inicializar π[0]=0; confundir índices 0-base com 1-base."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processar iterações iniciais sem backtrack (i=1 a i=2)",
                                  "subSteps": [
                                    "Para i=1 (P[1]='B'): len=0, então verifique P[1] != P[0] ('B'!='A'), mas como len=0 não backtrack, π[1]=0, i=2, len=0.",
                                    "Anote: i=1, len=0, P[1]='B' != P[0]='A', π[1]=0.",
                                    "Para i=2 (P[2]='A'): len=0, P[2]=='A'==P[0], len=1, π[2]=1, i=3.",
                                    "Anote: i=2, len=1, π[2]=1.",
                                    "Atualize tabela: π = [0, 0, 1, ?, ?, ?, ?]."
                                  ],
                                  "verification": "Tabela mostra π[1]=0 e π[2]=1 corretamente, com anotações de i e len para cada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha.",
                                  "tips": "Desenhe setas para mostrar comparações P[i] vs P[len].",
                                  "learningObjective": "Executar o loop básico quando len=0 ou match direto.",
                                  "commonMistakes": "Incrementar len incorretamente quando não há match; pular anotação de len=0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar iterações com matches sucessivos (i=3 a i=5)",
                                  "subSteps": [
                                    "Para i=3 (P[3]='B'): len=1, P[3]='B'==P[1]='B', len=2, π[3]=2, i=4.",
                                    "Anote: i=3, len=2, π[3]=2.",
                                    "Para i=4 (P[4]='A'): len=2, P[4]='A'==P[2]='A', len=3, π[4]=3, i=5.",
                                    "Anote: i=4, len=3, π[4]=3.",
                                    "Para i=5 (P[5]='B'): len=3, P[5]='B'==P[3]='B', len=4, π[5]=4, i=6.",
                                    "Anote: i=5, len=4, π[5]=4. Tabela agora: [0,0,1,2,3,4,?]."
                                  ],
                                  "verification": "Verifique se π[3]=2, π[4]=3, π[5]=4 e len cresceu progressivamente sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha.",
                                  "tips": "Observe o padrão repetitivo 'ABAB' permitindo len crescer.",
                                  "learningObjective": "Reconhecer como matches sucessivos aumentam len continuamente.",
                                  "commonMistakes": "Comparar com posição errada (ex: P[len] incorreto); não anotar cada incremento."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Lidar com mismatch e backtrack (i=6) e finalizar",
                                  "subSteps": [
                                    "Para i=6 (P[6]='C'): len=4, P[6]='C' != P[4]='A', backtrack: len=π[3]=2.",
                                    "Ainda P[6]='C' != P[2]='A', backtrack: len=π[1]=0.",
                                    "Agora len=0, P[6]='C' != P[0]='A', π[6]=0.",
                                    "Anote toda sequência: i=6, len=4→2→0, π[6]=0.",
                                    "Tabela final: [0,0,1,2,3,4,0]. Compare com algoritmo padrão."
                                  ],
                                  "verification": "Backtrack corretamente anotado (4→2→0) e π[6]=0 confirmado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha, tabela de referência do KMP.",
                                  "tips": "Use uma pilha visual para backtracks (ex: desenhe setas de retorno).",
                                  "learningObjective": "Dominar o mecanismo de backtrack usando π[len-1] em mismatches.",
                                  "commonMistakes": "Parar backtrack cedo (ex: len=2 sem checar P[2]); confundir π[len-1] com π[len]."
                                }
                              ],
                              "practicalExample": "Usando o padrão 'ABABABC', simule manualmente: inicialize π=[0,_,_,_,_,_,_], i=1, len=0. Prossiga i=1 ('B'≠'A') → π[1]=0; i=2 ('A'=='A') → π[2]=1; i=3 ('B'=='B') → π[3]=2; i=4 ('A'=='A') → π[4]=3; i=5 ('B'=='B') → π[5]=4; i=6 ('C'≠'A', backtrack 4→π[3]=2 'C'≠'A' → π[1]=0 'C'≠'A' →0) → π[6]=0. Resultado: [0,0,1,2,3,4,0].",
                              "finalVerifications": [
                                "Tabela π final exata: [0,0,1,2,3,4,0].",
                                "Anotações completas de i, len e π[i] para todos os 7 passos.",
                                "Backtrack em i=6 corretamente documentado: len 4→2→0.",
                                "Nenhum match indevido ou backtrack omitido.",
                                "Explicação verbal do porquê π[6]=0.",
                                "Capacidade de refazer sem consultar notas."
                              ],
                              "assessmentCriteria": [
                                "Precisão 100% na tabela π final.",
                                "Correta sequência de backtracks no mismatch.",
                                "Substeps detalhados e anotados para cada i.",
                                "Uso correto das regras do algoritmo (match, increment, backtrack).",
                                "Identificação de padrões prefixo-sufixo (ex: 'ABAB' em posições iniciais).",
                                "Tempo de execução dentro do estimado total (60 min)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Reconhecimento de padrões e funções recursivas em sequências.",
                                "Programação: Implementação de loops while e arrays em linguagens como Python/Java.",
                                "Biologia: Análise de sequências genéticas (DNA matching via KMP).",
                                "Linguística: Processamento de texto e busca de padrões em linguagem natural."
                              ],
                              "realWorldApplication": "O algoritmo KMP com tabela π acelera buscas de padrões em textos grandes, usado em editores como Vim/grep, motores de busca (Google), compiladores (análise léxica) e bioinformática (alinhamento de sequências genéticas em genomas)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.1.2.3",
                            "name": "Analisar correção da tabela π",
                            "description": "Verificar se uma tabela π computada está correta comparando com prefixos/sufixos e identificar erros comuns no algoritmo de construção.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a definição da função π",
                                  "subSteps": [
                                    "Revise a definição: π[i] é o tamanho do maior prefixo próprio de P[0..i] que é também sufixo de P[0..i].",
                                    "Identifique prefixos próprios: sequências P[0..k-1] para k=1 a i.",
                                    "Identifique sufixos correspondentes: P[i-k+1..i] e compare caractere por caractere.",
                                    "Note que prefixo próprio exclui o string inteiro (k < i+1)."
                                  ],
                                  "verification": "Liste 2-3 prefixos e sufixos para i=2 e confirme matches manuais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Padrão de string exemplo impresso"
                                  ],
                                  "tips": "Sempre comece comparando do menor para o maior possível k.",
                                  "learningObjective": "Dominar o conceito fundamental de prefixo-sufixo na tabela π.",
                                  "commonMistakes": [
                                    "Confundir prefixo próprio com prefixo total (π[i] nunca é i+1)",
                                    "Ignorar que comparações são sensíveis a maiúsculas/minúsculas se aplicável"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar valores iniciais da tabela π",
                                  "subSteps": [
                                    "Confirme π[0] = 0 sempre (prefixo próprio vazio).",
                                    "Para i=1: Compare P[0] com P[1]; se iguais, π[1]=1; senão 0.",
                                    "Para i=2 a 3: Liste todos prefixos próprios e sufixos, encontre maior match.",
                                    "Calcule manualmente e compare com a tabela proposta."
                                  ],
                                  "verification": "π[0]=0 e valores iniciais batem com cálculo manual para primeiros 3 índices.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora de strings (opcional)",
                                    "Referência do algoritmo KMP"
                                  ],
                                  "tips": "Use alinhamento visual: escreva o padrão e sublinhe prefixos/sufixos.",
                                  "learningObjective": "Validar casos base da tabela π.",
                                  "commonMistakes": [
                                    "Definir π[0] como 1 ou outro valor não-zero",
                                    "Parar match prematuramente sem checar todos k"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Validar construção iterativa para posições subsequentes",
                                  "subSteps": [
                                    "Para cada i >=1: Inicie k = π[i-1].",
                                    "Enquanto k>0 e P[i] != P[k], defina k = π[k-1].",
                                    "Se P[i] == P[k], π[i] = k+1; senão 0.",
                                    "Simule o loop de borda e compare com tabela proposta passo a passo."
                                  ],
                                  "verification": "Simulação iterativa reproduz exatamente os valores da tabela para todos i.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Tabela π proposta",
                                    "Implementação Python de KMP para referência (não copiar, só validar)"
                                  ],
                                  "tips": "Desenhe uma pilha de bordas para visualizar backtracks.",
                                  "learningObjective": "Aplicar a regra de fallback corretamente na verificação.",
                                  "commonMistakes": [
                                    "Não fazer backtrack suficiente (parar em k errado)",
                                    "Confundir P[i] com P[k] na comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Diagnosticar erros comuns e validar completamente",
                                  "subSteps": [
                                    "Cheque erros: π[i] > i+1 impossível; valores decrescentes incorretos.",
                                    "Compare prefixo-sufixo direto para cada i: verifique se P[0..π[i]-1] == P[i-π[i]+1..i].",
                                    "Teste consistência: para cada i, π[i] deve permitir fallback correto.",
                                    "Gere tabela oficial (manual ou código) e differe com proposta."
                                  ],
                                  "verification": "Todos valores satisfazem prefixo-sufixo e nenhum erro comum presente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código de validação simples ou ferramenta online KMP"
                                  ],
                                  "tips": "Use diff visual: alinhe padrão com shifts baseados em π.",
                                  "learningObjective": "Identificar e corrigir falhas na construção da tabela π.",
                                  "commonMistakes": [
                                    "Aceitar π[i] onde prefixo-sufixo não bate",
                                    "Ignorar que π deve ser não-decrecente em chains de bordas"
                                  ]
                                }
                              ],
                              "practicalExample": "Para o padrão P = 'AABAA':\nTabela π correta: [0,1,0,1,2]\nVerificação: Para i=4, π[4]=2 → prefixo 'AA' == sufixo 'AA' (P[3:5]).\nTabela errada proposta: [0,1,0,1,1] → Erro em i=4 (sufixo 'AA' match 'AA', não 'A'). Simule: k=π[3]=1, P[4]='A'==P[1]='A' → k+1=2.",
                              "finalVerifications": [
                                "π[0] = 0.",
                                "Para todo i, P[0..π[i]-1] == P[i-π[i]+1..i].",
                                "A regra iterativa (fallback) reproduz a tabela quando simulada.",
                                "Nenhum π[i] > i+1 ou valores inválidos.",
                                "Consistência de bordas: π[π[i]-1] é fallback correto.",
                                "Teste com pelo menos 2 padrões conhecidos bate.",
                                "Sem mismatches em prefixo-sufixo para qualquer i."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de matches prefixo-sufixo (100% para tabela correta).",
                                "Correta simulação do algoritmo iterativo sem erros de backtrack.",
                                "Detecção de pelo menos 3 erros comuns em tabelas inválidas.",
                                "Explicação clara de discrepâncias encontradas.",
                                "Tempo de verificação eficiente (<1h para padrões médios).",
                                "Validação cruzada com implementação de referência.",
                                "Relatório estruturado de erros e correções."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Debug de algoritmos de strings em Python/Java.",
                                "Matemática: Teoria de linguagens formais e autômatos.",
                                "Ciência da Computação: Análise de complexidade O(n) do KMP.",
                                "Lógica: Raciocínio dedutivo em verificações iterativas.",
                                "Engenharia de Software: Validação e testes unitários de código."
                              ],
                              "realWorldApplication": "Em motores de busca como Google ou editores de texto (VS Code find/replace), validar tabelas π garante buscas eficientes em textos/DNA grandes, evitando falhas em matching de padrões repetitivos como em genômica ou detecção de plágio."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.1.3"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.1.3",
                        "name": "Algoritmo de Busca KMP",
                        "description": "Uso da tabela π pré-computada para realizar busca eficiente de ocorrências do padrão no texto, evitando comparações desnecessárias com saltos baseados na função de falha.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.1.3.1",
                            "name": "Implementar o processo de busca KMP",
                            "description": "Escrever o algoritmo completo de busca usando a tabela π, gerenciando ponteiros q (estado do padrão) e i (posição no texto), reportando todas as posições de match.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a assinatura da função e inicializar variáveis",
                                  "subSteps": [
                                    "Crie uma função que receba o texto (text), o padrão (pattern) e a tabela π (pi_table) como parâmetros.",
                                    "Inicialize ponteiros: i = 0 para posição no texto, q = 0 para estado do padrão.",
                                    "Crie uma lista vazia matches para armazenar posições de match.",
                                    "Defina a constante m = len(pattern)."
                                  ],
                                  "verification": "Verifique se a função é definida corretamente e variáveis i, q e matches estão inicializadas em 0 ou vazias.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Jupyter)",
                                    "Pseudocódigo KMP para referência"
                                  ],
                                  "tips": "Use nomes de variáveis descritivos como 'text_length' para n = len(text).",
                                  "learningObjective": "Compreender a preparação inicial do algoritmo KMP para busca eficiente.",
                                  "commonMistakes": [
                                    "Esquecer de importar bibliotecas necessárias (ex: typing para List[int])",
                                    "Inicializar q como 1 em vez de 0",
                                    "Não capturar len(pattern) em m"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o loop principal de busca e matching",
                                  "subSteps": [
                                    "Inicie um loop while i < len(text):",
                                    "Se text[i] == pattern[q], incremente i e q.",
                                    "Se q == m, adicione (i - q) à lista matches e defina q = pi_table[q-1].",
                                    "Incremente i após cada iteração do loop interno."
                                  ],
                                  "verification": "Teste com texto='AA', pattern='A', pi_table=[0]; deve retornar [0,1].",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de teste simples (texto curto)"
                                  ],
                                  "tips": "Use print statements temporários para rastrear i e q durante o loop.",
                                  "learningObjective": "Dominar o avanço simultâneo de ponteiros durante matches parciais.",
                                  "commonMistakes": [
                                    "Incrementar i apenas no match, esquecendo no mismatch",
                                    "Adicionar posição errada (i - q em vez de i - m)",
                                    "Não resetar q após match completo"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Gerenciar mismatches usando a tabela π",
                                  "subSteps": [
                                    "No loop while i < len(text), se text[i] != pattern[q] e q != 0, defina q = pi_table[q-1].",
                                    "Se q == 0 após isso e ainda mismatch, incremente i apenas.",
                                    "Continue o loop até i == len(text).",
                                    "Garanta que o loop evite comparações desnecessárias."
                                  ],
                                  "verification": "Teste com texto='ABCAB', pattern='ABCA', pi_table=[0,0,1,1]; deve pular mismatch corretamente.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Calculadora para π manual (opcional)"
                                  ],
                                  "tips": "Lembre-se: π[q-1] é o maior prefixo próprio que é sufixo.",
                                  "learningObjective": "Implementar fallback eficiente para mismatches sem recuar i.",
                                  "commonMistakes": [
                                    "Decrementar i no mismatch",
                                    "Usar pi_table[q] em vez de pi_table[q-1]",
                                    "Loop infinito em q=0"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar a função e retornar resultados",
                                  "subSteps": [
                                    "Após o loop while, retorne a lista matches ordenada.",
                                    "Adicione docstring explicando parâmetros e retorno.",
                                    "Teste com múltiplos matches sobrepostos, ex: texto='AAAA', pattern='AA'.",
                                    "Otimize para O(n + m) confirmando não há loops extras."
                                  ],
                                  "verification": "Execute função com texto='AABAACAABAA', pattern='AABAAC', pi_table=[0,1,0,1,2,0]; deve retornar [0,4].",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Suite de testes unitários (ex: pytest)"
                                  ],
                                  "tips": "Use assert para testes rápidos no final da função.",
                                  "learningObjective": "Completar implementação robusta com saída correta e documentada.",
                                  "commonMistakes": [
                                    "Retornar posições 1-indexadas em vez de 0-indexadas",
                                    "Não lidar com pattern vazio",
                                    "Esquecer de ordenar matches"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e depurar a implementação completa",
                                  "subSteps": [
                                    "Crie 5 casos de teste: match único, múltiplos, sobrepostos, sem match, pattern maior que texto.",
                                    "Compare saídas com execução manual passo a passo.",
                                    "Meça tempo de execução para texto grande (ex: 10^6 chars).",
                                    "Refatore código para legibilidade."
                                  ],
                                  "verification": "Todos testes passam e complexidade é O(n+m).",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Gerador de textos longos (ex: string de 'A's)"
                                  ],
                                  "tips": "Use debugger para pausar em mismatches.",
                                  "learningObjective": "Validar corretude e eficiência da implementação KMP.",
                                  "commonMistakes": [
                                    "Ignorar casos edge como texto vazio",
                                    "Contar overlaps errados",
                                    "Não verificar pi_table pré-computada"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente kmp_search('ABABCABCAB', 'ABC', [0,0,1]) deve retornar [2, 5, 7], encontrando 'ABC' nas posições 2,5,7 sem recomeçar do zero após mismatches.",
                              "finalVerifications": [
                                "Função retorna todas posições de match corretas incluindo overlaps.",
                                "Gerencia mismatches retrocedendo apenas q usando π sem mover i para trás.",
                                "Executa em tempo linear O(n+m) em textos grandes.",
                                "Funciona com pattern vazio (retorna []) e texto vazio ([]).",
                                "Lista matches está ordenada crescente.",
                                "Não há índices fora de bounds."
                              ],
                              "assessmentCriteria": [
                                "Código limpo, comentado e com docstring.",
                                "Correta inicialização e gerenciamento de i e q.",
                                "Implementação exata do fallback π[q-1] em mismatches.",
                                "Coleta precisa de posições (i - m).",
                                "Tratamento completo de casos edge.",
                                "Eficiência demonstrada em testes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções de prefixo-sufixo e autômatos finitos.",
                                "Análise de Algoritmos: Comparação com busca ingênua O(n*m).",
                                "Engenharia de Software: Testes unitários e depuração.",
                                "Bioinformática: Busca em sequências de DNA.",
                                "Teoria da Computação: AFD para reconhecimento de padrões."
                              ],
                              "realWorldApplication": "Usado em motores de busca como Google para indexação de texto, editores como VS Code para 'find all', análise genômica para padrões em DNA/RNA, e compressão de dados como em ZIP."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.2",
                            "name": "Simular busca KMP em texto e padrão",
                            "description": "Executar manualmente a busca KMP para texto 'ABABABCDABABABCABAB' e padrão 'ABABABC', rastreando q e i em cada passo e identificando matches.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir a Tabela de Prefixo (Pi Array) para o Padrão 'ABABABC'",
                                  "subSteps": [
                                    "Escreva o padrão 'ABABABC' com índices de 0 a 6: 0:A, 1:B, 2:A, 3:B, 4:A, 5:B, 6:C.",
                                    "Inicialize o array pi com pi[0] = 0 e os demais como 0 temporariamente.",
                                    "Para i=1 ('B'), j=0: 'B' != 'A' (P[0]), então pi[1] = 0.",
                                    "Para i=2 ('A'), j=0: 'A' == 'A', j=1, pi[2] = 1.",
                                    "Para i=3 ('B'), j=1: 'B' == 'B', j=2, pi[3] = 2.",
                                    "Para i=4 ('A'), j=2: 'A' == 'A', j=3, pi[4] = 3.",
                                    "Para i=5 ('B'), j=3: 'B' == 'B', j=4, pi[5] = 4.",
                                    "Para i=6 ('C'), j=4: 'C' != 'A' (P[4]), j=pi[3]=2; 'C' != 'A' (P[2]), j=pi[1]=0; 'C' != 'A' (P[0]), pi[6] = 0."
                                  ],
                                  "verification": "Verifique se pi = [0, 0, 1, 2, 3, 4, 0] está correto comparando com o padrão.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Padrão 'ABABABC' escrito",
                                    "Tabela quadriculada para pi"
                                  ],
                                  "tips": "Desenhe o padrão acima e abaixo para visualizar prefixes e suffixes; sempre backtrack j = pi[j-1] em mismatches.",
                                  "learningObjective": "Calcular com precisão a tabela de prefixo para habilitar buscas eficientes sem reexames desnecessários.",
                                  "commonMistakes": [
                                    "Definir pi[0] diferente de 0",
                                    "Não backtrack corretamente j em mismatches múltiplos",
                                    "Confundir prefixo próprio com o padrão inteiro"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a Simulação de Busca no Texto 'ABABABCDABABABCABAB'",
                                  "subSteps": [
                                    "Escreva o texto completo com índices: 0:A,1:B,2:A,3:B,4:A,5:B,6:C,7:D,8:A,9:B,10:A,11:B,12:A,13:B,14:C,15:A,16:B,17:A,18:B.",
                                    "Inicialize variáveis: i=0 (posição no texto), q=0 (estado no padrão), lista de matches vazia.",
                                    "Prepare uma tabela com colunas: i, T[i], P[q], Match?, Nova q, Ação (match, mismatch, backtrack).",
                                    "Copie a tabela pi ao lado para referência rápida.",
                                    "Confirme comprimento do padrão M=7 e texto N=19."
                                  ],
                                  "verification": "Configuração inicial: i=0, q=0, tabela pi visível, texto e padrão indexados corretamente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado grande",
                                    "Texto 'ABABABCDABABABCABAB' escrito",
                                    "Tabela pi do Step 1"
                                  ],
                                  "tips": "Use cores diferentes para texto (azul), padrão (vermelho) e pi (verde) para facilitar o rastreamento visual.",
                                  "learningObjective": "Preparar o ambiente de simulação para rastrear precisamente as transições de estado.",
                                  "commonMistakes": [
                                    "Indexação errada do texto ou padrão",
                                    "Esquecer de preparar espaço para rastrear q em cada i",
                                    "Confundir i (texto) com q (padrão)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Simular a Busca até o Primeiro Match (i=0 a i=7)",
                                  "subSteps": [
                                    "i=0: T[0]='A'==P[0]='A', q=1.",
                                    "i=1: 'B'==P[1]='B', q=2.",
                                    "i=2: 'A'==P[2]='A', q=3.",
                                    "i=3: 'B'==P[3]='B', q=4.",
                                    "i=4: 'A'==P[4]='A', q=5.",
                                    "i=5: 'B'==P[5]='B', q=6.",
                                    "i=6: 'C'==P[6]='C', q=7 (match! Adicione posição i-M+1=0 à lista de matches, reset q=pi[6]=0).",
                                    "i=7: 'D' != P[0]='A', q=0 (mismatch, sem backtrack pois q=0)."
                                  ],
                                  "verification": "Tabela: q após cada i: 1,2,3,4,5,6,7(->0),0; Match em 0 confirmado.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Tabela de rastreamento iniciada",
                                    "Pi array referência"
                                  ],
                                  "tips": "Registre q antes e após cada comparação; ao atingir q==7, sempre reset para pi[q-1].",
                                  "learningObjective": "Executar matching sequencial e detectar o primeiro match completo usando a pi para reset.",
                                  "commonMistakes": [
                                    "Não resetar q=pi[6] após match",
                                    "Parar i++ sem avançar após mismatch com q=0",
                                    "Erro em comparação de caracteres"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Simular a Busca até o Segundo Match e Fim (i=8 a i=18)",
                                  "subSteps": [
                                    "i=8: 'A'==P[0]='A', q=1.",
                                    "i=9: 'B'==P[1]='B', q=2.",
                                    "i=10: 'A'==P[2]='A', q=3.",
                                    "i=11: 'B'==P[3]='B', q=4.",
                                    "i=12: 'A'==P[4]='A', q=5.",
                                    "i=13: 'B'==P[5]='B', q=6.",
                                    "i=14: 'C'==P[6]='C', q=7 (match! Adicione posição 8 à lista, q=pi[6]=0).",
                                    "i=15: 'A'==P[0]='A', q=1.",
                                    "i=16: 'B'==P[1]='B', q=2.",
                                    "i=17: 'A'==P[2]='A', q=3.",
                                    "i=18: 'B'==P[3]='B', q=4 (fim do texto)."
                                  ],
                                  "verification": "q após cada i:1,2,3,4,5,6,7(->0),1,2,3,4; Match em 8 confirmado, sem mais matches.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Continuação da tabela de rastreamento"
                                  ],
                                  "tips": "Note como após 'D' (mismatch simples), a busca recomeça eficientemente do zero.",
                                  "learningObjective": "Completar a simulação demonstrando múltiplos matches e handling de fim de texto.",
                                  "commonMistakes": [
                                    "Backtrack desnecessário quando q=0",
                                    "Não adicionar posição correta i-6 para match",
                                    "Perder o rastreamento no final"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Analisar Resultados e Verificar a Simulação Completa",
                                  "subSteps": [
                                    "Liste todos os matches: posições 0 e 8.",
                                    "Verifique subsequências: texto[0:7]='ABABABC', texto[8:15]='ABABABC'.",
                                    "Confirme tabela q completa para i=0-18: [1,2,3,4,5,6,7->0,0,1,2,3,4,5,6,7->0,1,2,3,4].",
                                    "Explique eficiência: sem pi, mismatches reexaminariam; aqui, backtracks mínimos.",
                                    "Teste manual: reescreva texto[0:7] e [8:15] para validar matches."
                                  ],
                                  "verification": "Matches: [0,8]; q final correto; explicação de pelo menos um backtrack.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Tabela completa de i,q",
                                    "Texto e padrão"
                                  ],
                                  "tips": "Valide matches copiando substrings exatas do texto.",
                                  "learningObjective": "Interpretar resultados da simulação e validar a corretude do algoritmo KMP.",
                                  "commonMistakes": [
                                    "Posições de match erradas (ex: usar i em vez de i-M+1)",
                                    "Ignorar resets de q após match",
                                    "Não verificar fim de texto com q parcial"
                                  ]
                                }
                              ],
                              "practicalExample": "Simule KMP para padrão 'AAB' (pi=[0,1,0]) em texto 'AAABAAB': matches em posições 0 e 3. Rastreie i,q: i=0 A=A q1;1 A=B? no->q=pi0=0,A=A q1;2 A=B?no q0;3 B!=A q0;4 A=A q1;5 A=B?no q=pi0=0,A? fim parcial.",
                              "finalVerifications": [
                                "Tabela pi correta: [0,0,1,2,3,4,0]",
                                "Matches exatos em posições 0 e 8",
                                "Rastreamento completo de q para todos i=0-18 sem erros",
                                "Backtracks corretos (ex: i=6 match reset q=0; i=7 mismatch q=0)",
                                "Substrings validadas: texto[0:7] e [8:15] iguais ao padrão",
                                "Explicação de eficiência KMP vs busca ingênua"
                              ],
                              "assessmentCriteria": [
                                "Construção 100% precisa da tabela pi",
                                "Rastreamento correto de i e q em todas as 19 posições",
                                "Identificação precisa das posições de match (0 e 8)",
                                "Demonstração correta de resets q=pi[q-1] após match",
                                "Explicação clara de backtracks e mismatches",
                                "Validação manual das substrings de match",
                                "Compreensão da otimização via pi (pulos evitados)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Autômatos finitos e funções de transição",
                                "Biologia: Busca de padrões em sequências de DNA/RNA",
                                "Linguística Computacional: Detecção de padrões em corpora textuais",
                                "Engenharia: Otimização em processadores de texto e compiladores",
                                "Física: Análise de sinais e padrões periódicos"
                              ],
                              "realWorldApplication": "O KMP é essencial em motores de busca (Google, Ctrl+F em editores), bioinformática (localizar genes em genomas via BLAST-like), detecção de plágio em documentos, e processamento de logs em sistemas para padrões de segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.3",
                            "name": "Analisar complexidade do KMP",
                            "description": "Provar que o pré-processamento e a busca do KMP rodam em O(m + n), onde m é o tamanho do padrão e n do texto, comparando com busca ingênua O(nm).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Pré-processamento do KMP (Construção da Tabela Pi)",
                                  "subSteps": [
                                    "Relembre a função da tabela pi: pi[i] é o comprimento do maior prefixo próprio que é também sufixo da substring P[0..i].",
                                    "Implemente ou simule manualmente a construção da tabela pi para um padrão exemplo, como P = 'AABAACAAB'.",
                                    "Trace o loop while para backtrack: quando pi[j-1] < i - j + 1, defina j = pi[j-1].",
                                    "Conte o número total de iterações e comparações durante a construção.",
                                    "Verifique a tabela pi resultante: para P='AABAACAAB', pi = [0,1,0,1,2,0,1,2,3]."
                                  ],
                                  "verification": "A tabela pi é construída corretamente sem erros de backtrack e todas as posições são preenchidas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e caneta para traçar",
                                    "Código Python do KMP para validar",
                                    "Exemplos de padrões variados"
                                  ],
                                  "tips": "Sempre inicialize pi[0]=0 e use j=0 como ponteiro de comprimento do prefixo.",
                                  "learningObjective": "Compreender o processo iterativo de construção da tabela pi e identificar os backtracks.",
                                  "commonMistakes": [
                                    "Confundir prefixo próprio com prefixo total",
                                    "Não resetar j corretamente no while",
                                    "Contar iterações incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Complexidade do Pré-processamento",
                                  "subSteps": [
                                    "Observe que o loop principal roda m vezes (para i de 1 a m-1).",
                                    "Analise o inner while: cada execução diminui j, e j nunca excede i, totalizando no máximo m decrementos.",
                                    "Prove por amortização: total de backtracks ≤ m, pois cada posição contribui no máximo 1 decremento extra.",
                                    "Conclua que comparações totais são O(m), pois cada iteração faz O(1) trabalho amortizado.",
                                    "Formalize: T_pre = O(m)."
                                  ],
                                  "verification": "Escreva uma prova curta mostrando que o número de execuções do while é ≤ m.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Folha para prova formal",
                                    "Pseudocódigo do KMP",
                                    "Referência: CLRS ou similar"
                                  ],
                                  "tips": "Pense em 'cada caractere é processado uma vez, com backtracks compensados'.",
                                  "learningObjective": "Provar que construção da pi é linear O(m) via análise amortizada.",
                                  "commonMistakes": [
                                    "Assumir O(m^2) por causa do while",
                                    "Ignorar que j diminui monotonicamente",
                                    "Confundir com worst-case por iteração"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Complexidade da Fase de Busca",
                                  "subSteps": [
                                    "Simule a busca: i para texto (0 a n-1), q para estado no autômato (0 a m).",
                                    "Trace shifts: enquanto q>0 e T[i] != P[q], q = pi[q-1]; se match, q++.",
                                    "Conte comparações: cada mismatch ou match avança i sempre, backtracks em q.",
                                    "Amortize: total matches + mismatches ≤ n + m, pois q aumenta ≤ m vezes no total.",
                                    "Conclua T_search = O(n + m)."
                                  ],
                                  "verification": "Simule busca em T='AABAACAABAABA' com P='AABAACAAB', contando ≤ 13 comparações para n=13,m=9.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Exemplo de texto longo",
                                    "Tabela pi pré-computada",
                                    "Planilha para contar operações"
                                  ],
                                  "tips": "Note que i sempre incrementa, q varia mas bounded por m.",
                                  "learningObjective": "Demonstrar linearidade da busca via contagem precisa de transições de estado.",
                                  "commonMistakes": [
                                    "Contar shifts como O(nm)",
                                    "Esquecer amortização de q",
                                    "Não distinguir matches de mismatches"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Busca Ingênua e Formalizar Prova Completa",
                                  "subSteps": [
                                    "Revise busca ingênua: para cada posição s em 0..n-m, compare P com T[s..s+m-1], O((n-m+1)*m) = O(nm).",
                                    "Compare worst-case: ingênua pode fazer ~nm/2 comparações (padrão 'AAAA...A' em texto similar).",
                                    "Some complexidades: KMP total O(m + n) vs O(nm), ganho quando m<<n ou padrões ruins.",
                                    "Escreva prova unificada: pré O(m) + busca O(n+m) = O(m+n).",
                                    "Discuta cenários: KMP sempre bom, ingênua simples para m pequeno."
                                  ],
                                  "verification": "Redija um parágrafo provando O(m+n) e um exemplo numérico de superioridade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigos lado a lado",
                                    "Exemplos numéricos de tempos",
                                    "Gráfico assintótico"
                                  ],
                                  "tips": "Use notação Θ para tight bound se possível, mas O basta.",
                                  "learningObjective": "Contrastar KMP com ingênua, solidificando superioridade assintótica.",
                                  "commonMistakes": [
                                    "Dizer KMP O(n) ignorando m",
                                    "Exemplos onde ingênua é pior que nm",
                                    "Confundir average com worst-case"
                                  ]
                                }
                              ],
                              "practicalExample": "Padrão P='AABAACAAB' (m=9), Texto T='AABAACAABAABA' (n=13). Construa pi=[0,1,0,1,2,0,1,2,3]. Busca: encontra em posição 4, total comparações ~12 < nm=117, ilustrando eficiência.",
                              "finalVerifications": [
                                "Construir pi corretamente para qualquer padrão de até 20 chars.",
                                "Simular busca contando exatamente número de comparações.",
                                "Provar O(m) para pi e O(n+m) para busca verbalmente.",
                                "Identificar worst-case para ingênua (ex: todos 'A's).",
                                "Calcular speedup relativo: O(nm / (n+m)) para n>>m.",
                                "Explicar amortização sem hesitação."
                              ],
                              "assessmentCriteria": [
                                "Exatidão na prova de linearidade (amortização correta).",
                                "Contagem precisa de operações em simulações.",
                                "Uso apropriado de notação Big-O/Θ.",
                                "Comparação clara e quantitativa com ingênua.",
                                "Identificação de bordes (m=1, m=n, mismatches totais).",
                                "Clareza na explicação oral/escrita."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Assintótica e Provas por Amortização.",
                                "Engenharia de Software: Otimização e Profiling de Algoritmos.",
                                "Bioinformática: Pattern Matching em Sequências Genéticas.",
                                "Processamento de Sinais: Detecção de Padrões em Strings.",
                                "Teoria da Computação: Autômatos Finitos e Aho-Corasick."
                              ],
                              "realWorldApplication": "KMP otimiza buscas em editores como VS Code (find/replace em arquivos grandes), compiladores (análise léxica), bioinformática (BLAST para DNA) e ferramentas de grep Unix, reduzindo tempo de nm para linear em terabytes de dados."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.2.3"
                            ]
                          },
                          {
                            "id": "10.1.5.1.3.4",
                            "name": "Comparar KMP com outros algoritmos de busca",
                            "description": "Discutir vantagens do KMP sobre busca exaustiva e Boyer-Moore, citando referências como Cormen et al., em cenários de strings longas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Fundamentos dos Algoritmos de Busca",
                                  "subSteps": [
                                    "Estude o funcionamento da busca exaustiva: compare o padrão com cada posição do texto, reiniciando em mismatches.",
                                    "Revise o Algoritmo KMP: construção da tabela de falha (prefix table) e uso para saltos eficientes.",
                                    "Analise o Boyer-Moore: regras de salto para trás (bad character e good suffix) baseadas em heurísticas.",
                                    "Implemente pseudocódigos simples para cada algoritmo em um editor de texto.",
                                    "Teste cada um com strings curtas para observar o comportamento básico."
                                  ],
                                  "verification": "Liste as diferenças chave nos pseudocódigos e execute testes manuais em papel com strings de exemplo.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Pseudocódigos de Cormen et al. (CLRS, Capítulo 32)",
                                    "Editor de texto ou Jupyter Notebook",
                                    "Strings de teste: texto='ABABDABACDABABCABAB', padrão='ABABCABAB'"
                                  ],
                                  "tips": "Comece com strings pequenas para visualizar mismatches antes de escalar.",
                                  "learningObjective": "Compreender os mecanismos internos de cada algoritmo para basear comparações precisas.",
                                  "commonMistakes": [
                                    "Confundir tabela de prefixo do KMP com shifts do Boyer-Moore",
                                    "Ignorar pré-processamento no KMP e Boyer-Moore"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Complexidades Temporais e Espaciais",
                                  "subSteps": [
                                    "Calcule a complexidade da busca exaustiva: O((n-m+1)*m) no pior caso.",
                                    "Detalhe KMP: O(n + m) pré-processamento e busca linear.",
                                    "Examine Boyer-Moore: O(n/m) médio, mas O(n*m) pior caso; destaque heurísticas.",
                                    "Compare espaços: KMP usa O(m), Boyer-Moore O(m), exaustiva O(1).",
                                    "Crie uma tabela comparativa em uma planilha."
                                  ],
                                  "verification": "Preencha e valide a tabela de complexidades com exemplos numéricos (n=10^6, m=100).",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "CLRS (Cormen et al., seções sobre string matching)",
                                    "Planilha Google Sheets ou Excel",
                                    "Calculadora para cenários grandes"
                                  ],
                                  "tips": "Use notação Big-O e casos médio/pior/melhor para cada.",
                                  "learningObjective": "Quantificar eficiência para embasar discussões sobre vantagens em strings longas.",
                                  "commonMistakes": [
                                    "Esquecer pré-processamento no tempo total do KMP",
                                    "Superestimar Boyer-Moore como sempre linear"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Desempenho em Cenários Específicos",
                                  "subSteps": [
                                    "Simule strings longas (n>>m) com padrões repetitivos para exaustiva vs KMP.",
                                    "Teste padrões com muitos mismatches para Boyer-Moore.",
                                    "Meça tempos em código real: implemente e rode com n=1M chars.",
                                    "Identifique cenários onde KMP brilha: textos genéticos ou logs longos.",
                                    "Registre ratios de performance em uma tabela."
                                  ],
                                  "verification": "Gere output de tempos de execução e compare com predições teóricas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Python ou C++ com bibliotecas de timing (timeit)",
                                    "Datasets: DNA sequence ou livro texto longo",
                                    "CLRS exemplos"
                                  ],
                                  "tips": "Use profilers para medir shifts reais em KMP vs backtracks em Boyer-Moore.",
                                  "learningObjective": "Aplicar teoria a prática, destacando superioridade do KMP em strings longas sem heurísticas ruins.",
                                  "commonMistakes": [
                                    "Testar só casos favoráveis ao Boyer-Moore",
                                    "Ignorar overhead de pré-processamento em strings curtas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Vantagens, Desvantagens e Referências",
                                  "subSteps": [
                                    "Liste vantagens KMP: previsível O(n+m), bom para worst-case.",
                                    "Compare com exaustiva: KMP evita reescaneios.",
                                    "Vs Boyer-Moore: KMP mais estável, menos dependente de alfabeto.",
                                    "Cite CLRS (Cormen et al., 2009) e outros papers.",
                                    "Escreva um resumo comparativo de 300 palavras."
                                  ],
                                  "verification": "Revise o resumo com um peer ou checklist de pontos chave citados.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "CLRS livro ou PDF",
                                    "Papers: 'Fast Pattern Matching' de Boyer-Moore (1977)",
                                    "Notas anteriores"
                                  ],
                                  "tips": "Estruture como prós/contras por algoritmo em cenários longos.",
                                  "learningObjective": "Sintetizar conhecimento com referências acadêmicas para discussões robustas.",
                                  "commonMistakes": [
                                    "Não citar fontes específicas",
                                    "Generalizar Boyer-Moore como sempre melhor"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um motor de busca de logs de servidor (string de 10MB), procure 'ERROR: timeout' usando KMP (rápido e previsível) vs exaustiva (lenta em falhas repetidas) vs Boyer-Moore (bom se padrão comum, mas piora em padrões raros). Meça tempo: KMP ~0.1s, exaustiva >10s.",
                              "finalVerifications": [
                                "Explicar verbalmente por que KMP é O(n+m) worst-case.",
                                "Identificar cenário onde Boyer-Moore falha em strings longas.",
                                "Citar página exata de CLRS sobre KMP.",
                                "Comparar tempos simulados em strings n=1M.",
                                "Listar 3 vantagens KMP sobre exaustiva.",
                                "Discutir trade-offs espaciais."
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise de complexidades (100% correto).",
                                "Uso de evidências empíricas de testes reais.",
                                "Referências acadêmicas corretas e contextualizadas.",
                                "Identificação clara de cenários ótimos para cada algoritmo.",
                                "Resumo comparativo lógico e conciso.",
                                "Ausência de erros conceituais em mecanismos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e recorrências (Big-O).",
                                "Ciência da Computação: Estruturas de dados (tabelas de prefixo como automatos).",
                                "Engenharia de Software: Otimização de performance em sistemas reais.",
                                "Bioinformática: Busca em sequências genéticas longas."
                              ],
                              "realWorldApplication": "Desenvolvimento de editores de texto como VS Code (busca rápida em arquivos grandes), ferramentas de grep avançadas em Unix, ou matching de padrões em bioinformática para alinhamento de DNA, onde strings longas são comuns e worst-case predictability é crucial."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.1.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.2",
                    "name": "Algoritmo Rabin-Karp",
                    "description": "Método probabilístico de busca de padrões baseado em hashing rolante para detecção rápida de substrings.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.2.1",
                        "name": "Fundamentos de Hashing para Strings",
                        "description": "Conceitos básicos de funções hash aplicadas a cadeias de caracteres, incluindo escolha de parâmetros para minimizar colisões em buscas de padrões.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.1.1",
                            "name": "Escolha de base e módulo primo",
                            "description": "Selecionar uma base numérica (como 256 para ASCII) e um módulo primo grande (ex: 10^9+7) para computar hashes polinomiais de strings e reduzir probabilidade de colisões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Papel da Base e Módulo no Hashing Polinomial",
                                  "subSteps": [
                                    "Estude a fórmula do hash polinomial: h(s) = s[0]*b^{n-1} + s[1]*b^{n-2} + ... + s[n-1]*b^0 mod p, onde b é a base e p o módulo.",
                                    "Analise por que a base representa o 'alfabeto' da string (ex: 256 para ASCII).",
                                    "Explique como o módulo primo reduz colisões ao distribuir hashes uniformemente.",
                                    "Discuta o risco de overflow sem módulo e como o primo evita ciclos ruins.",
                                    "Compare com hashing sem módulo."
                                  ],
                                  "verification": "Você pode derivar a fórmula do hash e explicar o impacto de b e p em colisões com um exemplo simples?",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Folha de papel e caneta",
                                    "Tabela ASCII (online ou impressa)",
                                    "Calculadora modular básica"
                                  ],
                                  "tips": [
                                    "Visualize a string como um número em base b.",
                                    "Lembre-se: módulo primo é chave para propriedades uniformes."
                                  ],
                                  "learningObjective": "Dominar os fundamentos matemáticos da base e módulo em hashes polinomiais.",
                                  "commonMistakes": [
                                    "Confundir base com tamanho da string.",
                                    "Ignorar que módulo deve ser primo para minimizar colisões."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar a Base Numérica Adequada",
                                  "subSteps": [
                                    "Identifique o tamanho do alfabeto da string (ex: 256 para ASCII, 26 para minúsculas).",
                                    "Escolha base b > tamanho do alfabeto (tipicamente b = tamanho +1 ou potência de 2 próxima).",
                                    "Justifique: b deve ser maior para representar todos os caracteres unicamente.",
                                    "Teste com exemplo: para DNA (A,C,G,T), use b=5.",
                                    "Evite bases muito grandes para prevenir overflow prematuro."
                                  ],
                                  "verification": "Calcule hashes para duas strings diferentes com a base escolhida e confirme distinção sem colisão.",
                                  "estimatedTime": "15-25 minutos",
                                  "materials": [
                                    "Lista de caracteres possíveis do domínio",
                                    "Editor de texto para strings de teste",
                                    "Python ou calculadora para potências"
                                  ],
                                  "tips": [
                                    "Use base=256 para texto padrão; ajuste para domínios específicos.",
                                    "Prefira potências de 2 para eficiência em hardware."
                                  ],
                                  "learningObjective": "Escolher base otimizada para o alfabeto, minimizando ambiguidades.",
                                  "commonMistakes": [
                                    "Escolher b menor ou igual ao alfabeto (causa colisões garantidas).",
                                    "Usar base=10 para strings não-decimais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Selecionar um Módulo Primo Grande",
                                  "subSteps": [
                                    "Entenda critérios: primo grande ( > 10^9), evita ciclos e distribui bem.",
                                    "Exemplos comuns: 10^9+7 (1000000007), 10^9+9 (1000000009), 2^64 para unsigned long long.",
                                    "Verifique primalidade (use testes Miller-Rabin ou listas confiáveis).",
                                    "Calcule tamanho: módulo >> n * max_char * b^{n-1} para evitar wrap-around excessivo.",
                                    "Teste com hash de strings curtas."
                                  ],
                                  "verification": "Confirme que o módulo escolhido é primo e compute hash de 'aa' vs 'bb' sem colisão.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Lista de primos grandes (Wikipedia ou OEIS)",
                                    "Ferramenta de teste de primalidade online (ex: Wolfram Alpha)",
                                    "Computador com Python"
                                  ],
                                  "tips": [
                                    "Sempre use módulo > 2^{32} para strings longas.",
                                    "Combine dois módulos para double hashing se necessário."
                                  ],
                                  "learningObjective": "Selecionar módulo primo que maximize uniformidade e minimize colisões.",
                                  "commonMistakes": [
                                    "Usar números compostos como 10^9 (colisões altas).",
                                    "Escolher módulo muito pequeno (wrap-around precoce)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar a Escolha e Testar em Hashes",
                                  "subSteps": [
                                    "Implemente função de hash com base e módulo escolhidos em pseudocódigo ou código.",
                                    "Compute hashes para 10 strings aleatórias e cheque colisões (deve ser ~0).",
                                    "Compare com rolling hash para substring.",
                                    "Ajuste se colisões > 1/10^6 esperadas.",
                                    "Documente escolhas com justificativas."
                                  ],
                                  "verification": "Gere relatório com 5 hashes sem colisões e probabilidade estimada < 10^{-9}.",
                                  "estimatedTime": "25-40 minutos",
                                  "materials": [
                                    "Ambiente de programação (Python, C++)",
                                    "Strings de teste (100+ chars)",
                                    "Biblioteca de hashing para benchmark"
                                  ],
                                  "tips": [
                                    "Use 64-bit integers; fallback para BigInt se necessário.",
                                    "Monitore tempo de computação."
                                  ],
                                  "learningObjective": "Validar empiricamente a escolha para Rabin-Karp.",
                                  "commonMistakes": [
                                    "Não testar com strings semelhantes (ex: 'abc' vs 'abd').",
                                    "Ignorar overhead computacional de potências grandes."
                                  ]
                                }
                              ],
                              "practicalExample": "Para strings ASCII em busca Rabin-Karp: base=256 (cobre 0-255), módulo=1000000007. Hash de 'abc': ((97*256^2 + 98*256 + 99) % 1000000007) = 1694849291. Para 'abd': diferente, reduz colisão.",
                              "finalVerifications": [
                                "Explicar fórmula hash com base e módulo.",
                                "Justificar base > |alfabeto|.",
                                "Provar módulo primo e tamanho adequado.",
                                "Calcular hash manual de string curta sem erro.",
                                "Estimar probabilidade de colisão para n=100.",
                                "Identificar quando double hashing é necessário."
                              ],
                              "assessmentCriteria": [
                                "Correção matemática na escolha (100%).",
                                "Justificativa clara para redução de colisões (detalhada).",
                                "Exemplos computados precisos.",
                                "Testes empíricos mostram baixa colisão (<0.001%).",
                                "Eficiência computacional considerada.",
                                "Documentação completa e organizada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e teoria dos números (primalidade).",
                                "Criptografia: Funções hash seguras e colisões.",
                                "Estatística: Distribuição uniforme de hashes.",
                                "Ciência da Computação: Algoritmos de string matching.",
                                "Física/Engenharia: Codificação de sinais (análoga a bases)."
                              ],
                              "realWorldApplication": "Em motores de busca como Google (Rabin-Karp para indexação rápida), detecção de plágio em documentos, compiladores para deduplicação de código, e blockchain para hashing de transações eficientes em strings."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.2",
                            "name": "Cálculo do hash do padrão",
                            "description": "Implementar o cálculo do valor hash para o padrão P de comprimento m usando fórmula polinomial: hash(P) = (P[0]*B^{m-1} + P[1]*B^{m-2} + ... + P[m-1]) mod Q.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes da fórmula de hash polinomial",
                                  "subSteps": [
                                    "Identifique o padrão P como uma string de comprimento m.",
                                    "Defina a base B (tipicamente um primo maior que o alfabeto, ex: 101 ou 256).",
                                    "Escolha o módulo Q como um número primo grande (ex: 10^9+7) para evitar overflow.",
                                    "Revise a fórmula: hash(P) = Σ (P[i] * B^(m-1-i)) mod Q para i de 0 a m-1."
                                  ],
                                  "verification": "Você pode explicar verbalmente ou por escrito cada componente (P, m, B, Q) e a fórmula.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Documentação sobre hashing (opcional)"
                                  ],
                                  "tips": "Escolha B próximo ao tamanho do alfabeto para eficiência; Q deve ser primo para reduzir colisões.",
                                  "learningObjective": "Entender os parâmetros e a estrutura matemática da fórmula de hash polinomial.",
                                  "commonMistakes": "Confundir o expoente (deve decrescer da esquerda para direita); escolher B ou Q inadequados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Converter o padrão P em array de valores numéricos",
                                  "subSteps": [
                                    "Obtenha o comprimento m = len(P).",
                                    "Para cada caractere P[i], converta para valor numérico (ex: ord(P[i]) em Python para ASCII).",
                                    "Armazene em um array numérico nums[0..m-1].",
                                    "Verifique se todos os valores estão no intervalo esperado (ex: 0-255 para ASCII)."
                                  ],
                                  "verification": "Crie um array numérico correto para um exemplo dado, como P='ABC' → [65,66,67].",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código ou calculadora",
                                    "Tabela ASCII"
                                  ],
                                  "tips": "Use funções built-in como ord() em linguagens de programação para automação.",
                                  "learningObjective": "Mapear caracteres de string para representação numérica adequada para cálculos.",
                                  "commonMistakes": "Usar índices errados (0-based); esquecer de tratar caracteres especiais ou maiúsculas/minúsculas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular as potências da base B",
                                  "subSteps": [
                                    "Compute B^(m-1), B^(m-2), ..., B^0.",
                                    "Use multiplicação iterativa para eficiência: comece com pow = 1 para B^0, multiplique por B ao contrário.",
                                    "Armazene em um array powers[0..m-1] onde powers[i] = B^(m-1-i).",
                                    "Teste com m pequeno para validar (ex: m=3, B=10 → [100,10,1])."
                                  ],
                                  "verification": "Liste corretamente as potências para m=4, B=2: [8,4,2,1].",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou código simples",
                                    "Papel para cálculos manuais"
                                  ],
                                  "tips": "Evite pow() recursiva para grandes expoentes; use loop from right to left.",
                                  "learningObjective": "Dominar o cálculo eficiente de potências decrescentes para a soma polinomial.",
                                  "commonMistakes": "Calcular potências crescentes em vez de decrescentes; overflow sem módulo intermediário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Realizar a soma polinomial e aplicar o módulo Q",
                                  "subSteps": [
                                    "Inicie soma = 0.",
                                    "Para cada i de 0 a m-1: soma += nums[i] * powers[i].",
                                    "Após a soma total, compute hash = soma % Q.",
                                    "Otimize aplicando % Q em cada adição para evitar overflow."
                                  ],
                                  "verification": "Implemente e execute o cálculo completo para P='AB', B=256, Q=1000000007, obtendo hash correto.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (Python recomendado)",
                                    "Calculadora grande"
                                  ],
                                  "tips": "Sempre aplique módulo após cada multiplicação/adção para números grandes.",
                                  "learningObjective": "Implementar o cálculo final do hash com prevenção de overflow.",
                                  "commonMistakes": "Esquecer o módulo final; multiplicar pelos expoentes errados; overflow em linguagens sem bigints."
                                }
                              ],
                              "practicalExample": "Para P='ABC', m=3, B=101, Q=10007: nums=[65,66,67], powers=[101^2=10201,101,1]. hash=(65*10201 + 66*101 + 67*1) % 10007 = (663065 + 6666 + 67) % 10007 = 669798 % 10007 = 6691.",
                              "finalVerifications": [
                                "Calcule manualmente o hash para P='AB' e compare com código.",
                                "Implemente função em Python e teste com 5 padrões aleatórios.",
                                "Verifique se hash é invariante a rotação com rolling hash simples.",
                                "Confirme ausência de overflow para m=10 com Q grande.",
                                "Compare hash de padrões idênticos (deve ser igual)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na conversão string → nums (100% match).",
                                "Potências calculadas corretamente sem erros aritméticos.",
                                "Soma polinomial exata antes do mod.",
                                "Hash final correto e consistente com implementações padrão.",
                                "Eficiência: tempo O(m) sem loops desnecessários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação polinomial de números e aritmética modular.",
                                "Criptografia: Conceitos básicos de funções hash e rolling hashes.",
                                "Algoritmos: Pré-processamento em busca de padrões (Rabin-Karp).",
                                "Programação: Manipulação de strings e big integers.",
                                "Estatística: Redução de colisões via módulo primo."
                              ],
                              "realWorldApplication": "Essencial no algoritmo Rabin-Karp para busca rápida de substrings em textos grandes, usado em editores de texto (find/replace), compiladores (detecção de duplicatas), bioinformática (busca de sequências genéticas) e motores de busca."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.1.3",
                            "name": "Cálculo do hash inicial da janela do texto",
                            "description": "Calcular o hash da primeira janela de tamanho m no texto T, aplicando a mesma fórmula polinomial para alinhar com o hash do padrão.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Configurar parâmetros do algoritmo e identificar a janela inicial",
                                  "subSteps": [
                                    "Defina o tamanho da janela m como o comprimento do padrão P.",
                                    "Identifique a substring inicial do texto T de tamanho m (T[0] a T[m-1]).",
                                    "Escolha a base b (ex: 256 para ASCII) e um primo grande q para o módulo.",
                                    "Anote todos os valores: T, P, m, b, q.",
                                    "Verifique se len(T) >= m."
                                  ],
                                  "verification": "Confirme que a janela inicial está corretamente extraída e parâmetros anotados sem erros.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta, editor de texto ou IDE para strings de exemplo.",
                                  "tips": "Use strings curtas inicialmente para evitar erros de digitação.",
                                  "learningObjective": "Entender a configuração inicial necessária para o hashing no Rabin-Karp.",
                                  "commonMistakes": "Confundir m com len(T); escolher q muito pequeno que cause colisões frequentes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Mapear caracteres da janela inicial para valores numéricos",
                                  "subSteps": [
                                    "Atribua um valor numérico único a cada caractere (ex: ord(c) para ASCII ou 'a'=0, 'b'=1).",
                                    "Liste os caracteres da janela T[0..m-1] com seus valores numéricos correspondentes.",
                                    "Crie uma sequência de números: num[0] = valor(T[0]), num[1] = valor(T[1]), ..., num[m-1] = valor(T[m-1]).",
                                    "Verifique a consistência do mapeamento com o usado no padrão P.",
                                    "Anote a sequência numérica em uma tabela."
                                  ],
                                  "verification": "A sequência numérica corresponde exatamente aos caracteres da janela sem duplicatas erradas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela de mapeamento de caracteres (ex: tabela ASCII), calculadora.",
                                  "tips": "Mantenha o mesmo mapeamento para P e T para garantir compatibilidade.",
                                  "learningObjective": "Converter strings em representações numéricas para cálculos hash.",
                                  "commonMistakes": "Usar mapeamento inconsistente entre P e T; ignorar caracteres maiúsculos/minúsculos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o valor polinomial da janela usando a fórmula de hashing",
                                  "subSteps": [
                                    "Calcule as potências de b: b^{m-1}, b^{m-2}, ..., b^0.",
                                    "Multiplique cada num[i] por b^{m-1-i}.",
                                    "Some todos os produtos: hash_val = num[0]*b^{m-1} + num[1]*b^{m-2} + ... + num[m-1]*b^0.",
                                    "Use expansão passo a passo para números grandes.",
                                    "Anote o hash_val intermediário antes do módulo."
                                  ],
                                  "verification": "O hash_val polinomial é calculado corretamente comparando com cálculo manual simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Calculadora científica ou Python para potências grandes, papel para cálculos manuais.",
                                  "tips": "Calcule potências de b de forma incremental para eficiência.",
                                  "learningObjective": "Aplicar a fórmula polinomial de rolling hash à janela inicial.",
                                  "commonMistakes": "Erro nos expoentes decrescentes; overflow em cálculos sem módulo intermediário."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o módulo q e validar o hash inicial",
                                  "subSteps": [
                                    "Compute hash_inicial = hash_val mod q.",
                                    "Calcule o hash do padrão P usando a mesma fórmula para comparação.",
                                    "Verifique se hash_inicial == hash_P (para match inicial).",
                                    "Teste com um exemplo pequeno para validar.",
                                    "Documente o resultado final."
                                  ],
                                  "verification": "Hashes coincidem quando há match inicial; cálculo mod q é correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora modular, código Python opcional para verificação.",
                                  "tips": "Use q primo grande (~10^9+7) para minimizar colisões.",
                                  "learningObjective": "Finalizar o hash modular e preparar para sliding window.",
                                  "commonMistakes": "Esquecer o módulo levando a números gigantes; erro aritmético no mod."
                                }
                              ],
                              "practicalExample": "Exemplo: P='ab' (m=2), T='abab', b=10, q=11, mapeamento 'a'=0, 'b'=1. Janela inicial T[0:2]='ab' → nums=[0,1]. hash_val = 0*10^1 + 1*10^0 = 1. hash_inicial = 1 mod 11 = 1. Hash P = 1, match!",
                              "finalVerifications": [
                                "Hash inicial calculado numericamente correto sem erros aritméticos.",
                                "Fórmula polinomial aplicada com expoentes decrescentes corretos.",
                                "Módulo q aplicado resultando em valor entre 0 e q-1.",
                                "Comparação com hash do padrão realizada.",
                                "Exemplo prático resolvido com match ou mismatch correto.",
                                "Preparado para cálculo da próxima janela."
                              ],
                              "assessmentCriteria": [
                                "Precisão no mapeamento caractere-numérico (100% correto).",
                                "Cálculo polinomial exato, incluindo potências.",
                                "Aplicação correta do módulo q.",
                                "Identificação correta de match inicial.",
                                "Documentação clara de todos os passos intermediários.",
                                "Tempo de execução dentro do estimado com compreensão demonstrada."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e polinômios.",
                                "Criptografia: Conceitos básicos de funções hash.",
                                "Algoritmos: Preparação para rolling hash e eficiência O(n+m).",
                                "Programação: Implementação em linguagens como Python ou C++."
                              ],
                              "realWorldApplication": "Essencial no algoritmo Rabin-Karp para busca eficiente de padrões em textos grandes, usado em editores de texto (busca/substituição), detecção de plágio, bioinformática (busca de sequências genéticas) e motores de busca."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.2",
                        "name": "Hashing Rolante (Rolling Hash)",
                        "description": "Técnica para atualizar eficientemente o hash de janelas deslizantes no texto, permitindo buscas em tempo linear médio.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.2.1",
                            "name": "Pré-computação de potências da base",
                            "description": "Calcular e armazenar B^{m} mod Q e B^{m-1} mod Q para facilitar atualizações rápidas no rolling hash.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Necessidade de Pré-computação no Rolling Hash",
                                  "subSteps": [
                                    "Revise a fórmula de atualização do rolling hash: h_{i+1} = (h_i - s[i] * B^{m-1}) * B + s[i+m] mod Q",
                                    "Identifique que B^{m-1} mod Q é usado para subtrair o caractere que sai da janela",
                                    "Explique por que calcular potências repetidamente seria ineficiente (O(m) por janela)",
                                    "Note que B^m mod Q pode ser usado para hash inicial ou verificações",
                                    "Discuta benefícios: pré-computação torna cada update O(1)"
                                  ],
                                  "verification": "Escreva a fórmula de update e destaque o termo B^{m-1} mod Q em um papel ou notebook",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e caneta ou editor de texto, documentação do Rabin-Karp",
                                  "tips": "Desenhe uma janela deslizante de tamanho m sobre a string para visualizar",
                                  "learningObjective": "Entender o papel das potências pré-computadas na eficiência do rolling hash",
                                  "commonMistakes": "Confundir B^{m-1} com B^m; ignorar overflow sem mod Q"
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Exponenciação Modular Rápida",
                                  "subSteps": [
                                    "Implemente a função pow(base, exp, mod) usando método binário (quadrado e multiplicar)",
                                    "Inicie com result = 1, enquanto exp > 0: se exp ímpar, result = (result * base) % mod; base = (base * base) % mod; exp //= 2",
                                    "Teste com valores pequenos: pow(2, 3, 100) deve retornar 8",
                                    "Otimize para grandes expoentes evitando loops O(exp)",
                                    "Adapte para calcular múltiplas potências se necessário"
                                  ],
                                  "verification": "Execute pow(B, m-1, Q) e pow(B, m, Q) com B=31, m=3, Q=10007; resultados: 961 e 29791",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código (Python ou C++), calculadora para verificação manual",
                                  "tips": "Use tipos de dados de 64-bit ou BigInt para evitar overflow durante multiplicações",
                                  "learningObjective": "Dominar exponenciação modular em O(log exp) para potências eficientes",
                                  "commonMistakes": "Esquecer % mod após cada multiplicação; usar pow built-in sem mod"
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular e Armazenar as Potências Específicas",
                                  "subSteps": [
                                    "Defina variáveis: power_m = pow(B, m, Q); power_m1 = pow(B, m-1, Q)",
                                    "Para m=1, trate caso especial: power_m1 = 1",
                                    "Armazene em array ou variáveis globais para acesso rápido no loop de hashing",
                                    "Integre no código do Rabin-Karp: calcule antes do loop principal",
                                    "Verifique modularidade: assegure 0 <= power < Q"
                                  ],
                                  "verification": "Imprima power_m e power_m1; confira manualmente para B=10, m=2, Q=13: 10^2=100%13=9, 10^1=10",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Código-fonte do Rabin-Karp parcial, debugger",
                                  "tips": "Pré-compute uma tabela de potências B^0 a B^m se m variar",
                                  "learningObjective": "Calcular e persistir B^m mod Q e B^{m-1} mod Q corretamente",
                                  "commonMistakes": "Calcular B^{m+1} por engano; não tratar m=0 ou m=1"
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar e Testar a Pré-computação no Rolling Hash",
                                  "subSteps": [
                                    "Atualize hash inicial: h = sum(s[i] * B^{m-1-i}) mod Q usando power_m",
                                    "No loop: h = (h - s[i] * power_m1 + Q) * B + s[i+m] ) % Q",
                                    "Teste com string completa: compare hashes rolantes manualmente",
                                    "Meça tempo: compare com versão sem pré-computação",
                                    "Debug erros de hash mismatch"
                                  ],
                                  "verification": "Execute em string 'abcab' com pattern 'ab', m=2; hashes devem coincidir em posições corretas",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código completo Rabin-Karp, dataset de teste (strings aleatórias)",
                                  "tips": "Adicione +Q antes de multiplicar para evitar negativos",
                                  "learningObjective": "Aplicar pré-computação para updates O(1) no rolling hash",
                                  "commonMistakes": "Não adicionar Q ao subtrair (hash negativo); overflow em * B"
                                }
                              ],
                              "practicalExample": "Para string S='aaab', pattern P='aab', m=3, B=31, Q=10007. Pré-compute: B^3 mod Q = 31^3=29791 %10007=961, B^2=961%10007=961. Hash inicial para S[0:3]='aaa': (1*961 + 1*31 + 1*1) %10007. Update para S[1:4]='aab': ((h -1*961 +10007)*31 +2) %10007.",
                              "finalVerifications": [
                                "power_m = B^m mod Q está correto (verifique manualmente com calculadora)",
                                "power_m1 = B^{m-1} mod Q != 0 e < Q",
                                "Update de hash rola sem erros numéricos em 10 janelas",
                                "Tempo de busca é O(n+m) devido a pré-computação",
                                "Hashes coincidem com cálculo naive para substring inicial",
                                "Nenhum overflow ou valor negativo em updates"
                              ],
                              "assessmentCriteria": [
                                "Correção: Potências calculadas precisamente com mod Q",
                                "Eficiência: Exponenciação em O(log m), update O(1)",
                                "Robustez: Trata casos edge (m=1, B=1, Q primo)",
                                "Clareza: Código comentado explicando uso das potências",
                                "Testes: Pelo menos 3 exemplos com matches e mismatches",
                                "Otimização: Sem loops desnecessários nas potências"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e algoritmo de exponenciação rápida",
                                "Ciência da Computação: Otimização de algoritmos e análise de complexidade",
                                "Engenharia de Software: Pré-computação e caching para performance",
                                "Bioinformática: Aplicação em matching de sequências de DNA"
                              ],
                              "realWorldApplication": "Em motores de busca como Google para indexação rápida de textos; detecção de plágio em sistemas educacionais; busca de padrões em genomas (bioinformática) para identificar sequências repetidas em O(n+m) tempo."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.2.2.2",
                            "name": "Atualização do hash para a próxima janela",
                            "description": "Atualizar o hash da janela atual para a próxima removendo o caractere mais antigo (subtrair T[i]*B^{m-1} mod Q) e adicionando o novo (multiplicar por B e somar T[i+m] mod Q).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e calcular a remoção do caractere mais antigo",
                                  "subSteps": [
                                    "Identifique o caractere mais antigo na janela atual (posição i).",
                                    "Mapeie o caractere para seu valor numérico T[i] (ex: 'a'=1, 'b'=2).",
                                    "Calcule B^{m-1} onde m é o tamanho da janela e B é a base.",
                                    "Multiplique T[i] por B^{m-1} para obter o valor a subtrair.",
                                    "Aplique módulo Q na subtração para evitar números negativos."
                                  ],
                                  "verification": "Verifique se hash_temp = (hash_atual - T[i] * B^{m-1}) mod Q é igual ao hash sem o caractere antigo manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta, calculadora, tabela de mapeamento de caracteres.",
                                  "tips": "Pré-calcule todas as potências de B para eficiência.",
                                  "learningObjective": "Dominar o cálculo de remoção do caractere de maior peso na janela deslizante.",
                                  "commonMistakes": "Esquecer o módulo Q após subtração, levando a valores negativos; confundir T[i] com o caractere errado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Multiplicar o hash restante pela base B",
                                  "subSteps": [
                                    "Pegue o hash_temp após remoção do caractere antigo.",
                                    "Multiplique hash_temp por B (a base do polinômio).",
                                    "Garanta que a multiplicação 'desloque' o hash para a nova posição.",
                                    "Aplique módulo Q imediatamente para manter o hash no intervalo [0, Q-1].",
                                    "Confirme que isso simula o 'shift' da janela."
                                  ],
                                  "verification": "Calcule manualmente e compare com hash esperado após shift, sem adicionar novo caractere.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Calculadora modular, pseudocódigo do rolling hash.",
                                  "tips": "Pense na multiplicação por B como mover todos os caracteres uma posição à esquerda no polinômio.",
                                  "learningObjective": "Entender o shift matemático via multiplicação pela base.",
                                  "commonMistakes": "Aplicar módulo Q antes da multiplicação, alterando o valor; usar B^{m} em vez de B."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar o novo caractere à janela",
                                  "subSteps": [
                                    "Identifique o novo caractere T[i+m] na posição seguinte.",
                                    "Mapeie T[i+m] para seu valor numérico.",
                                    "Some o valor numérico de T[i+m] ao hash deslocado.",
                                    "Aplique módulo Q na soma final.",
                                    "Registre o novo hash como hash para a próxima janela."
                                  ],
                                  "verification": "Compare o hash final com cálculo do zero da nova janela para igualdade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Exemplo de string de teste, planilha para cálculos.",
                                  "tips": "O novo caractere sempre vai para a posição de menor peso (unidade).",
                                  "learningObjective": "Implementar a inserção do caractere de menor peso no hash rolante.",
                                  "commonMistakes": "Adicionar T[i+m] multiplicado por B em vez de somar diretamente; índice errado para i+m."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar a atualização completa",
                                  "subSteps": [
                                    "Escreva pseudocódigo ou código para a fórmula completa: h = (h - T[i]*B^{m-1} + T[i+m]) * B mod Q? Não, ordem correta: subtrair, multiplicar B, somar.",
                                    "Teste com uma string pequena (ex: 'abcde', m=3).",
                                    "Execute para múltiplas janelas e compare hashes.",
                                    "Debug erros usando cálculo manual paralelo.",
                                    "Otimize pré-calculando B^{m-1}."
                                  ],
                                  "verification": "Todos os hashes rolantes coincidem com hashes computados independentemente para cada janela.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (Python/JS), string de teste longa.",
                                  "tips": "Use Q primo grande para reduzir colisões.",
                                  "learningObjective": "Integrar remoção, shift e adição em um algoritmo funcional.",
                                  "commonMistakes": "Ordem errada das operações (ex: somar antes de multiplicar); overflow sem módulo."
                                }
                              ],
                              "practicalExample": "Para string T = 'abacaba', m=3, B=31, Q=10^9+7. Janela 1: 'aba' → hash=1*31^2 + 2*31 + 1 = 961+62+1=1024 mod Q. Próxima 'bac': subtrair 1*31^2=961 → 1024-961=63; *31=1953; +3 (c=3)=1956 mod Q. Verifique hash direto de 'bac':2*961+1*31+3=1956.",
                              "finalVerifications": [
                                "Hash atualizado é idêntico ao hash recalculado da nova janela do zero.",
                                "Operações mod Q mantêm valores entre 0 e Q-1.",
                                "Funciona para todas as janelas consecutivas sem erros acumulados.",
                                "Pré-cálculo de B^{m-1} é usado corretamente.",
                                "Nenhum overflow ou valor negativo ocorre.",
                                "Teste com string contendo caracteres repetidos não falha."
                              ],
                              "assessmentCriteria": [
                                "Precisão na fórmula: subtração correta de T[i]*B^{m-1}.",
                                "Ordem exata das operações: subtrair → multiplicar B → somar T[i+m] → mod Q.",
                                "Eficiência: O(1) por janela via pré-cálculo.",
                                "Correção modular em todos os passos.",
                                "Capacidade de debugar com exemplo numérico.",
                                "Implementação em código sem erros lógicos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e polinômios.",
                                "Programação: Otimização de loops e estruturas de dados.",
                                "Ciência de Dados: Processamento eficiente de sequências (ex: genomas).",
                                "Criptografia: Conceitos de hash functions e rolling computations."
                              ],
                              "realWorldApplication": "No algoritmo Rabin-Karp, permite busca de padrões em textos longos (ex: detecção de plágio em documentos, busca de substrings em DNA para bioinformática) em tempo O(n+m) ao invés de O(n*m), usado em editores de texto, motores de busca e ferramentas de segurança."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.2.3",
                            "name": "Implementação do loop de sliding window",
                            "description": "Executar o loop sobre o texto T de posição i=0 a n-m, atualizando o hash rolante e comparando com o hash do padrão em cada iteração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar Variáveis Iniciais para o Sliding Window",
                                  "subSteps": [
                                    "Obter comprimentos: n = len(T), m = len(P)",
                                    "Calcular hash inicial da janela T[0:m] usando função de hash rolante pré-implementada",
                                    "Calcular hash do padrão hash_pattern = hash_rolling(P)",
                                    "Inicializar i = 0 e lista de matches vazia",
                                    "Precomputar potências de base: pow_base = base^(m-1) % mod"
                                  ],
                                  "verification": "Verificar manualmente se hash_window inicial corresponde ao hash calculado diretamente para T[0:m]",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Funções de hash rolante implementadas",
                                    "Exemplo de texto T e padrão P"
                                  ],
                                  "tips": "Use os mesmos parâmetros de base e módulo para hashes do texto e padrão para consistência.",
                                  "learningObjective": "Configurar o estado inicial do loop garantindo hashes comparáveis.",
                                  "commonMistakes": [
                                    "Erro no cálculo de n-m",
                                    "Esquecer precomputar potências de base",
                                    "Inicializar i incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Comparação de Hashes na Posição Atual",
                                  "subSteps": [
                                    "Iniciar loop: for i in range(n - m + 1):",
                                    "Se hash_window == hash_pattern:",
                                    "Verificar colisão comparando T[i:i+m] == P caractere por caractere",
                                    "Se verdadeiro, adicionar i à lista de matches",
                                    "Registrar posição para depuração (print opcional)"
                                  ],
                                  "verification": "Executar iteração i=0 e confirmar detecção de match se aplicável, sem falsos positivos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Strings de teste com matches conhecidos"
                                  ],
                                  "tips": "Sempre inclua verificação de caracteres após match de hash para lidar com colisões.",
                                  "learningObjective": "Detectar potenciais matches usando hashes e validar para precisão.",
                                  "commonMistakes": [
                                    "Pular verificação de colisão",
                                    "Comparar strings sem checar limites",
                                    "Não usar range(n-m+1)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atualizar Hash Rolante para a Próxima Janela",
                                  "subSteps": [
                                    "Remover caractere saindo: hash_window = (hash_window - (T[i] * pow_base) % mod + mod) % mod",
                                    "Rotacionar: hash_window = (hash_window * base) % mod",
                                    "Adicionar caractere entrando: hash_window = (hash_window + T[i + m]) % mod",
                                    "Incrementar i (automático no for loop)",
                                    "Garantir operações modulares para evitar overflow"
                                  ],
                                  "verification": "Após update de i=0 para i=1, verificar se hash_window == hash direto de T[1:1+m]",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Calculadora para validar hashes modulares",
                                    "Exemplos numéricos de hash"
                                  ],
                                  "tips": "Adicione '+ mod' após subtração para manter hash_window não-negativo.",
                                  "learningObjective": "Atualizar eficientemente o hash em O(1) tempo por iteração.",
                                  "commonMistakes": [
                                    "Esquecer % mod após cada operação",
                                    "Índice errado para T[i+m]",
                                    "Não tratar underflow na subtração"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Loop Completo e Testar Funcionalidade",
                                  "subSteps": [
                                    "Combinar inicialização, comparação e update em um loop único",
                                    "Adicionar condição de parada: i <= n - m",
                                    "Retornar ou imprimir lista de matches após loop",
                                    "Testar com casos: match inicial, múltiplos, sem matches",
                                    "Verificar tempo de execução O(n + m)"
                                  ],
                                  "verification": "Executar com T='abcdeabc', P='abc' e confirmar matches em posições 0 e 5.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Casos de teste variados",
                                    "Debugger ou prints intermediários"
                                  ],
                                  "tips": "Use asserts para validar matches em testes unitários.",
                                  "learningObjective": "Implementar e validar o loop de sliding window completo.",
                                  "commonMistakes": [
                                    "Loop infinito por condição errada",
                                    "Perder matches no final",
                                    "Ignorar casos edge como m > n"
                                  ]
                                }
                              ],
                              "practicalExample": "Para T = 'abcdeabc' (n=8), P = 'abc' (m=3), base=101, mod=10^9+7:\n- i=0: hash_window=hash('abc'), match após verify.\n- Update: remove 'a'*101^2, *101, add 'd' → hash('bcd')\n- i=1: no match\n- i=2: hash('cde'), no\n- i=3: hash('dea'), no\n- i=4: hash('eab'), no\n- i=5: hash('abc'), match. Matches: [0,5]",
                              "finalVerifications": [
                                "Loop executa exatamente n-m+1 iterações",
                                "Todos matches reais são detectados sem falsos positivos",
                                "Hashes são atualizados corretamente em cada passo (validado manualmente em 2-3 iterações)",
                                "Função lida com colisões hash via verificação de strings",
                                "Lista de matches contém posições corretas",
                                "Sem erros de overflow ou underflow modular"
                              ],
                              "assessmentCriteria": [
                                "Correção na atualização do hash rolante (O(1) por iteração)",
                                "Detecção precisa de matches com handling de colisões",
                                "Eficiência geral O(n + m) confirmada por testes",
                                "Tratamento de casos edge (m=0, m>n, n=0, todos chars iguais)",
                                "Código limpo com comentários e variáveis bem nomeadas",
                                "Validação numérica de hashes em pelo menos um exemplo completo"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e propriedades de potências",
                                "Criptografia: Conceitos de funções hash e rolling hashes em assinaturas digitais",
                                "Ciência de Dados: Processamento eficiente de sequências em big data",
                                "Biologia Computacional: Busca de padrões em sequências de DNA/RNA"
                              ],
                              "realWorldApplication": "Usado no algoritmo Rabin-Karp para busca rápida de substrings em textos grandes, como detecção de plágio em documentos, matching de padrões genéticos em bioinformática, filtros anti-spam em e-mails e indexação eficiente em motores de busca."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.2.3",
                        "name": "Detecção de Matches e Tratamento de Colisões",
                        "description": "Procedimentos para identificar ocorrências do padrão via hashes iguais e verificar colisões para garantir exatidão.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.2.3.1",
                            "name": "Comparação de hashes e relatório de candidatos",
                            "description": "Quando hash da janela == hash do padrão, adicionar a posição i à lista de candidatos potenciais para verificação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Comparação de Hashes no Rabin-Karp",
                                  "subSteps": [
                                    "Revise o cálculo do hash do padrão (P) e do hash da janela deslizante (T[i..i+m-1]).",
                                    "Identifique o momento exato no loop principal onde a comparação ocorre (para cada posição i de 0 a n-m).",
                                    "Entenda que hashes iguais indicam um match potencial, mas não garantem igualdade de strings devido a colisões.",
                                    "Discuta o papel da lista de candidatos como filtro para verificação exata posterior.",
                                    "Anote diferenças entre hash numérico (mod p) e comparação de strings."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que hashes iguais não implicam match exato, citando exemplo de colisão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo do Rabin-Karp",
                                    "Exemplos de strings com colisões (ex: 'abc' e 'abd')",
                                    "Calculadora para hashes modulares"
                                  ],
                                  "tips": "Sempre use um primo grande para o módulo p para reduzir colisões; visualize hashes como 'impressões digitais'.",
                                  "learningObjective": "Dominar o raciocínio probabilístico por trás da comparação de hashes como heurística eficiente.",
                                  "commonMistakes": [
                                    "Confundir igualdade de hashes com igualdade de strings",
                                    "Ignorar o módulo na comparação",
                                    "Esquecer que i inicia em 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a Condição de Igualdade de Hashes",
                                  "subSteps": [
                                    "No loop for i de 0 a n-m: compare h_window == h_pattern.",
                                    "Use operadores de igualdade exata (==) para inteiros de hash.",
                                    "Registre o valor de i atual antes de qualquer ação.",
                                    "Trate hashes como inteiros de 64 bits ou BigInt para evitar overflow.",
                                    "Teste com depurador para pausar na primeira comparação igual."
                                  ],
                                  "verification": "Execute código com input de teste e confirme que a condição if(h_window == h_pattern) é acionada corretamente em posições esperadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (VS Code/Python)",
                                    "Strings de teste: texto='abcabc', padrão='abc'",
                                    "Debugger integrado"
                                  ],
                                  "tips": "Imprima hashes lado a lado para depuração: print(f'i={i}, h_win={h_window}, h_pat={h_pattern}').",
                                  "learningObjective": "Implementar com precisão a comparação central do algoritmo Rabin-Karp.",
                                  "commonMistakes": [
                                    "Comparar strings diretamente em vez de hashes",
                                    "Erro de índice off-by-one em i",
                                    "Overflow em cálculos de hash sem mod"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Posições Candidatas à Lista de Relatório",
                                  "subSteps": [
                                    "Inicialize lista vazia: candidates = [].",
                                    "Dentro do if(h_window == h_pattern): candidates.append(i).",
                                    "Garanta que append use posição absoluta i (início da janela).",
                                    "Evite duplicatas com set() se necessário, mas liste todos potenciais.",
                                    "Atualize a janela hash para próxima iteração após append."
                                  ],
                                  "verification": "Após execução, inspecione lista candidates e confirme que contém apenas i's onde hashes batem.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código do Step 2 estendido",
                                    "Unit tests para append: assert 0 in candidates para match inicial"
                                  ],
                                  "tips": "Use lista dinâmica para eficiência O(1) append; nomeie como 'candidates_positions' para clareza.",
                                  "learningObjective": "Gerenciar coleção de candidatos potenciais de forma eficiente e correta.",
                                  "commonMistakes": [
                                    "Adicionar i+m em vez de i",
                                    "Append fora do if",
                                    "Não inicializar lista antes do loop"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relatar Lista de Candidatos e Preparar Verificação",
                                  "subSteps": [
                                    "Após o loop principal, imprima ou retorne a lista candidates.",
                                    "Para cada i em candidates, planeje verificação exata: compare T[i:i+m] == P.",
                                    "Calcule taxa de falsos positivos: len(candidates) / (n-m+1).",
                                    "Otimize relatório com formato legível (ex: 'Candidatos em posições: [0, 3]').",
                                    "Teste edge cases: sem matches, todos matches, colisões intencionais."
                                  ],
                                  "verification": "Gere relatório e valide manualmente contra strings originais para 100% recall de matches reais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código completo",
                                    "Casos de teste edge: texto vazio, padrão maior que texto"
                                  ],
                                  "tips": "Relate também número de candidatos para métricas de performance.",
                                  "learningObjective": "Finalizar o pipeline de detecção com relatório acionável para etapa de verificação.",
                                  "commonMistakes": [
                                    "Relatar sem filtrar colisões",
                                    "Índices 1-based em vez de 0-based",
                                    "Esquecer edge cases"
                                  ]
                                }
                              ],
                              "practicalExample": "Texto: 'abcabcabc', Padrão: 'abc' (m=3, n=9). Hashes mod 101: h_pattern=1120. Para i=0: h_window=1120 → candidato 0; i=1: diferente; i=2: diferente; i=3:1120 →3; i=4: diferente; i=5: diferente; i=6:1120→6. Lista: [0,3,6]. Verificação exata confirma matches reais.",
                              "finalVerifications": [
                                "Lista candidates contém exatamente as posições onde hashes coincidem.",
                                "Nenhum i fora de [0, n-m] está na lista.",
                                "Para matches reais, suas posições estão em candidates (recall 100%).",
                                "Código roda sem erros de índice ou overflow.",
                                "Relatório é legível e inclui contagem de candidatos.",
                                "Testes com colisão (ex: mod pequeno) geram candidatos extras corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na comparação == de hashes (sem falsos negativos).",
                                "Correto append de i apenas quando hashes iguais.",
                                "Eficiência: O(n) tempo no loop principal.",
                                "Tratamento robusto de edge cases (n<m, strings vazias).",
                                "Clareza no relatório com posições e contexto.",
                                "Compreensão demonstrada de colisões via exemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aritmética modular e propriedades de hashes polinomiais.",
                                "Probabilidade: Análise de falsos positivos em hashing.",
                                "Ciência de Dados: Pré-filtro em buscas de similaridade (ex: plágio).",
                                "Engenharia de Software: Gerenciamento de listas dinâmicas e depuração.",
                                "Segurança: Conceitos básicos de funções hash em criptografia."
                              ],
                              "realWorldApplication": "Em motores de busca como Google para encontrar substrings em documentos massivos; detecção de plágio em códigos fonte; bioinformática para alinhamento de sequências de DNA; ferramentas anti-vírus para padrões de malware em arquivos."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.2.3"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.2",
                            "name": "Verificação explícita de colisões",
                            "description": "Para cada candidato, comparar caractere por caractere a substring T[i..i+m-1] com P para confirmar match exato e descartar falsos positivos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de colisão e candidatos potenciais",
                                  "subSteps": [
                                    "Revise o algoritmo Rabin-Karp e identifique onde ocorrem colisões de hash.",
                                    "Defina 'candidato' como posição i onde hash(T[i..i+m-1]) == hash(P).",
                                    "Explique por que verificação explícita é necessária para evitar falsos positivos.",
                                    "Analise um exemplo simples de colisão com textos curtos.",
                                    "Liste vantagens da verificação explícita sobre confiança cega em hashes."
                                  ],
                                  "verification": "Escreva um parágrafo explicando colisões com exemplo; confirme com autoavaliação.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Documentação Rabin-Karp, editor de texto, exemplos de strings.",
                                  "tips": "Use diagramas para visualizar posições de hash no texto.",
                                  "learningObjective": "Entender a origem de colisões e o papel da verificação explícita.",
                                  "commonMistakes": "Confundir colisão com mismatch total; ignorar probabilidades baixas de colisão."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar extração da substring candidata",
                                  "subSteps": [
                                    "Para cada posição i candidata, extraia T[i..i+m-1] usando slicing em pseudocódigo ou linguagem escolhida.",
                                    "Verifique o comprimento da substring para garantir que seja igual a m (tamanho de P).",
                                    "Armazene substrings candidatas em uma lista temporária para análise.",
                                    "Teste extração com strings de diferentes tamanhos.",
                                    "Otimize para evitar recálculos desnecessários."
                                  ],
                                  "verification": "Execute código com input de teste e imprima substrings extraídas; compare manualmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "IDE de programação (Python/Java), strings de teste pré-definidas.",
                                  "tips": "Use índices zero-based e off-by-one checks para evitar erros de slicing.",
                                  "learningObjective": "Dominar extração precisa de substrings em textos grandes.",
                                  "commonMistakes": "Erro off-by-one no slicing; extrair além dos limites da string T."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar comparação caractere por caractere",
                                  "subSteps": [
                                    "Para cada substring extraída, inicie loop de 0 a m-1 comparando T[i+j] == P[j].",
                                    "Se qualquer caractere não bater, marque como falso positivo e avance.",
                                    "Se todos baterem, registre i como match confirmado.",
                                    "Implemente em código eficiente (O(m) por candidato).",
                                    "Adicione logging para depuração de mismatches."
                                  ],
                                  "verification": "Teste com casos de colisão real e falso; confirme zero falsos positivos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código do Step 2, casos de teste com colisões conhecidas.",
                                  "tips": "Prefira loops simples a funções built-in para entender o processo.",
                                  "learningObjective": "Implementar verificação exata e eficiente.",
                                  "commonMistakes": "Parar comparação cedo sem registrar; usar == em strings inteiras prematuramente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar verificação ao algoritmo e testar exhaustivamente",
                                  "subSteps": [
                                    "Incorpore a verificação no loop principal do Rabin-Karp após match de hash.",
                                    "Colete estatísticas: número de candidatos, falsos positivos, matches reais.",
                                    "Teste com textos grandes e padrões com alta probabilidade de colisão.",
                                    "Meça tempo de execução antes/depois da verificação.",
                                    "Refatore para modularidade (função separada para verify_collision)."
                                  ],
                                  "verification": "Rode suíte de testes; matches confirmados == esperados, sem falsos positivos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código completo Rabin-Karp, suíte de testes (unit tests).",
                                  "tips": "Use asserts para verificações automáticas em testes.",
                                  "learningObjective": "Integrar verificação de forma robusta e mensurar impacto.",
                                  "commonMistakes": "Esquecer verificação em alguns candidatos; overhead desnecessário em textos pequenos."
                                }
                              ],
                              "practicalExample": "Texto T = 'abracadabra', Padrão P = 'abr'. Hash matches em i=0 ('abr') e i=4 ('aca' - colisão). Verificação: i=0: a==a, b==b, r==r → match. i=4: a==a, c!=b → falso positivo. Matches reais: [0].",
                              "finalVerifications": [
                                "Nenhum falso positivo reportado em testes com colisões induzidas.",
                                "Todos matches reais detectados corretamente.",
                                "Tempo de verificação O(m * k) onde k é número de candidatos.",
                                "Código modular com função verify_explicit_collision(t_sub, p).",
                                "Estatísticas logadas: candidatos processados vs. matches confirmados.",
                                "Testes unitários passam 100%."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% sem falsos positivos/negativos.",
                                "Eficiência: Verificação só em candidatos de hash (não em todas posições).",
                                "Clareza: Código comentado explicando cada comparação.",
                                "Robustez: Lida com bordas (i+m > len(T), m=0).",
                                "Documentação: Exemplo prático no código.",
                                "Otimização: Evita comparações redundantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de números e funções hash modulares.",
                                "Programação: Estruturas de loop e manipulação de strings.",
                                "Ciência da Computação: Análise de complexidade O(n + m + k*m).",
                                "Segurança: Conceitos de hashing em criptografia (ex: detecção de colisões em SHA).",
                                "Engenharia de Software: Testes unitários e depuração."
                              ],
                              "realWorldApplication": "Em ferramentas de busca como grep ou editores (VS Code find), detecção de plágio em documentos, busca de DNA em genômica (sequências com hashes para eficiência), e sistemas de recomendação filtrando duplicatas em bancos de dados textuais."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.5.2.3.3",
                            "name": "Análise de complexidade probabilística",
                            "description": "Explicar tempo médio O(n+m) devido a rolling hash e probabilidade baixa de colisões O(1/Q), com pior caso O((n-m+1)*m) por verificações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Rolling Hash e seu Papel na Eficiência",
                                  "subSteps": [
                                    "Revise o algoritmo Rabin-Karp básico: computação de hash para pattern P e rolling hash para cada substring de T.",
                                    "Explique o cálculo incremental do rolling hash: h[i+1] = (h[i] * base - T[i]*base^{m}) mod Q + T[i+m]*base^0 mod Q.",
                                    "Demonstre com exemplo numérico: T='abcde', P='bcd', base=31, Q=10^9+7.",
                                    "Discuta como comparações de hash em O(1) evitam verificações completas na maioria dos casos.",
                                    "Calcule o número total de operações de hash: O(n+m)."
                                  ],
                                  "verification": "Calcule manualmente os hashes rolling para 5 posições consecutivas em uma string de exemplo e confirme igualdade com P.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e caneta para cálculos modulares",
                                    "Calculadora ou Python para verificação rápida",
                                    "Exemplos de strings: T='abcdeabc', P='bcd'"
                                  ],
                                  "tips": "Use base primo (ex: 31 ou 131) e Q primo grande para boa distribuição de hashes.",
                                  "learningObjective": "Compreender como o rolling hash permite análise em tempo linear esperado.",
                                  "commonMistakes": [
                                    "Esquecer o fator de remoção da janela deslizante (subtrair T[i]*base^m)",
                                    "Usar Q pequeno, levando a muitas colisões em testes",
                                    "Confundir hash forward com backward rolling"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar a Probabilidade de Colisões Falsas",
                                  "subSteps": [
                                    "Defina colisão falsa: hashes iguais mas strings diferentes, P(h(T[i..i+m-1]) = h(P)) ≈ 1/Q.",
                                    "Estime para n-m+1 posições: probabilidade esperada de k colisões é ≈ (n-m+1)/Q.",
                                    "Discuta escolha de Q: > n*m bits para P(colisão) < 1/n.",
                                    "Calcule exemplo: n=10^6, m=100, Q=2^64, P(colisão única) ≈ 10^{-12}.",
                                    "Relacione com birthday paradox: colisões múltiplas raras se Q >> n^2."
                                  ],
                                  "verification": "Para n=10^5, m=50, Q=10^9+7, calcule e explique se probabilidade de colisão é aceitável (<0.01).",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Folha de fórmulas probabilísticas",
                                    "Python ou calculadora para 1/Q * (n-m+1)",
                                    "Referência: 'Introduction to Algorithms' CLRS capítulo 32"
                                  ],
                                  "tips": "Pense em Q como universo de hashes; maior Q = menor P(colisão), mas custo computacional mod Q.",
                                  "learningObjective": "Dominar a modelagem probabilística de colisões como eventos independentes Bernoulli.",
                                  "commonMistakes": [
                                    "Assumir colisões independentes perfeitamente (na verdade, ligeiramente correlacionadas)",
                                    "Ignorar overflow em linguagens sem mod nativo grande",
                                    "Confundir P(colisão falsa) com P(match verdadeiro)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Derivar o Tempo Médio Esperado O(n+m)",
                                  "subSteps": [
                                    "Some custos: pré-processamento O(m+n) para hashes.",
                                    "Para cada das n-m+1 posições: O(1) comparação hash + O(m) verificação com prob p=1/Q.",
                                    "Tempo esperado: O(n+m) + (n-m+1)* (1/Q)*O(m) ≈ O(n+m) pois (n m)/Q << n para Q grande.",
                                    "Formalize: E[T] = O(n) + sum E[verificações_i] = O(n) + (n-m+1)/Q * O(m).",
                                    "Simule numericamente para validar: rode Rabin-Karp em textos aleatórios e meça tempo."
                                  ],
                                  "verification": "Escreva a equação E[T] e prove que é O(n+m) assumindo Q = Ω(n m).",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Código Python do Rabin-Karp",
                                    "Textos gerados aleatoriamente (ex: random strings len 10^4)",
                                    "Timer para medições empíricas"
                                  ],
                                  "tips": "Use double hashing (dois Qs) para reduzir P(colisão) para 1/Q1*Q2 sem custo extra.",
                                  "learningObjective": "Aplicar expectativa linear para análise amortizada probabilística.",
                                  "commonMistakes": [
                                    "Esquecer custo O(m) só em colisões falsas, não em matches verdadeiros",
                                    "Assumir verificação sempre O(1)",
                                    "Ignorar pré-processamento O(m+n)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar o Pior Caso O((n-m+1) m)",
                                  "subSteps": [
                                    "Descreva cenário: texto/padrão com caracteres repetidos (ex: todos 'a's), hashes colidem sempre.",
                                    "Nesse caso, toda posição triggera verificação O(m), total O((n-m+1) m) ≈ O(n m).",
                                    "Compare com KMP/Naive: Rabin-Karp pior que KMP O(n+m) sempre.",
                                    "Mitigações: randomize base/Q, ou fallback para KMP em muitos mismatches.",
                                    "Analise: probabilidade de pior caso é 1/Q^{m-1}, exponencialmente baixa."
                                  ],
                                  "verification": "Construa exemplo onde todos hashes colidem (T='a'*1000, P='a'*3) e conte verificações.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Strings repetitivas para teste",
                                    "Implementação Rabin-Karp com contador de verificações",
                                    "Comparador com Boyer-Moore ou KMP"
                                  ],
                                  "tips": "Em prática, use 64-bit hash sem mod para velocidade, aceitando raros overflows.",
                                  "learningObjective": "Reconhecer trade-offs entre médio/pior caso em algoritmos probabilísticos.",
                                  "commonMistakes": [
                                    "Pensar pior caso comum (é adversarial)",
                                    "Confundir O(n m) com O(n^2), ignorando m fixo",
                                    "Esquecer que matches verdadeiros também custam O(m) mas são raros"
                                  ]
                                }
                              ],
                              "practicalExample": "Text T='abracadabra' (n=11), Pattern P='abr' (m=3), base=101, Q=10^9+7. Compute hashes: h(P)=101^2*1 +101*2 +18. Rolling em T: posição 0 'abr' match hash, verifica chars OK; pos 7 'abr' hash match, verifica OK. Mostre 1 colisão falsa em 'aca' se hashes batessem por azar.",
                              "finalVerifications": [
                                "Explicar verbalmente por que tempo médio é O(n+m) com equação de expectativa.",
                                "Calcular P(colisão) para dados reais (n=10^6, Q=2^64) e concluir baixa.",
                                "Identificar input para pior caso e estimar seu tempo.",
                                "Simular em código e confirmar tempo linear em textos aleatórios.",
                                "Comparar com alternativas determinísticas como KMP.",
                                "Defender uso de Rabin-Karp em cenários práticos apesar de probabilístico."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação probabilística (expectativa <5% erro).",
                                "Correta identificação de rolling hash incremental e mod Q.",
                                "Explicação clara de trade-off médio vs pior caso.",
                                "Exemplos numéricos sem erros aritméticos.",
                                "Conexão com prática: sugestões para Q/base ótimos.",
                                "Uso correto de notação Big-O em contextos médio/pior."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Probabilidade, Expectativa Linear e Análise Assintótica.",
                                "Ciência da Computação: Tabelas Hash, Estruturas de Dados e Análise de Algoritmos.",
                                "Estatística: Modelos Bernoulli e Birthday Paradox.",
                                "Engenharia de Software: Otimização de Strings em Buscadores e Compiladores."
                              ],
                              "realWorldApplication": "Detecção de plágio em sistemas educacionais (comparar trechos de essays), busca substring em genomas biológicos (BLAST-like), filtros anti-spam em emails (padrões maliciosos), e indexação de texto em bancos de dados como Elasticsearch."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.2.3.2"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.3",
                    "name": "Distância de Edição de Levenshtein",
                    "description": "Medida da similaridade entre strings calculada por programação dinâmica, considerando inserções, deleções e substituições.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.3.1",
                        "name": "Definição e Operações Básicas da Distância de Levenshtein",
                        "description": "Compreender o conceito fundamental da distância de edição de Levenshtein como medida mínima de operações para transformar uma string em outra, incluindo inserções, deleções e substituições, cada uma com custo unitário.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.1.1",
                            "name": "Identificar as operações de edição",
                            "description": "Explicar as três operações básicas: inserção (adicionar caractere), deleção (remover caractere) e substituição (trocar caractere), com custo 1 para cada uma, e zero se caracteres iguais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Geral de Operações de Edição",
                                  "subSteps": [
                                    "Defina operação de edição como transformações mínimas para converter uma string em outra.",
                                    "Identifique as três operações básicas: inserção, deleção e substituição.",
                                    "Aprenda que cada operação tem custo unitário de 1.",
                                    "Entenda que caracteres idênticos em posições correspondentes têm custo 0.",
                                    "Visualize strings alinhadas lado a lado para análise."
                                  ],
                                  "verification": "Explique em suas palavras as três operações e seus custos, com um exemplo simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto",
                                    "Strings de exemplo como 'abc' e 'abd'"
                                  ],
                                  "tips": "Pense nas strings como sequências mutáveis, como editar um texto manualmente.",
                                  "learningObjective": "Dominar os fundamentos conceituais das operações de edição na Distância de Levenshtein.",
                                  "commonMistakes": [
                                    "Confundir custo de operações com zero sempre.",
                                    "Ignorar a importância do alinhamento de strings."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Dominar a Operação de Inserção",
                                  "subSteps": [
                                    "Defina inserção: adicionar um caractere em uma posição específica da string origem.",
                                    "Exemplo: De 'gato' para 'gaita', inserir 'i' após 'g'.",
                                    "Calcule o custo: sempre 1 por inserção.",
                                    "Pratique identificando onde inserir para minimizar transformações.",
                                    "Compare com não-inserção quando caracteres divergem."
                                  ],
                                  "verification": "Transforme 'abc' em 'abcd' identificando apenas inserções necessárias.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de pares de strings curtas",
                                    "Planilha para anotar operações"
                                  ],
                                  "tips": "Marque com '+' o local de inserção no alinhamento.",
                                  "learningObjective": "Identificar e aplicar corretamente a operação de inserção com custo associado.",
                                  "commonMistakes": [
                                    "Confundir inserção com substituição ao lidar com caracteres extras."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Dominar a Operação de Deleção",
                                  "subSteps": [
                                    "Defina deleção: remover um caractere de uma posição na string origem.",
                                    "Exemplo: De 'gaita' para 'gato', deletar 'i' e 'a'.",
                                    "Calcule o custo: sempre 1 por deleção.",
                                    "Pratique em alinhamentos onde um caractere está presente apenas em uma string.",
                                    "Diferencie de substituição quando o caractere é desnecessário."
                                  ],
                                  "verification": "Transforme 'abcd' em 'abc' listando deleções e custos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pares de strings assimétricas",
                                    "Ferramenta de desenho para alinhamento"
                                  ],
                                  "tips": "Use '-' para representar deleções no alinhamento visual.",
                                  "learningObjective": "Reconhecer e quantificar operações de deleção precisamente.",
                                  "commonMistakes": [
                                    "Esquecer de contar múltiplas deleções em strings longas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Dominar Substituição e Comparação de Caracteres",
                                  "subSteps": [
                                    "Defina substituição: trocar um caractere por outro em posição correspondente.",
                                    "Exemplo: De 'gato' para 'pato', substituir 'g' por 'p'.",
                                    "Custo: 1 se diferentes, 0 se iguais.",
                                    "Pratique alinhando strings e decidindo entre substituição ou inserção/deleção.",
                                    "Integre todas operações em um exemplo completo."
                                  ],
                                  "verification": "Analise 'kitten' e 'sitting', listando operações e custos totais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos clássicos de Levenshtein",
                                    "Calculadora para somar custos"
                                  ],
                                  "tips": "Priorize custo 0 para iguais antes de editar.",
                                  "learningObjective": "Diferenciar substituição de outras operações e calcular custos corretamente.",
                                  "commonMistakes": [
                                    "Atribuir custo 1 a caracteres iguais.",
                                    "Não considerar substituição como alternativa viável."
                                  ]
                                }
                              ],
                              "practicalExample": "Dadas as strings 'gato' e 'gaita': Alinhe-as como g a t o e g a i t a. Identifique inserção de 'i' (custo 1). Total: 1 operação.",
                              "finalVerifications": [
                                "Liste e defina as três operações básicas com exemplos.",
                                "Calcule custo para pares simples como 'a' -> 'ab' (inserção=1).",
                                "Identifique custo 0 em 'aa' -> 'aa'.",
                                "Analise um par médio como 'sábado' -> 'sábados' (inserção de 's').",
                                "Explique quando usar cada operação em um alinhamento.",
                                "Some custos corretamente em um exemplo com múltiplas operações."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e identificação de cada operação (100%).",
                                "Cálculo correto de custos, incluindo zero para iguais.",
                                "Capacidade de alinhar strings e escolher operações mínimas.",
                                "Explicação clara de exemplos práticos sem erros conceituais.",
                                "Integração de todas operações em análises complexas.",
                                "Detecção e correção de erros comuns em cenários simulados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelos de otimização e custos unitários.",
                                "Linguística: Análise de similaridade fonética e ortográfica.",
                                "Biologia: Alinhamento de sequências genéticas (DNA/RNA).",
                                "Programação: Base para implementação de algoritmos dinâmicos.",
                                "Inteligência Artificial: Processamento de linguagem natural (NLP)."
                              ],
                              "realWorldApplication": "Aplicado em corretores ortográficos (ex: Google Docs), sugestões de busca ('did you mean?'), alinhamento de sequências em bioinformática para edição genética, e detecção de plágio em textos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.2",
                            "name": "Calcular distância manualmente para strings curtas",
                            "description": "Realizar cálculo passo a passo da distância mínima entre duas strings curtas (ex: 'kitten' e 'sitting'), listando sequências possíveis de operações sem programação dinâmica.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender as operações básicas de edição da Distância de Levenshtein",
                                  "subSteps": [
                                    "Defina inserção: adicionar um caractere em qualquer posição, custo 1.",
                                    "Defina deleção: remover um caractere de qualquer posição, custo 1.",
                                    "Defina substituição: trocar um caractere por outro em uma posição, custo 1.",
                                    "Note que caracteres iguais (match) têm custo 0 e não requerem operação.",
                                    "Crie exemplos mínimos: 'a' para 'ab' (inserção), 'ab' para 'a' (deleção), 'a' para 'b' (substituição)."
                                  ],
                                  "verification": "Liste as três operações com definições, custos e um exemplo simples cada, confirmando que matches custam 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de strings curtas como 'a', 'ab', 'b'"
                                  ],
                                  "tips": "Visualize as operações como transformações sequenciais em uma cópia da string origem.",
                                  "learningObjective": "Dominar as regras exatas das operações de edição e seus custos unitários.",
                                  "commonMistakes": [
                                    "Confundir substituição (custo 1) com inserção + deleção (custo 2)",
                                    "Ignorar matches de custo 0",
                                    "Aplicar operações em posições erradas sem rastrear"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar visualmente as strings de entrada",
                                  "subSteps": [
                                    "Escreva a string origem (S1) e alvo (S2) alinhadas verticalmente.",
                                    "Identifique e marque matches (caracteres iguais em posições alinhadas).",
                                    "Destaque diferenças: posições com caracteres distintos, comprimentos diferentes.",
                                    "Calcule comprimentos iniciais e diferença de tamanho (|len(S1) - len(S2)| como limite inferior).",
                                    "Liste caracteres exclusivos de cada string para guiar operações potenciais."
                                  ],
                                  "verification": "Produza um alinhamento visual anotado com marks para matches (✓), diffs (✗), inserções/deleções potenciais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "As strings específicas, ex: 'kitten' e 'sitting'"
                                  ],
                                  "tips": "Alinhe pelo início ou fim para maximizar matches iniciais e reduzir enumerações.",
                                  "learningObjective": "Identificar padrões de similaridade para otimizar enumeração posterior.",
                                  "commonMistakes": [
                                    "Ignorar alinhamentos alternativos além do prefixo",
                                    "Não notar inserções/deleções necessárias pelo comprimento",
                                    "Confundir ordem de caracteres"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Enumerar sequências possíveis de operações",
                                  "subSteps": [
                                    "Comece com S1 e aplique uma operação por vez, gerando ramificações (ex: ins/del/sub em cada posição).",
                                    "Rastreie o estado atual da string e custo cumulativo em uma árvore ou tabela.",
                                    "Continue ramificações até matching exato de S2 ou limite de profundidade (ex: 5 ops para strings curtas).",
                                    "Registre pelo menos 4-6 sequências viáveis, priorizando caminhos com matches.",
                                    "Aborte caminhos com custo > diferença de comprimento + diffs observadas."
                                  ],
                                  "verification": "Crie uma tabela com pelo menos 4 sequências, cada uma mostrando ops passo a passo, strings intermediárias e custo total.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel para árvore de decisões",
                                    "Marcadores coloridos para ops diferentes"
                                  ],
                                  "tips": "Use abreviações: I=ins, D=del, S=sub, com posição (ex: I3:a = ins 'a' na pos 3).",
                                  "learningObjective": "Gerar exaustivamente caminhos de transformação viáveis sem programação.",
                                  "commonMistakes": [
                                    "Explorar caminhos muito profundos sem poda",
                                    "Não rastrear string intermediária exatamente",
                                    "Duplicar ops desnecessárias"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Determinar a distância mínima e validar a sequência ótima",
                                  "subSteps": [
                                    "Compile todos os custos das sequências que alcançam S2 exatamente.",
                                    "Selecione o menor custo como distância de Levenshtein.",
                                    "Liste a sequência ótima completa com strings intermediárias para verificação.",
                                    "Teste aplicando as ops manualmente na S1 para confirmar chegada em S2.",
                                    "Compare com limite inferior (max(|len diff|, # diffs mínimas)) para validar."
                                  ],
                                  "verification": "Declare a distância final, mostre 1-2 sequências ótimas e confirme transformação manual.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista de sequências do step 3",
                                    "Caneta para simulação final"
                                  ],
                                  "tips": "Se múltiplas ótimas, liste todas; foque na mais curta em ops.",
                                  "learningObjective": "Identificar e validar o caminho de custo mínimo entre opções enumeradas.",
                                  "commonMistakes": [
                                    "Escolher sequência errada por erro de cálculo",
                                    "Não verificar se atinge exatamente S2",
                                    "Subestimar custo por esquecer ops"
                                  ]
                                }
                              ],
                              "practicalExample": "Para 'kitten' (S1) e 'sitting' (S2): Sequência ótima (distância 3): 1. 'kitten' → 'sitten' (substituição k→s na pos 1), 2. 'sitten' → 'sittin' (inserção 'i' após 'tt'), 3. 'sittin' → 'sitting' (inserção 'g' no fim). Verificação: Aplicar ops leva exatamente a 'sitting'. Outra: kitten → kittin (ins i), kittin → sittin (sub k→s), sittin → sitting (ins g).",
                              "finalVerifications": [
                                "Distância mínima calculada corretamente e igual ao conhecido (ex: 3 para 'kitten'/'sitting').",
                                "Pelo menos uma sequência ótima listada com strings intermediárias exatas.",
                                "Transformação manual das ops confirma chegada à string alvo.",
                                "Todas ops usadas são válidas (ins/del/sub) com custo 1 cada.",
                                "Limite inferior respeitado (não há custo menor possível).",
                                "Enumeração cobre caminhos principais sem lacunas óbvias."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Custo mínimo correto e sequência válida.",
                                "Completude: Pelo menos 4 sequências enumeradas com rastreio completo.",
                                "Clareza: Apresentação tabular/árvore legível com strings intermediárias.",
                                "Validação: Verificação manual das ops e matches.",
                                "Eficiência: Poda de caminhos inviáveis e foco em strings curtas.",
                                "Conformidade: Apenas ops básicas, sem DP ou atalhos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Busca de caminhos mínimos em grafos implícitos.",
                                "Linguística: Medição de similaridade ortográfica entre palavras.",
                                "Biologia: Comparação de sequências genéticas curtas (DNA/RNA).",
                                "Ciência da Computação: Fundamento para algoritmos de fuzzy matching."
                              ],
                              "realWorldApplication": "Aplicado em corretores ortográficos (ex: sugestões no Word/Google), detecção de similaridade em buscas (ex: 'reciepe' → 'recipe'), alinhamento de sequências biológicas curtas em bioinformática, e sistemas de deduplicação de dados em bancos (identificar entradas similares)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.3.1.3",
                            "name": "Reconhecer casos especiais",
                            "description": "Identificar distâncias zero (strings iguais), um (uma operação) e calcular para transposições ou inserções múltiplas, entendendo a não-otimalidade de abordagens gulosas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar Distância Zero: Strings Idênticas",
                                  "subSteps": [
                                    "Defina distância de Levenshtein como o mínimo de operações (inserção, deleção, substituição) para transformar uma string em outra.",
                                    "Examine pares de strings idênticas, como 'abc' e 'abc'.",
                                    "Confirme que nenhuma operação é necessária, resultando em distância 0.",
                                    "Teste com strings vazias: ambas vazias têm distância 0.",
                                    "Registre exemplos em um caderno para reforço."
                                  ],
                                  "verification": "Liste 5 pares de strings idênticas e confirme distância 0 para cada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplos de strings simples"
                                  ],
                                  "tips": "Sempre compare caractere por caractere primeiro para detectar igualdade total.",
                                  "learningObjective": "Compreender que strings iguais requerem zero edições.",
                                  "commonMistakes": [
                                    "Confundir com strings semelhantes mas não idênticas",
                                    "Ignorar strings vazias"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Reconhecer Distância Um: Uma Única Operação",
                                  "subSteps": [
                                    "Liste as três operações básicas: inserção (adicionar char), deleção (remover char), substituição (trocar char).",
                                    "Teste inserção: 'abc' para 'abcd' (distância 1).",
                                    "Teste deleção: 'abcd' para 'abc' (distância 1).",
                                    "Teste substituição: 'abc' para 'axc' (distância 1).",
                                    "Verifique que nenhuma operação composta é necessária aqui."
                                  ],
                                  "verification": "Calcule manualmente distância para 5 pares com exatamente uma diferença e justifique a operação.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de texto para simular edições",
                                    "Tabela de exemplos pré-preparada"
                                  ],
                                  "tips": "Visualize as strings lado a lado alinhadas para spotting a diferença única.",
                                  "learningObjective": "Identificar quando uma única operação resolve a transformação.",
                                  "commonMistakes": [
                                    "Contar transposições como uma operação (é 2)",
                                    "Misturar inserção com substituição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Transposições: Distância Dois",
                                  "subSteps": [
                                    "Explique transposição como troca de dois caracteres adjacentes, custando 2 operações (substituição + inserção/deleção).",
                                    "Exemplo: 'ab' para 'ba' – substitua 'a' por 'b', insira 'a' (ou vice-versa), distância 2.",
                                    "Teste com strings maiores: 'abc' para 'acb' (transposição de 'b' e 'c').",
                                    "Compare com DP básica: confirme custo 2.",
                                    "Discuta por que não é uma operação primitiva na Levenshtein padrão."
                                  ],
                                  "verification": "Descreva sequência de 2 operações para 3 pares transpostos e calcule distância.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Strings de exemplo escritas",
                                    "Calculadora manual ou pseudocódigo DP simples"
                                  ],
                                  "tips": "Pense em alinhamento: transposições criam mismatches em posições adjacentes.",
                                  "learningObjective": "Reconhecer que transposições custam 2 na métrica padrão.",
                                  "commonMistakes": [
                                    "Assumir custo 1 para transposição",
                                    "Confundir com Damerau-Levenshtein (que tem custo 1)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Entender Inserções Múltiplas e Falhas de Abordagens Gulosas",
                                  "subSteps": [
                                    "Exemplo de inserções múltiplas: 'a' para 'abcd' (3 inserções, distância 3).",
                                    "Mostre falha greedy: para 'ca' e 'ac', greedy pode substituir 'c' por 'a' e inserir 'c' (2 ops), mas ótimo é 2 transposições efetivas – wait, confirme DP dá 2.",
                                    "Melhor exemplo: 'ab' para 'ba' greedy falha se priorizar match errado.",
                                    "Exemplo clássico: 'Saturday' e 'Sunday' – greedy pode errar, DP acha 3.",
                                    "Implemente mentalmente por que DP é necessário vs. greedy sequencial."
                                  ],
                                  "verification": "Identifique 3 casos onde greedy falha e explique o custo ótimo via raciocínio.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Lista de pares problemáticos para greedy",
                                    "Pseudocódigo de greedy vs. DP"
                                  ],
                                  "tips": "Sempre valide com alinhamento global, não local greedy.",
                                  "learningObjective": "Compreender limitações greedy e necessidade de DP para casos complexos.",
                                  "commonMistakes": [
                                    "Achar que greedy sempre funciona",
                                    "Subestimar custo de múltiplas inserções"
                                  ]
                                }
                              ],
                              "practicalExample": "Compare 'kitten' e 'sitting': distância 3 (substituição k->s, t->i, inserção g). Mas para casos especiais: 'kit' e 'kit' (0), 'kit' e 'kits' (1 inserção), 'kit' e 'kti' (transposição i-t, distância 2), 'a' e 'abc' (2 inserções). Teste greedy: pode inserir 'b' cedo e errar.",
                              "finalVerifications": [
                                "Calcula corretamente distância 0 para strings idênticas.",
                                "Identifica operações únicas para distância 1.",
                                "Explica por que transposição custa 2 operações.",
                                "Fornece contraexemplo onde greedy falha vs. ótimo.",
                                "Lista 3 pares com inserções múltiplas e seus custos.",
                                "Diferencia Levenshtein padrão de variantes com transposição."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de distância para casos especiais (100% correto).",
                                "Explicação clara das operações envolvidas em cada caso.",
                                "Identificação correta de falhas em abordagens gulosas com exemplos.",
                                "Uso de alinhamento visual para justificar distâncias.",
                                "Capacidade de gerar novos exemplos válidos.",
                                "Compreensão conceitual sem depender de código DP."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Métricas de distância e grafos (caminho mínimo).",
                                "Linguística: Similaridade fonética e correção ortográfica.",
                                "Biologia: Alinhamento de sequências de DNA/RNA.",
                                "Programação: Implementação de algoritmos dinâmicos vs. heurísticas."
                              ],
                              "realWorldApplication": "Em corretores ortográficos (detectar erros de uma letra), busca de similaridade em bancos de dados (busca fuzzy), edição de genes (comparar sequências mutadas), e sistemas de recomendação de texto (auto-complete com tolerância a erros)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.2",
                        "name": "Formulação com Programação Dinâmica",
                        "description": "Entender a abordagem de programação dinâmica para computar eficientemente a distância, usando uma matriz bidimensional que armazena subproblemas.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.2.1",
                            "name": "Definir a recorrência da DP",
                            "description": "Especificar a fórmula recursiva para a matriz D[i][j]: min(D[i-1][j]+1 deleção, D[i][j-1]+1 inserção, D[i-1][j-1] + (0 se iguais, 1 se diferentes)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos da Distância de Levenshtein",
                                  "subSteps": [
                                    "Explique o que é a Distância de Levenshtein: número mínimo de operações (inserção, deleção, substituição) para transformar uma string em outra.",
                                    "Identifique as três operações básicas e seus custos (cada uma custa 1).",
                                    "Discuta por que uma abordagem recursiva ingênua é ineficiente (exponencial).",
                                    "Introduza a Programação Dinâmica (DP) como solução para memoização de subproblemas.",
                                    "Desenhe strings de exemplo curtas, como 'a' e 'b', para ilustrar transformações."
                                  ],
                                  "verification": "Escreva uma definição clara da Distância de Levenshtein e liste as três operações com exemplos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou editor de texto",
                                    "Exemplos de strings simples"
                                  ],
                                  "tips": "Use analogias como editar um texto no Word para visualizar operações.",
                                  "learningObjective": "Compreender o problema e justificar o uso de DP.",
                                  "commonMistakes": [
                                    "Confundir substituição com inserção/deleção",
                                    "Ignorar custo uniforme das operações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a Matriz DP e Condições de Base",
                                  "subSteps": [
                                    "Crie uma matriz D de tamanho (m+1) x (n+1), onde m e n são comprimentos das strings S e T.",
                                    "Explique D[i][j] como distância mínima entre prefixos S[1..i] e T[1..j].",
                                    "Defina D[i][0] = i (apenas deleções para prefixo vazio de T).",
                                    "Defina D[0][j] = j (apenas inserções para prefixo vazio de S).",
                                    "Preencha manualmente as bordas para strings de exemplo como 'ab' e 'a'."
                                  ],
                                  "verification": "Construa a matriz de base para S='kit', T='sit' e confirme valores das bordas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Planilha ou papel quadriculado",
                                    "Strings de exemplo"
                                  ],
                                  "tips": "Sempre indexe a partir de 0 para prefixos vazios.",
                                  "learningObjective": "Estabelecer as condições iniciais da recorrência.",
                                  "commonMistakes": [
                                    "Errar indexação (começar em 1 em vez de 0)",
                                    "Confundir i e j entre strings"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Especificar a Recorrência para Células Internas",
                                  "subSteps": [
                                    "Para D[i][j], considere três opções: deleção (D[i-1][j] + 1), inserção (D[i][j-1] + 1).",
                                    "Adicione substituição: D[i-1][j-1] + (0 se S[i]==T[j], senão 1).",
                                    "Escreva a fórmula completa: D[i][j] = min das três opções.",
                                    "Explique dependências: cada célula depende apenas de células anteriores.",
                                    "Preencha uma célula interna manualmente usando a fórmula."
                                  ],
                                  "verification": "Escreva a fórmula exata e compute D[1][1] para S='kitten', T='sitting'.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Matriz parcial preenchida",
                                    "Pseudocódigo da fórmula"
                                  ],
                                  "tips": "Pense em 'match' como substituição gratuita.",
                                  "learningObjective": "Formular a recorrência recursiva precisa.",
                                  "commonMistakes": [
                                    "Esquecer o custo condicional na substituição",
                                    "Usar max em vez de min"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Refinar a Recorrência com Exemplo",
                                  "subSteps": [
                                    "Preencha toda a matriz para strings curtas como 'sunday' e 'saturday'.",
                                    "Trace o caminho ótimo na matriz para justificar o resultado final D[m][n].",
                                    "Compare com implementação recursiva simples para validar.",
                                    "Identifique otimizações potenciais (espaço O(min(m,n))).",
                                    "Teste casos edge: strings iguais, vazia, uma caractere diferente."
                                  ],
                                  "verification": "Compute distância completa para exemplo e explique cada escolha na recorrência.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Calculadora ou Python para verificação opcional",
                                    "Matriz grande em papel"
                                  ],
                                  "tips": "Siga ordem de preenchimento: topo para baixo, esquerda para direita.",
                                  "learningObjective": "Aplicar e validar a recorrência em prática.",
                                  "commonMistakes": [
                                    "Preencher fora de ordem, causando erros de dependência",
                                    "Ignorar match gratuito"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Documentar e Generalizar a Recorrência",
                                  "subSteps": [
                                    "Escreva a recorrência em pseudocódigo formal.",
                                    "Discuta complexidade: O(mn) tempo e espaço.",
                                    "Relacione com outros problemas DP (ex: LCS).",
                                    "Crie um fluxograma visual da recorrência.",
                                    "Prepare para implementação codificada."
                                  ],
                                  "verification": "Produza pseudocódigo completo e diagrama da recorrência.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de diagrama como Draw.io",
                                    "Template de pseudocódigo"
                                  ],
                                  "tips": "Use notação matemática clara: D_{i,j} = \\min(...).",
                                  "learningObjective": "Formalizar para uso em algoritmos maiores.",
                                  "commonMistakes": [
                                    "Omitir condições de base no pseudocódigo",
                                    "Confundir com distância de Hamming"
                                  ]
                                }
                              ],
                              "practicalExample": "Para strings S='kitten' (m=5) e T='sitting' (n=6), a matriz D[6][7] resulta em D[5][6]=3. Preenchendo: bordas D[i][0]=i, D[0][j]=j; para D[1][1] ('k' vs 's'): min(D[0][1]+1=2, D[1][0]+1=2, D[0][0]+1=2)=2; continue até D[5][6]=3 (substituições 'k'->'s', 'e'->'i', inserção 'g').",
                              "finalVerifications": [
                                "Pode escrever a fórmula recursiva exata sem olhar notas?",
                                "Construir matriz completa para strings de 3-4 caracteres corretamente?",
                                "Explicar o papel de cada operação na min?",
                                "Identificar D[m][n] como resposta final?",
                                "Validar com pelo menos dois exemplos diferentes?",
                                "Discutir condições de base verbalmente?"
                              ],
                              "assessmentCriteria": [
                                "Precisão da fórmula: inclui min, três casos, custo condicional correto (100%)",
                                "Compreensão conceitual: explica dependências e otimalidade (80-100%)",
                                "Aplicação prática: matriz preenchida sem erros para exemplo médio (90%)",
                                "Generalização: relaciona com complexidade e variantes (70-90%)",
                                "Clareza na documentação: pseudocódigo e diagrama legíveis (85%)",
                                "Tratamento de edges: casos vazios e iguais corretos (95%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrências e minimização em otimização discreta",
                                "Bioinformática: Alinhamento de sequências genéticas (similar a Needleman-Wunsch)",
                                "Ciência da Computação: Teoria da Computação e autômatos",
                                "Engenharia de Software: Algoritmos em corretores ortográficos e busca fuzzy"
                              ],
                              "realWorldApplication": "Usado em corretores ortográficos (Google Docs), sistemas de busca tolerante a erros (busca no Google), alinhamento de DNA em genômica, detecção de similaridade em processamento de texto e edição de código em IDEs."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.2.2",
                            "name": "Construir a tabela de programação dinâmica",
                            "description": "Preencher manualmente a matriz DP para strings exemplo (ex: 'sunday' e 'saturday'), inicializando bordas (inserções/deleções) e computando valores internos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar as strings de entrada e inicializar a matriz DP",
                                  "subSteps": [
                                    "Identifique as duas strings de exemplo, como S = 'sunday' (comprimento 6 com índice 0) e T = 'saturday' (comprimento 8 com índice 0).",
                                    "Crie uma matriz vazia de (len(S)+1) x (len(T)+1), ou seja, 6x8 para este exemplo.",
                                    "Rotule as linhas com caracteres de S (incluindo espaço vazio no topo) e colunas com T (espaço vazio à esquerda)."
                                  ],
                                  "verification": "Matriz criada com dimensões corretas (m+1 linhas por n+1 colunas) e rótulos visíveis.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel quadriculado ou planilha digital",
                                    "Caneta ou software como Excel/Google Sheets"
                                  ],
                                  "tips": "Use uma grade grande o suficiente para evitar erros de alinhamento; comece com strings curtas para prática.",
                                  "learningObjective": "Compreender as dimensões da matriz DP baseadas nos comprimentos das strings.",
                                  "commonMistakes": [
                                    "Confundir len(S)+1 com len(S); esquecer o índice 0 para strings vazias."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar as bordas da matriz (inserções e deleções)",
                                  "subSteps": [
                                    "Preencha a primeira linha (i=0): dp[0][j] = j para j de 0 a len(T), representando inserções.",
                                    "Preencha a primeira coluna (j=0): dp[i][0] = i para i de 0 a len(S), representando deleções.",
                                    "Verifique que dp[0][0] = 0 (string vazia vs vazia)."
                                  ],
                                  "verification": "Primeira linha: 0,1,2,3,4,5,6,7; primeira coluna: 0,1,2,3,4,5.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Matriz preparada do step 1",
                                    "Calculadora opcional para contagens"
                                  ],
                                  "tips": "Pense nas bordas como custo cumulativo de transformar uma string vazia na outra apenas com inserções/deleções.",
                                  "learningObjective": "Dominar a inicialização das condições base para operações de inserção e deleção.",
                                  "commonMistakes": [
                                    "Começar contagem de 1 em vez de 0; inverter linha e coluna."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher as células internas usando a fórmula DP",
                                  "subSteps": [
                                    "Para cada célula dp[i][j] onde i>0 e j>0: se S[i-1] == T[j-1], dp[i][j] = dp[i-1][j-1].",
                                    "Senão, dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) (substituição, deleção, inserção).",
                                    "Preencha linha por linha, da esquerda para a direita, começando do canto superior esquerdo.",
                                    "Calcule para o exemplo: foque em células chave como dp[1][1] ('s'=='s') = 0."
                                  ],
                                  "verification": "Células internas preenchidas corretamente; valor em dp[5][7] deve ser 3 para 'sunday' vs 'saturday'.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Matriz com bordas preenchidas",
                                    "Fórmula anotada ao lado"
                                  ],
                                  "tips": "Anote a origem de cada min() para rastrear; pratique com papel para visualização manual.",
                                  "learningObjective": "Aplicar recursivamente a fórmula de recorrência para computar distâncias ótimas.",
                                  "commonMistakes": [
                                    "Índices off-by-one (usar i em vez de i-1); escolher min incorreto ou esquecer +1."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar a tabela completa e calcular a distância final",
                                  "subSteps": [
                                    "Localize o valor em dp[len(S)][len(T)], que é a distância de Levenshtein mínima.",
                                    "Trace um caminho de volta (backtrack) opcionalmente para ver as operações (inserção/deleção/substituição).",
                                    "Compare com expectativa: para 'sunday' e 'saturday', distância = 3 (ex: delete 'u','n'; insert 'a','t','r' ajustado)."
                                  ],
                                  "verification": "Distância final correta (3) e pelo menos um caminho de edições válido identificado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Matriz completa"
                                  ],
                                  "tips": "Backtrack ajuda a validar; use setas para marcar o caminho do min.",
                                  "learningObjective": "Extrair e interpretar o resultado final da tabela DP como distância editável.",
                                  "commonMistakes": [
                                    "Ler valor errado no canto; ignorar que backtrack é para validação, não obrigatório."
                                  ]
                                }
                              ],
                              "practicalExample": "Para S='sunday' e T='saturday':\nMatriz 6x8:\nBordas: Linha 0: [0,1,2,3,4,5,6,7]; Col 0: [0,1,2,3,4,5]^T.\nExemplo célula dp[1][1]: 's'=='s' → 0.\ndp[1][2]: 's'!='a' → 1 + min(dp[0][2]=2, dp[1][1]=0, dp[0][1]=1) = 1.\nContinue até dp[5][7]=3.",
                              "finalVerifications": [
                                "Dimensões da matriz: (len(S)+1) x (len(T)+1).",
                                "Bordas corretas: incrementos unitários.",
                                "Células internas seguem fórmula exata (igualdade ou min+1).",
                                "Valor final dp[m][n] = 3 para exemplo dado.",
                                "Pelo menos 80% das células calculadas manualmente sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inicialização de bordas (100% correto).",
                                "Aplicação correta da fórmula recursiva em todas células internas.",
                                "Identificação correta da distância final e justificativa via backtrack parcial.",
                                "Tempo de execução manual dentro do estimado total (65 min).",
                                "Explicação clara de pelo menos 3 decisões de min() em células chave."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recorrência e otimização em matrizes, similar a álgebra linear.",
                                "Biologia: Alinhamento de sequências de DNA/RNA usando distâncias editáveis.",
                                "Linguística: Medição de similaridade semântica ou fonética em processadores de texto.",
                                "Programação: Base para implementação eficiente de algoritmos O(mn) em código."
                              ],
                              "realWorldApplication": "Em corretores ortográficos (Google Docs), detecção de similaridade em buscas (autocomplete), bioinformática para comparar genes mutados, e edição de código-fonte para refatoração automática."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.1.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.2.3",
                            "name": "Explicar dependências subproblemas",
                            "description": "Demonstrar como cada célula depende apenas de células anteriores (direita, cima, diagonal), garantindo aciclicidade e ordenação topológica implícita na iteração.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a estrutura da tabela de Programação Dinâmica para Levenshtein",
                                  "subSteps": [
                                    "Desenhe uma tabela DP vazia de tamanho (m+1) x (n+1), onde m e n são os comprimentos das strings S e T.",
                                    "Preencha a primeira linha e primeira coluna com valores iniciais: 0 na célula (0,0), i na primeira coluna (inserções), j na primeira linha (deleções).",
                                    "Rotule as células com coordenadas (i,j), onde i é o prefixo de S e j de T.",
                                    "Identifique visualmente que o preenchimento ocorre da esquerda para a direita e de cima para baixo."
                                  ],
                                  "verification": "A tabela inicial está corretamente preenchida e rotulada, com valores crescentes nas bordas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, lápis, exemplo de strings curtas como 'a' e 'b'",
                                  "tips": "Use cores diferentes para bordas e células internas para facilitar visualização.",
                                  "learningObjective": "Visualizar a tabela DP como uma grade 2D com preenchimento sequencial.",
                                  "commonMistakes": "Confundir índices de linhas/colunas ou errar os valores iniciais nas bordas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar dependências específicas por operação em cada célula",
                                  "subSteps": [
                                    "Para uma célula (i,j), liste as três possíveis origens: cima (i-1,j) para deleção (custo +1), esquerda (i,j-1) para inserção (custo +1), diagonal (i-1,j-1) para match/substituição (custo 0 ou 1).",
                                    "Calcule o valor mínimo entre as três dependências + custo da operação.",
                                    "Anote setas apontando das células dependentes para (i,j) em um exemplo pequeno.",
                                    "Verifique que nenhuma dependência aponta para células futuras (direita ou abaixo).",
                                    "Repita para 3-4 células consecutivas."
                                  ],
                                  "verification": "Para cada célula escolhida, as três dependências estão corretamente identificadas com setas e custos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela DP impressa ou desenhada, calculadora para custos",
                                  "tips": "Comece com células próximas às bordas para dependências mais simples.",
                                  "learningObjective": "Mapear precisamente as dependências locais de cada célula.",
                                  "commonMistakes": "Incluir dependências de células à direita ou abaixo, violando a direção."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Visualizar o grafo de dependências e fluxo de ordenação",
                                  "subSteps": [
                                    "Represente a tabela como um grafo direcionado, onde cada célula é um nó e setas vão das dependências para a célula atual.",
                                    "Trace o caminho de preenchimento: de (0,0) para todas as células em ordem row-major (linha por linha).",
                                    "Destaque que todas as setas apontam apenas para cima, esquerda ou diagonal superior-esquerda.",
                                    "Simule a iteração em código pseudocódigo, mostrando como acessa apenas células já computadas.",
                                    "Confirme que não há ciclos no grafo."
                                  ],
                                  "verification": "Grafo desenhado sem setas para frente e simulação de iteração sem acessar células não computadas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para grafo, pseudocódigo de DP Levenshtein",
                                  "tips": "Use software como Draw.io para grafos se preferir digital.",
                                  "learningObjective": "Entender o preenchimento como travessia topológica em um DAG implícito.",
                                  "commonMistakes": "Desenhar setas bidirecionais ou assumir dependências circulares."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explicar garantias de aciclicidade e ordenação topológica",
                                  "subSteps": [
                                    "Defina aciclicidade: ausência de ciclos no grafo de dependências.",
                                    "Prove que dependências só de 'passado' (cima/esquerda/diagonal) impedem ciclos.",
                                    "Explique ordenação topológica: ordem de preenchimento respeita dependências (células anteriores primeiro).",
                                    "Discuta implicações: permite computação bottom-up sem recursão com memoização.",
                                    "Compare com grafos cíclicos e por que DP falharia ali.",
                                    "Resuma em uma frase: 'Cada célula depende só de anteriores, garantindo DAG e topo-order.'"
                                  ],
                                  "verification": "Escreva uma explicação de 1 parágrafo cobrindo aciclicidade, topo-order e implicações.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Folha para resumo, referências de teoria dos grafos",
                                  "tips": "Use analogia de 'construir tijolo por tijolo, só usando os já prontos'.",
                                  "learningObjective": "Articular por que a estrutura garante corretude em DP.",
                                  "commonMistakes": "Confundir com ordenação topológica explícita ou ignorar diagonal."
                                }
                              ],
                              "practicalExample": "Considere strings S='kit' e T='sit'. Na célula (2,2) para 'i' e 'i': depende de (1,2)='k'vs'i' (substituição), (2,1)='i'vs's' (inserção), (1,1)='k'vs's' (diagonal). Valor = min(1+1, 1+1, 0+1) = 1, dependendo só de células anteriores, permitindo preenchimento sequencial sem ciclos.",
                              "finalVerifications": [
                                "Pode desenhar dependências com setas para qualquer célula em uma tabela 3x3.",
                                "Explica corretamente as três operações e suas origens sem erros.",
                                "Identifica que todas dependências são de células com índices menores ou iguais.",
                                "Simula preenchimento sem acessar células futuras.",
                                "Resume aciclicidade e topo-order em termos próprios.",
                                "Aplica a um exemplo novo sem ajuda."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de dependências (cima, esquerda, diagonal).",
                                "Correta representação visual do grafo de dependências como DAG.",
                                "Explicação clara de aciclicidade e ordenação topológica.",
                                "Uso correto de terminologia DP (bottom-up, subproblemas).",
                                "Capacidade de generalizar para outras tabelas DP.",
                                "Ausência de erros comuns como dependências para frente."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Reconhecimento de DAGs e ordenação topológica.",
                                "Matemática Discreta: Relações parciais e dependências direcionadas.",
                                "Algoritmos: Comparação com memoização recursiva e grafos explícitos.",
                                "Programação: Iteração em 2D arrays e otimização de espaço."
                              ],
                              "realWorldApplication": "Em editores de texto como Google Docs ou VS Code para sugestões de correção ortográfica (distância Levenshtein), garantindo eficiência em buscas de similaridade de strings em bancos de dados de DNA ou detecção de plágio."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.3.3",
                        "name": "Implementação e Análise de Complexidade",
                        "description": "Implementar o algoritmo em pseudocódigo ou código e analisar sua eficiência, comparando com métodos exaustivos.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.3.3.1",
                            "name": "Implementar algoritmo em pseudocódigo",
                            "description": "Escrever pseudocódigo completo para função levenshtein(s1, s2), criando matriz m x n, preenchendo-a e retornando D[m][n], otimizando espaço se possível.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a assinatura da função e inicializar variáveis",
                                  "subSteps": [
                                    "Analise as entradas: s1 (comprimento m) e s2 (comprimento n).",
                                    "Defina m = len(s1), n = len(s2).",
                                    "Crie matriz D de tamanho (m+1) x (n+1), inicializada com zeros.",
                                    "Defina pseudocódigo inicial: function levenshtein(s1, s2) { ... }",
                                    "Anote a complexidade esperada: O(m*n) tempo e espaço."
                                  ],
                                  "verification": "Verifique se m, n e matriz D estão corretamente dimensionados e inicializados no pseudocódigo.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Papel e caneta ou editor de texto simples",
                                    "Referência ao algoritmo Levenshtein"
                                  ],
                                  "tips": "Sempre use comprimentos +1 para incluir o caso vazio.",
                                  "learningObjective": "Entender as dimensões da matriz DP para distâncias de edição.",
                                  "commonMistakes": [
                                    "Esquecer +1 nas dimensões",
                                    "Confundir len(s1) com len(s2)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Preencher a primeira linha e coluna da matriz",
                                  "subSteps": [
                                    "Para i de 0 a m: D[i][0] = i (custo de deletar i caracteres de s1).",
                                    "Para j de 0 a n: D[0][j] = j (custo de inserir j caracteres de s2).",
                                    "Escreva loops separados para bordas no pseudocódigo.",
                                    "Teste mentalmente com s1='', s2='' → D[0][0]=0.",
                                    "Confirme que bordas representam operações de inserção/deleção."
                                  ],
                                  "verification": "Simule preenchimento para s1='a', s2='' e verifique D[1][0]=1.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Editor de pseudocódigo",
                                    "Exemplos pequenos de strings"
                                  ],
                                  "tips": "Pense nas bordas como sequências puras de inserções ou deleções.",
                                  "learningObjective": "Dominar inicialização das bordas para alinhamento ótimo.",
                                  "commonMistakes": [
                                    "Inicializar com 0 em vez de i/j",
                                    "Inverter loops de i e j"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher as células internas da matriz",
                                  "subSteps": [
                                    "Para i=1 a m: Para j=1 a n:",
                                    "  custo = 0 se s1[i-1]==s2[j-1], senão 1 (substituição).",
                                    "  D[i][j] = min( D[i-1][j]+1 (deletar), D[i][j-1]+1 (inserir), D[i-1][j-1]+custo (substituir/manter) ).",
                                    "Inclua os três loops aninhados no pseudocódigo.",
                                    "Trace um exemplo pequeno como s1='a', s2='b'."
                                  ],
                                  "verification": "Calcule manualmente D para s1='cat', s2='cut' e confira D[3][3]=2.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Grade de papel para matriz 4x4",
                                    "Referência de recorrência Levenshtein"
                                  ],
                                  "tips": "Sempre subtraia 1 nos índices de strings (0-based).",
                                  "learningObjective": "Implementar a recorrência principal do DP.",
                                  "commonMistakes": [
                                    "Índices errados em strings",
                                    "Esquecer o +custo na diagonal"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar otimização de espaço e retornar resultado",
                                  "subSteps": [
                                    "Para otimizar: use duas arrays prev e curr de tamanho n+1.",
                                    "Ou uma array diagonal com O(min(m,n)) se m>>n.",
                                    "Atualize prev e curr nos loops internos, copiando no final.",
                                    "Adicione return D[m][n] ou equivalente otimizado.",
                                    "Opcional: comente complexidade otimizada O(min(m,n)) espaço."
                                  ],
                                  "verification": "Reescreva pseudocódigo otimizado e simule para exemplo anterior sem matriz completa.",
                                  "estimatedTime": "35 min",
                                  "materials": [
                                    "Editor para refatorar pseudocódigo",
                                    "Comparador de versões completa vs otimizada"
                                  ],
                                  "tips": "Comece com duas linhas antes de uma só para depurar.",
                                  "learningObjective": "Otimizar DP clássico para espaço em problemas de strings.",
                                  "commonMistakes": [
                                    "Perder track de prev/curr",
                                    "Não copiar corretamente no final do loop"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e analisar o pseudocódigo completo",
                                  "subSteps": [
                                    "Execute pseudocódigo mentalmente com s1='kitten', s2='sitting' → esperado 3.",
                                    "Verifique todos os casos: vazios, iguais, unidirecional.",
                                    "Adicione comentários explicando cada operação.",
                                    "Analise complexidade: tempo O(mn), espaço otimizado O(n).",
                                    "Teste com strings desiguais em comprimento."
                                  ],
                                  "verification": "Pseudocódigo roda sem erros lógicos em 2-3 exemplos variados.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Lista de casos de teste pré-definidos"
                                  ],
                                  "tips": "Use indentação clara para loops aninhados.",
                                  "learningObjective": "Garantir correção e eficiência do algoritmo.",
                                  "commonMistakes": [
                                    "Ignorar casos edge como strings vazias",
                                    "Erros em otimização que alteram resultado"
                                  ]
                                }
                              ],
                              "practicalExample": "Para s1='kitten' (m=6), s2='sitting' (n=7): Matriz final D[6][7]=3, representando substituir 'e'→'i', inserir 'i','g' (ou equivalente mínimo). Pseudocódigo deve computar isso corretamente com otimização usando 2 arrays de tamanho 8.",
                              "finalVerifications": [
                                "Pseudocódigo define corretamente m=len(s1), n=len(s2) e matriz (m+1)x(n+1).",
                                "Bordas preenchidas com D[i][0]=i e D[0][j]=j.",
                                "Células internas usam min de delete, insert, substitute.",
                                "Otimização de espaço implementada (ex: duas arrays).",
                                "Retorna D[m][n] e lida com casos vazios/iguais.",
                                "Trace de exemplo pequeno coincide com valor esperado.",
                                "Comentários explicam recorrência e complexidade."
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: 30% (bordas e recorrência exatas).",
                                "Otimizações espaciais: 20% (reduz de O(mn) para O(n)).",
                                "Clareza e estrutura: 20% (pseudocódigo legível com loops corretos).",
                                "Tratamento de edges: 15% (vazios, iguais).",
                                "Análise de complexidade: 10% (comentada).",
                                "Exemplos validados: 5% (trace correto)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Programação Dinâmica e recursão (cálculo de mínimos).",
                                "Bioinformática: Alinhamento de sequências de DNA/proteínas.",
                                "Linguística Computacional: Correção ortográfica e similaridade semântica.",
                                "Ciência de Dados: Métricas de distância em NLP e clustering de textos."
                              ],
                              "realWorldApplication": "Usado em editores de texto (auto-correção no Google Docs), busca fuzzy em bancos de dados (correção de digitação em e-commerces), alinhamento genético em bioinformática (comparar sequências de DNA mutadas) e detecção de plágio (medir similaridade entre documentos)."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.2",
                            "name": "Analisar complexidade temporal e espacial",
                            "description": "Determinar O(mn) tempo e espaço para strings de comprimentos m e n, discutindo otimizações para O(min(m,n)) espaço usando duas arrays.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Implementação Padrão da Programação Dinâmica para Distância de Levenshtein",
                                  "subSteps": [
                                    "Desenhe a tabela DP de (m+1) x (n+1) células para strings S1 (comprimento m) e S2 (comprimento n).",
                                    "Explique as operações base: inicialização da primeira linha e coluna com valores 0,1,2,...,m e 0,1,2,...,n.",
                                    "Descreva a recursão para células internas: min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + custo de substituição/inserção/deleção.",
                                    "Implemente ou trace um exemplo pequeno, como S1='abc', S2='ac', preenchendo a tabela manualmente.",
                                    "Identifique o número total de células e operações por célula."
                                  ],
                                  "verification": "A tabela DP está corretamente preenchida para um exemplo pequeno e a distância final é calculada.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e caneta para desenhar tabela, editor de código com implementação Levenshtein em Python/Java.",
                                  "tips": "Use cores diferentes para operações de inserção, deleção e substituição para visualizar melhor.",
                                  "learningObjective": "Compreender a estrutura da tabela DP e suas dependências locais.",
                                  "commonMistakes": "Confundir índices (começar de 0 ou 1), ignorar custo zero para match."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Complexidade Temporal",
                                  "subSteps": [
                                    "Conte o número de células na tabela: (m+1) * (n+1).",
                                    "Para cada célula, identifique as 3 operações de min e 1 comparação de caracteres: O(1) tempo por célula.",
                                    "Multiplique: tempo total O((m+1)(n+1)) ≈ O(mn).",
                                    "Discuta casos extremos: m<<n ou n<<m, mas confirme que é sempre Θ(mn).",
                                    "Meça empiricamente com código, cronometrando para m=n=100, 200, etc., e plote gráfico."
                                  ],
                                  "verification": "Gráfico ou tabela mostra tempo proporcional a mn, com coeficiente próximo de 1.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código de implementação, ferramenta de profiling (timeit em Python), planilha para plotar.",
                                  "tips": "Ignore constantes pequenas; foque no termo dominante mn.",
                                  "learningObjective": "Derivar notação Big O a partir de loops aninhados em DP.",
                                  "commonMistakes": "Contar apenas loops como O(m+n), esquecendo preenchimento total da tabela."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Complexidade Espacial Padrão",
                                  "subSteps": [
                                    "Identifique o espaço para tabela: (m+1) * (n+1) inteiros, cada O(1), total O(mn).",
                                    "Discuta overhead: strings input O(m+n), mas tabela domina.",
                                    "Calcule em bytes: para m=n=1000, ~4MB assumindo int32.",
                                    "Trace dependências: cada célula usa apenas célula acima, esquerda e diagonal.",
                                    "Confirme que tabela completa é necessária para reconstruir alinhamento, mas não para só distância."
                                  ],
                                  "verification": "Cálculo de espaço para m=1000, n=1000 bate com medição heap (sys.getsizeof).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código fonte, documentação de memória em linguagem usada.",
                                  "tips": "Use sizeof ou memory_profiler para validar teoricamente.",
                                  "learningObjective": "Avaliar espaço em estruturas 2D e identificar dependências.",
                                  "commonMistakes": "Dizer O(m+n) espacial sem justificativa, confundindo com otimizações."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Otimização Espacial para O(min(m,n)) Usando Duas Arrays",
                                  "subSteps": [
                                    "Assuma m ≤ n sem perda de generalidade; otimize para altura m.",
                                    "Use duas arrays de tamanho n+1: prev e curr, atualizando linha por linha.",
                                    "Inicialize prev[0..n] = 0..n; para cada i=1 a m: curr[0]=i, então para j=1 a n: min das três de prev e curr.",
                                    "Copie curr para prev após cada linha; espaço total 2*(n+1) = O(n) = O(min(m,n)).",
                                    "Implemente e compare memória com versão original para m=100, n=1000."
                                  ],
                                  "verification": "Código otimizado retorna mesma distância e usa ~1/100 do espaço original.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Editor de código, profiler de memória, exemplos de strings desbalanceadas.",
                                  "tips": "Troque m e n se m > n para minimizar.",
                                  "learningObjective": "Aplicar análise de dependências para otimizar espaço em DP.",
                                  "commonMistakes": "Atualizar prev incorretamente, perdendo valores necessários para diagonal."
                                }
                              ],
                              "practicalExample": "Para S1='kitten' (m=6), S2='sitting' (n=7): Tabela padrão 7x8, tempo O(42), espaço O(42). Otimizado (min=6): duas arrays de 8, espaço O(16). Trace: distância=3 (sub k->s, ins i, sub e->g).",
                              "finalVerifications": [
                                "Calcula corretamente O(mn) tempo para qualquer m,n.",
                                "Explica por que cada célula é O(1) tempo.",
                                "Justifica O(mn) espaço na implementação naive.",
                                "Implementa e verifica otimização com duas arrays retornando mesmo resultado.",
                                "Compara memória empiricamente para m=100, n=1000.",
                                "Discute trade-offs: otimização quebra reconstrução de caminho."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de O(mn) temporal e espacial.",
                                "Correta implementação da otimização espacial com testes.",
                                "Análise qualitativa de dependências na DP.",
                                "Uso de notação assintótica rigorosa (Θ vs O).",
                                "Evidências empíricas (gráficos/tempos/memória).",
                                "Identificação de pré-condições para otimização (min(m,n))."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e recorrências.",
                                "Algoritmos: Programação Dinâmica geral (Knapsack, LCS).",
                                "Engenharia de Software: Otimização de recursos em sistemas com constraints.",
                                "Bioinformática: Alinhamento de sequências genéticas."
                              ],
                              "realWorldApplication": "Em corretores ortográficos (diff entre palavra digitada e dicionário), alinhamento de DNA (sequências longas, otimização essencial para gigabytes), editores de texto colaborativos (merge conflicts), e busca fuzzy em bancos de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.5.3.3.3",
                            "name": "Aplicar em contexto de similaridade de strings",
                            "description": "Discutir usos em correção ortográfica, busca fuzzy ou alinhamento de DNA, referenciando bibliografia como Cormen et al. e Skiena.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Fundamentos da Similaridade de Strings via Distância de Levenshtein",
                                  "subSteps": [
                                    "Relembrar definição de distância de Levenshtein como mínimo de inserções, deleções e substituições.",
                                    "Calcular distância manualmente para pares de strings exemplo (ex: 'teste' e 'texto').",
                                    "Converter distância em métrica de similaridade (similaridade = 1 - distância / max(len1, len2)).",
                                    "Identificar limiares de similaridade para aplicações práticas (ex: >0.8 para matches).",
                                    "Explorar variações como distância de Damerau-Levenshtein para transposições."
                                  ],
                                  "verification": "Calcular corretamente distância e similaridade para 3 pares de strings fornecidos.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Implementação prévia do algoritmo de Levenshtein",
                                    "Papel e calculadora para simulações manuais",
                                    "Capítulo 15 de Cormen et al. (Introduction to Algorithms)"
                                  ],
                                  "tips": "Comece com strings curtas para visualizar a matriz DP; visualize a matriz para intuição.",
                                  "learningObjective": "Dominar como distância de edição quantifica similaridade entre strings.",
                                  "commonMistakes": "Ignorar normalização de comprimento; confundir distância zero com similaridade perfeita apenas em strings idênticas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar em Correção Ortográfica e Busca Fuzzy",
                                  "subSteps": [
                                    "Construir dicionário de palavras e função para encontrar top-K similares dentro de distância limite.",
                                    "Implementar busca fuzzy: para query com erro, listar candidatos ordenados por distância.",
                                    "Otimizar com estruturas como BK-Tree para dicionários grandes.",
                                    "Testar com erros reais: 'ortografia' -> 'ortografai', 'busca' -> 'buscca'.",
                                    "Avaliar precisão e recall em conjunto de testes com erros introduzidos."
                                  ],
                                  "verification": "Implementar e demonstrar sugestões corretas para 5 palavras com erros comuns.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Linguagem de programação (Python preferencial com biblioteca fuzzywuzzy ou custom)",
                                    "Dicionário de 1000 palavras em português",
                                    "Capítulo sobre string matching em Skiena (Algorithm Design Manual)"
                                  ],
                                  "tips": "Use distância máxima de 2 para eficiência; priorize substituições comuns em idiomas.",
                                  "learningObjective": "Aplicar Levenshtein para correção automática e buscas tolerantes a erros.",
                                  "commonMistakes": "Não limitar distância máxima, levando a buscas lentas; ignorar frequência de palavras no ranking."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Aplicação em Alinhamento de Sequências de DNA",
                                  "subSteps": [
                                    "Mapear strings para sequências biológicas (A,C,G,T como alfabeto).",
                                    "Adaptar Levenshtein para alinhamento global/local, comparando com Needleman-Wunsch.",
                                    "Implementar para sequências curtas de DNA e visualizar alinhamento.",
                                    "Discutir custos: inserção/deleção como gaps, substituição como mismatch.",
                                    "Analisar exemplo: alinhar 'AGCT' e 'AGCCT' com gaps."
                                  ],
                                  "verification": "Produzir alinhamento correto e calcular distância para 2 sequências de DNA exemplo.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Ferramentas bioinformáticas como Biopython",
                                    "Sequências de DNA de GenBank",
                                    "Referências em Cormen et al. seção de sequence alignment"
                                  ],
                                  "tips": "Visualize alinhamentos com ferramentas como Jalview; foque em sequências curtas inicialmente.",
                                  "learningObjective": "Entender adaptação de edit distance para bioinformática.",
                                  "commonMistakes": "Tratar DNA como texto genérico sem considerar gaps biológicos; ignorar penalidades diferenciadas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar Complexidade, Limitações e Referenciar Bibliografia",
                                  "subSteps": [
                                    "Revisar complexidade O(mn) e otimizações (ex: diagonal banding para sequências similares).",
                                    "Discutir limitações: custo computacional para strings longas, insensibilidade a ordem sem Damerau.",
                                    "Referenciar Cormen et al. (Cap. 15) e Skiena (Caps. 11-12) com citações específicas.",
                                    "Comparar com alternativas: Jaro-Winkler para nomes, BLAST para DNA.",
                                    "Escrever relatório resumindo 3 aplicações com análise."
                                  ],
                                  "verification": "Redigir parágrafo citando referências e análise de complexidade com trade-offs.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Livros: Cormen et al., Skiena",
                                    "Ferramentas de análise Big-O (ex: visualizadores online)",
                                    "Editor de texto para relatório"
                                  ],
                                  "tips": "Use citações APA/MLA; foque em como autores conectam edit distance a aplicações.",
                                  "learningObjective": "Integrar teoria bibliográfica com prática em contextos reais.",
                                  "commonMistakes": "Citar superficialmente sem conectar a edit distance; subestimar impacto de mn em big data."
                                }
                              ],
                              "practicalExample": "Desenvolva um corretor ortográfico fuzzy para português: dado 'recbido', sugira 'recebido' como top-1 usando Levenshtein em dicionário de 5000 palavras, otimizado com limite de distância 2, e teste em 10 frases com erros.",
                              "finalVerifications": [
                                "Calcular e explicar similaridade para exemplos em spell check, fuzzy search e DNA.",
                                "Implementar funcionalidade funcional em pelo menos uma aplicação.",
                                "Citar corretamente Cormen et al. e Skiena com páginas/relevância.",
                                "Identificar limitação computacional e uma otimização.",
                                "Demonstrar alinhamento de DNA com gaps.",
                                "Discutir 2 trade-offs em aplicações reais."
                              ],
                              "assessmentCriteria": [
                                "Precisão conceitual e cálculos corretos (30%)",
                                "Qualidade da implementação prática e testes (25%)",
                                "Profundidade em aplicações específicas (20%)",
                                "Referenciação bibliográfica e análise crítica (15%)",
                                "Clareza em explicações e visualizações (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Biologia Computacional: Alinhamento de sequências genéticas.",
                                "Processamento de Linguagem Natural: Correção ortográfica e NER tolerante.",
                                "Ciência de Dados: Busca aproximada em bancos de dados textuais.",
                                "Inteligência Artificial: Matching em recommenders fuzzy."
                              ],
                              "realWorldApplication": "Em motores de busca como Google para sugestões automáticas ('hte' -> 'the'), autocorretores em Word/Smartphones, e ferramentas bioinformáticas como Clustal Omega para alinhamento de DNA em pesquisas genômicas."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.5.3.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.5.4",
                    "name": "Automato de Aho-Corasick",
                    "description": "Estrutura de automato para busca simultânea de múltiplos padrões em um texto.",
                    "individualConcepts": [
                      {
                        "id": "10.1.5.4.1",
                        "name": "Construção do Trie para Múltiplos Padrões",
                        "description": "Criação da estrutura de árvore trie (prefix tree) que armazena eficientemente todos os padrões a serem buscados simultaneamente, permitindo transições rápidas baseadas em caracteres.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.1.1",
                            "name": "Implementar inserção de padrões no Trie",
                            "description": "Desenvolver função para inserir múltiplas cadeias de caracteres no trie, criando nós com transições para cada caractere possível e marcando nós finais de padrões.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura da classe Node para o Trie",
                                  "subSteps": [
                                    "Crie uma classe chamada Node em Python.",
                                    "Adicione um atributo 'children' como um dicionário vazio {} para mapear cada caractere a um nó filho.",
                                    "Adicione um atributo booleano 'is_end_of_word' inicializado como False para marcar o final de um padrão.",
                                    "Implemente o método __init__ para inicializar esses atributos.",
                                    "Adicione um método opcional para imprimir o nó para depuração."
                                  ],
                                  "verification": "Instancie um objeto Node() e imprima seus atributos: children deve ser {} e is_end_of_word False.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Use dict[str, Node] para children, onde str é o caractere (suporte a minúsculas inicialmente).",
                                  "learningObjective": "Entender e implementar a representação básica de um nó em uma Trie.",
                                  "commonMistakes": [
                                    "Inicializar children como None em vez de dict vazio.",
                                    "Esquecer de definir is_end_of_word como atributo de instância."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a classe Trie e o método de inserção para uma única string",
                                  "subSteps": [
                                    "Crie uma classe Trie com um atributo self.root = Node().",
                                    "Defina o método insert(self, pattern: str) -> None.",
                                    "Inicialize current = self.root.",
                                    "Para cada caractere char em pattern: se char não estiver em current.children, crie current.children[char] = Node(); avance current = current.children[char].",
                                    "Ao final, defina current.is_end_of_word = True."
                                  ],
                                  "verification": "Crie um Trie, insira 'he' e verifique manualmente: root.children['h'].children['e'].is_end_of_word == True.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python 3.x",
                                    "Console para testes interativos"
                                  ],
                                  "tips": "Assuma padrões em minúsculas sem espaços; normalize entrada se necessário.",
                                  "learningObjective": "Dominar a lógica de travessia e criação dinâmica de nós durante a inserção de um padrão.",
                                  "commonMistakes": [
                                    "Não atualizar current após criar novo nó.",
                                    "Marcar is_end_of_word no nó errado (ex: no meio da string)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estender a inserção para múltiplos padrões",
                                  "subSteps": [
                                    "Adicione um método build_trie(self, patterns: list[str]) -> None.",
                                    "Implemente um loop for pattern in patterns: self.insert(pattern).",
                                    "Adicione tratamento para padrões vazios: ignore ou levante erro.",
                                    "Opcionalmente, adicione contadores de frequência se múltiplas inserções do mesmo padrão.",
                                    "Teste com lista ['he', 'she'] para verificar sobreposições."
                                  ],
                                  "verification": "Insira ['he', 'she'] e confirme: root -> 'h' -> 'e' (end), e 's' -> 'h' -> 'e' (end).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python 3.x"
                                  ],
                                  "tips": "Reutilize o método insert existente para evitar duplicação de código.",
                                  "learningObjective": "Aprender a modularizar código para lidar com coleções de dados de forma eficiente.",
                                  "commonMistakes": [
                                    "Inserir duplicatas sem tratamento, causando re-inserções desnecessárias.",
                                    "Não lidar com lista vazia, causando erro."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar verificações e depuração da estrutura do Trie",
                                  "subSteps": [
                                    "Adicione um método print_trie(self, node=None, prefix='') para visualizar a Trie recursivamente.",
                                    "Escreva testes unitários: insira padrões e verifique nós finais e profundidade.",
                                    "Teste casos edge: padrão vazio, padrão único char, padrões com sobreposição.",
                                    "Meça tempo de inserção para lista de 100 padrões.",
                                    "Corrija erros identificados nos testes."
                                  ],
                                  "verification": "Execute print_trie() após inserções e confirme estrutura visual; testes passam 100%.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python 3.x",
                                    "Biblioteca unittest ou pytest opcional"
                                  ],
                                  "tips": "Use recursão com cuidado para evitar stack overflow em Tries profundas.",
                                  "learningObjective": "Desenvolver habilidades de teste e depuração em estruturas de dados dinâmicas.",
                                  "commonMistakes": [
                                    "Recursão infinita no print_trie por falta de base case.",
                                    "Ignorar casos edge como strings vazias."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um Trie e use build_trie(['he', 'she', 'his', 'hers']). A estrutura resultante terá: root.children['h']['e'](end) com filho 'r'['s'](end); 'h']['i']['s'](end); 's']['h']['e'](end). Verifique imprimindo a Trie ou buscando prefixos.",
                              "finalVerifications": [
                                "Todos os padrões inseridos têm nós finais marcados corretamente com is_end_of_word=True.",
                                "Sobreposições são gerenciadas: prefixos compartilhados usam o mesmo nó.",
                                "Nenhum nó extra é criado para caracteres não necessários.",
                                "Inserção de múltiplos padrões (ex: 10+) mantém eficiência sem erros.",
                                "Casos edge (padrão vazio, duplicatas) são tratados sem crash.",
                                "Estrutura é imprimível e navegável manualmente."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todos os padrões são inseridos e recuperáveis via travessia.",
                                "Eficiência: Tempo O(total comprimento dos padrões), sem buscas lineares.",
                                "Robustez: Lida com caracteres especiais, vazios e duplicatas.",
                                "Modularidade: Métodos insert e build_trie bem separados.",
                                "Testabilidade: Inclui verificações e prints para depuração.",
                                "Legibilidade: Código comentado com nomes claros de variáveis."
                              ],
                              "crossCurricularConnections": [
                                "Ciência da Computação: Estruturas de árvores e grafos direcionados.",
                                "Matemática Discreta: Autômatos finitos e linguagens regulares.",
                                "Engenharia de Software: Princípios OOP e modularidade.",
                                "Inteligência Artificial: Aplicações em processamento de linguagem natural (NLP)."
                              ],
                              "realWorldApplication": "Construção do Trie é o primeiro passo no algoritmo Aho-Corasick para busca simultânea de múltiplos padrões em textos grandes, usado em antivírus (detecção de malware), motores de busca (autocompletar), filtros de spam e análise de logs em sistemas de segurança."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.2",
                            "name": "Representar estrutura de nós do Trie",
                            "description": "Definir classe ou estrutura para nós do trie contendo mapa de transições, lista de padrões terminados e ponteiro para nó pai.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar componentes essenciais de um nó Trie",
                                  "subSteps": [
                                    "Analise o papel do nó no Trie: armazena transições por caractere, indica fim de padrões e mantém referência ao pai.",
                                    "Liste os campos necessários: mapa de transições (dict<char, node>), lista de padrões terminados (list<string>), ponteiro para nó pai (node* ou None).",
                                    "Pesquise referências no contexto Aho-Corasick para confirmar inclusão de output (padrões terminados).",
                                    "Desenhe um diagrama simples de um nó com setas para children, parent e output.",
                                    "Documente por que cada campo é crucial para construção e busca eficiente."
                                  ],
                                  "verification": "Crie um esboço escrito ou diagrama confirmando os três componentes principais listados corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de diagramação como Draw.io",
                                    "Documentação de Aho-Corasick"
                                  ],
                                  "tips": "Comece pelo nó raiz (parent=None) para visualizar melhor.",
                                  "learningObjective": "Compreender os atributos fundamentais de um nó Trie no contexto de múltiplos padrões.",
                                  "commonMistakes": [
                                    "Esquecer o ponteiro pai, essencial para backtracking",
                                    "Confundir lista de padrões com flag booleana simples"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a classe ou estrutura básica do nó",
                                  "subSteps": [
                                    "Escolha Python para implementação (classe Node).",
                                    "Defina atributos: self.children = {}, self.outputs = [], self.parent = None.",
                                    "Use dict para children com chaves como str (caracteres) e valores como Node.",
                                    "Garanta que outputs seja uma lista mutável para múltiplos padrões.",
                                    "Adicione docstring explicando cada atributo."
                                  ],
                                  "verification": "Escreva o código da classe vazia e execute sem erros de sintaxe.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código como VS Code ou Jupyter Notebook",
                                    "Referência Python dict e list"
                                  ],
                                  "tips": "Use typing hints: from typing import Dict, List, Optional; self.children: Dict[str, 'Node']",
                                  "learningObjective": "Criar uma representação orientada a objetos precisa da estrutura de nó.",
                                  "commonMistakes": [
                                    "Usar lista para children em vez de dict, perdendo eficiência O(1)",
                                    "Tornar parent obrigatório, ignorando raiz"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o construtor e métodos auxiliares iniciais",
                                  "subSteps": [
                                    "Crie __init__(self, parent=None) que inicializa children={}, outputs=[], self.parent=parent.",
                                    "Adicione método get_child(char): retorna self.children.get(char).",
                                    "Implemente add_output(pattern): self.outputs.append(pattern).",
                                    "Teste o construtor criando um nó raiz e um child manualmente.",
                                    "Verifique se parent é corretamente propagado ao criar child."
                                  ],
                                  "verification": "Instancie dois nós (raiz e child) e imprima atributos para confirmar inicialização.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Ambiente Python executável",
                                    "Console para print/debug"
                                  ],
                                  "tips": "Sempre inicialize com parent=None para evitar recursão infinita.",
                                  "learningObjective": "Garantir que a estrutura suporte inserção dinâmica de transições e padrões.",
                                  "commonMistakes": [
                                    "Não inicializar listas vazias, causando erros em append",
                                    "Ignorar propagação de parent em filhos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e refinar a estrutura com exemplo prático",
                                  "subSteps": [
                                    "Crie um Trie simples com padrões ['he', 'she'] e inspecione nós.",
                                    "Confirme que nó de 'e' tem outputs=['he'], parent apontando corretamente e children vazios.",
                                    "Adicione método __repr__ para visualização fácil: f'Node(outputs={self.outputs}, children={len(self.children)})'",
                                    "Teste cenários edge: nó sem children, múltiplos outputs.",
                                    "Refatore se necessário para incluir fail pointer stub (para Aho-Corasick futuro)."
                                  ],
                                  "verification": "Execute código de teste e confirme saídas esperadas no console.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código dos steps anteriores",
                                    "Padrões de teste: ['he', 'she', 'hers']"
                                  ],
                                  "tips": "Use assert para automação: assert len(node.outputs) == 1",
                                  "learningObjective": "Aplicar a estrutura em um mini-Trie e identificar refinamentos.",
                                  "commonMistakes": [
                                    "Não tratar caracteres minúsculos/maiusculos uniformemente",
                                    "Outputs duplicados sem verificação"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python: class TrieNode: def __init__(self, parent=None): self.children = {}; self.outputs = []; self.parent = parent. Crie raiz = TrieNode(); child_h = TrieNode(raiz); raiz.children['h'] = child_h; child_e = TrieNode(child_h); child_h.children['e'] = child_e; child_e.outputs.append('he'). Isso representa nós para padrão 'he'.",
                              "finalVerifications": [
                                "Classe possui exatamente children (dict), outputs (list) e parent (Node/None).",
                                "Construtor inicializa atributos vazios corretamente.",
                                "Método get_child retorna None para transições inexistentes.",
                                "add_output permite múltiplos padrões no mesmo nó.",
                                "Nó raiz tem parent=None; filhos têm parent válido.",
                                "Representação permite backtracking via parent."
                              ],
                              "assessmentCriteria": [
                                "Precisão dos três campos obrigatórios (100% match).",
                                "Eficiência: children como dict/hashmap.",
                                "Robustez: construtor lida com parent=None.",
                                "Documentação: docstrings e comentários claros.",
                                "Testabilidade: métodos simples para verificação.",
                                "Extensibilidade: pronto para fail pointers em Aho-Corasick."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Grafos: nós como vértices com arestas rotuladas.",
                                "Programação Orientada a Objetos: encapsulamento de estado de nó.",
                                "Teoria de Autômatos: estados finitos com transições.",
                                "Análise de Algoritmos: complexidade O(1) por transição."
                              ],
                              "realWorldApplication": "Em motores de busca como Google ou antivírus (ex: ClamAV), nós Trie aceleram matching de múltiplos padrões em textos grandes, detectando spam, malware signatures ou autocomplete em apps."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.1.3",
                            "name": "Gerenciar alfabeto finito nas transições",
                            "description": "Implementar transições para um alfabeto definido (ex: 26 letras minúsculas), usando arrays ou mapas para acesso O(1).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e mapear o alfabeto finito",
                                  "subSteps": [
                                    "Identifique o alfabeto alvo, como 26 letras minúsculas (a-z).",
                                    "Crie um mapeamento de caracteres para índices inteiros (ex: 'a' -> 0, 'b' -> 1).",
                                    "Defina o tamanho do alfabeto (ex: ALPHABET_SIZE = 26).",
                                    "Implemente uma função de mapeamento segura para caracteres válidos.",
                                    "Trate caracteres inválidos com fallback para raiz ou caractere especial."
                                  ],
                                  "verification": "Execute uma função de teste que mapeia todos os caracteres do alfabeto e verifica índices corretos sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código, documentação da linguagem (Python/C++), tabela ASCII.",
                                  "tips": "Use constantes para ALPHABET_SIZE para facilitar manutenção.",
                                  "learningObjective": "Compreender como representar um alfabeto finito numericamente para acesso eficiente.",
                                  "commonMistakes": "Esquecer de tratar caracteres maiúsculos ou fora do alfabeto, causando crashes."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar estrutura de transições com array para O(1)",
                                  "subSteps": [
                                    "Crie um array multidimensional ou de ponteiros para cada nó do Trie (ex: vector<vector<int>> transitions(num_nodes, vector<int>(26, -1)).",
                                    "Inicialize transições como -1 ou nó inválido para estados vazios.",
                                    "Implemente método para definir transição: transitions[current_node][char_index] = next_node.",
                                    "Adicione verificação de bounds antes de acessar o array.",
                                    "Teste inserção de um padrão simples e verifique transições criadas."
                                  ],
                                  "verification": "Insira um padrão como 'abc' e imprima a matriz de transições do nó raiz para confirmar índices corretos.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, debugger, exemplos de Trie em Python/C++.",
                                  "tips": "Prefira arrays fixos sobre maps para garantir O(1) em todos os acessos.",
                                  "learningObjective": "Dominar o uso de arrays indexados por caracteres para transições eficientes.",
                                  "commonMistakes": "Usar map<std::string, int> em vez de array, perdendo O(1); inicializar sem -1."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar transições no Trie do Aho-Corasick",
                                  "subSteps": [
                                    "Modifique a classe Nó do Trie para incluir o array de transições.",
                                    "Atualize o método de inserção de padrões para preencher transições durante a construção.",
                                    "Implemente função de transição: get_next(current, char) que usa mapeamento e array.",
                                    "Adicione fail pointers básicos compatíveis com transições.",
                                    "Construa Trie com múltiplos padrões e navegue uma string de teste."
                                  ],
                                  "verification": "Construa Trie com padrões ['he', 'she', 'his'] e processe 'ushers' para verificar saltos corretos via transições.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Código base do Trie Aho-Corasick, strings de teste.",
                                  "tips": "Mantenha transições e fail pointers separados para clareza.",
                                  "learningObjective": "Integrar gerenciamento de alfabeto nas transições do Trie multi-padrão.",
                                  "commonMistakes": "Não sincronizar transições com inserções, causando nós perdidos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar, testar e validar performance O(1)",
                                  "subSteps": [
                                    "Meça tempo de acesso a transições com benchmark simples (ex: 1M acessos).",
                                    "Implemente handling para alfabeto expandido se necessário (ex: a-zA-Z).",
                                    "Adicione unit tests para edge cases: char inválido, nó sem transição.",
                                    "Compare performance com versão map-based.",
                                    "Documente tamanho de memória usado pelo array."
                                  ],
                                  "verification": "Benchmark mostra tempo médio <1ns por transição; todos tests passam.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Ferramentas de profiling (timeit Python, gprof C++), framework de testes (pytest/unittest).",
                                  "tips": "Use char - 'a' para mapeamento simples em C++.",
                                  "learningObjective": "Validar eficiência O(1) e robustez das transições.",
                                  "commonMistakes": "Ignorar overhead de memória em alfabetos grandes; testes insuficientes para inválidos."
                                }
                              ],
                              "practicalExample": "Em um Trie Aho-Corasick para padrões ['cat', 'dog'], ao inserir 'cat', defina transitions[0]['c'-'a'] = 1, transitions[1]['a'-'a'] = 2, etc. Processando 'caterpillar', transições: raiz ->1('c') ->2('a') ->3('t') -> fallback para 'e'.",
                              "finalVerifications": [
                                "Todas transições para alfabeto a-z são definidas ou fallback corretamente.",
                                "Acesso a qualquer transição leva O(1) tempo confirmado por benchmark.",
                                "Processamento de string longa encontra padrões sem falhas.",
                                "Memória alocada é previsível (num_nodes * 26 * sizeof(int)).",
                                "Edge cases (char inválido, Trie vazio) não crasham.",
                                "Integração com fail pointers preserva matches corretos."
                              ],
                              "assessmentCriteria": [
                                "Eficiência: Todas transições O(1) com array, não maps.",
                                "Correção: 100% de acerto em unit tests de navegação.",
                                "Robustez: Trata chars fora alfabeto sem erros.",
                                "Clareza: Código bem comentado com mapeamento explícito.",
                                "Performance: Benchmark < versão map em 10x.",
                                "Escalabilidade: Funciona para 1000+ nós."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Grafos dirigidos com rótulos em alfabeto finito.",
                                "Ciência da Computação: Estruturas de dados (arrays vs. hash tables).",
                                "Engenharia de Software: Otimização de tempo/espaço em autômatos.",
                                "Linguística Computacional: Modelagem de linguagens formais."
                              ],
                              "realWorldApplication": "Em motores de busca como Google ou antivírus (ex: ClamAV), onde Aho-Corasick varre gigabytes de texto por assinaturas maliciosas em tempo real, usando transições O(1) para throughput máximo."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.2",
                        "name": "Construção das Ligações de Falha e Saída",
                        "description": "Computação da função de falha (failure links) similar ao KMP, e links de saída para propagar matches de padrões, completando o autômato.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.2.1",
                            "name": "Calcular ligações de falha via BFS",
                            "description": "Usar fila (BFS) para processar nós do trie em ordem de profundidade, definindo falhas para transições inexistentes apontando para o nó mais longo sufixo-prefixo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar o Trie e a Estrutura de BFS",
                                  "subSteps": [
                                    "Construa o trie a partir dos padrões inseridos, garantindo que cada nó tenha transições para caracteres filhos.",
                                    "Inicialize o ponteiro de falha (fail) para todos os nós como null ou raiz.",
                                    "Crie uma fila (queue) vazia para BFS e defina a profundidade ou nível do nó raiz como 0.",
                                    "Enfileire todos os filhos diretos da raiz, marcando suas falhas como apontando para a raiz.",
                                    "Configure o ponteiro de saída (output) da raiz como vazio."
                                  ],
                                  "verification": "Verifique se a fila contém apenas os filhos da raiz e todas as falhas iniciais estão corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Implementação do trie em Python ou pseudocódigo",
                                    "Diagrama do trie desenhado à mão"
                                  ],
                                  "tips": "Use uma fila de pares (nó, profundidade) para rastrear níveis explicitamente.",
                                  "learningObjective": "Entender a preparação inicial para traversal BFS no trie.",
                                  "commonMistakes": [
                                    "Esquecer de enfileirar filhos da raiz",
                                    "Não inicializar falhas da raiz corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processar Nós na Fila BFS",
                                  "subSteps": [
                                    "Enquanto a fila não estiver vazia, desinfileire o nó atual (u).",
                                    "Para cada caractere possível nas transições de u, verifique se existe transição direta.",
                                    "Se existir, processe o filho v = transição(u, char) e calcule sua falha.",
                                    "Atualize a profundidade de v como profundidade(u) + 1.",
                                    "Enfileire v apenas se não processado anteriormente."
                                  ],
                                  "verification": "Confirme que cada nó é processado exatamente uma vez por nível de profundidade.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código de fila (collections.deque em Python)",
                                    "Exemplo de trie com 3-4 padrões"
                                  ],
                                  "tips": "Mantenha um array de visitados para evitar reprocessamento.",
                                  "learningObjective": "Dominar o loop principal de BFS para traversal nivelado.",
                                  "commonMistakes": [
                                    "Processar nós fora de ordem de profundidade",
                                    "Enfileirar nós múltiplas vezes"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Ligações de Falha para Transições Inexistentes",
                                  "subSteps": [
                                    "Para o nó atual u e caractere c sem transição direta, siga a falha de u (pai_fail) até encontrar um ancestral com transição para c.",
                                    "Defina fail(v) como o nó mais profundo (mais longo sufixo) que tem transição para c.",
                                    "Copie as saídas (output link) do fail(v) para v, se aplicável.",
                                    "Para transições existentes em v, defina-as apontando para transição(fail(v), c).",
                                    "Atualize o output link de v para incluir saídas próprias e herdadas."
                                  ],
                                  "verification": "Para cada transição inexistente, a falha aponta para o sufixo-prefixo correto.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Pseudocódigo do algoritmo de falha",
                                    "Ferramenta de debug como papel e lápis para tracing"
                                  ],
                                  "tips": "Implemente um loop while para subir na cadeia de falhas até encontrar match.",
                                  "learningObjective": "Implementar a lógica de KMP-like para sufixos no contexto de trie.",
                                  "commonMistakes": [
                                    "Parar no primeiro ancestral sem verificar sufixo mais longo",
                                    "Não propagar outputs corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar e Validar as Ligações de Falha",
                                  "subSteps": [
                                    "Após processar toda a fila, verifique todas as falhas e transições derivadas.",
                                    "Teste com um texto de entrada simulada para matching.",
                                    "Ajuste qualquer falha que aponte para si mesma ou ciclos incorretos.",
                                    "Documente o grafo final de falhas.",
                                    "Otimize para cache de transições (goto function)."
                                  ],
                                  "verification": "Execute uma busca simples e confirme matches corretos via falhas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Texto de teste com padrões overlapping",
                                    "Visualizador de grafos como Graphviz"
                                  ],
                                  "tips": "Sempre teste com padrões que tenham sufixos compartilhados, ex: 'he' e 'hers'.",
                                  "learningObjective": "Validar a corretude do autômato completo.",
                                  "commonMistakes": [
                                    "Ignorar falhas na raiz para chars inexistentes",
                                    "Não lidar com profundidade 0 corretamente"
                                  ]
                                }
                              ],
                              "practicalExample": "Para padrões ['he', 'hers', 'she']: No trie, para nó 'r' em 'hers', falha aponta para raiz (vazio), mas transição 's' via falha vai para 's' de 'she'. Simule BFS: raiz -> h,s -> he,sh,he r -> hers, etc., calculando fail('ers') -> 'rs' não existe, sobe para 's' de she.",
                              "finalVerifications": [
                                "Todas as falhas apontam para sufixos-prefixos corretos sem ciclos.",
                                "Transições inexistentes são resolvidas via falha em O(1) médio.",
                                "Outputs incluem matches próprios e herdados.",
                                "BFS processou todos os nós exatamente uma vez.",
                                "Teste com texto 'hershe' encontra 'he', 'hers', 'she' corretamente.",
                                "Profundidades respeitam ordem BFS."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de fail links (100% corretos em exemplo dado).",
                                "Eficiência: tempo O(total chars + alfabeto * estados).",
                                "Tratamento correto de bordas (raiz, folhas).",
                                "Código limpo com comentários em pontos críticos.",
                                "Validação via testes unitários em 3 cenários.",
                                "Explicação clara do raciocínio para um par nó-falha."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Traversal BFS em árvores/acíclicos.",
                                "Estruturas de Dados: Filas e tries para strings.",
                                "Algoritmos de Strings: Similar ao KMP para sufixos.",
                                "Programação Competitiva: Otimização para múltiplos padrões."
                              ],
                              "realWorldApplication": "Em sistemas de detecção de intrusão (Snort), busca múltipla de assinaturas em pacotes de rede; em bioinformática para encontrar múltiplos genes em sequências de DNA; em editores de texto para highlight de termos relacionados."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.2",
                            "name": "Implementar links de saída (output links)",
                            "description": "Construir cadeia de links de saída nos nós terminais para relatar todos os padrões que terminam em um match, seguindo falhas até a raiz.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Failure Links e Identificar Nós Terminais",
                                  "subSteps": [
                                    "Relembre a construção do trie e das failure links via BFS.",
                                    "Identifique todos os nós terminais (que correspondem ao fim de um padrão).",
                                    "Anote os padrões associados a cada nó terminal.",
                                    "Crie uma lista de outputs iniciais para cada nó (o próprio padrão se terminal).",
                                    "Verifique que failure links já estão corretamente implementados."
                                  ],
                                  "verification": "Lista de nós terminais e seus outputs iniciais impressa ou logada corretamente.",
                                  "estimatedTime": "20-30 minutes",
                                  "materials": [
                                    "Código fonte do Aho-Corasick com trie e failure links",
                                    "Editor de código (VS Code ou similar)",
                                    "Papel e caneta para diagrama"
                                  ],
                                  "tips": "Desenhe o trie manualmente para visualizar failure links antes de codificar.",
                                  "learningObjective": "Compreender como failure links propagam informações de matches para output links.",
                                  "commonMistakes": "Confundir failure link (para transição) com output link (para coleta de matches); sempre diferencie os dois."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Construção dos Output Links via BFS",
                                  "subSteps": [
                                    "Modifique o BFS de failure links para também construir output links.",
                                    "Para cada nó, defina output_link como o output_link do nó de failure, se não terminal.",
                                    "Se o nó atual for terminal, adicione seu próprio output ao output_link.",
                                    "Mantenha uma lista ou conjunto de padrões em cada output_link.",
                                    "Atualize recursivamente: output_link(nó) = union de outputs do nó e do failure(nó)."
                                  ],
                                  "verification": "Execute BFS e imprima output links para cada nó; verifique se propagam corretamente.",
                                  "estimatedTime": "30-45 minutes",
                                  "materials": [
                                    "Código do Step 1",
                                    "Exemplo de trie pequeno com 3-4 padrões",
                                    "Debugger para inspecionar nós"
                                  ],
                                  "tips": "Use uma fila BFS e processe nó por nó, copiando outputs do pai de failure.",
                                  "learningObjective": "Implementar propagação eficiente de matches através de failure chains sem recursão excessiva.",
                                  "commonMistakes": "Não unionar outputs corretamente, perdendo matches múltiplos; teste com padrões sobrepostos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar Output Links na Função de Matching",
                                  "subSteps": [
                                    "Na função de matching, ao chegar em um nó via transição, colete todos os outputs desse nó.",
                                    "Siga o output_link chain até a raiz, reportando todos os padrões encontrados.",
                                    "Otimize evitando loops: use o output_link precomputado em vez de seguir failure toda vez.",
                                    "Implemente relatório de matches com posições no texto.",
                                    "Adicione logging para mostrar cadeia de output links seguida."
                                  ],
                                  "verification": "Teste matching em texto com múltiplos padrões; todos matches reportados sem duplicatas.",
                                  "estimatedTime": "25-40 minutes",
                                  "materials": [
                                    "Código completo até Step 2",
                                    "Textos de teste com padrões sobrepostos",
                                    "Unit tests framework (ex: Jest)"
                                  ],
                                  "tips": "Precompute output_link para O(1) coleta durante matching, evitando gargalos.",
                                  "learningObjective": "Aplicar output links para relatar todos matches terminando em um estado de forma eficiente.",
                                  "commonMistakes": "Seguir failure links em runtime em vez de output_link, causando lentidão; sempre use precomputado."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Otimizar a Implementação Completa",
                                  "subSteps": [
                                    "Crie casos de teste: padrões simples, sobrepostos, vazios.",
                                    "Execute matching em textos longos e meça performance.",
                                    "Verifique se todos padrões em chains de failure são reportados.",
                                    "Otimize memória se listas de outputs crescerem muito (use bitsets para padrões múltiplos).",
                                    "Documente a função com comentários sobre output links."
                                  ],
                                  "verification": "100% pass em unit tests; performance linear no tamanho do texto.",
                                  "estimatedTime": "20-35 minutes",
                                  "materials": [
                                    "Código final",
                                    "Suite de testes",
                                    "Profiler (ex: Node.js inspector)"
                                  ],
                                  "tips": "Use padrões como ['he', 'she', 'his', 'hers'] para testar chains profundas.",
                                  "learningObjective": "Garantir robustez da implementação de output links em cenários reais.",
                                  "commonMistakes": "Ignorar matches na raiz ou em chains longas; sempre teste com 'a' e 'ab'."
                                }
                              ],
                              "practicalExample": "Padrões: ['he', 'she', 'his', 'hers']. No trie, nó 's' (de 'she') tem failure para 'h' (de 'he'), output_link de 's' inclui 'she' e segue para 'he'. Em texto 'ushers', ao matching em 's' final, reporta 'she', 'he', 'hers' via chain.",
                              "finalVerifications": [
                                "Todos nós terminais têm outputs corretos propagados via output_links.",
                                "Matching reporta todos padrões terminando em cada posição sem omissões.",
                                "Performance é O(n + z) onde n=texto, z=ocorrências.",
                                "Chains de failure até raiz coletam todos matches corretamente.",
                                "Nenhum loop infinito em output_link chains.",
                                "Testes com padrões sobrepostos passam 100%."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todos matches reportados via output_links.",
                                "Eficiência: Output_links precomputados evitam traversal em runtime.",
                                "Robustez: Lida com trie vazio, padrões duplicados, texto vazio.",
                                "Clareza: Código comentado diferenciando failure/output links.",
                                "Otimização: Memória e tempo adequados para tamanhos reais.",
                                "Testes: Cobertura mínima de 90% com asserts em outputs."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Output_links como caminhos em grafo de falhas.",
                                "Programação Funcional: Union de sets de outputs como operação fold.",
                                "Estruturas de Dados: Uso de queues BFS e maps para nós.",
                                "Análise de Algoritmos: Amortização em chains de failure.",
                                "Engenharia de Software: Unit testing para algoritmos avançados."
                              ],
                              "realWorldApplication": "Em motores de busca múltiplos padrões como antivírus (Snort), filtros de spam ou IDEs (busca de símbolos em código), onde texto longo é escaneado por milhares de padrões, reportando todas ocorrências sobrepostas eficientemente."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.2.3",
                            "name": "Preencher transições de falha no automato",
                            "description": "Para cada nó e caractere sem transição direta, copiar transição do nó de falha, recursivamente até encontrar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a estrutura do autômato e verificar pré-requisitos",
                                  "subSteps": [
                                    "Liste todos os nós (estados) do trie construído, numerando-os sequencialmente.",
                                    "Defina o alfabeto completo (ex: {a, b, c, ..., z}).",
                                    "Confirme que os ponteiros de falha (fail) já foram computados para todos os nós.",
                                    "Inicialize uma tabela de transições delta[state][char] copiando as transições diretas existentes do trie e marcando as ausentes como 'null'.",
                                    "Configure a raiz: fail(raiz) = raiz e delta(raiz, char ausente) = raiz."
                                  ],
                                  "verification": "Verifique se todos os nós têm fail pointers definidos e se a tabela delta reflete corretamente as transições diretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama do trie impresso ou desenhado, pseudocódigo do algoritmo anterior de fail, editor de código ou planilha para tabela delta.",
                                  "tips": "Desenhe o grafo do trie com setas de fail para visualizar dependências.",
                                  "learningObjective": "Entender a dependência das transições de falha nos ponteiros fail já computados.",
                                  "commonMistakes": "Esquecer de tratar transições da raiz como auto-referentes; assumir alfabeto incompleto."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar função recursiva para resolução de transições",
                                  "subSteps": [
                                    "Defina uma função get_transition(state, char): se delta[state][char] existe, retorne; senão, retorne get_transition(fail[state], char).",
                                    "Adicione base case: se state == raiz e delta[raiz][char] não existe, retorne raiz.",
                                    "Teste a função recursivamente em um exemplo pequeno para estados sem transição direta.",
                                    "Registre chamadas para detectar profundidade de recursão e potenciais loops.",
                                    "Implemente uma versão com cache simples (mapa state-char -> resultado) para memoização básica."
                                  ],
                                  "verification": "Execute get_transition em transições conhecidas e ausentes; confirme que retorna o estado correto sem loops infinitos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (Python/JavaScript), debugger para rastrear recursão, exemplo de trie pequeno.",
                                  "tips": "Use print/debug para rastrear a cadeia de fails seguida durante a recursão.",
                                  "learningObjective": "Dominar recursão sobre a cadeia de falha para resolver transições ausentes.",
                                  "commonMistakes": "Não tratar o caso da raiz corretamente, causando recursão infinita; ignorar memoização em grafos profundos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Preencher todas as transições faltantes na tabela",
                                  "subSteps": [
                                    "Percorra todos os estados u (exceto raiz inicialmente) em ordem BFS ou topológica baseada em fail.",
                                    "Para cada char c no alfabeto, se delta[u][c] == null, defina delta[u][c] = get_transition(u, c).",
                                    "Atualize a tabela de forma iterativa para estados processados, garantindo completude.",
                                    "Para a raiz, preencha delta[raiz][c] ausentes como raiz.",
                                    "Salve a tabela completa em formato legível (JSON/CSV)."
                                  ],
                                  "verification": "Confirme que 100% das entradas em delta[state][char] estão preenchidas para todos states e chars.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Código da função get_transition, estrutura de dados para delta (array 2D ou mapa), validador de completude.",
                                  "tips": "Processar em ordem BFS garante que transições de fails inferiores já estejam preenchidas.",
                                  "learningObjective": "Aplicar recursão de forma sistemática para tornar o autômato completo e determinístico.",
                                  "commonMistakes": "Processar estados fora de ordem, causando chamadas recursivas desnecessárias; esquecer chars do alfabeto."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e otimizar o autômato preenchido",
                                  "subSteps": [
                                    "Simule transições para sequências de teste, comparando com resolução manual recursiva.",
                                    "Verifique ausência de ciclos em cadeias de fail para qualquer char.",
                                    "Otimize substituindo recursão por laço não-recursivo: while sem transição, state = fail[state].",
                                    "Meça performance: tempo de preenchimento e consultas delta.",
                                    "Documente mudanças na tabela delta com exemplos de cópias."
                                  ],
                                  "verification": "Todas simulações de strings de teste processam sem erros e encontram matches corretos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Strings de teste curtas, simulador de autômato, profiler de código.",
                                  "tips": "Use laço while para otimização: evite recursão em autômatos grandes.",
                                  "learningObjective": "Garantir corretude e eficiência do autômato completo.",
                                  "commonMistakes": "Não validar contra casos onde fail aponta para si mesmo; otimizar prematuramente sem testar."
                                }
                              ],
                              "practicalExample": "Trie para padrões 'a', 'ab' sobre alfabeto {a,b}. Nós: raiz(0), 1('a'), 2('ab'). fail[1]=0, fail[2]=1. Transições diretas: delta[0]['a']=1, delta[1]['b']=2. Preenchimento: delta[1]['a'] = delta[0]['a']=1; delta[2]['a']=delta[1]['a']=1; delta[0]['b']=0 (raiz), delta[2]['b']=delta[1]['b']=2. Resultado: tabela completa sem nulls.",
                              "finalVerifications": [
                                "Todas as  |estados| * |alfabeto| entradas em delta estão definidas.",
                                "Para qualquer delta[u][c] copiada, get_transition(u,c) recursivo retorna o mesmo.",
                                "Simulação de strings como 'aba' segue transições corretamente sem falhas.",
                                "Nenhuma cadeia de fail para um char forma ciclo infinito.",
                                "Tempo de consulta delta é O(1) após preenchimento.",
                                "Matches de padrões originais preservados em buscas."
                              ],
                              "assessmentCriteria": [
                                "Correção: 100% das transições resolvidas coincidem com definição recursiva (40%).",
                                "Completude: Nenhuma entrada null na tabela final (20%).",
                                "Eficiência: Uso de memoização ou laço evita recursão profunda (20%).",
                                "Clareza: Código comentado com exemplos inline (10%).",
                                "Validação: Testes automatizados para casos edge (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Computação: Construção de autômatos finitos determinísticos (AFD).",
                                "Estruturas de Dados: Grafos direcionados e travessia BFS/recursiva.",
                                "Algoritmos: Otimização de consultas com memoização dinâmica.",
                                "Programação: Recursão vs iteração em estruturas acíclicas."
                              ],
                              "realWorldApplication": "Em motores de busca de múltiplos padrões como grep avançado, detecção de malware via assinaturas de strings maliciosas, ou matching de sequências genéticas em bioinformática, onde o autômato completo permite buscas eficientes O(n + m) em textos longos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.5.4.3",
                        "name": "Busca Simultânea no Texto",
                        "description": "Utilização do autômato completo para percorrer o texto de entrada, detectando e reportando todas as ocorrências dos padrões em tempo linear.",
                        "specificSkills": [
                          {
                            "id": "10.1.5.4.3.1",
                            "name": "Processar texto caractere por caractere",
                            "description": "Implementar função de busca que inicia na raiz e segue transições (ou falhas) para cada caractere do texto, coletando matches.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar o estado e estruturas de dados",
                                  "subSteps": [
                                    "Defina o estado atual (current_state) como 0, representando a raiz do autômato.",
                                    "Crie uma lista vazia para armazenar os matches encontrados (ex: matches = []).",
                                    "Inicialize um contador de posição no texto (ex: pos = 0).",
                                    "Verifique se o autômato Aho-Corasick está pré-construído com goto, fail e output links.",
                                    "Prepare o texto de entrada como uma string iterável."
                                  ],
                                  "verification": "Confirme que current_state == 0, matches está vazia e pos == 0.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Código do autômato Aho-Corasick construído",
                                    "Editor de código (VS Code ou similar)",
                                    "Exemplo de texto de teste"
                                  ],
                                  "tips": "Sempre inicialize matches como lista vazia para evitar resíduos de execuções anteriores.",
                                  "learningObjective": "Compreender o ponto de partida do algoritmo de busca múltipla.",
                                  "commonMistakes": [
                                    "Não resetar current_state para 0",
                                    "Usar lista não vazia para matches",
                                    "Esquecer de preparar o texto como iterável"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Processar transições para cada caractere do texto",
                                  "subSteps": [
                                    "Inicie um loop for para cada caractere c no texto (usando pos como índice).",
                                    "Enquanto não existir transição goto(current_state, c), defina current_state = fail[current_state].",
                                    "Se existir transição, defina current_state = goto(current_state, c).",
                                    "Caso contrário, após falhas, defina current_state = goto(0, c) ou 0 se não existir.",
                                    "Atualize pos += 1 após processar o caractere."
                                  ],
                                  "verification": "Para cada caractere, current_state é atualizado corretamente e pos avança.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Implementação de goto e fail do autômato",
                                    "Texto de teste com padrões conhecidos"
                                  ],
                                  "tips": "O loop de falha deve priorizar transições diretas antes de seguir fail links.",
                                  "learningObjective": "Dominar a navegação no autômato usando transições e links de falha.",
                                  "commonMistakes": [
                                    "Loop infinito em falhas sem base case (estado 0)",
                                    "Não tratar caracteres ausentes na raiz",
                                    "Incrementar pos antes de processar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Coletar matches nos estados visitados",
                                  "subSteps": [
                                    "Após atualizar current_state para o caractere, defina temp_state = current_state.",
                                    "Enquanto temp_state != 0, colete outputs[temp_state] e adicione à lista de matches com posição pos.",
                                    "Defina temp_state = output_link[temp_state] ou fail[temp_state] para chain de outputs.",
                                    "Registre a posição atual do texto para cada match encontrado.",
                                    "Evite duplicatas adicionando apenas se output não vazio."
                                  ],
                                  "verification": "Todos os estados de match no chain de output são visitados e adicionados aos matches.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função de output_link pré-computada",
                                    "Lista de matches para debug"
                                  ],
                                  "tips": "Use um loop while para percorrer toda a chain de output links eficientemente.",
                                  "learningObjective": "Implementar coleta recursiva de matches via links de saída.",
                                  "commonMistakes": [
                                    "Parar na primeira output sem seguir chain",
                                    "Adicionar matches duplicados",
                                    "Esquecer posição do match"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar processamento e retornar resultados",
                                  "subSteps": [
                                    "Após o loop do texto, verifique matches finais.",
                                    "Formate os matches com palavras encontradas e posições (ex: [{'word': 'he', 'pos': 1}]).",
                                    "Teste com texto conhecido para validar todos matches.",
                                    "Otimize para eficiência O(n + z) onde z é saídas.",
                                    "Retorne a lista de matches ordenada por posição."
                                  ],
                                  "verification": "Função retorna lista completa de matches com posições corretas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Casos de teste unitários",
                                    "Ferramenta de debug (print ou logger)"
                                  ],
                                  "tips": "Ordene matches por posição para facilitar análise.",
                                  "learningObjective": "Integrar processamento e saída para função completa.",
                                  "commonMistakes": [
                                    "Retornar antes de coletar todos outputs",
                                    "Não ordenar ou formatar resultados",
                                    "Ignorar matches no estado final"
                                  ]
                                }
                              ],
                              "practicalExample": "Para autômato com dicionário ['he', 'she', 'hers'] processando 'ushers': Inicie em raiz (0). 'u'->falha para 0. 's'->estado S. 'h'->falha para H (match 'he' via output? não), mas segue para estado com 'sh'. 'e'->match 'he' e 'she'. 'r'->falha coletando 'hers'. 's'->finaliza. Matches: 'she' em pos 2-4, 'he' em 3-4, 'hers' em 2-6.",
                              "finalVerifications": [
                                "Todos caracteres do texto são processados (pos == len(texto)).",
                                "Lista de matches contém todas ocorrências sem duplicatas.",
                                "Posições de matches correspondem exatamente às esperadas.",
                                "Nenhum crash em caracteres não mapeados.",
                                "Eficiência mantida: tempo linear no tamanho do texto.",
                                "Estado final é raiz ou válido após último caractere."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação do loop de falhas sem loops infinitos.",
                                "Coleta exaustiva de matches via output chain.",
                                "Tratamento preciso de posições de início/fim de matches.",
                                "Eficiência O(n) no processamento do texto.",
                                "Robustez com textos vazios ou sem matches.",
                                "Formatação clara dos resultados de saída."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Modelagem de autômatos finitos como grafos direcionados.",
                                "Linguística Computacional: Análise lexical e busca de padrões em corpora.",
                                "Ciência de Dados: Processamento de streams de texto em big data.",
                                "Engenharia de Software: Design de algoritmos eficientes para pattern matching."
                              ],
                              "realWorldApplication": "Implementado em ferramentas como grep multi-padrão, filtros de spam (busca por frases suspeitas), editores de texto avançados (busca múltipla), antivírus (detecção de assinaturas de malware em arquivos) e motores de busca web para queries compostas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.2",
                            "name": "Relatar ocorrências com posições",
                            "description": "Ao atingir nó com saída, percorrer cadeia de output links para listar todos os padrões encontrados e suas posições no texto.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Nós de Saída e Links de Output no Autômato Aho-Corasick",
                                  "subSteps": [
                                    "Revise a construção do trie e a função de falha (fail pointers).",
                                    "Identifique nós de saída: aqueles onde um padrão completo termina (marcados com o índice do padrão).",
                                    "Estude os output links: ponteiros que ligam um nó a outros nós de saída via sufixos (geralmente output_link = fail_link até encontrar nó de saída).",
                                    "Desenhe um exemplo simples de autômato com 2-3 padrões para visualizar as cadeias de output links."
                                  ],
                                  "verification": "Desenhe o autômato manualmente e anote todos os nós de saída e suas chains de output links.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho como Draw.io",
                                    "Exemplo de código de construção do Aho-Corasick"
                                  ],
                                  "tips": "Comece com padrões curtos como 'a', 'ab', 'b' para ver sufixos claros.",
                                  "learningObjective": "Entender como os output links permitem reportar múltiplos matches em um único estado.",
                                  "commonMistakes": "Confundir output links com fail links; lembre-se que output links otimizam a chain de saídas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar Chegada a um Nó de Saída Durante o Processamento do Texto",
                                  "subSteps": [
                                    "No loop principal de busca, avance pelo autômato consumindo caracteres do texto.",
                                    "Ao processar um caractere, atualize o estado atual seguindo transições ou fail pointers.",
                                    "Verifique se o estado atual é um nó de saída (ex: se tem lista de outputs não vazia).",
                                    "Registre a posição atual no texto (índice do caractere processado)."
                                  ],
                                  "verification": "Implemente um print ou log quando estado atual for nó de saída, testando com texto simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (Python ou C++ com Aho-Corasick implementado)",
                                    "Texto de teste curto"
                                  ],
                                  "tips": "Use debug prints para rastrear estado atual e posição a cada caractere.",
                                  "learningObjective": "Implementar detecção precisa de matches durante a varredura linear do texto.",
                                  "commonMistakes": "Esquecer de ajustar posição para fim do padrão (posição + len(padrão) -1)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Percorrer a Cadeia de Output Links para Coletar Todos os Padrões",
                                  "subSteps": [
                                    "Iniciando do estado atual (nó de saída), colete o(s) padrão(ões) próprio(s).",
                                    "Siga o output_link (ou fail até saída) e colete padrões adicionais repetidamente.",
                                    "Evite loops: use um conjunto ou visited para estados já percorridos na chain.",
                                    "Armazene pares (padrão, posição) em uma lista de resultados."
                                  ],
                                  "verification": "Para um match, liste manualmente a chain e verifique se todos sufixos são coletados corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do autômato com função de get_output_chain",
                                    "Exemplo de autômato com padrões sobrepostos"
                                  ],
                                  "tips": "Implemente uma função recursiva ou iterativa para traverse_output_links.",
                                  "learningObjective": "Coletar todos os matches múltiplos (próprio + sufixos) de forma eficiente em O(1) amortizado.",
                                  "commonMistakes": "Parar prematuramente na chain, perdendo matches sufixais como 'he' em 'she'."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reportar e Armazenar Todas as Ocorrências com Posições",
                                  "subSteps": [
                                    "Após percorrer a chain, adicione a lista de (padrão, posição) aos resultados globais.",
                                    "Garanta que posições sejam reportadas no fim do padrão (posição atual - len(padrão) +1).",
                                    "Ordene ou agrupe resultados por posição ou padrão se necessário.",
                                    "Teste com texto contendo múltiplas/overlapping ocorrências."
                                  ],
                                  "verification": "Execute o algoritmo e compare output com matches esperados manualmente contados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo de busca",
                                    "Casos de teste com overlapping como 'aaa' procurando 'a', 'aa'"
                                  ],
                                  "tips": "Use uma lista de dicts {pattern: str, position: int} para clareza.",
                                  "learningObjective": "Gerar relatório completo e preciso de todas ocorrências com posições.",
                                  "commonMistakes": "Duplicar reports se chain for mal implementada ou posição calculada errada."
                                }
                              ],
                              "practicalExample": "Padrões: ['he', 'she', 'hers']. Texto: 'ushers'. Ao processar 's-h-e-r-s': Em posição 3 ('e'), estado é saída para 'she'; chain: 'she' -> 'he'; report: ('she',3), ('he',3). Em posição 5 ('s'), chain para 'hers': ('hers',5), ('hers',3? via fail), ('he',5), etc. Output: [('she',1-3), ('he',2-3), ('hers',2-5), ('he',3-4? ajustado)].",
                              "finalVerifications": [
                                "Todos os padrões matching são listados exatamente uma vez por ocorrência.",
                                "Posições reportadas correspondem ao fim exato de cada match no texto.",
                                "Nenhum falso positivo ou match perdido em sobreposições.",
                                "Eficiência: tempo total O(n + z) onde z é #matches.",
                                "Código roda sem erros em textos longos (>10k chars).",
                                "Relatório é legível e bem formatado (ex: 'Padrão X encontrado na posição Y')."
                              ],
                              "assessmentCriteria": [
                                "Precisão: 100% dos matches corretos com posições exatas.",
                                "Eficiência: chain traversal não excede O(altura do trie) por match.",
                                "Robustez: lida com padrões vazios, texto vazio, múltiplos iguais.",
                                "Clareza: código comentado explicando output chain logic.",
                                "Escalabilidade: performance boa em dataset grande (ex: 1M chars)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Autômatos e Linguagens Formais (estados de aceitação).",
                                "Estruturas de Dados Avançadas (tries e grafos de fail/output links).",
                                "Processamento de Linguagem Natural (detecção de entidades múltiplas).",
                                "Análise de Algoritmos (análise amortizada de chains)."
                              ],
                              "realWorldApplication": "Em ferramentas de busca como grep avançado ou IDEs para find/replace múltiplos padrões; detecção de plágio em documentos comparando frases; scanners de segurança cibernética procurando assinaturas de malware em logs de rede."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.5.4.3.3",
                            "name": "Analisar complexidade temporal e espacial",
                            "description": "Demonstrar que construção é O(total comprimento padrões * alfabeto) e busca é O(comprimento texto + matches reportados).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Recapitular a Construção do Autômato Aho-Corasick",
                                  "subSteps": [
                                    "Liste todos os padrões e calcule o comprimento total dos padrões (S = sum |Pi|).",
                                    "Construa a Trie inicial adicionando cada padrão, contando o número de estados criados (aprox. S).",
                                    "Implemente as transições de falha (fail pointers) usando BFS na Trie.",
                                    "Adicione as saídas (output links) para reportar matches.",
                                    "Identifique o papel do alfabeto Σ no número de transições por estado."
                                  ],
                                  "verification": "Desenhe o autômato completo para 3 padrões exemplo e liste todas as transições e fail pointers.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Documentação de Aho-Corasick",
                                    "Papel e caneta ou diagrama digital",
                                    "Exemplos de padrões simples"
                                  ],
                                  "tips": "Comece com padrões curtos para visualizar; use BFS para preencher fails sistematicamente.",
                                  "learningObjective": "Identificar componentes da construção que impactam a complexidade temporal e espacial.",
                                  "commonMistakes": [
                                    "Ignorar o tamanho do alfabeto nas transições",
                                    "Confundir fail pointers com output links",
                                    "Subestimar estados na Trie"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Complexidade Temporal da Construção",
                                  "subSteps": [
                                    "Calcule o tempo para inserir padrões na Trie: O(S) para criação de estados e transições diretas.",
                                    "Analise o BFS para fail pointers: visite cada estado e para cada char em Σ, resolva fails.",
                                    "Mostre que o total de trabalho é O(S * |Σ|), pois cada transição é processada uma vez.",
                                    "Inclua o tempo para output links: O(altura da Trie) por estado, ainda O(S).",
                                    "Some tudo para obter O(S * |Σ|)."
                                  ],
                                  "verification": "Escreva a derivação matemática passo a passo e teste com um exemplo numérico.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Folha de cálculo para contagens",
                                    "Pseudocódigo da construção",
                                    "Calculadora"
                                  ],
                                  "tips": "Conte o número exato de operações em cada loop; lembre que |Σ| é fixo mas multiplicativo.",
                                  "learningObjective": "Derivar formalmente a big-O da fase de construção.",
                                  "commonMistakes": [
                                    "Contar |Σ| por estado sem amortização",
                                    "Esquecer recursão em fail resolutions",
                                    "Confundir com complexidade da Trie sozinha"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar Complexidade Espacial do Autômato",
                                  "subSteps": [
                                    "Conte estados: no máximo S + 1 (raiz).",
                                    "Transições: até (S + 1) * |Σ|, mas otimizadas para O(S * |Σ|) no pior caso.",
                                    "Armazenamento de fail pointers e outputs: O(S) cada.",
                                    "Total: O(S * |Σ|) espaço para transições, domínios por padrões e estruturas auxiliares.",
                                    "Discuta otimizações como tabelas de salto."
                                  ],
                                  "verification": "Calcule espaço exato para um autômato exemplo e compare com big-O.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Diagrama do autômato",
                                    "Tabela de contagem de memória"
                                  ],
                                  "tips": "Use representação em grafo para visualizar; foque em transições densas.",
                                  "learningObjective": "Quantificar o uso de memória em termos de S e |Σ|.",
                                  "commonMistakes": [
                                    "Subestimar transições para |Σ| grande",
                                    "Ignorar outputs em matches múltiplos",
                                    "Confundir com espaço da Trie pura"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar Complexidade Temporal da Busca",
                                  "subSteps": [
                                    "Para texto T de comprimento n, inicie na raiz e siga transições.",
                                    "Cada char processado em tempo O(1) via fail chains (amortizado).",
                                    "Total avanços: O(n), pois cada falha leva para baixo na árvore.",
                                    "Reportar matches: O(1 + k) onde k é número de matches, via output links.",
                                    "Conclua O(n + k) para busca."
                                  ],
                                  "verification": "Simule busca em texto exemplo, conte passos e matches reportados.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Texto de teste longo",
                                    "Autômato construído",
                                    "Cronômetro para simulação"
                                  ],
                                  "tips": "Trace falhas explicitamente; note que chains são lineares.",
                                  "learningObjective": "Explicar por que busca é linear apesar de múltiplos padrões.",
                                  "commonMistakes": [
                                    "Contar O(n * |Σ|) sem fails",
                                    "Esquecer custo de reportar k matches",
                                    "Confundir com busca ingênua"
                                  ]
                                }
                              ],
                              "practicalExample": "Padrões: ['he', 'she', 'his', 'hers'] (S=10, |Σ|=26). Construa autômato (~11 estados), espaço O(10*26)=O(260). Busca em texto 'ushers' (n=6), matches: 'she','he','hers','his' (k=4), tempo O(6+4).",
                              "finalVerifications": [
                                "Deriva corretamente construção O(S * |Σ|).",
                                "Calcula espaço O(S * |Σ|).",
                                "Explica busca O(n + k).",
                                "Identifica dependência do alfabeto.",
                                "Compara com alternativas como múltiplos KMP.",
                                "Aplica a exemplo real com números exatos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação matemática (equações corretas).",
                                "Compreensão de amortização em fail chains.",
                                "Cálculos numéricos consistentes com big-O.",
                                "Identificação de fatores como |Σ| e k.",
                                "Explicação clara de otimizações.",
                                "Uso correto de notação assintótica."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise Assintótica e Notação Big-O.",
                                "Engenharia de Software: Otimização de Algoritmos e Trade-offs Tempo-Espaço.",
                                "Inteligência Artificial: Processamento de Linguagem Natural e Matching de Padrões.",
                                "Ciência de Dados: Análise de Complexidade em Pipelines de Texto."
                              ],
                              "realWorldApplication": "Em antivírus para escanear assinaturas de malware em arquivos (múltiplos padrões em textos grandes), motores de busca como grep múltiplo, ou detecção de plágio em documentos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.6",
                "name": "Algoritmos em Árvores: Árvore Geradora Mínima",
                "description": "Métodos como Kruskal e Prim para encontrar a subárvore conectada de custo mínimo em grafos não direcionados.",
                "totalSkills": 54,
                "atomicTopics": [
                  {
                    "id": "10.1.6.1",
                    "name": "Definição de Árvore Geradora Mínima",
                    "description": "Subárvore conectada sem ciclos que conecta todos os vértices de um grafo não direcionado ponderado e conexo, com custo total mínimo.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.1.1",
                        "name": "Conceito de Árvore em Grafos",
                        "description": "Uma árvore é um grafo não direcionado que é conexo e acíclico, possuindo exatamente n-1 arestas para n vértices, servindo como base para estruturas hierárquicas sem loops.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.1.1",
                            "name": "Identificar propriedades de uma árvore",
                            "description": "Reconhecer que uma árvore deve ser conexa (todos os vértices alcançáveis) e acíclica (sem caminhos que retornem ao ponto inicial), verificando número de arestas igual a n-1.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Verificar a conectividade do grafo",
                                  "subSteps": [
                                    "Defina um vértice inicial arbitrário no grafo.",
                                    "Execute uma busca em profundidade (DFS) ou largura (BFS) a partir desse vértice.",
                                    "Marque todos os vértices visitados durante a busca.",
                                    "Confirme se todos os vértices do grafo foram visitados.",
                                    "Registre o caminho percorrido para análise visual."
                                  ],
                                  "verification": "Todos os vértices são alcançáveis a partir de um vértice inicial, sem vértices isolados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis para desenhar o grafo",
                                    "Ferramenta online como Graph Online ou yEd"
                                  ],
                                  "tips": "Comece sempre por um vértice com grau maior para otimizar a busca.",
                                  "learningObjective": "Compreender e aplicar o conceito de grafo conexo.",
                                  "commonMistakes": [
                                    "Parar a busca prematuramente sem visitar todos os vértices",
                                    "Confundir conectividade com existência de caminhos bidirecionais"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Detectar a presença de ciclos no grafo",
                                  "subSteps": [
                                    "Durante a DFS ou BFS da etapa anterior, monitore back-edges (arestas para ancestrais).",
                                    "Para cada vértice visitado, verifique se há arestas para vértices já visitados que não sejam o pai imediato.",
                                    "Desenhe o grafo com cores para destacar possíveis ciclos.",
                                    "Liste todos os ciclos encontrados, se houver.",
                                    "Conclua que o grafo é acíclico apenas se nenhum ciclo for detectado."
                                  ],
                                  "verification": "Não existem back-edges ou caminhos que retornem a um vértice já visitado, exceto pelo pai.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Gráfico impresso ou digital do grafo",
                                    "Marcadores coloridos para anotar visitas"
                                  ],
                                  "tips": "Use pilha para DFS e anote o tempo de descoberta e finalização de cada vértice.",
                                  "learningObjective": "Identificar e evitar ciclos em grafos direcionados ou não direcionados.",
                                  "commonMistakes": [
                                    "Ignorar ciclos de comprimento 2 em grafos não simples",
                                    "Confundir árvore com grafo dirigido"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Contar e validar o número de arestas",
                                  "subSteps": [
                                    "Conte o número total de vértices (n = |V|).",
                                    "Conte o número total de arestas (m = |E|).",
                                    "Verifique se m = n - 1.",
                                    "Compare com os resultados das etapas anteriores: conectividade e aciclicidade.",
                                    "Documente a fórmula e o cálculo em uma tabela."
                                  ],
                                  "verification": "O número de arestas é exatamente n-1, onde n é o número de vértices.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista numerada de vértices e arestas",
                                    "Calculadora simples"
                                  ],
                                  "tips": "Em grafos não simples, ignore laços e múltiplas arestas entre o mesmo par.",
                                  "learningObjective": "Aplicar o teorema fundamental das árvores: |E| = |V| - 1.",
                                  "commonMistakes": [
                                    "Contar arestas duplas como duas",
                                    "Esquecer vértices isolados no cálculo de n"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Sintetizar as propriedades e confirmar que é uma árvore",
                                  "subSteps": [
                                    "Reúna evidências das três etapas: conectividade, aciclicidade e |E| = n-1.",
                                    "Teste com um contraexemplo: adicione/remova uma aresta e reavalie.",
                                    "Explique verbalmente ou por escrito por que o grafo atende a todas as propriedades.",
                                    "Classifique o grafo como árvore ou não.",
                                    "Salve o relatório final com diagramas."
                                  ],
                                  "verification": "Todas as três propriedades são satisfeitas simultaneamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Relatório das etapas anteriores",
                                    "Software de edição de texto"
                                  ],
                                  "tips": "Lembre-se: as propriedades são equivalentes; falha em uma invalida a árvore.",
                                  "learningObjective": "Integrar as propriedades para caracterizar uma árvore.",
                                  "commonMistakes": [
                                    "Aceitar grafo com |E| = n-1 mas desconexo",
                                    "Ignorar que floresta é múltiplas árvores"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo não dirigido G com 4 vértices {A, B, C, D} e arestas {A-B, B-C, C-D}. Verifique: é conexo (DFS de A alcança todos), acíclico (sem back-edges), |E|=3=4-1. É uma árvore. Agora adicione A-D: cria ciclo A-B-C-D-A, não é árvore.",
                              "finalVerifications": [
                                "O grafo é conexo: todos vértices alcançáveis?",
                                "Não há ciclos detectados por DFS/BFS?",
                                "|E| = |V| - 1 exatamente?",
                                "Remoção de qualquer aresta desconecta o grafo?",
                                "Adição de qualquer aresta cria um ciclo?",
                                "Todos os vértices têm grau pelo menos 1 (exceto grafo trivial)?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de conectividade (100% dos vértices visitados).",
                                "Correta identificação de ciclos com evidências (back-edges listados).",
                                "Cálculo exato de |V| e |E| com fórmula aplicada.",
                                "Explicação integrada das três propriedades.",
                                "Uso correto de ferramentas e documentação visual.",
                                "Capacidade de contraexemplos e síntese final."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teorema de Euler para grafos planares.",
                                "Biologia: Árvores filogenéticas em evolução.",
                                "Informática: Estruturas de dados como árvores binárias.",
                                "Física: Modelagem de redes elétricas sem loops.",
                                "Economia: Árvores de decisão em análise de risco."
                              ],
                              "realWorldApplication": "Em redes de computadores, o protocolo STP (Spanning Tree Protocol) usa árvores geradoras para evitar loops em switches, garantindo conectividade sem broadcast storms; em logística, modela rotas de entrega eficientes sem retornos cíclicos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.1.1.2",
                            "name": "Verificar conectividade e aciclicidade",
                            "description": "Aplicar testes para confirmar conectividade via busca em profundidade ou largura e detectar ciclos usando união de conjuntos ou rastreamento de caminhos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a representação do grafo",
                                  "subSteps": [
                                    "Escolha uma representação adequada: lista de adjacência para DFS/BFS ou Union-Find para detecção de ciclos.",
                                    "Defina os vértices (n) e arestas (m) do grafo não direcionado.",
                                    "Implemente ou desenhe a estrutura inicial em código ou papel.",
                                    "Inicialize estruturas auxiliares: visitados para DFS/BFS, parent para Union-Find.",
                                    "Valide que o grafo é simples (sem auto-loops ou múltiplas arestas iniciais)."
                                  ],
                                  "verification": "Confirme que a lista de adjacência ou matriz está corretamente populada comparando com o grafo de entrada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Computador com Python ou Java, papel e lápis para grafos pequenos, editor de código (VS Code).",
                                  "tips": "Use dicionários em Python para listas de adjacência flexíveis com vértices rotulados.",
                                  "learningObjective": "Entender e implementar representações eficientes de grafos para testes subsequentes.",
                                  "commonMistakes": "Esquecer de tratar grafos desconectados na inicialização ou confundir direção das arestas em grafos não direcionados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar conectividade usando DFS ou BFS",
                                  "subSteps": [
                                    "Escolha um vértice inicial arbitrário e inicie DFS ou BFS.",
                                    "Marque vértices como visitados durante a travessia.",
                                    "Continue a travessia até esgotar a fila/pilha ou todos os vizinhos.",
                                    "Conte o número de vértices visitados.",
                                    "Repita a partir de vértices não visitados se necessário para componentes conectadas."
                                  ],
                                  "verification": "Todos os n vértices foram visitados a partir de um único início; caso contrário, o grafo é desconectado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Código Python com bibliotecas padrão (collections para deque em BFS), grafo de teste com 5-10 vértices.",
                                  "tips": "Prefira BFS para grafos densos por simplicidade na fila; use recursão em DFS com cuidado para evitar stack overflow.",
                                  "learningObjective": "Aplicar algoritmos de travessia para determinar se o grafo é fortemente conectado.",
                                  "commonMistakes": "Não resetar o array de visitados entre tentativas ou tratar grafos direcionados como não direcionados."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar ciclos usando Union-Find ou rastreamento de caminhos",
                                  "subSteps": [
                                    "Inicialize Union-Find com n conjuntos (um por vértice).",
                                    "Para cada aresta (u,v): encontre raízes de u e v.",
                                    "Se raízes iguais, ciclo detectado; senão, una os conjuntos.",
                                    "Alternativa: em DFS/BFS, rastreie caminho pai para evitar back-edges.",
                                    "Registre todas as detecções de ciclo para relatório."
                                  ],
                                  "verification": "Nenhum ciclo se o número de uniões for n-1 sem conflitos de raiz.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Implementação Union-Find com path compression e union-by-rank, grafo com arestas conhecidas cíclicas.",
                                  "tips": "Implemente find com path compression para eficiência em grafos grandes.",
                                  "learningObjective": "Dominar detecção eficiente de ciclos em grafos não direcionados.",
                                  "commonMistakes": "Não usar union-by-rank levando a degeneração em árvore, ou ignorar auto-loops como ciclos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar testes e confirmar propriedades de árvore",
                                  "subSteps": [
                                    "Execute conectividade e aciclicidade sequencialmente.",
                                    "Verifique se m == n-1 para árvore candidata.",
                                    "Gere relatório: conectado? Acíclico? É árvore?",
                                    "Teste em grafo modificado (adicione/remova aresta).",
                                    "Otimize código para múltiplos testes."
                                  ],
                                  "verification": "Grafo é árvore se conectado, acíclico e m = n-1.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Código integrado dos steps anteriores, conjunto de grafos de teste (árvore, com ciclo, desconectado).",
                                  "tips": "Automatize com funções modulares para reutilização em MST como Kruskal.",
                                  "learningObjective": "Combinar testes para validar pré-condições de algoritmos de árvores geradoras.",
                                  "commonMistakes": "Assumir conectividade sem contar todos vértices ou ignorar m != n-1 em acíclicos."
                                }
                              ],
                              "practicalExample": "Considere o grafo com vértices A,B,C,D e arestas A-B, B-C, C-D, A-C. 1. Represente como adj: A:[B,C], etc. 2. DFS de A visita A,B,C,D? Sim (conectado). 3. Union-Find: une A-B, B-C, C-D ok; A-C falha (raízes iguais) → ciclo. Conclusão: conectado mas cíclico, não árvore.",
                              "finalVerifications": [
                                "Todos vértices visitados em uma única DFS/BFS.",
                                "Union-Find realiza exatamente n-1 uniões sem conflitos.",
                                "Número de arestas m = n-1.",
                                "Nenhum back-edge detectado em travessia.",
                                "Teste passa em grafos conhecidos (árvore vs. ciclo).",
                                "Código roda em < O(n+m) tempo."
                              ],
                              "assessmentCriteria": [
                                "Correta implementação de DFS/BFS com contagem de visitados.",
                                "Union-Find com path compression e union-by-rank funcional.",
                                "Detecção precisa de ciclos em 100% dos casos de teste.",
                                "Integração lógica dos testes com relatório claro.",
                                "Eficiência temporal demonstrada em grafos médios (n=100).",
                                "Código limpo, comentado e modular."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e propriedades de árvores (Euler, Cayley).",
                                "Programação: Estruturas de dados (fila, pilha, dicionários).",
                                "Ciência da Computação: Pré-requisito para MST (Kruskal/Prim) e redes.",
                                "Engenharia: Verificação de topologias em redes elétricas/telecom."
                              ],
                              "realWorldApplication": "Em redes de computadores, verificar se uma topologia de rede é uma árvore (sem loops para roteamento eficiente) ou em planejamento urbano para spans de pontes sem ciclos redundantes, evitando desperdício de recursos."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.1.3",
                            "name": "Relacionar árvores com subgrafos",
                            "description": "Entender que uma árvore é um subgrafo especial que preserva conectividade sem adicionar ciclos desnecessários em grafos maiores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Grafos e Subgrafos",
                                  "subSteps": [
                                    "Defina um grafo como um par (V, E), onde V é o conjunto de vértices e E o de arestas.",
                                    "Explique subgrafo: um grafo G' = (V', E') onde V' ⊆ V e E' ⊆ E.",
                                    "Identifique tipos de subgrafos: induzido (todas arestas entre V') e arbitrário.",
                                    "Diferencie conectividade em grafos: caminho entre todos pares de vértices.",
                                    "Pratique com um grafo exemplo: desenhe G com 4 vértices e extraia subgrafos."
                                  ],
                                  "verification": "Desenhe um grafo simples e liste 3 subgrafos corretos, explicando por quê.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Software de grafos como Graphviz ou Draw.io"
                                  ],
                                  "tips": "Sempre verifique se E' respeita as regras de subgrafo para evitar erros.",
                                  "learningObjective": "Compreender subgrafos como base para estruturas como árvores.",
                                  "commonMistakes": [
                                    "Confundir subgrafo com grafo desconectado",
                                    "Incluir arestas não existentes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Propriedades Fundamentais de Árvores",
                                  "subSteps": [
                                    "Defina árvore: grafo conexo com |V| - 1 arestas e sem ciclos.",
                                    "Prove que árvores têm exatamente um caminho entre qualquer par de vértices.",
                                    "Compare com grafos cíclicos: adição de aresta cria ciclo.",
                                    "Calcule número de arestas em árvores para diferentes tamanhos de V.",
                                    "Desenhe exemplos: árvore com 5 vértices e verifique propriedades."
                                  ],
                                  "verification": "Construa uma árvore com 6 vértices e confirme ausência de ciclos e conectividade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha de exercícios de grafos",
                                    "Ferramenta online como GeoGebra Graphing"
                                  ],
                                  "tips": "Use a fórmula |E| = |V| - 1 como checklist rápido.",
                                  "learningObjective": "Dominar definição e propriedades únicas de árvores.",
                                  "commonMistakes": [
                                    "Contar arestas erradas",
                                    "Ignorar conectividade"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Relacionar Árvores como Subgrafos Especiais",
                                  "subSteps": [
                                    "Explique spanning tree: subgrafo que inclui todos vértices de G e é uma árvore.",
                                    "Mostre como spanning tree preserva conectividade sem ciclos do grafo original.",
                                    "Diferencie de outros subgrafos: árvores evitam ciclos desnecessários.",
                                    "Identifique em grafo com ciclos: remova arestas para formar árvore.",
                                    "Compare múltiplas spanning trees em um grafo não-árvore."
                                  ],
                                  "verification": "Dado um grafo com 5 vértices e ciclo, extraia uma spanning tree e justifique.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplos impressos de grafos",
                                    "Python com NetworkX para visualização"
                                  ],
                                  "tips": "Comece removendo arestas de ciclos para manter conectividade mínima.",
                                  "learningObjective": "Reconhecer árvores como subgrafos conectados acíclicos.",
                                  "commonMistakes": [
                                    "Criar subgrafo desconectado",
                                    "Adicionar ciclos extras"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Conceito em Grafos Maiores e Verificar",
                                  "subSteps": [
                                    "Analise grafo completo K4: encontre todas spanning trees.",
                                    "Discuta por que árvores minimizam arestas enquanto preservam conectividade.",
                                    "Relacione com Árvore Geradora Mínima: spanning tree de peso mínimo.",
                                    "Teste propriedade: adicione aresta à árvore e crie ciclo.",
                                    "Resuma: árvore como subgrafo 'essencial' sem redundâncias."
                                  ],
                                  "verification": "Em um grafo dado, liste 2 spanning trees e explique preservação de conectividade.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Problemas de prática de grafos",
                                    "Simulador online de MST como Visualgo"
                                  ],
                                  "tips": "Visualize grafos para intuitivamente ver ciclos e conexões.",
                                  "learningObjective": "Integrar conceito em contextos de grafos complexos.",
                                  "commonMistakes": [
                                    "Confundir spanning tree com caminho Hamiltoniano",
                                    "Esquecer todos vértices"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo de rede urbana com 4 interseções (vértices) e ruas (arestas formando um ciclo). Uma spanning tree remove uma rua, criando caminhos únicos entre interseções sem loops desnecessários, otimizando rotas sem perder conectividade.",
                              "finalVerifications": [
                                "Defina corretamente subgrafo e árvore.",
                                "Identifique spanning tree em grafo com ciclos.",
                                "Explique preservação de conectividade sem ciclos extras.",
                                "Calcule |E| para uma spanning tree de n vértices.",
                                "Distinga árvore de outros subgrafos acíclicos.",
                                "Aplique em exemplo real de grafo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de árvore como subgrafo (90% correto).",
                                "Capacidade de extrair spanning tree válida (sem erros de conectividade).",
                                "Explicação clara de propriedades (conexidade e aciclicidade).",
                                "Uso correto de terminologia (subgrafo, spanning tree).",
                                "Criatividade em exemplos práticos.",
                                "Identificação de erros comuns em contraexemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória.",
                                "Ciência da Computação: Algoritmos de Kruskal/Prim para MST.",
                                "Engenharia: Otimização de redes elétricas ou de transporte.",
                                "Biologia: Filogenia e árvores evolutivas como subgrafos genealógicos."
                              ],
                              "realWorldApplication": "Em telecomunicações, spanning trees evitam loops em protocolos de roteamento como STP (Spanning Tree Protocol), garantindo transmissão eficiente de dados sem broadcast storms causados por ciclos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.2",
                        "name": "Subárvore Geradora",
                        "description": "Uma subárvore geradora é um subgrafo em forma de árvore que inclui todos os vértices do grafo original, mantendo conectividade sem ciclos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.2.1",
                            "name": "Definir subgrafo gerador",
                            "description": "Explicar que uma spanning tree conecta todos os vértices do grafo G com o mínimo de arestas possível, sem formar ciclos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Grafos",
                                  "subSteps": [
                                    "Identifique os componentes básicos de um grafo: vértices (nós) e arestas (conexões).",
                                    "Diferencie grafos direcionados de não direcionados e simples de multigrafos.",
                                    "Desenhe um grafo simples com 4-5 vértices e arestas para praticar.",
                                    "Explique o que é um subgrafo: um grafo formado por um subconjunto de vértices e arestas do grafo original."
                                  ],
                                  "verification": "Desenhe um grafo e identifique corretamente pelo menos 2 subgrafos dele.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis ou software de grafos como Graphviz ou Draw.io"
                                  ],
                                  "tips": "Sempre rotule vértices claramente para evitar confusão.",
                                  "learningObjective": "Compreender os elementos básicos de grafos e subgrafos.",
                                  "commonMistakes": [
                                    "Confundir vértices com arestas",
                                    "Incluir arestas que não existem no grafo original"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender Conectividade e Ciclos em Grafos",
                                  "subSteps": [
                                    "Defina um grafo conectado: todo par de vértices tem um caminho entre eles.",
                                    "Identifique ciclos em um grafo: sequências fechadas de arestas.",
                                    "Remova arestas para eliminar ciclos e verifique se o grafo permanece conectado.",
                                    "Conte o número mínimo de arestas necessário para conectar n vértices (n-1)."
                                  ],
                                  "verification": "Em um grafo dado, remova arestas para torná-lo acíclico e conectado, confirmando n-1 arestas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Exemplos de grafos impressos ou digitais"
                                  ],
                                  "tips": "Use busca em profundidade (DFS) mentalmente para checar conectividade.",
                                  "learningObjective": "Dominar conceitos de conectividade e ausência de ciclos.",
                                  "commonMistakes": [
                                    "Achar que um grafo desconectado pode ter spanning tree",
                                    "Contar errado o número de arestas mínimas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Árvores como Subgrafos Especiais",
                                  "subSteps": [
                                    "Defina uma árvore: grafo conectado acíclico com n-1 arestas para n vértices.",
                                    "Compare árvores com grafos gerais, destacando propriedades únicas.",
                                    "Construa uma árvore a partir de um grafo removendo arestas redundantes.",
                                    "Verifique propriedades: única caminho entre vértices, nenhum ciclo."
                                  ],
                                  "verification": "Construa uma árvore de um grafo simples e liste suas propriedades.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Software de visualização de grafos como yEd ou GeoGebra"
                                  ],
                                  "tips": "Lembre-se: árvores são 'minimalistas' em conexões.",
                                  "learningObjective": "Reconhecer árvores como subgrafos acíclicos conectados.",
                                  "commonMistakes": [
                                    "Confundir árvore com caminho simples",
                                    "Ignorar a exigência de todos os vértices"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Formalmente o Subgrafo Gerador (Spanning Tree)",
                                  "subSteps": [
                                    "Combine conceitos: subgrafo que inclui TODOS os vértices do grafo G.",
                                    "Exija conectividade e ausência de ciclos.",
                                    "Confirme mínimo de arestas: exatamente n-1 para n vértices.",
                                    "Escreva a definição formal: 'Uma spanning tree de G é um subgrafo acíclico conectado que spans todos os vértices'."
                                  ],
                                  "verification": "Escreva a definição e aplique a um grafo exemplo, identificando uma spanning tree.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Folha de exercícios com grafos"
                                  ],
                                  "tips": "Use a sigla T (spanning tree) para lembrar: Tree = acíclico e conectado.",
                                  "learningObjective": "Formular a definição precisa de subgrafo gerador.",
                                  "commonMistakes": [
                                    "Omitir 'todos os vértices'",
                                    "Permitir ciclos ou desconexões"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Identificação e Construção",
                                  "subSteps": [
                                    "Dado um grafo, liste possíveis spanning trees.",
                                    "Use algoritmo simples como remoção de arestas para construir uma.",
                                    "Compare com spanning trees mínimas (antecipação para MST).",
                                    "Desafie-se com grafos maiores (6-8 vértices)."
                                  ],
                                  "verification": "Identifique pelo menos 2 spanning trees em um grafo não-trivial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exercícios online como em GeeksforGeeks ou Khan Academy"
                                  ],
                                  "tips": "Comece pelos vértices de menor grau para eficiência.",
                                  "learningObjective": "Aplicar a definição na prática.",
                                  "commonMistakes": [
                                    "Escolher subgrafos que não incluem todos vértices",
                                    "Criar florestas em vez de árvores"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo G com vértices A, B, C, D e arestas AB, AC, BC, BD, CD. Uma spanning tree é AB, AC, BD: conecta todos (A-B-D, A-C), sem ciclos, 3 arestas para 4 vértices. Remover BC ou CD criaria ciclo.",
                              "finalVerifications": [
                                "Pode definir spanning tree sem erros?",
                                "Identifica corretamente em um grafo dado?",
                                "Constrói uma spanning tree válida?",
                                "Explica por que n-1 arestas?",
                                "Distingue de subgrafos não-geradores?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição (inclui todos elementos chave)",
                                "Correta identificação de spanning trees em exemplos",
                                "Compreensão de propriedades (conectado, acíclico, spanning)",
                                "Capacidade de construção manual",
                                "Evita erros comuns como ciclos ou omissões"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de Grafos",
                                "Ciência da Computação: Algoritmos de Busca (DFS/BFS)",
                                "Engenharia: Otimização de Redes",
                                "Estatística: Análise de Conectividade"
                              ],
                              "realWorldApplication": "Em redes de computadores, spanning trees evitam loops em protocolos como STP (Spanning Tree Protocol), garantindo transmissão eficiente sem broadcast storms; em logística, conecta cidades com estradas mínimas sem redundâncias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.2",
                            "name": "Identificar árvores geradoras em grafos",
                            "description": "Dado um grafo conexo, listar ou reconhecer subconjuntos de arestas que formam uma árvore incluindo todos os vértices.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos fundamentais de grafos e árvores geradoras",
                                  "subSteps": [
                                    "Defina um grafo conexo: todo par de vértices tem um caminho entre eles.",
                                    "Explique o que é uma árvore: grafo acíclico e conexo.",
                                    "Descreva uma árvore geradora: subgrafo que é uma árvore e inclui todos os vértices do grafo original.",
                                    "Diferencie árvore geradora de árvore geradora mínima (MST): aqui, foco em qualquer spanning tree, não necessariamente de peso mínimo.",
                                    "Estude exemplos simples com 3-4 vértices para visualizar."
                                  ],
                                  "verification": "Resuma as definições em suas próprias palavras e desenhe um grafo conexo com uma árvore geradora destacada.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta online como draw.io ou Graphviz"
                                  ],
                                  "tips": "Use diagramas visuais para fixar conceitos; comece com grafos pequenos.",
                                  "learningObjective": "Dominar as definições básicas para reconhecer árvores geradoras.",
                                  "commonMistakes": [
                                    "Confundir grafo conexo com completo",
                                    "Esquecer que árvore geradora deve incluir TODOS os vértices"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar as propriedades essenciais de uma árvore geradora",
                                  "subSteps": [
                                    "Confirme conectividade: todos os vértices estão conectados sem desconexões.",
                                    "Verifique ausência de ciclos: use busca em profundidade (DFS) ou largura (BFS) para detectar ciclos.",
                                    "Conte as arestas: deve ser exatamente |V| - 1, onde |V| é o número de vértices.",
                                    "Aplique as três verificações em um subgrafo candidato.",
                                    "Compare com contraexemplos: adicione uma aresta extra ou remova uma para ver falhas."
                                  ],
                                  "verification": "Aplique as verificações em um subgrafo dado e justifique se é ou não uma árvore geradora.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Grafo impresso ou digital",
                                    "Calculadora para contar arestas"
                                  ],
                                  "tips": "Sempre comece contando arestas: se não for |V|-1, pare imediatamente.",
                                  "learningObjective": "Aplicar critérios quantitativos e qualitativos para validar árvores geradoras.",
                                  "commonMistakes": [
                                    "Ignorar ciclos ocultos em caminhos longos",
                                    "Contar vértices incorretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar árvores geradoras em grafos dados",
                                  "subSteps": [
                                    "Desenhe o grafo e liste todos os vértices e arestas.",
                                    "Selecione um subconjunto de arestas candidato e aplique verificações do Step 2.",
                                    "Use algoritmo BFS ou DFS para construir uma spanning tree automaticamente e valide manualmente.",
                                    "Liste múltiplas árvores geradoras possíveis no grafo.",
                                    "Teste remoção/adição de arestas para gerar variações."
                                  ],
                                  "verification": "Forneça pelo menos duas árvores geradoras diferentes para um grafo com 4-5 vértices.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software de grafos como Gephi ou Python com NetworkX",
                                    "Papel para rascunhos"
                                  ],
                                  "tips": "Comece com BFS para uma spanning tree canônica; explore variações manualmente.",
                                  "learningObjective": "Reconhecer e listar subconjuntos de arestas que formam árvores geradoras.",
                                  "commonMistakes": [
                                    "Gerar subgrafos desconexos",
                                    "Incluir arestas desnecessárias criando ciclos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar e analisar exemplos complexos",
                                  "subSteps": [
                                    "Resolva exercícios com grafos de 5-6 vértices, incluindo alguns não conexos para contraste.",
                                    "Identifique se um subgrafo dado É uma árvore geradora e explique por quê.",
                                    "Compare árvores geradoras com MSTs usando pesos fictícios.",
                                    "Crie seu próprio grafo e encontre suas árvores geradoras.",
                                    "Discuta limitações: número exponencial em grafos densos."
                                  ],
                                  "verification": "Resolva 3 exercícios independentes e autoavalie usando critérios do Step 2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Lista de exercícios impressos",
                                    "Python/NetworkX para automação opcional"
                                  ],
                                  "tips": "Varie tamanhos de grafos para construir intuição; use código para verificação rápida.",
                                  "learningObjective": "Consolidar habilidades através de prática iterativa e análise.",
                                  "commonMistakes": [
                                    "Assumir que toda árvore no grafo é geradora",
                                    "Não testar conectividade em subgrafos grandes"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo G com vértices {A, B, C, D} e arestas {A-B, A-C, B-C, B-D, C-D}. Uma árvore geradora é {A-B, B-C, B-D}: conecta todos (4 vértices, 3 arestas), sem ciclos. Verificação: BFS de A alcança todos; sem loops.",
                              "finalVerifications": [
                                "Liste corretamente 2-3 árvores geradoras em um grafo de 4 vértices.",
                                "Identifique por que um subgrafo com ciclo ou desconexão NÃO é geradora.",
                                "Confirme |E| = |V| - 1 em exemplos dados.",
                                "Explique usando DFS/BFS por que um subconjunto é spanning tree.",
                                "Crie um grafo simples e forneça sua árvore geradora.",
                                "Diferencie spanning tree de MST em um exemplo pesado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas verificações de conectividade e aciclicidade (100% correto).",
                                "Completude: inclui todos os vértices e explica contagem de arestas.",
                                "Clareza na justificativa: usa termos técnicos corretos.",
                                "Criatividade: identifica múltiplas árvores geradoras quando possível.",
                                "Eficiência: aplica critérios sem passos desnecessários.",
                                "Análise de erros: identifica e corrige contraexemplos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória (contagem de spanning trees via Matriz de Kirchhoff).",
                                "Computação: Algoritmos de Busca (BFS/DFS) e Estruturas de Dados.",
                                "Engenharia: Design de Redes Elétricas e Comunicação (evitar loops).",
                                "Biologia: Filogenética (árvores evolutivas como spanning trees em grafos de similaridade).",
                                "Física: Modelagem de Redes Sociais e Propagação (conectividade em sistemas complexos)."
                              ],
                              "realWorldApplication": "Em redes de computadores, spanning trees são usadas em protocolos como STP (Spanning Tree Protocol) para prevenir loops em switches, garantindo conectividade sem broadcast storms em LANs."
                            },
                            "estimatedTime": "0.75 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.1.3",
                              "10.1.6.1.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.2.3",
                            "name": "Diferenciar árvores geradoras de outros subgrafos",
                            "description": "Comparar com subgrafos desconexos ou cíclicos, destacando a unicidade em termos de conectividade total e ausência de redundâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Fundamentais de Grafos e Árvores",
                                  "subSteps": [
                                    "Defina grafo conexo: todo par de vértices tem um caminho entre eles.",
                                    "Defina árvore: grafo conexo sem ciclos, com n-1 arestas para n vértices.",
                                    "Liste propriedades de subgrafos: conjunto de vértices e arestas do grafo original.",
                                    "Diferencie subgrafo induzido de subgrafo arbitrário.",
                                    "Desenhe um grafo simples conexo com 4 vértices para prática."
                                  ],
                                  "verification": "Liste verbalmente ou por escrito as 4 propriedades principais de uma árvore.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de desenho de grafos como draw.io ou Graphviz"
                                  ],
                                  "tips": "Use cores diferentes para vértices e arestas para visualizar melhor a conectividade.",
                                  "learningObjective": "Compreender os blocos de construção teóricos para árvores geradoras.",
                                  "commonMistakes": "Confundir conectividade com ausência de ciclos; lembre-se que ambos são necessários."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Propriedades Únicas de Árvores Geradoras",
                                  "subSteps": [
                                    "Confirme que uma árvore geradora inclui todos os vértices do grafo original.",
                                    "Verifique conectividade total: um único componente conexo.",
                                    "Assegure ausência de ciclos: exatamente n-1 arestas.",
                                    "Compare com o grafo original: subgrafo acíclico e conectado.",
                                    "Teste em um exemplo: remova arestas de um grafo até formar uma árvore."
                                  ],
                                  "verification": "Desenhe uma árvore geradora válida para um grafo dado e conte arestas (deve ser n-1).",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Exemplos de grafos impressos ou digitais"
                                  ],
                                  "tips": "Sempre conte vértices primeiro para validar o número de arestas esperado.",
                                  "learningObjective": "Dominar as características definidoras de uma árvore geradora.",
                                  "commonMistakes": "Incluir menos vértices; árvore geradora deve spanning (abranger todos)."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar com Subgrafos Desconexos",
                                  "subSteps": [
                                    "Identifique subgrafos com múltiplos componentes conexos.",
                                    "Explique por quê não é árvore geradora: falha na conectividade total.",
                                    "Exemplo: remova uma aresta crítica de uma árvore geradora.",
                                    "Quantifique: mais de um componente ou arestas insuficientes.",
                                    "Pratique: classifique 3 subgrafos como desconexos ou não."
                                  ],
                                  "verification": "Para um subgrafo dado, prove que é desconexo listando componentes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Lista de subgrafos de exemplo"
                                  ],
                                  "tips": "Use busca em profundidade (DFS) mentalmente para checar componentes.",
                                  "learningObjective": "Reconhecer falhas de conectividade em subgrafos.",
                                  "commonMistakes": "Ignorar vértices isolados; eles criam desconexão."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Subgrafos Cíclicos",
                                  "subSteps": [
                                    "Identifique ciclos: caminhos fechados em subgrafos conectados.",
                                    "Explique por quê não é árvore: mais de n-1 arestas ou loops.",
                                    "Exemplo: adicione uma aresta redundante a uma árvore geradora.",
                                    "Use teorema: em grafo conexo, ciclos implicam redundância.",
                                    "Pratique: detecte e remova ciclos até formar árvore geradora."
                                  ],
                                  "verification": "Conte arestas em um subgrafo conectado; se > n-1, identifique o ciclo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta online como yEd Graph Editor"
                                  ],
                                  "tips": "Procure por triângulos ou caminhos que voltam ao início.",
                                  "learningObjective": "Diferenciar redundâncias cíclicas de estruturas arbóreas.",
                                  "commonMistakes": "Confundir múltiplas arestas paralelas com ciclos; foque em loops."
                                }
                              ],
                              "practicalExample": "Considere um grafo G com 4 cidades (vértices A,B,C,D) conectadas por estradas (arestas). Uma árvore geradora conecta todas sem loops (ex: A-B, B-C, B-D). Subgrafo desconexo: A-B e C-D (dois componentes). Subgrafo cíclico: A-B, B-C, C-A, D isolado (ciclo ABC, desconexo). Diferencie: AG tem conectividade total e zero ciclos.",
                              "finalVerifications": [
                                "Explicar verbalmente as duas propriedades essenciais de uma árvore geradora.",
                                "Classificar corretamente 3 subgrafos como AG, desconexo ou cíclico.",
                                "Identificar e corrigir um subgrafo inválido para torná-lo AG.",
                                "Contar arestas e componentes em um grafo de 5 vértices.",
                                "Desenhar uma AG válida e provar sua unicidade em propriedades."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições de conectividade e aciclicidade (90%+ correto).",
                                "Capacidade de identificar diferenças em exemplos visuais.",
                                "Explicações claras destacando unicidade da AG.",
                                "Detecção correta de erros em subgrafos (sem falsos positivos).",
                                "Uso correto do critério n-1 arestas para n vértices.",
                                "Aplicação consistente em grafos variados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria dos grafos e contagem de componentes.",
                                "Programação: Implementação de algoritmos como DFS para detecção de ciclos.",
                                "Engenharia de Redes: Modelagem de topologias sem loops.",
                                "Otimização: Base para algoritmos de AGM como Kruskal/Prim."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações, uma árvore geradora mínima otimiza cabos para conectar todas as torres sem loops desnecessários, reduzindo custos e falhas, diferentemente de redes desconexas (sem comunicação total) ou cíclicas (tráfego redundante)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.1.3",
                        "name": "Árvore Geradora Mínima (MST)",
                        "description": "Em um grafo não direcionado, conexo e ponderado, a MST é a árvore geradora com o menor custo total de arestas, otimizando a conexão de todos os vértices.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.1.3.1",
                            "name": "Definir formalmente a MST",
                            "description": "Articular que a MST é uma subárvore conectada, acíclica, spanning, com soma mínima dos pesos das arestas em grafos conexos, não direcionados e ponderados.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os pré-requisitos de grafos para MST",
                                  "subSteps": [
                                    "Estude a definição de grafo conexo: todo par de vértices possui um caminho entre eles.",
                                    "Revise grafo não direcionado: arestas sem direção, representadas como {u,v}.",
                                    "Analise grafo ponderado: cada aresta possui um peso (custo) associado.",
                                    "Identifique exemplos de grafos que atendem ou não atendem esses critérios.",
                                    "Desenhe um grafo simples conexo, não direcionado e ponderado."
                                  ],
                                  "verification": "Desenhe e rotule um grafo que satisfaça todas as três condições, explicando por quê.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Tutorial online sobre teoria dos grafos (ex: Khan Academy)",
                                    "Software de grafos como Graphviz"
                                  ],
                                  "tips": "Comece com grafos pequenos (3-5 vértices) para visualizar conexões.",
                                  "learningObjective": "Dominar as propriedades fundamentais de grafos que permitem a existência de MST.",
                                  "commonMistakes": [
                                    "Confundir grafo conexo com completo",
                                    "Ignorar pesos nas arestas",
                                    "Considerar grafos direcionados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir os componentes de uma Árvore Geradora (Spanning Tree)",
                                  "subSteps": [
                                    "Defina 'spanning': a subárvore deve incluir todos os vértices do grafo original.",
                                    "Explique 'conectada': existe um caminho único entre qualquer par de vértices na subárvore.",
                                    "Descreva 'acíclica': não pode conter ciclos, ou seja, número de arestas = número de vértices - 1.",
                                    "Verifique essas propriedades em um grafo exemplo.",
                                    "Compare uma spanning tree com um subgrafo que não é spanning tree."
                                  ],
                                  "verification": "Identifique e desenhe uma spanning tree em um grafo dado, confirmando spanning, conectada e acíclica.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Grafo exemplo impresso ou digital",
                                    "Calculadora para contar arestas/vértices"
                                  ],
                                  "tips": "Use a fórmula |E| = |V| - 1 para verificar aciclicidade rapidamente.",
                                  "learningObjective": "Articular precisamente os três requisitos para uma spanning tree.",
                                  "commonMistakes": [
                                    "Incluir ciclos acidentalmente",
                                    "Esquecer vértices isolados",
                                    "Confundir conectada com spanning"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir o critério de minimização por pesos",
                                  "subSteps": [
                                    "Explique que em grafos ponderados, comparamos a soma total dos pesos das arestas.",
                                    "Defina 'mínima': entre todas as spanning trees possíveis, a que tem soma de pesos mais baixa.",
                                    "Calcule somas de pesos para diferentes spanning trees em um grafo exemplo.",
                                    "Discuta unicidade: MST pode não ser única se houver pesos iguais.",
                                    "Compare MST com outras spanning trees não mínimas."
                                  ],
                                  "verification": "Calcule e compare somas de pesos de pelo menos duas spanning trees diferentes.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Planilha Excel ou papel para somas",
                                    "Grafo ponderado com múltiplas spanning trees"
                                  ],
                                  "tips": "Ordene arestas por peso crescente para visualizar candidatos a MST.",
                                  "learningObjective": "Compreender o papel dos pesos na seleção da MST.",
                                  "commonMistakes": [
                                    "Usar pesos negativos sem cuidado (MST assume pesos não negativos)",
                                    "Confundir soma mínima com número mínimo de arestas",
                                    "Ignorar todas as spanning trees possíveis"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Formalizar a definição completa da MST",
                                  "subSteps": [
                                    "Combine todos os elementos: subárvore conectada, acíclica, spanning, com soma mínima de pesos.",
                                    "Escreva a definição formal: 'Em um grafo conexo, não direcionado e ponderado G=(V,E,w), uma MST T é uma subárvore tal que T é conectada, acíclica, spanning e ∑_{e∈T} w(e) é mínimo.'",
                                    "Traduza para linguagem natural e formal matematica.",
                                    "Teste a definição em um contraexemplo (ex: grafo não conexo).",
                                    "Recite e explique a definição para um parceiro ou gravando áudio."
                                  ],
                                  "verification": "Escreva a definição formal correta e aplique-a a um grafo exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha para escrita formal",
                                    "Gravação de áudio para autoavaliação"
                                  ],
                                  "tips": "Memorize a sigla C.A.S.M. (Conectada, Acíclica, Spanning, Mínima).",
                                  "learningObjective": "Produzir uma definição formal precisa e completa da MST.",
                                  "commonMistakes": [
                                    "Omitir 'conexo' no grafo original",
                                    "Esquecer 'não direcionado'",
                                    "Não especificar soma mínima de pesos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo G com vértices {A,B,C,D}, arestas: A-B(1), A-C(3), B-C(2), B-D(4), C-D(1). Uma MST é A-B(1), B-C(2), C-D(1) com soma 4, conectada, acíclica e spanning, mínima entre opções como A-B(1), A-C(3), C-D(1) soma 5.",
                              "finalVerifications": [
                                "Recitar a definição formal completa sem erros.",
                                "Identificar corretamente se um subgrafo dado é uma MST.",
                                "Explicar por que um grafo não conexo não tem MST.",
                                "Calcular soma de pesos de uma MST proposta.",
                                "Diferenciar MST de uma spanning tree não mínima.",
                                "Aplicar definição a um grafo com pesos iguais."
                              ],
                              "assessmentCriteria": [
                                "Precisão e completude na definição formal (todos os 4 elementos: conectada, acíclica, spanning, mínima).",
                                "Correto uso de terminologia técnica (ex: subárvore, pesos das arestas).",
                                "Capacidade de validar propriedades em exemplos concretos.",
                                "Clareza na explicação oral ou escrita.",
                                "Identificação de pré-condições do grafo (conexo, não direcionado, ponderado).",
                                "Ausência de erros comuns como omitir aciclicidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria dos grafos e árvores.",
                                "Otimização: Problemas de minimização em redes.",
                                "Engenharia de Software: Algoritmos de Kruskal e Prim.",
                                "Física: Modelagem de redes elétricas ou transporte.",
                                "Economia: Problemas de custo mínimo em alocação de recursos."
                              ],
                              "realWorldApplication": "A MST é usada no design de redes de telecomunicações para conectar cidades com cabos de fibra ótica minimizando custos totais, em clustering de dados para agrupamentos eficientes e em roteamento de entregas logísticas otimizando distâncias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.2",
                            "name": "Especificar condições do grafo para MST",
                            "description": "Listar requisitos: grafo deve ser conexo (um componente), não direcionado (arestas bidirecionais) e ponderado (pesos positivos nas arestas).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos fundamentais de grafos",
                                  "subSteps": [
                                    "Defina o que é um grafo: conjunto de vértices e arestas.",
                                    "Diferencie grafos direcionados de não direcionados.",
                                    "Explique o que significa um grafo conexo com um exemplo simples.",
                                    "Identifique componentes conexos em um grafo desconexo.",
                                    "Liste propriedades básicas de grafos ponderados."
                                  ],
                                  "verification": "Desenhe um grafo simples e rotule vértices, arestas e pondereções corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou software de grafos como Draw.io ou Graphviz.",
                                  "tips": "Comece com grafos pequenos (3-5 vértices) para visualização fácil.",
                                  "learningObjective": "Compreender os elementos básicos de um grafo para contextualizar MST.",
                                  "commonMistakes": "Confundir arestas direcionadas com bidirecionais; ignorar auto-loops ou múltiplas arestas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar condição de conectividade",
                                  "subSteps": [
                                    "Verifique se todos os vértices estão conectados por caminhos.",
                                    "Use DFS ou BFS para contar componentes conexos.",
                                    "Confirme que há exatamente um componente conexo.",
                                    "Teste com um grafo desconexo removendo uma aresta crítica.",
                                    "Documente o número de componentes encontrados."
                                  ],
                                  "verification": "Implemente ou simule uma busca para provar conectividade (1 componente).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (Python com NetworkX) ou papel para simulação manual.",
                                  "tips": "Sempre inicie a busca de um vértice e verifique se todos são visitados.",
                                  "learningObjective": "Identificar e validar se o grafo é conexo, pré-requisito para MST.",
                                  "commonMistakes": "Assumir conectividade sem verificação; confundir caminho com ciclo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar se o grafo é não direcionado",
                                  "subSteps": [
                                    "Confirme que todas as arestas são bidirecionais (u-v equivale a v-u).",
                                    "Represente o grafo com matriz de adjacência simétrica.",
                                    "Identifique e rejeite grafos com arestas direcionadas.",
                                    "Converta um grafo direcionado em não direcionado se aplicável.",
                                    "Valide ausência de direções em uma representação de lista de adjacência."
                                  ],
                                  "verification": "Crie a matriz de adjacência e confirme simetria (A[i][j] == A[j][i]).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Planilha ou código Python para matriz de adjacência.",
                                  "tips": "Use representações visuais para spotting direções intuitivamente.",
                                  "learningObjective": "Garantir que o grafo suporte traversais bidirecionais para MST.",
                                  "commonMistakes": "Tratar arestas como direcionadas por padrão; ignorar pesos em direções opostas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Confirmar ponderação com pesos positivos",
                                  "subSteps": [
                                    "Atribua pesos positivos (>0) a todas as arestas.",
                                    "Verifique ausência de pesos zero, negativos ou indefinidos.",
                                    "Some os pesos para confirmar todos positivos.",
                                    "Teste impacto de peso negativo removendo-o.",
                                    "Documente a lista completa de arestas com pesos."
                                  ],
                                  "verification": "Liste todas as arestas e seus pesos, confirmando todos >0.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela em Excel ou lista em código para validação.",
                                  "tips": "Use funções min/max para scan rápido de pesos.",
                                  "learningObjective": "Validar que pesos permitem minimização correta em MST.",
                                  "commonMistakes": "Permitir pesos zero (equivalente a não-ponderado); pesos negativos quebram algoritmos."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar todas as condições para MST",
                                  "subSteps": [
                                    "Compile um checklist: conexo, não direcionado, ponderado positivo.",
                                    "Aplique o checklist a um grafo exemplo.",
                                    "Rejeite grafos que falhem em qualquer condição.",
                                    "Escreva uma declaração formal das condições.",
                                    "Compare com definições padrão de literatura."
                                  ],
                                  "verification": "Crie um relatório resumindo validação de todas as condições.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Documento ou notebook Jupyter para relatório.",
                                  "tips": "Use um template de checklist para eficiência.",
                                  "learningObjective": "Articular completamente as pré-condições para aplicação de MST.",
                                  "commonMistakes": "Omitir uma condição; superestimar grafos não conexos como válidos."
                                }
                              ],
                              "practicalExample": "Considere um grafo de 4 cidades (A,B,C,D) com arestas: A-B(2), A-C(3), B-C(1), B-D(4), C-D(5). Verifique: Conexo (sim, todos conectados), Não direcionado (sim, bidirecionais), Ponderado positivo (sim, todos >0). Agora, remova B-D: ainda conexo? Sim. Adicione direção A->B: não mais válido para MST.",
                              "finalVerifications": [
                                "Grafo tem exatamente 1 componente conexo.",
                                "Matriz de adjacência é simétrica.",
                                "Todos os pesos das arestas são estritamente positivos.",
                                "Não há arestas direcionadas ou auto-loops.",
                                "Pode ser representado como G=(V,E,w) com w(e)>0 para todo e em E.",
                                "Checklist completo assinado e sem falhas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de conectividade (100% cobertura de vértices).",
                                "Correta distinção entre grafos direcionados e não direcionados.",
                                "Validação rigorosa de pesos positivos sem exceções.",
                                "Síntese clara e concisa das três condições.",
                                "Uso de exemplos para ilustrar validações.",
                                "Ausência de erros comuns como ignorar desconexidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Otimização Linear.",
                                "Programação: Implementação em Python (NetworkX, Kruskal/Prim).",
                                "Engenharia: Design de redes elétricas ou de telecomunicações.",
                                "Economia: Problemas de custo mínimo em alocação de recursos."
                              ],
                              "realWorldApplication": "Em planejamento de redes de distribuição elétrica, especificar que o grafo de subestações deve ser conexo, não direcionado e com custos ponderados garante o uso de MST (ex: Kruskal) para minimizar cabos sem loops."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.2.1",
                              "10.1.6.1.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.3",
                            "name": "Exemplificar custo mínimo em MST",
                            "description": "Calcular e comparar o custo total de diferentes árvores geradoras em um grafo exemplo, identificando a de menor soma de pesos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir ou selecionar um grafo exemplo ponderado",
                                  "subSteps": [
                                    "Desenhe um grafo não direcionado com 4-6 vértices e pelo menos 6 arestas com pesos variados.",
                                    "Rotule os vértices (ex: A, B, C, D) e as arestas com pesos numéricos positivos.",
                                    "Garanta que o grafo seja conexo, permitindo múltiplas árvores geradoras.",
                                    "Liste todas as arestas em uma tabela com origem, destino e peso.",
                                    "Verifique visualmente se todos os vértices estão conectados."
                                  ],
                                  "verification": "O grafo é conexo, sem vértices isolados, e todas as arestas têm pesos atribuídos corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis e borracha",
                                    "Calculadora"
                                  ],
                                  "tips": "Use pesos distintos para facilitar comparações e evite grafos muito simétricos.",
                                  "learningObjective": "Representar grafos ponderados de forma clara e precisa.",
                                  "commonMistakes": [
                                    "Esquecer de rotular pesos nas arestas",
                                    "Criar grafos não conexos",
                                    "Usar pesos negativos ou zero"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar pelo menos duas árvores geradoras possíveis",
                                  "subSteps": [
                                    "Encontre uma árvore geradora removendo arestas para eliminar ciclos, mantendo n-1 arestas.",
                                    "Identifique uma segunda árvore geradora diferente, variando as arestas escolhidas.",
                                    "Desenhe cada árvore destacando as arestas selecionadas.",
                                    "Confirme que cada árvore conecta todos os vértices sem ciclos.",
                                    "Nomeie as árvores como AG1, AG2, etc., para referência."
                                  ],
                                  "verification": "Cada árvore tem exatamente n-1 arestas, conecta todos os vértices e não possui ciclos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Lápis coloridos para destacar arestas"
                                  ],
                                  "tips": "Comece removendo a aresta de maior peso para aproximar da MST.",
                                  "learningObjective": "Reconhecer propriedades fundamentais de árvores geradoras em grafos.",
                                  "commonMistakes": [
                                    "Incluir ciclos nas árvores",
                                    "Deixar vértices desconectados",
                                    "Selecionar menos de n-1 arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular o custo total de cada árvore geradora",
                                  "subSteps": [
                                    "Para cada árvore, some os pesos das arestas selecionadas.",
                                    "Registre o custo em uma tabela comparativa (ex: AG1: soma das arestas).",
                                    "Repita o cálculo para todas as árvores identificadas.",
                                    "Use uma calculadora para precisão e anote os passos da soma.",
                                    "Destaque a árvore com o menor custo."
                                  ],
                                  "verification": "Somas verificadas duas vezes, sem erros aritméticos, e registradas corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Calculadora",
                                    "Tabela impressa ou planilha simples"
                                  ],
                                  "tips": "Some verbalmente os pesos para dupla verificação antes de anotar.",
                                  "learningObjective": "Executar cálculos precisos de custos em estruturas de árvores.",
                                  "commonMistakes": [
                                    "Somar pesos de arestas não selecionadas",
                                    "Erros de adição básica",
                                    "Confundir arestas entre árvores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar custos e exemplificar a árvore de custo mínimo",
                                  "subSteps": [
                                    "Compare os custos totais das árvores em uma tabela ou gráfico de barras.",
                                    "Identifique e destaque a Árvore Geradora Mínima (MST) com o menor custo.",
                                    "Explique por que essa é a MST, citando a soma mínima.",
                                    "Discuta diferenças entre as árvores e impactos nos custos.",
                                    "Resuma o exemplo em um parágrafo conclusivo."
                                  ],
                                  "verification": "MST corretamente identificada com custo mínimo comprovado pela comparação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela comparativa",
                                    "Marcadores para destaque"
                                  ],
                                  "tips": "Ordene as árvores por custo crescente para visualização clara.",
                                  "learningObjective": "Aplicar comparação quantitativa para otimização em grafos.",
                                  "commonMistakes": [
                                    "Selecionar MST incorreta",
                                    "Ignorar diferenças mínimas nos custos",
                                    "Não justificar a escolha"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo com vértices A, B, C, D. Arestas: A-B(2), A-C(3), B-C(1), B-D(4), C-D(2). Árvore AG1: A-B(2), B-C(1), C-D(2) → Custo 5. AG2: A-B(2), A-C(3), C-D(2) → Custo 7. AG3: A-C(3), B-C(1), B-D(4) → Custo 8. A MST é AG1 com custo mínimo 5.",
                              "finalVerifications": [
                                "Grafo exemplo construído corretamente com pesos e conexões.",
                                "Pelo menos duas árvores geradoras válidas identificadas.",
                                "Custos calculados com precisão aritmética.",
                                "MST corretamente selecionada como a de menor custo.",
                                "Comparação tabular ou visual clara.",
                                "Explicação concisa do porquê da MST."
                              ],
                              "assessmentCriteria": [
                                "Precisão na representação do grafo (10%)",
                                "Validade das árvores geradoras (25%)",
                                "Correção dos cálculos de custo (30%)",
                                "Identificação correta da MST (20%)",
                                "Clareza na comparação e explicação (15%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Cálculo de somas, comparações e otimização numérica.",
                                "Programação: Implementação de algoritmos como Kruskal ou Prim para automação.",
                                "Economia: Modelagem de custos em redes de suprimentos ou infraestrutura.",
                                "Física: Otimização de circuitos elétricos ou rotas de energia."
                              ],
                              "realWorldApplication": "Em telecomunicações, projetar redes de fibra ótica conectando cidades com mínimo custo de cabos, priorizando arestas de menor peso para eficiência econômica."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.1",
                              "10.1.6.1.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.1.3.4",
                            "name": "Reconhecer unicidade da MST",
                            "description": "Discutir que a MST pode não ser única se houver arestas de mesmo peso, mas sempre existe pelo menos uma com custo mínimo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o conceito de unicidade em Árvores Geradoras Mínimas (MST)",
                                  "subSteps": [
                                    "Defina unicidade como a propriedade de existir apenas uma MST possível em um grafo ponderado conectado.",
                                    "Discuta que a unicidade depende da distinção dos pesos das arestas.",
                                    "Explique que mesmo sem unicidade, sempre existe pelo menos uma MST com custo mínimo.",
                                    "Revise definições básicas de grafo conectado e árvore geradora.",
                                    "Diferencie 'única MST' de 'múltiplas MSTs com mesmo custo mínimo'."
                                  ],
                                  "verification": "Escreva uma definição clara de unicidade de MST e dê um exemplo simples de grafo único vs. não único.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Editor de texto para notas"
                                  ],
                                  "tips": "Use diagramas simples para visualizar conceitos abstratos.",
                                  "learningObjective": "Compreender o que significa unicidade em MSTs e sua relação com pesos de arestas.",
                                  "commonMistakes": [
                                    "Confundir unicidade com existência de MST.",
                                    "Ignorar que múltiplas MSTs podem ter o mesmo custo total."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar condições para unicidade da MST",
                                  "subSteps": [
                                    "Estude o teorema: Uma MST é única se e somente se todos os pesos das arestas são distintos.",
                                    "Prove informalmente: Se pesos distintos, Kruskal/Prim selecionam sempre as mesmas arestas.",
                                    "Discuta o inverso: Pesos iguais permitem escolhas alternativas sem alterar o custo.",
                                    "Analise impacto de ciclos com pesos iguais.",
                                    "Verifique com contraexemplos pequenos."
                                  ],
                                  "verification": "Enuncie o teorema de unicidade e forneça uma justificativa breve.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Quadro branco ou papel quadriculado",
                                    "Referência teórica de grafos (PDF ou livro)"
                                  ],
                                  "tips": "Comece com grafos pequenos (4-5 vértices) para testar condições.",
                                  "learningObjective": "Reconhecer as condições matemáticas precisas para unicidade de uma MST.",
                                  "commonMistakes": [
                                    "Acreditar que unicidade sempre existe independentemente dos pesos.",
                                    "Confundir pesos distintos com grafo acíclico."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar exemplos de MSTs não únicas",
                                  "subSteps": [
                                    "Construa um grafo com arestas de pesos iguais (ex: pesos 1,1,2).",
                                    "Aplique Kruskal ou Prim e observe múltiplas seleções possíveis.",
                                    "Calcule o custo mínimo e liste todas as MSTs possíveis.",
                                    "Compare com grafo de pesos distintos para contrastar.",
                                    "Documente pelo menos duas MSTs alternativas."
                                  ],
                                  "verification": "Desenhe o grafo e liste explicitamente 2+ MSTs com mesmo custo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Software de grafos como Graphviz ou Draw.io",
                                    "Papel para desenhos manuais"
                                  ],
                                  "tips": "Rotule arestas claramente e trace caminhos para evitar confusão.",
                                  "learningObjective": "Demonstrar através de exemplos que MSTs não são sempre únicas.",
                                  "commonMistakes": [
                                    "Selecionar arestas que criam ciclos inadvertidamente.",
                                    "Errar o cálculo do custo total das alternativas."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e discutir existência garantida de MST mínima",
                                  "subSteps": [
                                    "Revise que em grafos conectados ponderados, sempre existe pelo menos uma MST.",
                                    "Discuta algoritmos (Kruskal/Prim) garantem encontrar uma, mesmo não única.",
                                    "Teste em grafos com pesos repetidos e confirme custo mínimo igual.",
                                    "Debata implicações: Otimalidade vs. Unicidade.",
                                    "Resuma em um fluxograma de verificação de unicidade."
                                  ],
                                  "verification": "Crie um fluxograma ou checklist para determinar unicidade em qualquer grafo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de fluxogramas online (Lucidchart ou similar)",
                                    "Exemplos de grafos impressos"
                                  ],
                                  "tips": "Sempre verifique conectividade primeiro antes de discutir MST.",
                                  "learningObjective": "Afirmar que, apesar da possível não-unicidade, uma MST ótima sempre existe.",
                                  "commonMistakes": [
                                    "Concluir erroneamente que pesos iguais impedem existência de MST.",
                                    "Ignorar pré-condição de grafo conectado."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo com 4 vértices A,B,C,D e arestas: A-B(1), A-C(1), B-C(1), B-D(2), C-D(2). Há duas MSTs: {A-B, A-C, B-D} e {A-B, B-C, C-D}, ambas com custo 4, demonstrando não-unicidade devido a pesos iguais.",
                              "finalVerifications": [
                                "Explicar corretamente o teorema de unicidade de MST.",
                                "Identificar em um grafo dado se a MST é única ou não.",
                                "Listar múltiplas MSTs em um exemplo não único.",
                                "Calcular custo mínimo corretamente em casos ambíguos.",
                                "Discutir existência garantida de pelo menos uma MST.",
                                "Diferenciar unicidade de otimalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de unicidade (90%+ correto).",
                                "Uso correto de teoremas e condições (sem erros lógicos).",
                                "Análise de exemplos com diagramas claros e cálculos exatos.",
                                "Identificação de erros comuns evitados.",
                                "Conexão clara entre teoria e prática.",
                                "Completude do fluxograma de verificação."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Otimização.",
                                "Programação: Implementação de Kruskal/Prim em Python/Java.",
                                "Estatística: Análise de redes e clustering.",
                                "Engenharia: Design de redes de infraestrutura."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações, pesos representam custos de cabos; múltiplas MSTs permitem flexibilidade em layouts sem aumentar custo total, otimizando deployment em cenários com materiais de custo similar."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.1.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.2",
                    "name": "Algoritmo de Kruskal",
                    "description": "Método guloso que ordena as arestas por peso crescente e as adiciona à árvore se não formarem ciclos, usando estrutura Union-Find.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.2.1",
                        "name": "Ordenação das Arestas por Peso",
                        "description": "Processo inicial do algoritmo de Kruskal que consiste em ordenar todas as arestas do grafo não direcionado e ponderado em ordem crescente de peso, permitindo a seleção gulosa das arestas mais leves sem formar ciclos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.1.1",
                            "name": "Representar o grafo como lista de arestas",
                            "description": "Estruturar o grafo como uma lista de tuplas ou objetos contendo vértice inicial, vértice final e peso da aresta, facilitando a manipulação para ordenação e iteração subsequentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar todas as arestas do grafo",
                                  "subSteps": [
                                    "Examine o grafo fornecido, seja em representação matricial, adjacência ou visual.",
                                    "Liste manualmente todos os pares de vértices conectados por uma aresta.",
                                    "Registre o peso associado a cada aresta, garantindo que arestas não direcionadas sejam tratadas como bidirecionais apenas uma vez.",
                                    "Ignore vértices isolados, focando apenas em conexões existentes."
                                  ],
                                  "verification": "Confira se a lista inicial cobre todos os pares conectados sem omissões ou duplicatas.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Diagrama do grafo",
                                    "Papel e caneta ou editor de texto"
                                  ],
                                  "tips": "Comece pelos vértices de menor grau para facilitar a contagem.",
                                  "learningObjective": "Reconhecer e enumerar precisamente as arestas de um grafo não direcionado.",
                                  "commonMistakes": [
                                    "Duplicar arestas não direcionadas",
                                    "Omitir arestas com peso zero ou negativo",
                                    "Confundir vértices isolados com arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair componentes de cada aresta",
                                  "subSteps": [
                                    "Para cada par de vértices (u,v), associe o peso w correspondente.",
                                    "Padronize a notação: u < v para evitar duplicatas em grafos não direcionados.",
                                    "Anote como tupla (u, v, w) ou objeto {origem: u, destino: v, peso: w}.",
                                    "Verifique se todos os pesos foram copiados corretamente do grafo original."
                                  ],
                                  "verification": "Cada aresta tem exatamente três componentes: origem, destino e peso.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista de arestas do passo 1",
                                    "Planilha ou editor de código (opcional)"
                                  ],
                                  "tips": "Use ordenação alfabética ou numérica para u e v consistência.",
                                  "learningObjective": "Extrair e padronizar dados de arestas para manipulação computacional.",
                                  "commonMistakes": [
                                    "Inverter origem e destino em grafos direcionados",
                                    "Esquecer pesos em arestas implícitas",
                                    "Usar notação inconsistente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a lista completa de arestas",
                                  "subSteps": [
                                    "Compile todas as tuplas ou objetos em uma única lista ordenada por vértice inicial.",
                                    "Exemplo em Python: edges = [(u1,v1,w1), (u2,v2,w2), ...].",
                                    "Garanta que a lista esteja pronta para iteração e ordenação por peso.",
                                    "Teste a lista iterando manualmente para contar o número de arestas."
                                  ],
                                  "verification": "A lista tem o número exato de arestas do grafo e formato uniforme.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou IDE como VS Code",
                                    "Linguagem de programação preferida (Python recomendado)"
                                  ],
                                  "tips": "Use listas ou arrays para facilitar a ordenação futura no Kruskal.",
                                  "learningObjective": "Estruturar dados de grafo em formato iterável para algoritmos.",
                                  "commonMistakes": [
                                    "Ordem incorreta das tuplas",
                                    "Incluir vértices sem arestas",
                                    "Formato misto (tuplas e objetos)"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e preparar a representação",
                                  "subSteps": [
                                    "Conte o número de arestas e compare com o grafo original.",
                                    "Verifique se todos os pesos somam corretamente ou correspondem.",
                                    "Simule uma ordenação por peso para testar integridade.",
                                    "Documente a lista com comentários sobre o grafo fonte."
                                  ],
                                  "verification": "Lista validada passa em testes de completude, precisão e formato.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Lista construída",
                                    "Calculadora para soma de pesos"
                                  ],
                                  "tips": "Salve a lista em um arquivo para reutilização em implementações.",
                                  "learningObjective": "Garantir robustez da representação para etapas subsequentes do algoritmo.",
                                  "commonMistakes": [
                                    "Ignorar arestas múltiplas entre mesmos vértices",
                                    "Alterar pesos acidentalmente",
                                    "Não preparar para ordenação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo com vértices A, B, C, D e arestas: A-B (peso 4), A-C (2), B-C (1), B-D (5), C-D (3). Representação: edges = [('A','B',4), ('A','C',2), ('B','C',1), ('B','D',5), ('C','D',3)]. Essa lista permite ordenar por peso: [('B','C',1), ('A','C',2), ...] para Kruskal.",
                              "finalVerifications": [
                                "Lista contém exatamente o número de arestas do grafo original.",
                                "Cada item tem formato correto: (u, v, w) ou equivalente.",
                                "Pesos correspondem aos do grafo sem alterações.",
                                "Não há duplicatas ou arestas ausentes.",
                                "Lista é iterável e ordenável por peso."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todas as arestas presentes (100%).",
                                "Precisão: Pesos e vértices corretos (sem erros).",
                                "Formato: Uniforme e padronizado (tuplas/objetos consistentes).",
                                "Preparação: Pronta para ordenação sem ajustes.",
                                "Eficiência: Estrutura facilita iteração rápida."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de grafos e relações binárias.",
                                "Programação: Estruturas de dados (listas, tuplas) e manipulação.",
                                "Análise de Redes: Modelagem de conexões em sistemas reais.",
                                "Banco de Dados: Representação de relações em tabelas de arestas."
                              ],
                              "realWorldApplication": "Em sistemas de roteamento de redes (ex: OSPF em telecomunicações), onde grafos de links são representados como listas de arestas para calcular caminhos mínimos eficientes, otimizando tráfego de dados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.1.2",
                            "name": "Implementar ordenação das arestas",
                            "description": "Utilizar um algoritmo de ordenação eficiente como quicksort ou a função nativa de ordenação da linguagem de programação para classificar as arestas em ordem não decrescente de peso, garantindo estabilidade se houver pesos iguais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a representação das arestas com pesos",
                                  "subSteps": [
                                    "Identifique as arestas do grafo como uma lista de tuplas ou objetos contendo origem, destino e peso.",
                                    "Garanta que o peso seja o terceiro elemento para facilitar a ordenação por chave.",
                                    "Inicialize a lista com dados de exemplo de um grafo pequeno para testes iniciais."
                                  ],
                                  "verification": "Imprima a lista de arestas e confirme que cada item tem exatamente três componentes: (origem, destino, peso).",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (ex: VS Code), Python 3+",
                                  "tips": "Use tuplas para imutabilidade e eficiência em comparações.",
                                  "learningObjective": "Entender como estruturar dados de arestas para ordenação eficiente.",
                                  "commonMistakes": "Esquecer de incluir pesos ou usar formato inconsistente, levando a erros de indexação."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar ordenação estável usando função nativa",
                                  "subSteps": [
                                    "Importe bibliotecas necessárias se aplicável (nenhuma extra para sorted() em Python).",
                                    "Aplique a função sorted() com chave lambda que acessa o peso: sorted(arestas, key=lambda x: x[2]).",
                                    "Para estabilidade, use stable=True implicitamente (sorted() é estável por padrão em Python)."
                                  ],
                                  "verification": "Execute print(sorted_arestas) e confirme ordem não decrescente nos pesos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código, Python 3+",
                                  "tips": "Use key=lambda aresta: aresta[2] para ordenar apenas pelo peso, preservando ordem original em empates.",
                                  "learningObjective": "Dominar o uso de funções nativas de ordenação com chaves personalizadas para eficiência.",
                                  "commonMistakes": "Usar sort() in-place sem copiar lista original, ou esquecer lambda resultando em ordenação errada."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Garantir estabilidade e corretude para pesos iguais",
                                  "subSteps": [
                                    "Crie um exemplo com pesos duplicados e verifique se a ordem relativa é preservada.",
                                    "Adicione um índice único à chave se necessário para estabilidade explícita: key=lambda x: (x[2], index).",
                                    "Compare lista original e ordenada para pesos iguais."
                                  ],
                                  "verification": "Teste com arestas de mesmo peso e confirme preservação da ordem relativa via asserts ou prints.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, Python 3+",
                                  "tips": "Python's sorted() é estável, mas teste sempre para confirmar.",
                                  "learningObjective": "Compreender e implementar ordenação estável no contexto de algoritmos como Kruskal.",
                                  "commonMistakes": "Assumir estabilidade sem testar, levando a ciclos inesperados em Kruskal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e integrar a ordenação no fluxo de Kruskal",
                                  "subSteps": [
                                    "Integre a lista ordenada no loop principal do Kruskal.",
                                    "Execute o algoritmo completo e verifique se a MST resultante é correta.",
                                    "Use casos de teste variados: grafos conectados, desconectados, com pesos iguais."
                                  ],
                                  "verification": "Compare a MST gerada com a esperada manualmente para o grafo de teste.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código, Python 3+, grafos de teste pré-definidos",
                                  "tips": "Salve a lista ordenada em variável para reutilização e depuração.",
                                  "learningObjective": "Aplicar ordenação como pré-processamento em algoritmos de grafos maiores.",
                                  "commonMistakes": "Ordenar in-place sem backup, ou ignorar pesos não numéricos."
                                }
                              ],
                              "practicalExample": "Grafo: arestas = [('A','B',1), ('B','C',3), ('A','C',2), ('B','D',1)]. Após sorted(arestas, key=lambda x: x[2]): [('A','B',1), ('B','D',1), ('A','C',2), ('B','C',3)]. Note estabilidade: ('A','B',1) antes de ('B','D',1).",
                              "finalVerifications": [
                                "Lista de arestas ordenada em ordem não decrescente por peso.",
                                "Preservação da ordem relativa para arestas com pesos iguais.",
                                "Ausência de erros de tipo ou indexação na ordenação.",
                                "Eficiência demonstrada com n log n via análise ou testes de tempo.",
                                "Integração correta no algoritmo de Kruskal sem alterar pesos."
                              ],
                              "assessmentCriteria": [
                                "Corretude: 100% das arestas ordenadas corretamente em testes.",
                                "Eficiência: Tempo O(n log n) confirmado com input grande.",
                                "Estabilidade: Ordem preservada em 3+ casos com pesos duplicados.",
                                "Clareza de código: Uso de lambda legível e comentários.",
                                "Robustez: Lida com grafos vazios ou com uma aresta."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceitos de ordem total e relações parciais em conjuntos ordenados.",
                                "Estruturas de Dados: Manipulação de listas e tuplas para grafos.",
                                "Análise de Algoritmos: Complexidade temporal de ordenação.",
                                "Programação Funcional: Uso de funções lambda e higher-order functions."
                              ],
                              "realWorldApplication": "Em sistemas de roteamento de redes (ex: OSPF usa similar para MST), otimização de circuitos elétricos minimizando custo total de conexões, ou logística para rotas de menor custo em entregas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.2",
                        "name": "Estrutura Union-Find para Detecção de Ciclos",
                        "description": "Estrutura de dados essencial para o algoritmo de Kruskal, que gerencia conjuntos disjuntos de vértices, permitindo verificar rapidamente se adicionar uma aresta conectaria vértices já no mesmo componente (formando ciclo) e unir componentes quando necessário.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.2.1",
                            "name": "Inicializar a estrutura Union-Find",
                            "description": "Criar arrays para pai e rank de cada vértice, inicializando cada vértice como seu próprio pai com rank 0, preparando para operações de união e busca.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Determinar o número de vértices e preparar os arrays",
                                  "subSteps": [
                                    "Analise o grafo de entrada para identificar o número total de vértices (n), geralmente indexados de 0 a n-1.",
                                    "Crie um array ou lista chamada 'parent' com tamanho n usando a sintaxe apropriada da linguagem (ex: parent = [0] * n em Python).",
                                    "Crie um array ou lista chamada 'rank' com tamanho n, também inicializado temporariamente (ex: rank = [0] * n).",
                                    "Confirme os tipos de dados: inteiros para representar índices de vértices.",
                                    "Documente o valor de n no código para clareza."
                                  ],
                                  "verification": "Imprima os tamanhos de parent e rank; ambos devem ser iguais a n e conter valores iniciais padrão.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Jupyter Notebook)",
                                    "Exemplo de grafo com vértices conhecidos (ex: 4 vértices)"
                                  ],
                                  "tips": "Sempre use indexação de 0 a n-1 para consistência com arrays; evite indexação 1-based a menos que especificado.",
                                  "learningObjective": "Compreender a base de dados necessária para rastrear pais e ranks em Union-Find.",
                                  "commonMistakes": [
                                    "Usar número de arestas em vez de vértices para n.",
                                    "Criar arrays com tamanho n+1 por engano.",
                                    "Usar floats em vez de inteiros para índices."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar o array parent",
                                  "subSteps": [
                                    "Para cada vértice i de 0 a n-1, defina parent[i] = i, tornando cada vértice seu próprio pai inicialmente.",
                                    "Implemente um loop for para percorrer todos os índices: for i in range(n): parent[i] = i.",
                                    "Teste com print(parent) para visualizar o array como [0, 1, 2, ..., n-1].",
                                    "Adicione uma função auxiliar find (simplificada) para verificar se find(i) retorna i.",
                                    "Garanta que o loop seja O(n) eficiente."
                                  ],
                                  "verification": "Execute um loop de teste: para cada i, assert parent[i] == i; sem erros significa sucesso.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código Python ou pseudocódigo",
                                    "Ferramenta de debug (ex: print statements)"
                                  ],
                                  "tips": "Use range(n) em Python para loops limpos; evite while loops desnecessários aqui.",
                                  "learningObjective": "Implementar a inicialização de conjuntos disjuntos onde cada elemento é um conjunto singleton.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar alguns índices no loop.",
                                    "Definir parent[i] = -1 ou outro valor inválido.",
                                    "Invertar o loop (i de 1 a n)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar o array rank",
                                  "subSteps": [
                                    "Para cada vértice i de 0 a n-1, defina rank[i] = 0, indicando que todos os conjuntos têm altura 1 inicialmente.",
                                    "Implemente um loop for: for i in range(n): rank[i] = 0.",
                                    "Verifique com print(rank) esperando [0, 0, ..., 0].",
                                    "Explique em comentário que rank será usado para union by rank na próxima etapa.",
                                    "Integre com parent para uma visualização completa."
                                  ],
                                  "verification": "Para todo i em 0 a n-1, assert rank[i] == 0; array deve ser uniforme.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Mesmos do step anterior",
                                    "Comentários no código para documentação"
                                  ],
                                  "tips": "Rank 0 significa árvore de altura 1; isso otimiza futuras uniões pela heurística de rank.",
                                  "learningObjective": "Entender o papel do rank na otimização da estrutura Union-Find para quase O(1) por operação.",
                                  "commonMistakes": [
                                    "Inicializar rank com 1 em vez de 0.",
                                    "Confundir rank com tamanho do conjunto.",
                                    "Não inicializar todos os elementos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e encapsular a inicialização em uma função",
                                  "subSteps": [
                                    "Crie uma função initialize_union_find(n) que retorne (parent, rank).",
                                    "Inclua asserções ou testes unitários dentro da função para validar inicialização.",
                                    "Teste com n=4: chame a função e imprima parent e rank.",
                                    "Adicione docstring explicando parâmetros e retornos.",
                                    "Prepare para uso em Kruskal: passe n do grafo."
                                  ],
                                  "verification": "Chame a função e confirme parent == list(range(n)) e all(r == 0 for r in rank).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Framework de testes (ex: unittest em Python)",
                                    "Grafo de exemplo para n"
                                  ],
                                  "tips": "Encapsule em função para reutilização em algoritmos como Kruskal; facilita depuração.",
                                  "learningObjective": "Modularizar código para estruturas de dados reutilizáveis em algoritmos avançados.",
                                  "commonMistakes": [
                                    "Retornar arrays vazios ou None.",
                                    "Esquecer de retornar ambos os arrays.",
                                    "Função com side-effects indesejados."
                                  ]
                                }
                              ],
                              "practicalExample": "Para um grafo com 4 vértices (0,1,2,3) em Python:\nparent = [0,1,2,3]\nrank = [0,0,0,0]\nApós inicialização, find(2) deve retornar 2, confirmando conjuntos disjuntos.",
                              "finalVerifications": [
                                "parent[i] == i para todo i em 0 a n-1.",
                                "rank[i] == 0 para todo i em 0 a n-1.",
                                "len(parent) == len(rank) == n.",
                                "Função initialize_union_find(n) retorna arrays corretos sem erros.",
                                "Teste básico de find(i) retorna i para todos i.",
                                "Tempo de inicialização é O(n), verificado empiricamente."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todos os arrays inicializados precisamente como especificado.",
                                "Eficiência: Loops O(n) sem operações desnecessárias.",
                                "Clareza: Código comentado, variáveis bem nomeadas, função modular.",
                                "Robustez: Inclui verificações ou asserções contra erros comuns.",
                                "Testabilidade: Fácil de testar com exemplos pequenos.",
                                "Documentação: Docstrings e comentários explicando propósitos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Representação de partições de conjuntos e relações de equivalência.",
                                "Programação Geral: Uso de arrays/listas e loops para inicialização de estruturas de dados.",
                                "Análise de Algoritmos: Introdução à análise de complexidade amortizada (Union-Find).",
                                "Engenharia de Software: Modularidade e funções reutilizáveis.",
                                "Ciência de Dados: Preparação para clustering e detecção de componentes conectados."
                              ],
                              "realWorldApplication": "Na implementação do Algoritmo de Kruskal para encontrar Árvore Geradora Mínima em redes de telecomunicações, evitando ciclos durante a adição de arestas de menor peso, otimizando rotas em GPS ou infraestrutura elétrica."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.2.2.2",
                            "name": "Implementar operação Find com compressão de caminho",
                            "description": "Desenvolver a função recursiva ou iterativa que encontra a raiz do conjunto de um vértice, aplicando compressão de caminho para otimizar buscas futuras, reduzindo a complexidade amortizada para quase O(1).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Estrutura Union-Find e o Conceito de Compressão de Caminho",
                                  "subSteps": [
                                    "Revise a estrutura básica de Union-Find: array parent[] e rank[] para union por rank.",
                                    "Entenda a operação Find sem compressão: seguir ponteiros até a raiz recursivamente ou iterativamente.",
                                    "Analise o problema: árvores profundas degradam performance para O(n); compressão achata a árvore.",
                                    "Estude exemplos visuais de path compression: nodos intermediários apontam diretamente para raiz.",
                                    "Compare complexidades: sem compressão O(n), com compressão amortizada quase O(1)."
                                  ],
                                  "verification": "Desenhe um diagrama de árvore antes e após compressão para 4-5 nodos e explique verbalmente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou ferramenta de desenho como Draw.io; pseudocódigo de Union-Find.",
                                  "tips": "Visualize a árvore como uma cadeia longa para entender o ganho da compressão.",
                                  "learningObjective": "Dominar o raciocínio por trás da path compression e sua importância na otimização.",
                                  "commonMistakes": "Confundir compressão com union por rank; ignorar que compressão só afeta find, não union."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a Operação Find Recursiva com Compressão de Caminho",
                                  "subSteps": [
                                    "Defina a função find(parent, i): se parent[i] == i, retorne i (raiz).",
                                    "Caso contrário, chame recursivamente find(parent, parent[i]) para encontrar raiz.",
                                    "Aplique compressão: defina parent[i] = find(parent, parent[i]) (compressão por halving ou full).",
                                    "Retorne a raiz encontrada.",
                                    "Implemente em Python ou C++ com array de inteiros para parent."
                                  ],
                                  "verification": "Execute find em uma árvore profunda e verifique se todos nodos apontam para raiz após chamada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (VS Code ou Jupyter Notebook); linguagem Python preferencial.",
                                  "tips": "Use recursão com memoização implícita via atribuição para evitar stack overflow em testes pequenos.",
                                  "learningObjective": "Codificar corretamente a versão recursiva otimizada de find.",
                                  "commonMistakes": "Esquecer de atualizar parent[i] antes de retornar; recursão infinita por falta de base case."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Versão Iterativa de Find com Compressão de Caminho",
                                  "subSteps": [
                                    "Inicie com raiz = i; siga parent[raiz] = parent[parent[raiz]] até raiz == parent[raiz] (two-pass).",
                                    "Primeira passada: encontre raiz iterativamente sem comprimir.",
                                    "Segunda passada: comprima nodos do caminho original apontando diretamente para raiz.",
                                    "Alternativa one-pass: comprima enquanto sobe, usando nó pai temporário.",
                                    "Teste ambas abordagens e compare legibilidade e performance."
                                  ],
                                  "verification": "Compare saídas recursiva vs iterativa em mesmo conjunto de dados; confirme achatamento da árvore.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Mesmo editor de código; gerador de grafos aleatórios para testes.",
                                  "tips": "Prefira two-pass para simplicidade; evite modificar parent durante subida para clareza.",
                                  "learningObjective": "Desenvolver implementação iterativa eficiente, evitando recursão profunda.",
                                  "commonMistakes": "Perder nodos no caminho durante compressão; loop infinito em detecção de raiz."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Integrar a Operação Find no Contexto de Kruskal",
                                  "subSteps": [
                                    "Crie testes unitários: árvores lineares, aleatórias, com 10-100 nodos.",
                                    "Meça tempo de múltiplas unions/finds antes/depois compressão.",
                                    "Integre em Union-Find completo com union por rank.",
                                    "Aplique em Kruskal: detecte ciclos em grafo de 5-10 arestas.",
                                    "Analise complexidade amortizada via contagem de saltos médios."
                                  ],
                                  "verification": "Testes passam 100%; tempo de execução < 1ms para n=1000 em cenários típicos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Biblioteca de testes (pytest para Python); cronômetro para performance.",
                                  "tips": "Use asserts para verificar raiz correta e estrutura achatada pós-find.",
                                  "learningObjective": "Validar implementação em contexto real e medir ganhos de performance.",
                                  "commonMistakes": "Não inicializar parent[i]=i; ignorar off-by-one em índices de array."
                                }
                              ],
                              "practicalExample": "Considere 5 nodos (0-4) com unions: union(0,1), union(1,2), union(2,3), union(3,4) criando cadeia 0->1->2->3->4 (raiz=0). Chame find(4): sem compressão, 4 saltos. Com compressão recursiva, após find(4), árvore vira todos apontando para 0. find(4) agora O(1). Em Kruskal, isso acelera detecção de ciclos em grafos densos.",
                              "finalVerifications": [
                                "Função find retorna raiz correta para qualquer vértice.",
                                "Após múltiplos finds, árvore está achatada (profundidade <=2).",
                                "Complexidade amortizada confirmada por testes com n=1000 (tempo médio <2 saltos).",
                                "Integração com union por rank preserva corretude.",
                                "Sem vazamentos de memória ou stack overflow em recursão.",
                                "Testes unitários cobrem casos edge: grafos desconexos, singleton."
                              ],
                              "assessmentCriteria": [
                                "Corretude: find sempre acha raiz verdadeira (100% testes passem).",
                                "Eficiência: path compression aplicada em todos nodos do caminho.",
                                "Legibilidade: código comentado, variáveis claras (parent, root).",
                                "Robustez: lida com n=1 a 10^5 sem crash.",
                                "Performance: speedup mensurável vs sem compressão (>=50%).",
                                "Versatilidade: ambas versões recursiva/iterativa funcionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise de complexidade amortizada e funções Ackermann.",
                                "Grafos: Aplicação em MST (Kruskal/Prim) e detecção de componentes conectados.",
                                "Otimização: Técnicas de heurísticas como union por rank.",
                                "Programação: Recursão vs iteração; análise de Big-O prática."
                              ],
                              "realWorldApplication": "Em redes de computadores para roteamento dinâmico (encontrar sub-redes); clustering em machine learning (agrupamento eficiente); sistemas distribuídos como Google Spanner para transações consistentes; bioinformática para análise de árvores filogenéticas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.2.3",
                            "name": "Implementar operação Union por rank",
                            "description": "Realizar a união de dois conjuntos ligando a raiz de menor rank à de maior rank, atualizando o rank apenas quando necessário, garantindo balanceamento da árvore e eficiência.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura de dados para Union-Find com rank",
                                  "subSteps": [
                                    "Inicialize o array 'parent' onde cada elemento é inicialmente seu próprio pai: parent[i] = i para i de 0 a n-1.",
                                    "Inicialize o array 'rank' com zeros: rank[i] = 0 para todos i.",
                                    "Garanta que os arrays tenham tamanho igual ao número de elementos n.",
                                    "Defina funções auxiliares para acessar parent e rank."
                                  ],
                                  "verification": "Verifique se parent[i] == i e rank[i] == 0 para todos i, imprimindo os arrays.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Linguagem de programação (ex: Python, C++)",
                                    "Editor de código"
                                  ],
                                  "tips": "Use listas ou vetores dinâmicos para facilitar testes com diferentes tamanhos.",
                                  "learningObjective": "Compreender e configurar os arrays fundamentais para Union-Find com heurística de rank.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar rank como zero.",
                                    "Usar tamanho errado para os arrays (off-by-one error)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função find com compressão de caminho",
                                  "subSteps": [
                                    "Crie a função find(x) que retorna a raiz de x seguindo os pais recursivamente.",
                                    "Implemente compressão de caminho: parent[x] = find(parent[x]) durante a recursão.",
                                    "Use recursão ou iteração para path compression (preferencialmente recursiva para simplicidade).",
                                    "Teste find em um elemento isolado: deve retornar ele mesmo."
                                  ],
                                  "verification": "Execute find em elementos e confirme que retorna a raiz correta e que o caminho foi comprimido (parent aponta diretamente para raiz).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código da estrutura do Step 1",
                                    "Ferramentas de debug (print ou debugger)"
                                  ],
                                  "tips": "Recursão é elegante, mas cuidado com stack overflow em n grande; use path halving como alternativa iterativa.",
                                  "learningObjective": "Dominar a busca pela raiz com otimização para reduzir altura da árvore.",
                                  "commonMistakes": [
                                    "Não implementar compressão, levando a árvores desbalanceadas.",
                                    "Erro em recursão base: if parent[x] == x return x."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a operação union por rank",
                                  "subSteps": [
                                    "Na função union(x, y): encontre raizX = find(x) e raizY = find(y).",
                                    "Se raizX != raizY, compare rank[raizX] e rank[raizY].",
                                    "Se rank[raizX] > rank[raizY], defina parent[raizY] = raizX.",
                                    "Se rank[raizX] < rank[raizY], defina parent[raizX] = raizY. Se iguais, escolha um (ex: parent[raizY] = raizX) e incremente rank[raizX]++."
                                  ],
                                  "verification": "Após unions, verifique parent e rank: ligações corretas e rank só incrementado quando ranks iguais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código dos Steps 1 e 2",
                                    "Exemplos de teste manuais"
                                  ],
                                  "tips": "Sempre use find antes de comparar para garantir raízes reais.",
                                  "learningObjective": "Aplicar heurística de union by rank para manter árvores rasas (altura O(log n)).",
                                  "commonMistakes": [
                                    "Ligar sem comparar ranks, perdendo balanceamento.",
                                    "Incrementar rank sempre, em vez de só quando iguais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a implementação completa",
                                  "subSteps": [
                                    "Crie testes unitários: union de elementos com ranks diferentes e iguais.",
                                    "Verifique find após múltiplas unions: confirme compressão e corretude.",
                                    "Meça altura da árvore simulando unions aleatórias e cheque max depth <= log n.",
                                    "Integre com Kruskal: teste detecção de ciclos em grafo simples."
                                  ],
                                  "verification": "Todos testes passam; altura máxima da árvore é baixa (ex: < 5 para n=100).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Framework de testes (ex: unittest em Python)",
                                    "Grafo de teste para Kruskal"
                                  ],
                                  "tips": "Use seeds aleatórias para reproducibilidade em testes de unions randômicas.",
                                  "learningObjective": "Garantir robustez e eficiência da operação union por rank em cenários reais.",
                                  "commonMistakes": [
                                    "Testes insuficientes para ranks iguais.",
                                    "Ignorar path compression nos testes."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere n=4 elementos [0,1,2,3]. Inicial: parent=[0,1,2,3], rank=[0,0,0,0]. union(0,1): ranks=0=0, parent[1]=0, rank[0]=1. union(2,3): parent[3]=2, rank[2]=1. union(1,3): find(1)=0 (rank1), find(3)=2 (rank1), iguais, parent[2]=0, rank[0]=2. Result: árvore balanceada com raiz 0.",
                              "finalVerifications": [
                                "Ranks só incrementados quando raízes tinham ranks iguais.",
                                "Sempre liga raiz de menor rank à maior.",
                                "Após unions, find retorna raiz correta para todos elementos unidos.",
                                "Altura da árvore permanece O(log n) em testes com 100+ elementos.",
                                "Não há ciclos introduzidos indevidamente."
                              ],
                              "assessmentCriteria": [
                                "Corretude: unions conectam componentes corretamente sem ciclos errados.",
                                "Eficiência: tempo de union/find próximo a O(α(n)) ~ constante.",
                                "Balanceamento: ranks refletem altura aproximada; max rank baixo.",
                                "Clareza do código: funções modulares e comentadas.",
                                "Robustez: lida com n=1, elementos já unidos, etc."
                              ],
                              "crossCurricularConnections": [
                                "Teoria de Grafos: Detecção de conectividade e ciclos.",
                                "Matemática Discreta: Estruturas de árvores e heurísticas de balanceamento.",
                                "Algoritmos: Complexidade amortizada e análise de Kruskal.",
                                "Programação: Recursão, ponteiros/referências e otimização de dados."
                              ],
                              "realWorldApplication": "Essencial no Algoritmo de Kruskal para encontrar Árvore Geradora Mínima em redes de telecomunicações, clustering em machine learning e detecção de componentes conectados em grafos sociais ou biológicos, garantindo eficiência em grandes escalas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.2.3",
                        "name": "Execução do Algoritmo de Kruskal",
                        "description": "Loop principal guloso que itera pelas arestas ordenadas, adicionando à árvore geradora mínima apenas aquelas que não formam ciclos (via Union-Find), até obter V-1 arestas ou esgotar as arestas disponíveis.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.2.3.1",
                            "name": "Inicializar MST e Union-Find",
                            "description": "Preparar uma lista vazia para as arestas da MST e inicializar a estrutura Union-Find com todos os vértices como conjuntos singleton.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar vértices e preparar lista vazia para MST",
                                  "subSteps": [
                                    "Determine o número de vértices (V) no grafo a partir da entrada.",
                                    "Crie uma lista ou array vazio chamado mstEdges para armazenar as arestas da Árvore Geradora Mínima.",
                                    "Confirme que a lista está completamente vazia (tamanho 0).",
                                    "Anote o número de vértices para uso posterior na inicialização do Union-Find.",
                                    "Teste adicionando e removendo um item temporário para validar a estrutura."
                                  ],
                                  "verification": "Verifique se mstEdges.length === 0 e se é possível adicionar/remover itens sem erros.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Editor de código ou papel/caneta",
                                    "Exemplo de grafo simples"
                                  ],
                                  "tips": "Use uma lista dinâmica como ArrayList em Java ou vector em C++ para flexibilidade.",
                                  "learningObjective": "Compreender a necessidade de uma estrutura vazia para acumular arestas selecionadas na MST.",
                                  "commonMistakes": [
                                    "Inicializar com arestas do grafo original",
                                    "Usar array fixo sem redimensionamento",
                                    "Confundir com lista de todas as arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar array parent para Union-Find",
                                  "subSteps": [
                                    "Crie um array parent de tamanho V.",
                                    "Para cada vértice i de 0 a V-1, defina parent[i] = i (conjuntos singleton).",
                                    "Verifique o indexing (0-based ou 1-based) consistindo com o grafo.",
                                    "Imprima ou liste o array para inspeção visual.",
                                    "Teste acessando parent[i] para alguns i."
                                  ],
                                  "verification": "Confirme que parent[i] === i para todo i em 0 até V-1.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Pseudocódigo de Union-Find"
                                  ],
                                  "tips": "Sempre use laço for para inicializar para evitar erros manuais.",
                                  "learningObjective": "Estabelecer cada vértice como seu próprio conjunto inicial no Union-Find.",
                                  "commonMistakes": [
                                    "Off-by-one error no tamanho do array",
                                    "Definir parent[i] = -1 ou null",
                                    "Misturar indexing com rótulos de vértices"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar array rank para otimização Union-Find",
                                  "subSteps": [
                                    "Crie um array rank de tamanho V, inicializado com zeros.",
                                    "Para cada vértice i, defina rank[i] = 0.",
                                    "Explique o papel do rank na union-by-rank para balanceamento.",
                                    "Integre os arrays parent e rank em uma estrutura de dados unificada se aplicável.",
                                    "Valide que todos os valores são zero."
                                  ],
                                  "verification": "Verifique se rank[i] === 0 para todo i em 0 até V-1.",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Diagrama de Union-Find"
                                  ],
                                  "tips": "Rank é opcional para versão básica, mas essencial para eficiência em grafos grandes.",
                                  "learningObjective": "Preparar estrutura para union-by-rank, evitando árvores desbalanceadas.",
                                  "commonMistakes": [
                                    "Inicializar rank com 1",
                                    "Esquecer de criar o array",
                                    "Confundir rank com tamanho do conjunto"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e testar a inicialização completa",
                                  "subSteps": [
                                    "Implemente uma função find básica para testar singletons.",
                                    "Chame find(i) para vários i e confirme que retorna i.",
                                    "Simule uma union desnecessária e reverta para validar.",
                                    "Documente o estado inicial: MST vazia, todos singletons.",
                                    "Prepare para próxima fase: ordenar arestas."
                                  ],
                                  "verification": "find(i) === i para todos i, e mstEdges vazia.",
                                  "estimatedTime": "7 minutos",
                                  "materials": [
                                    "Código de teste unitário",
                                    "Grafo de exemplo com 4 vértices"
                                  ],
                                  "tips": "Escreva testes unitários agora para evitar bugs posteriores no Kruskal.",
                                  "learningObjective": "Garantir que a inicialização está correta antes de prosseguir com o algoritmo.",
                                  "commonMistakes": [
                                    "Não testar find",
                                    "Ignorar discrepâncias de indexing",
                                    "Prosseguir sem validação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para um grafo com 4 vértices (0,1,2,3): mstEdges = []; parent = [0,1,2,3]; rank = [0,0,0,0]. Teste find(2) deve retornar 2, confirmando singleton.",
                              "finalVerifications": [
                                "Lista mstEdges está vazia (tamanho 0).",
                                "parent[i] === i para todos os vértices i.",
                                "rank[i] === 0 para todos os vértices i.",
                                "Função find(i) retorna i para qualquer vértice i.",
                                "Nenhuma memória extra alocada desnecessariamente.",
                                "Indexing consistente com o grafo de entrada."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todas as estruturas inicializadas conforme especificação.",
                                "Eficiência: Inicialização em O(V) tempo.",
                                "Robustez: Funciona para V=1 até grafos grandes (ex: V=1000).",
                                "Clareza: Código comentado e variáveis nomeadas intuitivamente.",
                                "Testabilidade: Verificações implementadas e passando.",
                                "Escalabilidade: Preparado para union-find otimizado."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Partições de Conjuntos.",
                                "Programação: Manipulação de Arrays e Recursão (path compression).",
                                "Engenharia de Software: Inicialização de Estruturas de Dados e Testes Unitários.",
                                "Ciência da Computação: Complexidade Assintótica O(α(V)) para operações.",
                                "Análise de Dados: Clustering e Componentes Conexos."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações, inicializa Union-Find para conectar torres com cabos de menor custo total sem ciclos, otimizando infraestrutura como na construção de redes 5G ou estradas entre cidades."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.1.2",
                              "10.1.6.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.2",
                            "name": "Iterar e adicionar arestas sem ciclo",
                            "description": "Percorrer a lista ordenada de arestas; para cada uma, se find(u) != find(v), adicionar à MST e executar union(u, v), evitando a formação de ciclos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a iteração na lista de arestas ordenadas",
                                  "subSteps": [
                                    "Confirmar que a lista de arestas está ordenada em ordem crescente de peso.",
                                    "Inicializar a estrutura Union-Find com todos os vértices como conjuntos separados.",
                                    "Preparar uma lista vazia para armazenar as arestas da MST.",
                                    "Definir contador de arestas na MST (inicialmente 0).",
                                    "Garantir que o número de vértices V seja conhecido para verificação final."
                                  ],
                                  "verification": "Lista de arestas ordenada confirmada e Union-Find inicializado com parent[i] = i para todos i.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Lista de arestas com pesos",
                                    "Estrutura Union-Find (array parent e rank)",
                                    "Papel e lápis ou editor de código"
                                  ],
                                  "tips": "Sempre ordene as arestas antes de iniciar; use peso como chave primária.",
                                  "learningObjective": "Entender a preparação pré-iteração para garantir eficiência no algoritmo de Kruskal.",
                                  "commonMistakes": [
                                    "Esquecer de ordenar arestas",
                                    "Não inicializar corretamente o Union-Find",
                                    "Ignorar o contador de arestas na MST"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iterar pela lista de arestas e identificar representantes",
                                  "subSteps": [
                                    "Iniciar um loop for que percorre cada aresta na lista ordenada.",
                                    "Para a aresta atual (u, v, peso), executar find(u) para obter representante ru.",
                                    "Executar find(v) para obter representante rv.",
                                    "Armazenar ru e rv temporariamente para comparação.",
                                    "Prosseguir para o próximo passo apenas após encontrar representantes raiz."
                                  ],
                                  "verification": "Para cada aresta processada, ru e rv são corretamente computados via path compression.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Código ou pseudocódigo do find",
                                    "Exemplo de grafo impresso"
                                  ],
                                  "tips": "Implemente path compression no find para otimizar futuras consultas.",
                                  "learningObjective": "Dominar a consulta de representantes para detectar ciclos potenciais.",
                                  "commonMistakes": [
                                    "Não usar recursão ou iteração correta no find",
                                    "Confundir u e v nas chamadas",
                                    "Ignorar compressão de caminho"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar ciclo e adicionar aresta à MST se possível",
                                  "subSteps": [
                                    "Comparar ru != rv; se verdadeiro, a aresta não forma ciclo.",
                                    "Se ru != rv, adicionar a aresta (u, v, peso) à lista da MST.",
                                    "Incrementar o contador de arestas na MST.",
                                    "Executar union(ru, rv) para mesclar os conjuntos.",
                                    "Se ru == rv, pular a aresta e continuar para a próxima."
                                  ],
                                  "verification": "Aresta adicionada apenas quando ru != rv, e union executado imediatamente após.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Pseudocódigo de union por rank ou tamanho",
                                    "Lista da MST em construção"
                                  ],
                                  "tips": "Use union por rank para manter a árvore balanceada e eficiente.",
                                  "learningObjective": "Aplicar corretamente a condição de não-ciclo e atualização da Union-Find.",
                                  "commonMistakes": [
                                    "Adicionar aresta mesmo com ru == rv",
                                    "Executar union antes da verificação",
                                    "Não incrementar contador"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar a iteração e validar a MST",
                                  "subSteps": [
                                    "Continuar o loop até o fim da lista de arestas ou contador == V-1.",
                                    "Verificar se o grafo é conexo (contador == V-1).",
                                    "Listar todas as arestas na MST final.",
                                    "Calcular o custo total da MST somando pesos das arestas selecionadas.",
                                    "Visualizar ou desenhar a MST resultante."
                                  ],
                                  "verification": "MST tem exatamente V-1 arestas, sem ciclos e custo mínimo.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Ferramenta de visualização de grafos (ex: Graphviz)",
                                    "Calculadora para soma de pesos"
                                  ],
                                  "tips": "Pare cedo se MST completa para otimização.",
                                  "learningObjective": "Reconhecer o término correto e validar propriedades da MST.",
                                  "commonMistakes": [
                                    "Continuar iteração após V-1 arestas",
                                    "Não checar conectividade",
                                    "Erro na soma de pesos"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com 4 vértices {A,B,C,D}. Arestas ordenadas: AB(1), AC(3), BD(4), AD(2), CD(5). Iteração: AB (findA=A, findB=B → add AB, union(A,B)); AD (findA=A, findD=D → add AD, union(A,D)); AC (findA=A, findC=C → add AC? Não, mas espere: após unions, findC=C, mas sim add se !=; na verdade: após AB e AD, conjuntos {A,B,D}, C separado → próxima seria BD mas lista é AB,AD? Assuma lista correta: add AB(1), AD(2), AC(3) mas AC conecta A-C, add. Resultado MST: AB,AD,AC custo 6.",
                              "finalVerifications": [
                                "Número de arestas na MST é exatamente V-1.",
                                "Nenhum ciclo detectado (todos adds com ru != rv).",
                                "Union-Find reflete partição única no final.",
                                "Custo total é soma mínima possível.",
                                "Estrutura resultante é uma árvore conectada.",
                                "Todas arestas processadas na ordem correta."
                              ],
                              "assessmentCriteria": [
                                "Correta detecção de ciclos via find(u) != find(v).",
                                "Arestas adicionadas estritamente na ordem de peso crescente.",
                                "Union executado apenas após adição de aresta válida.",
                                "Eficiência mantida com path compression e union by rank.",
                                "Validação final confirma conectividade e minimalidade.",
                                "Sem adição de arestas que formem ciclos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e conjuntos disjuntos.",
                                "Programação: Implementação de estruturas de dados dinâmicas (Union-Find).",
                                "Otimização: Algoritmos gulosos e problemas NP.",
                                "Engenharia: Design de redes e infraestrutura mínima."
                              ],
                              "realWorldApplication": "No planejamento de redes de telecomunicações, o algoritmo de Kruskal é usado para conectar torres de celular com cabos de fibra ótica minimizando custos totais, evitando loops desnecessários e garantindo conectividade total."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.2.3",
                              "10.1.6.2.3.1"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.3",
                            "name": "Verificar completude da MST",
                            "description": "Garantir que a MST resultante tenha exatamente V-1 arestas e conecte todos os vértices, ou detectar se o grafo não é conexo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o número de vértices e preparar a estrutura da MST",
                                  "subSteps": [
                                    "Liste todos os vértices do grafo original (V).",
                                    "Extraia as arestas selecionadas pelo algoritmo de Kruskal para formar a MST.",
                                    "Crie uma representação visual ou tabular da MST (lista de arestas e vértices envolvidos).",
                                    "Inicialize a estrutura Union-Find com todos os V vértices.",
                                    "Conte o número atual de arestas na MST (E_mst)."
                                  ],
                                  "verification": "Confirme que todos os V vértices estão listados e E_mst foi contado corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis ou editor de texto",
                                    "Diagrama do grafo original",
                                    "Estrutura Union-Find"
                                  ],
                                  "tips": "Sempre rotule vértices claramente para evitar confusão em grafos grandes.",
                                  "learningObjective": "Preparar dados precisos para verificação quantitativa e qualitativa da MST.",
                                  "commonMistakes": [
                                    "Esquecer vértices isolados",
                                    "Contar arestas duplicadas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar o número de arestas contra V-1",
                                  "subSteps": [
                                    "Calcule V-1, onde V é o número total de vértices.",
                                    "Compare E_mst com V-1.",
                                    "Se E_mst < V-1, marque como incompleta imediatamente.",
                                    "Se E_mst == V-1, prossiga; se E_mst > V-1, revise o algoritmo de Kruskal por ciclos.",
                                    "Registre o resultado da comparação."
                                  ],
                                  "verification": "E_mst deve igualar exatamente V-1 para prosseguir à conectividade.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Calculadora ou contador simples",
                                    "Lista de arestas da MST"
                                  ],
                                  "tips": "Use uma tabela para registrar V, E_mst e V-1 lado a lado.",
                                  "learningObjective": "Aplicar a propriedade fundamental das árvores: |E| = |V| - 1.",
                                  "commonMistakes": [
                                    "Confundir V com o número de arestas originais",
                                    "Arredondar incorretamente em grafos ponderados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar conectividade usando Union-Find ou busca em grafo",
                                  "subSteps": [
                                    "Aplique Union-Find nas arestas da MST para unir componentes.",
                                    "Após processar todas as arestas, conte o número de componentes conectados (CC).",
                                    "Se CC == 1, a MST está completa e conecta todos os vértices.",
                                    "Se CC > 1, detecte desconexidade e liste componentes separados.",
                                    "Opcionalmente, valide com DFS/BFS a partir de um vértice raiz."
                                  ],
                                  "verification": "Número de componentes conectados (CC) deve ser 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Implementação Union-Find (papel ou código Python)",
                                    "Software como NetworkX para visualização"
                                  ],
                                  "tips": "Reutilize o Union-Find do Kruskal para eficiência.",
                                  "learningObjective": "Confirmar propriedade de conectividade em árvores geradoras.",
                                  "commonMistakes": [
                                    "Não resetar Union-Find",
                                    "Ignorar vértices sem arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir verificação e reportar resultados",
                                  "subSteps": [
                                    "Combine resultados: E_mst == V-1 E CC == 1 para MST completa.",
                                    "Se falhar, identifique causa (ex: grafo não conexo).",
                                    "Gere relatório com evidências (contagens, componentes).",
                                    "Visualize a MST final e destaque problemas se houver.",
                                    "Salve ou apresente o resultado final."
                                  ],
                                  "verification": "Relatório assinado confirma completude ou detecta falha corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Ferramenta de diagramação (Draw.io ou papel)",
                                    "Template de relatório"
                                  ],
                                  "tips": "Inclua snapshots visuais para clareza.",
                                  "learningObjective": "Sintetizar verificações em uma conclusão acionável.",
                                  "commonMistakes": [
                                    "Declarar completa sem checar conectividade",
                                    "Não especificar se grafo é não conexo"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com 4 vértices (A,B,C,D) e arestas: A-B(1), A-C(2), B-C(3), B-D(4), C-D(5). Kruskal seleciona A-B, A-C, B-D (E_mst=3, V-1=3). Union-Find une todos em um componente (CC=1). Completa. Se remover B-D, E_mst=2 <3 e CC=2 (D isolado), grafo desconexo detectado.",
                              "finalVerifications": [
                                "Número de arestas na MST é exatamente V-1.",
                                "Todos os vértices estão em um único componente conectado.",
                                "Não há ciclos na estrutura (verificado implicitamente por Kruskal).",
                                "Union-Find ou busca confirma conectividade total.",
                                "Relatório documenta contagens e componentes.",
                                "Visualização mostra árvore conectando todos os vértices."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de V e E_mst (100% correto).",
                                "Correta aplicação de Union-Find para CC (sem erros de implementação).",
                                "Detecção precisa de grafos não conexos.",
                                "Relatório claro com evidências quantitativas e qualitativas.",
                                "Tempo de execução dentro do estimado com qualidade.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e propriedades de árvores.",
                                "Programação: Implementação de Union-Find e estruturas de dados.",
                                "Redes de Computadores: Otimização de rotas em redes.",
                                "Ciência de Dados: Clustering e análise de conectividade."
                              ],
                              "realWorldApplication": "Em telecomunicações, verificar se uma rede mínima (MST) conecta todos os nodos sem loops extras, evitando custos desnecessários; em logística, garantir rotas eficientes conectando todos os pontos de distribuição."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.2.3.4",
                            "name": "Calcular o peso total da MST",
                            "description": "Somar os pesos das arestas selecionadas para obter o custo total da árvore geradora mínima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar as arestas selecionadas na MST",
                                  "subSteps": [
                                    "Revise a execução do Algoritmo de Kruskal até o ponto de seleção das arestas que formam a MST.",
                                    "Liste todas as arestas que foram adicionadas à floresta sem formar ciclos, ignorando as rejeitadas.",
                                    "Anote o par de vértices e o peso de cada aresta selecionada em uma tabela organizada.",
                                    "Confirme que o número de arestas selecionadas é exatamente V-1, onde V é o número de vértices.",
                                    "Marque visualmente no grafo as arestas da MST para clareza."
                                  ],
                                  "verification": "Verifique se a lista contém exatamente V-1 arestas conectadas sem ciclos e que todas foram selecionadas pelo algoritmo.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Papel e lápis, diagrama do grafo, tabela de arestas do Kruskal",
                                  "tips": "Use cores diferentes para arestas selecionadas e rejeitadas para visualização rápida.",
                                  "learningObjective": "Reconhecer e isolar precisamente as arestas que compõem a MST final.",
                                  "commonMistakes": "Incluir arestas rejeitadas por formar ciclos ou contar arestas incorretamente."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair e registrar os pesos das arestas selecionadas",
                                  "subSteps": [
                                    "Para cada aresta na lista da MST, copie o peso associado dela da tabela original de arestas.",
                                    "Crie uma coluna separada apenas com os valores numéricos dos pesos, em ordem de seleção ou crescente.",
                                    "Some manualmente dois pesos iniciais para testar precisão aritmética.",
                                    "Verifique se os pesos estão na unidade correta (ex: km, dólares) conforme o contexto do grafo.",
                                    "Anote a soma parcial inicial para rastreamento."
                                  ],
                                  "verification": "Confira que cada peso corresponde exatamente à aresta listada, sem duplicatas ou omissões.",
                                  "estimatedTime": "4 minutos",
                                  "materials": "Tabela de pesos extraída, calculadora opcional para verificação",
                                  "tips": "Ordene os pesos em uma lista vertical para facilitar a soma visual.",
                                  "learningObjective": "Extrair dados numéricos relevantes de forma precisa e organizada.",
                                  "commonMistakes": "Copiar peso errado de outra aresta ou inverter valores decimais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a soma total dos pesos",
                                  "subSteps": [
                                    "Inicie a soma adicionando o primeiro e segundo peso, anotando o subtotal.",
                                    "Adicione o terceiro peso ao subtotal, verificando o novo total.",
                                    "Continue adicionando pesos restantes um a um, recalculando a cada passo.",
                                    "Use uma calculadora para uma soma paralela e compare com a manual.",
                                    "Registre o peso total final em negrito ou destacado."
                                  ],
                                  "verification": "Realize uma soma reversa (subtraia pesos sequencialmente) para confirmar o total.",
                                  "estimatedTime": "3 minutos",
                                  "materials": "Lista de pesos, calculadora, papel para somas parciais",
                                  "tips": "Some em pares (1+2, 3+4) e depois some os pares para reduzir erros.",
                                  "learningObjective": "Executar somas aritméticas precisas com múltiplos operandos.",
                                  "commonMistakes": "Erros de transporte (ex: 23+45=78 em vez de 68) ou pular um peso."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e documentar o custo total da MST",
                                  "subSteps": [
                                    "Compare o total calculado com uma soma alternativa (ex: de trás para frente).",
                                    "Verifique se o total é coerente com o grafo (maior que o menor peso, menor que soma de todas arestas).",
                                    "Documente o resultado com a lista de arestas e pesos para referência.",
                                    "Teste com um grafo conhecido para validar o método.",
                                    "Registre qualquer observação sobre o algoritmo ou grafo específico."
                                  ],
                                  "verification": "O total deve coincidir em pelo menos duas somas independentes e fazer sentido contextual.",
                                  "estimatedTime": "3 minutos",
                                  "materials": "Resultado anterior, grafo de referência",
                                  "tips": "Sempre valide com o princípio: MST deve ter custo mínimo comparado a outras árvores geradoras.",
                                  "learningObjective": "Garantir a confiabilidade do cálculo através de validações múltiplas.",
                                  "commonMistakes": "Ignorar validação, aceitando somas erradas sem checagem."
                                }
                              ],
                              "practicalExample": "Considere um grafo com 4 vértices A, B, C, D e arestas: AB=2, AC=3, AD=7, BC=5, BD=4, CD=1. No Kruskal, arestas selecionadas: CD=1, AB=2, AC=3 (MST conecta todos sem ciclos). Peso total: 1+2+3=6.",
                              "finalVerifications": [
                                "Lista correta de V-1 arestas da MST sem ciclos.",
                                "Pesos extraídos precisamente correspondem às arestas.",
                                "Soma total calculada duas vezes com resultados idênticos.",
                                "Total é o menor possível para uma árvore geradora.",
                                "Documentação inclui grafo, arestas e cálculo passo a passo.",
                                "Validação reversa confirma o resultado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação das arestas da MST (100% corretas).",
                                "Exatidão na extração e soma dos pesos (erro zero).",
                                "Organização clara da tabela de pesos e somas parciais.",
                                "Validações múltiplas demonstradas.",
                                "Tempo de execução dentro do estimado com qualidade.",
                                "Explicação verbal do processo sem hesitações."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Aplicação de somatórias e aritmética básica em grafos.",
                                "Programação: Implementação de soma em loops para automação do Kruskal.",
                                "Economia: Cálculo de custos mínimos em redes de suprimentos.",
                                "Física: Modelagem de tensões mínimas em estruturas conectadas."
                              ],
                              "realWorldApplication": "Em telecomunicações, calcular o custo total de cabos em uma rede de fibra ótica mínima para conectar cidades, otimizando despesas de infraestrutura."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "beginner",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.2.3.3"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.3",
                    "name": "Algoritmo de Prim",
                    "description": "Método que inicia de um vértice e itera adicionando a aresta de menor peso que conecta um vértice fora do conjunto atual à árvore.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.3.1",
                        "name": "Fundamentos do Algoritmo de Prim",
                        "description": "Princípios básicos do algoritmo de Prim para construção de Árvore Geradora Mínima (AGM), incluindo o enfoque guloso que inicia de um vértice arbitrário e adiciona iterativamente a aresta de menor peso conectando o conjunto atual a um vértice externo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.1.1",
                            "name": "Identificar aplicação do Algoritmo de Prim",
                            "description": "Reconhecer cenários onde o algoritmo de Prim é adequado para grafos conexos e não direcionados com pesos positivos, diferenciando-o de Kruskal e justificando sua escolha para grafos densos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Fundamentos de Grafos e Árvores Geradoras Mínimas (MST)",
                                  "subSteps": [
                                    "Defina grafo conexo, não direcionado e com pesos positivos.",
                                    "Explique o conceito de Árvore Geradora Mínima (MST) e suas propriedades.",
                                    "Liste requisitos para aplicar algoritmos de MST: conectividade e pesos não negativos.",
                                    "Identifique diferenças entre grafos densos (muitos edges) e esparsos (poucos edges).",
                                    "Resuma algoritmos comuns para MST: Prim e Kruskal."
                                  ],
                                  "verification": "Crie um diagrama simples de um grafo conexo e destaque uma MST possível.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta de desenho como Draw.io",
                                    "Notas de aula sobre grafos"
                                  ],
                                  "tips": "Use exemplos visuais para diferenciar grafos densos (ex.: rede social completa) de esparsos (ex.: estradas rurais).",
                                  "learningObjective": "Compreender pré-requisitos para algoritmos de MST.",
                                  "commonMistakes": [
                                    "Confundir grafos direcionados com não direcionados",
                                    "Ignorar requisito de pesos positivos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Estudar o Funcionamento do Algoritmo de Prim",
                                  "subSteps": [
                                    "Descreva o processo: inicia de um vértice, cresce a MST adicionando o edge de menor peso conectado ao conjunto atual.",
                                    "Explique uso de fila de prioridade para selecionar o próximo vértice.",
                                    "Liste vantagens: eficiente para grafos densos (O(E log V) com heap binário).",
                                    "Implemente pseudocódigo básico em papel.",
                                    "Simule em um grafo pequeno com 4-5 vértices."
                                  ],
                                  "verification": "Simule Prim em um grafo exemplo e verifique se a MST resultante é mínima.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo de Prim (impresso ou online)",
                                    "Ferramenta de simulação de grafos como VisuAlgo"
                                  ],
                                  "tips": "Sempre inicie de um vértice arbitrário; o resultado é o mesmo independentemente do início.",
                                  "learningObjective": "Dominar mecânica e complexidade do Prim.",
                                  "commonMistakes": [
                                    "Esquecer de atualizar chaves na fila de prioridade",
                                    "Aplicar em grafos desconexos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar Prim com Kruskal e Identificar Diferenças",
                                  "subSteps": [
                                    "Resuma Kruskal: ordena todas as edges e adiciona sem formar ciclos (Union-Find).",
                                    "Compare complexidades: Kruskal O(E log E), bom para esparsos; Prim para densos.",
                                    "Discuta cenários: Prim acessa edges adjacentes (bom em densos), Kruskal global (bom em esparsos).",
                                    "Crie tabela de comparação: requisitos, vantagens, desvantagens.",
                                    "Justifique escolha: densidade medida por E ≈ V²/2 (denso) vs. E ≈ V (esparso)."
                                  ],
                                  "verification": "Preencha tabela comparativa e aplique ambos em grafos denso/esparso exemplo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela comparativa em branco",
                                    "Exemplos de grafos denso e esparso"
                                  ],
                                  "tips": "Meça densidade: se E > V log V, prefira Prim.",
                                  "learningObjective": "Diferenciar e escolher entre Prim e Kruskal baseado em características do grafo.",
                                  "commonMistakes": [
                                    "Confundir Union-Find de Kruskal com heap de Prim",
                                    "Ignorar impacto da densidade na performance"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Praticar Identificação de Cenários de Aplicação",
                                  "subSteps": [
                                    "Liste cenários para Prim: redes densas como circuitos integrados ou mapas urbanos completos.",
                                    "Analise problemas: 'Conecte cidades com estradas mínimas' – avalie densidade.",
                                    "Justifique escolha: 'Grafo denso → Prim eficiente por acessar localmente'.",
                                    "Resolva 3 exercícios: identifique se Prim é adequado e por quê.",
                                    "Discuta limitações: não para pesos negativos ou grafos desconexos."
                                  ],
                                  "verification": "Para 3 cenários dados, justifique uso de Prim vs. Kruskal por escrito.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Lista de 5 problemas de MST variados",
                                    "Calculadora para densidade"
                                  ],
                                  "tips": "Sempre pergunte: 'O grafo tem muitos edges? Use Prim.'",
                                  "learningObjective": "Reconhecer e justificar aplicações reais do Prim.",
                                  "commonMistakes": [
                                    "Aplicar Prim em grafos com ciclos negativos",
                                    "Não considerar conectividade"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede de telecomunicações urbana densa (grafo com 100 torres, ~5000 links possíveis), use Prim para encontrar a infraestrutura de cabos mínima: inicie de uma torre central, adicione links mais baratos adjacentes até conectar todas, otimizando custo total em milhões.",
                              "finalVerifications": [
                                "Explique verbalmente 3 cenários onde Prim é preferível a Kruskal.",
                                "Dado um grafo, calcule densidade e justifique algoritmo.",
                                "Simule Prim vs. Kruskal em grafo denso e compare passos.",
                                "Identifique erro em aplicação incorreta de Prim.",
                                "Crie MST manual para grafo pequeno e verifique minimalidade."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de pré-requisitos (grafos conexos, pesos positivos).",
                                "Correta diferenciação Prim vs. Kruskal por densidade.",
                                "Justificativa clara e baseada em complexidade/performance.",
                                "Uso correto de terminologia (MST, fila de prioridade, Union-Find).",
                                "Aplicação prática em exemplos reais sem erros comuns.",
                                "Completude na simulação e verificação de resultados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Otimização Combinatória.",
                                "Engenharia: Design de Redes (elétrica, telecomunicações).",
                                "Ciência da Computação: Estruturas de Dados (Heaps, Union-Find).",
                                "Economia: Problemas de Minimização de Custos em Projetos.",
                                "Física: Modelagem de Redes em Sistemas Complexos."
                              ],
                              "realWorldApplication": "Projeto de redes elétricas em cidades densas, conectando subestações com cabos mínimos para reduzir custos e perdas; ou roteamento em data centers com alta conectividade entre servidores."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.2",
                            "name": "Descrever passos iniciais do algoritmo",
                            "description": "Explicar a inicialização escolhendo um vértice inicial, marcando-o como visitado e definindo chaves de distância infinita para outros vértices, exceto os adjacentes ao inicial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de inicialização no Algoritmo de Prim",
                                  "subSteps": [
                                    "Revise o objetivo do Algoritmo de Prim: construir uma Árvore Geradora Mínima (MST) a partir de um grafo não direcionado e ponderado.",
                                    "Identifique que a inicialização é o ponto de partida, simulando o 'começo' da construção da MST.",
                                    "Estude a estrutura de dados necessária: chaves de distância (key[]), conjunto de vértices visitados (visited[]) e pai (parent[]).",
                                    "Desenhe um grafo simples com 4-5 vértices para visualizar o processo.",
                                    "Explique verbalmente por que a inicialização arbitrária funciona em grafos conectados."
                                  ],
                                  "verification": "Descreva em voz alta ou por escrito o propósito da inicialização e liste as estruturas de dados envolvidas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel, lápis, diagrama de grafo exemplo",
                                  "tips": "Sempre comece com um grafo pequeno para evitar confusão; foque no 'porquê' antes do 'como'.",
                                  "learningObjective": "Entender o papel fundamental da inicialização na construção incremental da MST.",
                                  "commonMistakes": "Confundir inicialização com o loop principal de seleção de arestas mínimas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e marcar o vértice inicial como visitado",
                                  "subSteps": [
                                    "Selecione um vértice arbitrário como inicial (ex: vértice 0).",
                                    "Marque esse vértice como visitado no array visited[] (visited[0] = true).",
                                    "Inicialize a chave de distância do vértice inicial como 0 (key[0] = 0), indicando custo zero para si mesmo.",
                                    "Registre o pai do vértice inicial como -1 ou nulo (parent[0] = -1).",
                                    "Verifique se a marcação afeta apenas o inicial, mantendo outros como não visitados."
                                  ],
                                  "verification": "Apresente um grafo e mostre o array visited[] atualizado após essa etapa.",
                                  "estimatedTime": "8 minutos",
                                  "materials": "Diagrama de grafo impresso ou digital (ex: em Draw.io)",
                                  "tips": "Use cores diferentes para vértice inicial (verde) e não visitados (vermelho) para visualização rápida.",
                                  "learningObjective": "Dominar a seleção arbitrária e marcação inicial do ponto de partida da MST.",
                                  "commonMistakes": "Esquecer de definir key inicial como 0 ou marcar múltiplos vértices por engano."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Definir chaves de distância infinita para vértices não adjacentes",
                                  "subSteps": [
                                    "Para todos os vértices exceto o inicial, defina key[i] = ∞ (representado como um grande número, ex: INF = 99999).",
                                    "Confirme que isso reflete a ausência de conexão direta conhecida inicialmente.",
                                    "Mantenha parent[i] = -1 para indicar sem pai atribuído ainda.",
                                    "Liste explicitamente os vértices com key infinita em um exemplo.",
                                    "Explique que ∞ garante que apenas arestas reais sejam consideradas posteriormente."
                                  ],
                                  "verification": "Escreva o array key[] completo para um grafo exemplo, destacando ∞.",
                                  "estimatedTime": "7 minutos",
                                  "materials": "Planilha ou quadro para arrays key[], parent[] e visited[]",
                                  "tips": "Use notação matemática ∞ em vez de números finitos para clareza conceitual.",
                                  "learningObjective": "Configurar distâncias iniciais para priorizar conexões reais no algoritmo.",
                                  "commonMistakes": "Aplicar ∞ ao vértice inicial ou confundir com pesos de arestas reais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Ajustar chaves para vértices adjacentes ao inicial",
                                  "subSteps": [
                                    "Identifique todos os vizinhos do vértice inicial no grafo.",
                                    "Para cada vizinho u do inicial v, defina key[u] = peso da aresta (v, u).",
                                    "Atualize parent[u] = v para registrar o pai potencial.",
                                    "Verifique que apenas adjacentes recebem valores finitos; outros permanecem ∞.",
                                    "Simule em um grafo exemplo e compare antes/depois."
                                  ],
                                  "verification": "Atualize e apresente arrays key[] e parent[] após ajustes para adjacentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Grafo exemplo com pesos de arestas anotados",
                                  "tips": "Percorra a lista de adjacência do inicial sistematicamente para não pular vizinhos.",
                                  "learningObjective": "Estabelecer as primeiras candidatas a arestas da MST baseadas em vizinhança.",
                                  "commonMistakes": "Atualizar key para não-adjacentes ou usar peso errado da aresta."
                                }
                              ],
                              "practicalExample": "Considere um grafo com vértices 0,1,2,3. Arestas: (0-1:2), (0-2:4), (1-3:1), (2-3:3). Inicial: v0. Após init: visited=[true,false,false,false], key=[0,2,4,∞], parent=[-1,0,0,-1].",
                              "finalVerifications": [
                                "Descreva verbalmente os 4 passos iniciais sem consultar notas.",
                                "Aplique a inicialização em um novo grafo de 5 vértices e liste arrays resultantes.",
                                "Explique por que key inicial é 0 e adjacentes recebem pesos reais.",
                                "Identifique erros em uma inicialização incorreta fornecida.",
                                "Compare inicialização de Prim vs. Kruskal em termos de vértice inicial."
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição da marcação visited[] e key[] inicial.",
                                "Correta distinção entre vértices adjacentes e não-adjacentes.",
                                "Uso correto de estruturas de dados (key, parent, visited).",
                                "Capacidade de aplicar em exemplo prático sem erros.",
                                "Clareza na explicação verbal ou escrita dos passos.",
                                "Compreensão do impacto na execução subsequente do algoritmo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e otimização discreta.",
                                "Programação: Implementação em linguagens como Python (listas e loops).",
                                "Física: Modelagem de redes elétricas ou minimização de cabos.",
                                "Economia: Otimização de custos em redes de transporte."
                              ],
                              "realWorldApplication": "Em telecomunicações, inicializar a partir de uma central (vértice 0) para conectar cidades adjacentes com cabos de menor custo total, definindo distâncias infinitas para regiões remotas até expansão."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.1.3",
                            "name": "Explicar escolha gulosa da aresta mínima",
                            "description": "Detalhar como, em cada iteração, seleciona-se o vértice não visitado com menor chave de distância e atualiza-se as chaves dos seus vizinhos não visitados se houver aresta de menor peso.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de escolha gulosa no Algoritmo de Prim",
                                  "subSteps": [
                                    "Defina o que é uma estratégia gulosa: seleção local ótima em cada etapa sem olhar o todo.",
                                    "Relacione com o Prim: em cada iteração, escolhe-se a aresta mínima conectando o subgrafo visitado ao não visitado.",
                                    "Explique a 'chave' (key): distância mínima conhecida para cada vértice não visitado.",
                                    "Discuta por que guloso funciona aqui: propriedade de matroide ou cut property em grafos.",
                                    "Compare com Dijkstra: similar, mas Prim foca em AGM."
                                  ],
                                  "verification": "Escreva uma definição em suas palavras e dê um exemplo simples de escolha gulosa em outro contexto.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta; vídeo introdutório sobre algoritmos gulosos (YouTube ou Khan Academy).",
                                  "tips": "Use analogia: como escolher o menor preço em uma vitrine sem considerar o orçamento total.",
                                  "learningObjective": "Entender o princípio guloso como base para a seleção de arestas no Prim.",
                                  "commonMistakes": "Confundir guloso com exaustivo; achar que guloso sempre é ótimo (não é, mas é no Prim)."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o vértice não visitado com menor chave de distância",
                                  "subSteps": [
                                    "Inicialize chaves: infinito para todos exceto raiz (0), e conjunto visitado vazio.",
                                    "Em cada iteração: escaneie todos não visitados e encontre o de menor key[u].",
                                    "Marque o vértice selecionado como visitado e adicione à AGM.",
                                    "Registre o pai (predecessor) para reconstruir a árvore.",
                                    "Repita até todos visitados."
                                  ],
                                  "verification": "Simule manualmente a seleção em um grafo de 3 vértices e liste as chaves atualizadas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Representação de grafo em papel ou ferramenta como Graphviz online.",
                                  "tips": "Mantenha uma tabela de chaves e visitados para visualização rápida.",
                                  "learningObjective": "Dominar o mecanismo de seleção do vértice com menor chave em cada passo.",
                                  "commonMistakes": "Selecionar vértice já visitado; ignorar que raiz inicia com key=0."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atualizar as chaves dos vizinhos não visitados do vértice selecionado",
                                  "subSteps": [
                                    "Para cada vizinho v de u (selecionado): se v não visitado e peso(u,v) < key[v], atualize key[v] = peso(u,v) e pai[v] = u.",
                                    "Use lista de adjacência para iterar vizinhos eficientemente.",
                                    "Explique: isso relaxa as distâncias via nova conexão ao subgrafo.",
                                    "Verifique se não atualiza visitados (desnecessário).",
                                    "Registre mudanças em uma tabela de rastreamento."
                                  ],
                                  "verification": "Aplique atualização em um exemplo com 4 vértices e confirme novas chaves.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Planilha Excel ou Python simples para simular chaves; grafo impresso.",
                                  "tips": "Pense como 'propagar' a menor distância conhecida para vizinhos.",
                                  "learningObjective": "Executar corretamente a relaxação de chaves para vizinhos.",
                                  "commonMistakes": "Atualizar chaves de visitados; usar peso errado ou esquecer condição < key[v]."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Analisar a garantia de minimalidade da escolha gulosa",
                                  "subSteps": [
                                    "Prove por contradicção: suponha aresta não mínima na AGM; leve a ciclo ou corte violado.",
                                    "Use propriedade de corte: menor aresta cruzando corte é segura.",
                                    "Discuta complexidade: O(V^2) na versão simples.",
                                    "Compare iterações: mostra como árvore cresce minimamente.",
                                    "Teste com grafo completo para validar."
                                  ],
                                  "verification": "Escreva um parágrafo explicando por que a escolha é ótima e dê contraexemplo guloso falho (ex: fração mochila).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Artigo ou pseudocódigo do Prim; quadro para prova.",
                                  "tips": "Lembre: Prim é correto por indução em cada adição.",
                                  "learningObjective": "Justificar matematicamente a correção da estratégia gulosa no Prim.",
                                  "commonMistakes": "Achar que guloso falha no Prim; confundir com Kruskal (ordem global)."
                                }
                              ],
                              "practicalExample": "Considere grafo com vértices A,B,C,D. Arestas: A-B:2, A-C:3, B-C:1, B-D:4, C-D:2. Inicie em A (key[A]=0). Iter1: selecione A, atualize B:2, C:3. Iter2: selecione B (min key=2), atualize C:min(3,1)=1, D:4. Iter3: C (key=1), atualize D:min(4,2)=2. Iter4: D. AGM: A-B, B-C, C-D (peso total 5).",
                              "finalVerifications": [
                                "Explicar verbalmente o processo de uma iteração completa.",
                                "Simular 2 iterações em grafo dado sem erros.",
                                "Identificar atualizações corretas de chaves em exemplo.",
                                "Justificar por que a escolha gulosa produz AGM mínima.",
                                "Diferenciar de Kruskal em ordenação de arestas."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de chave e seleção (90% correto).",
                                "Correta execução de atualizações em simulação (sem erros lógicos).",
                                "Compreensão da prova de otimalidade (explicação coerente).",
                                "Uso de terminologia adequada (guloso, relaxação, corte).",
                                "Capacidade de aplicar em grafo não-trivial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e propriedades de matroides.",
                                "Programação: Implementação em Python/Java com heaps para otimização.",
                                "Otimização: Paralelos com problemas de minimização em IA.",
                                "Economia: Redes de distribuição mínima custo."
                              ],
                              "realWorldApplication": "No planejamento de redes de telecomunicações (ex: ligar torres com cabos mínimos), clustering em machine learning para agrupar dados com ligações mínimas, ou design de circuitos elétricos eficientes em energia."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.2",
                        "name": "Estruturas de Dados e Implementação",
                        "description": "Uso de filas de prioridade (heap binário ou Fibonacci) e arrays para rastrear vértices visitados, chaves mínimas e pais na árvore, com implementação pseudocódigo ou em linguagem de programação.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.2.1",
                            "name": "Representar grafo para Prim",
                            "description": "Implementar grafo não direcionado ponderado usando listas de adjacência com pares (vértice, peso), garantindo eficiência para atualizações de distâncias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender conceitos fundamentais de grafos não direcionados ponderados",
                                  "subSteps": [
                                    "Estude a definição de grafo não direcionado: conjunto de vértices V e arestas E sem direção.",
                                    "Revise listas de adjacência: array onde cada índice representa um vértice e armazena lista de vizinhos.",
                                    "Aprenda representação ponderada: cada vizinho é um par (vértice_alvo, peso_da_aresta).",
                                    "Analise requisitos para Prim: acesso eficiente O(deg(v)) aos vizinhos para atualizações de distâncias.",
                                    "Desenhe um grafo exemplo com 4 vértices para visualizar."
                                  ],
                                  "verification": "Resuma em um diagrama manual se a lista de adjacência captura pares (vértice, peso) corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou ferramenta de desenho como Draw.io; documentação de grafos.",
                                  "tips": "Use notação Python: lista de listas de tuplas [(vizinho, peso)].",
                                  "learningObjective": "Identificar como listas de adjacência suportam eficiência em algoritmos como Prim.",
                                  "commonMistakes": "Confundir grafos direcionados (adicionar só uma direção) com não direcionados."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e inicializar a estrutura de dados do grafo",
                                  "subSteps": [
                                    "Crie uma classe Graph com atributo adj: lista vazia de tamanho n (número de vértices).",
                                    "Implemente o construtor __init__(self, n) que inicializa self.adj = [[] for _ in range(n)].",
                                    "Adicione método para obter número de vértices: def num_vertices(self): return len(self.adj).",
                                    "Teste inicialização com n=4: verifique se adj tem 4 listas vazias.",
                                    "Documente a estrutura com comentários explicando pares (v, w)."
                                  ],
                                  "verification": "Execute print(graph.adj) e confirme [[], [], [], []] para n=4.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código (VS Code ou Jupyter); Python 3+.",
                                  "tips": "Use type hints: from typing import List, Tuple; adj: List[List[Tuple[int, int]]].",
                                  "learningObjective": "Criar uma representação escalável para grafos densos/esparsos.",
                                  "commonMistakes": "Inicializar com lista simples em vez de lista de listas, causando IndexError."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar adição de arestas ponderadas para grafo não direcionado",
                                  "subSteps": [
                                    "Defina método add_edge(self, u: int, v: int, w: int): adicione (v, w) em adj[u] e (u, w) em adj[v].",
                                    "Garanta u e v entre 0 e n-1; adicione validação opcional.",
                                    "Ordene listas de adjacência por vértice para facilitar buscas (opcional para Prim).",
                                    "Adicione arestas exemplo: add_edge(0,1,10), add_edge(0,2,6), add_edge(1,2,5), etc.",
                                    "Implemente método para imprimir grafo: for i, neighbors in enumerate(self.adj): print(f'Vértice {i}: {neighbors}')."
                                  ],
                                  "verification": "Adicione arestas e imprima: confirme simetria (ex: adj[0] tem (1,10) e adj[1] tem (0,10)).",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Editor de código; biblioteca typing para Python.",
                                  "tips": "Mantenha listas não ordenadas para O(1) append; Prim itera linearmente.",
                                  "learningObjective": "Garantir bidirecionalidade e eficiência em inserções O(1).",
                                  "commonMistakes": "Esquecer de adicionar a aresta reversa, tornando o grafo direcionado acidentalmente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e otimizar para uso no algoritmo de Prim",
                                  "subSteps": [
                                    "Crie função para acessar vizinhos de vértice: def neighbors(self, u): return self.adj[u].",
                                    "Simule iteração Prim: para cada vizinho, atualize distância mínima mock.",
                                    "Meça tempo de acesso: use timeit para 1000 iterações em vizinhos de um vértice.",
                                    "Adicione suporte a grafos desconexos (não obrigatório para Prim denso).",
                                    "Refatore para evitar duplicatas em add_edge verificando existência."
                                  ],
                                  "verification": "Execute simulação Prim parcial e confirme atualizações corretas de distâncias.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código; módulo timeit do Python.",
                                  "tips": "Para Prim, priorize append rápido; ordenação só se necessário para heap.",
                                  "learningObjective": "Validar eficiência para relaxações de arestas em Prim.",
                                  "commonMistakes": "Não tratar pesos negativos (inválido para Prim, mas adicionar check)."
                                }
                              ],
                              "practicalExample": "Grafo com 4 vértices: arestas (0-1:10), (0-2:6), (1-2:5), (1-3:15), (2-3:6). Representação: adj = [[(1,10),(2,6)], [(0,10),(2,5),(3,15)], [(0,6),(1,5),(3,6)], [(1,15),(2,6)]]. Ideal para Prim iniciar em vértice 0.",
                              "finalVerifications": [
                                "A estrutura adj é uma lista de listas de tuplas (vértice, peso).",
                                "Adicionar aresta u-v adiciona ambas direções com mesmo peso.",
                                "Acesso a vizinhos de qualquer vértice retorna lista correta em O(1).",
                                "Impressão do grafo mostra simetria perfeita.",
                                "Nenhum erro de índice ou duplicatas em arestas múltiplas.",
                                "Tempo de iteração sobre vizinhos é proporcional ao grau do vértice."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todas arestas bidirecionais com pesos exatos.",
                                "Eficiência: Inserção O(1), acesso vizinhos O(deg(v)).",
                                "Robustez: Validação de índices e pesos positivos.",
                                "Clareza: Código comentado com type hints e docstrings.",
                                "Escalabilidade: Funciona para n até 10^4 sem lentidão.",
                                "Testabilidade: Métodos para print e neighbors funcionais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Matrizes de Adjacência.",
                                "Algoritmos: Preparação para Kruskal e Dijkstra.",
                                "Ciência da Computação: Representações em Redes e Big Data (Graph Databases).",
                                "Programação: Estruturas de Dados Avançadas (HashMaps alternativas)."
                              ],
                              "realWorldApplication": "Em roteirização de entregas (ex: Google Maps otimiza árvores geradoras mínimas para clusters de pontos), redes elétricas (conexão mínima de postes com custos de cabos) ou design de circuitos integrados (minimizar fiação total)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.2",
                            "name": "Inicializar estruturas de dados",
                            "description": "Configurar arrays key[], parent[] e visited[], fila de prioridade com chaves iniciais, inserindo todos os vértices com suas distâncias iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Declarar as estruturas de dados básicas",
                                  "subSteps": [
                                    "Determinar o número de vértices n do grafo.",
                                    "Criar array key[] de tamanho n.",
                                    "Criar array parent[] de tamanho n.",
                                    "Criar array visited[] de tamanho n.",
                                    "Definir o vértice fonte (source) como ponto de partida."
                                  ],
                                  "verification": "Compilar o código sem erros e verificar dimensões dos arrays via depurador ou print.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Grafo de exemplo com 4-5 vértices representado em adjacência"
                                  ],
                                  "tips": "Use typedef ou const int INF = 1e9; para facilitar manutenção.",
                                  "learningObjective": "Entender o papel das estruturas auxiliares na rastreabilidade do algoritmo de Prim.",
                                  "commonMistakes": [
                                    "Usar tamanho n-1 em vez de n.",
                                    "Esquecer de incluir <vector> ou <queue> no início."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar arrays key[] e parent[] com valores padrão",
                                  "subSteps": [
                                    "Definir key[u] = INF para todos u != source.",
                                    "Configurar key[source] = 0.",
                                    "Definir parent[u] = -1 para todos os vértices u.",
                                    "Usar loops for para percorrer todos os índices de 0 a n-1."
                                  ],
                                  "verification": "Imprimir os arrays e confirmar: key[source]=0, outros=INF, todos parent=-1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Função de debug/print para arrays"
                                  ],
                                  "tips": "Sempre inicialize com loops explícitos para evitar resíduos de memória.",
                                  "learningObjective": "Dominar a configuração inicial de distâncias e predecessores.",
                                  "commonMistakes": [
                                    "Esquecer de setar key[source]=0.",
                                    "Usar =0 para todos key, ignorando INF."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar array visited[] e fila de prioridade",
                                  "subSteps": [
                                    "Definir visited[u] = false para todos u.",
                                    "Criar priority_queue min-heap: priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;",
                                    "Inserir todos os vértices: pq.push({key[u], u}) para u de 0 a n-1.",
                                    "Verificar inclusão do source com prioridade 0."
                                  ],
                                  "verification": "Imprimir visited[] (todos false) e tamanho da pq (deve ser n).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Biblioteca <queue> e <utility> incluídas"
                                  ],
                                  "tips": "Use pair<int,int> onde first=chave (distância), second=vértice para min-heap.",
                                  "learningObjective": "Implementar corretamente uma priority_queue para seleção eficiente.",
                                  "commonMistakes": [
                                    "Usar max-heap padrão sem greater<>.",
                                    "Inserir só source na pq."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a inicialização completa",
                                  "subSteps": [
                                    "Executar uma função de validação para checar todos os arrays.",
                                    "Simular extração do mínimo da pq e confirmar source.",
                                    "Corrigir discrepâncias encontradas.",
                                    "Salvar o código inicializado para uso no algoritmo completo.",
                                    "Testar com grafo pequeno (n=4)."
                                  ],
                                  "verification": "Todos checks passam: key correta, pq com n itens, source acessível.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Grafo teste hardcoded"
                                  ],
                                  "tips": "Crie uma função bool isInitialized() para automação.",
                                  "learningObjective": "Garantir robustez na fase inicial do algoritmo.",
                                  "commonMistakes": [
                                    "Ignorar overflow em INF.",
                                    "Não testar com n=1 (grafo trivial)."
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com 4 vértices (0=A,1=B,2=C,3=D), source=0. Após init: key=[0, INF, INF, INF], parent=[-1,-1,-1,-1], visited=[false,false,false,false], pq contém {(0,0),(INF,1),(INF,2),(INF,3)}. Extrair min deve retornar 0.",
                              "finalVerifications": [
                                "key[source] == 0 e key[u] == INF para u != source.",
                                "Todos parent[u] == -1.",
                                "Todos visited[u] == false.",
                                "Priority queue possui exatamente n elementos.",
                                "Menor elemento na pq é {0, source}.",
                                "Nenhuma chave negativa ou inválida nos arrays."
                              ],
                              "assessmentCriteria": [
                                "Precisão na inicialização de key[] (fonte=0, outros=INF).",
                                "Correta configuração de parent[] e visited[].",
                                "Implementação funcional da priority_queue min-heap.",
                                "Ausência de erros de compilação ou runtime na init.",
                                "Validação completa com teste em grafo exemplo.",
                                "Eficiência: O( n log n ) implícito na inserção inicial."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Otimização.",
                                "Programação: Estruturas de Dados Avançadas (Heaps).",
                                "Engenharia de Software: Boas Práticas de Inicialização.",
                                "Redes: Aplicações em Protocolos de Roteamento."
                              ],
                              "realWorldApplication": "Na configuração inicial de redes de telecomunicações para calcular árvores geradoras mínimas, minimizando custos de cabos ou links, como em provedores de internet ou infraestrutura de dados centers."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.3",
                            "name": "Implementar loop principal com extração mínima",
                            "description": "Codificar o ciclo que extrai o vértice u com menor chave via extract-min, marca como visitado e relaxa arestas para vizinhos v não visitados atualizando key[v] e parent[v] se necessário.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar a extração do vértice com menor chave (extract-min)",
                                  "subSteps": [
                                    "Inicialize min_key com um valor infinito (ex: 999999) e u com null.",
                                    "Percorra todos os vértices i de 0 a V-1 usando um loop for.",
                                    "Dentro do loop, verifique se !visited[i] && key[i] < min_key, então atualize min_key = key[i] e u = i.",
                                    "Após o loop de busca, verifique se u foi encontrado."
                                  ],
                                  "verification": "Teste com um array key simulado e visited parcial; confirme que u selecionado tem a menor key entre não visitados.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Arrays simulados para key e visited",
                                    "Lista de adjacência do grafo de teste"
                                  ],
                                  "tips": "Use const INF = 999999 para infinito; adicione console.log para debug da min_key.",
                                  "learningObjective": "Dominar a seleção dinâmica do vértice não visitado com menor key via varredura linear.",
                                  "commonMistakes": [
                                    "Esquecer de checar !visited[i]",
                                    "Inicializar min_key incorretamente",
                                    "Usar <= em vez de < na comparação"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Marcar o vértice extraído como visitado",
                                  "subSteps": [
                                    "Após extrair u, defina visited[u] = true.",
                                    "Adicione um log de debug: console.log('Visitando vértice:', u).",
                                    "Confirme que u não é null antes de marcar."
                                  ],
                                  "verification": "Após execução, verifique que visited[u] === true e u não é reselecionado em extract-min subsequente.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código do step 1",
                                    "Array visited inicializado como false"
                                  ],
                                  "tips": "Sempre cheque if (u === null) return; antes de prosseguir.",
                                  "learningObjective": "Garantir processamento único de cada vértice no algoritmo.",
                                  "commonMistakes": [
                                    "Marcar u antes da extração completa",
                                    "Não checar null e causar erro",
                                    "Marcar vértices errados"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar relaxação das arestas para vizinhos não visitados",
                                  "subSteps": [
                                    "Obtenha a lista de vizinhos adj[u] ou use matriz de adjacência.",
                                    "Inicie um loop for each v em adj[u]:",
                                    "Verifique if (!visited[v] && weight(u, v) < key[v]), então key[v] = weight(u, v) e parent[v] = u.",
                                    "Adicione log para atualizações: console.log('Atualizando key[' + v + '] para ' + weight(u,v))."
                                  ],
                                  "verification": "Simule relaxação em um vértice u com vizinhos; confirme keys e parents atualizados apenas quando melhorados.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Representação do grafo (adjacency list ou matrix)",
                                    "Arrays key, parent, weight function"
                                  ],
                                  "tips": "Implemente weight(u,v) como grafo[u][v] se usando matriz.",
                                  "learningObjective": "Aplicar o princípio de relaxação condicional em algoritmos de caminho mínimo.",
                                  "commonMistakes": [
                                    "Relaxar para v visitados",
                                    "Esquecer atualização de parent[v]",
                                    "Usar <= ou == em vez de <"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar todos os componentes no loop principal completo",
                                  "subSteps": [
                                    "Estruture um while (true) { ... }.",
                                    "Dentro: u = extractMin(); if (u === null) break;",
                                    "Em seguida: markVisited(u); relaxNeighbors(u);",
                                    "Execute o loop completo com prints por iteração."
                                  ],
                                  "verification": "Rode no grafo de exemplo; verifique todos visited true, parents formam árvore, keys corretas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo dos steps anteriores",
                                    "Grafo de teste pequeno com known MST"
                                  ],
                                  "tips": "Conte iterações; deve ser |V| vezes.",
                                  "learningObjective": "Construir e depurar o ciclo iterativo central do Prim.",
                                  "commonMistakes": [
                                    "Loop infinito sem break em u===null",
                                    "Ordem errada: relaxar antes de marcar",
                                    "Não integrar corretamente os blocos"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com V=4 (0,1,2,3), arestas: 0-1(w=1), 0-2(4), 1-2(2), 1-3(5), 2-3(3). Init: key[0]=0, others=INF; parent=-1; visited=false. Iter1: u=0, visit0, relax1(key=1,p=0),2(key=4,p=0). Iter2: u=1, visit1, relax2(key=2,p=1),3(key=5,p=1). Iter3: u=2, visit2, relax3(key=3,p=2). Iter4: u=3, visit3. MST custo=1+2+3=6.",
                              "finalVerifications": [
                                "Loop executa exatamente |V| iterações até todos visitados.",
                                "visited[] todos true no final.",
                                "keys refletem distâncias mínimas da MST.",
                                "parent[] forma árvore conectada sem ciclos.",
                                "Nenhuma relaxação ocorre após todos visitados.",
                                "Custo total da MST matches o esperado para o grafo."
                              ],
                              "assessmentCriteria": [
                                "Extract-min ignora corretamente visitados e seleciona menor key.",
                                "Relaxação usa condição exata: !visited[v] && w(u,v) < key[v].",
                                "Loop while(true) com break apropriado em u===null.",
                                "Estruturas (key, parent, visited, adj) usadas corretamente.",
                                "Código eficiente O(V^2), limpo e bem comentado.",
                                "Testes passam em grafo exemplo com MST correta."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Arrays e listas de adjacência.",
                                "Teoria dos Grafos: Relaxação e propriedades de MST.",
                                "Análise de Algoritmos: Complexidade O(V^2) vs. O(E log V) com heap.",
                                "Programação: Controle de loops, condicionais e debugging."
                              ],
                              "realWorldApplication": "Projeto de redes de telecomunicações para conectar torres com mínimo custo de fibra ótica; otimização de rotas de entrega em logística; clustering em visão computacional para segmentar imagens."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.2.4",
                            "name": "Tratar atualizações com decrease-key",
                            "description": "Implementar operação decrease-key na fila de prioridade para eficiência em grafos densos, evitando re-inserções desnecessárias.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Decrease-Key no Contexto do Algoritmo de Prim",
                                  "subSteps": [
                                    "Estude o problema de atualizações de chaves mínimas em filas de prioridade durante a execução do Prim.",
                                    "Identifique cenários onde uma distância conhecida para um vértice é reduzida, necessitando atualização na heap.",
                                    "Compare com a abordagem ingênua de inserir múltiplas entradas, destacando ineficiências em grafos densos (O(V^2) vs. O((V+E) log V)).",
                                    "Revise a estrutura de dados: heap binária com array de posições/handles para cada vértice.",
                                    "Analise o impacto: sem decrease-key, re-inserções levam a heap inchada e extrações desnecessárias."
                                  ],
                                  "verification": "Explique em suas palavras por que decrease-key é crucial para grafos densos e desenhe um exemplo simples de heap antes/depois de uma atualização.",
                                  "estimatedTime": "45 min",
                                  "materials": [
                                    "Documentação de heaps binárias",
                                    "Pseudocódigo do Prim padrão",
                                    "Artigo sobre implementações eficientes de Prim"
                                  ],
                                  "tips": "Visualize a heap como uma estrutura onde cada nó tem um 'pai' rastreável via handles para subir rapidamente.",
                                  "learningObjective": "Entender a motivação e mecânica conceitual de decrease-key para otimizar Prim.",
                                  "commonMistakes": [
                                    "Confundir decrease-key com delete-min",
                                    "Ignorar o custo de re-inserções em grafos densos",
                                    "Assumir que heaps padrão suportam decrease-key nativamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar Estruturas de Dados para Suportar Decrease-Key",
                                  "subSteps": [
                                    "Implemente uma heap binária mínima com suporte a handles: adicione um array pos[] onde pos[v] armazena o índice de v na heap.",
                                    "Modifique insert para registrar pos[v] = tamanho da heap antes de adicionar.",
                                    "Atualize swap e bubble-up/down para manter pos[] consistente após movimentações.",
                                    "Crie funções auxiliares: getPosition(v), setPosition(v, i).",
                                    "Teste inserções e extrações mínimas para validar consistência de pos[]."
                                  ],
                                  "verification": "Insira 5 elementos, extraia min e verifique se pos[] reflete posições corretas pós-operações.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Editor de código (Python/C++)",
                                    "Biblioteca heapq (para referência, mas implemente custom)",
                                    "Diagrama de heap com handles"
                                  ],
                                  "tips": "Use um dicionário ou array paralelo para pos[] se vertices não forem 0-indexados.",
                                  "learningObjective": "Configurar heap com rastreamento de posições para permitir atualizações eficientes.",
                                  "commonMistakes": [
                                    "Esquecer de atualizar pos[] em swaps recursivos",
                                    "Usar heapq nativa sem handles (não suporta decrease-key)",
                                    "Índices off-by-one em pos[]"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Operação Decrease-Key",
                                  "subSteps": [
                                    "Defina decreaseKey(v, newKey): se newKey >= key[v], ignore; senão atualize key[v] e pos = pos[v].",
                                    "Enquanto pos > 0 e key[parent(pos)] > key[v], troque com pai e atualize pos[].",
                                    "Implemente parent(i) = (i-1)//2, left(i)=2*i+1, right(i)=2*i+2.",
                                    "Adicione verificação se v já foi expandido (infinito ou marcado).",
                                    "Integre lazy decrease: permita múltiplas decreases sem invalidações imediatas."
                                  ],
                                  "verification": "Teste decrease-key em uma heap de 10 elementos, reduzindo chaves e confirmando heap property e pos[] corretos.",
                                  "estimatedTime": "75 min",
                                  "materials": [
                                    "Código da heap do step 2",
                                    "Casos de teste unitários para decrease-key",
                                    "Debugger visual de heaps"
                                  ],
                                  "tips": "Sempre valide heap property pós-operação com uma função checkHeap().",
                                  "learningObjective": "Codificar decrease-key com bubble-up eficiente O(log V).",
                                  "commonMistakes": [
                                    "Não atualizar pos[] do pai após swap",
                                    "Bubble-up infinito sem condição de parada",
                                    "Atualizar chaves de vértices já extraídos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Decrease-Key no Algoritmo de Prim",
                                  "subSteps": [
                                    "Inicialize heap com todos vértices, key[u]=inf, key[s]=0, insert(s).",
                                    "No loop while heap não vazia: u = extract-min(); para cada vizinho v de u, if key[v] > key[u] + w(u,v), decreaseKey(v, key[u] + w(u,v)).",
                                    "Marque vértices extraídos para evitar decreases desnecessários.",
                                    "Execute em um grafo denso (ex: 100 vértices completos) e meça tempo vs. versão sem decrease-key.",
                                    "Otimize: use array de chaves e predecessores paralelos."
                                  ],
                                  "verification": "Rode Prim em grafo de teste, verifique árvore geradora mínima correta e ausência de duplicatas na heap.",
                                  "estimatedTime": "90 min",
                                  "materials": [
                                    "Grafo de teste denso (adj matrix)",
                                    "Código base de Prim ingênuo",
                                    "Profiler de performance"
                                  ],
                                  "tips": "Para grafos densos, prefira matriz de adjacência para O(1) acesso a pesos.",
                                  "learningObjective": "Aplicar decrease-key para alcançar complexidade O((V+E) log V) em Prim.",
                                  "commonMistakes": [
                                    "Decrease-key em vértice já na MST",
                                    "Não resetar pos[] para vértices extraídos",
                                    "Usar insert em vez de decrease-key"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Depurar e Otimizar",
                                  "subSteps": [
                                    "Crie suíte de testes: grafos pequenos/densos, casos com decreases múltiplos.",
                                    "Meça performance: compare com Prim O(V^2) em grafos densos.",
                                    "Depure erros comuns: heapify inválida, pos[] incorretos.",
                                    "Otimize para Fibonacci heap conceitualmente (mas implemente binary).",
                                    "Documente complexidades: decrease-key O(log V), total O(E log V)."
                                  ],
                                  "verification": "Todos testes passam, performance melhora em >20% em grafos densos vs. baseline.",
                                  "estimatedTime": "60 min",
                                  "materials": [
                                    "Framework de testes (pytest/unittest)",
                                    "Gerador de grafos aleatórios",
                                    "Ferramentas de profiling (timeit)"
                                  ],
                                  "tips": "Use asserts para key[], pos[] e heap order em cada operação.",
                                  "learningObjective": "Validar implementação robusta e otimizada de decrease-key em Prim.",
                                  "commonMistakes": [
                                    "Testes só em grafos esparsos",
                                    "Ignorar overflows em chaves infinitas",
                                    "Não medir performance real"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo denso com 5 vértices (A-B:1, A-C:4, B-C:2, B-D:3, C-D:5, etc.), inicie Prim de A. Após extrair A, relaxe B(1), C(4). Então extraia B, relaxe D para 1+3=4 (mas C atualiza D para 1+2+? espere: de B-D=3 -> key[D]=4, mas se depois C for relaxado melhor, decrease-key atualiza sem re-inserir). Heap mantém uma entrada por vértice, atualizando via handle.",
                              "finalVerifications": [
                                "Heap mantém exatamente V entradas ativas (sem duplicatas).",
                                "Todas decreases propagam corretamente com bubble-up.",
                                "MST resultante tem peso mínimo correto.",
                                "pos[] consistente pós-todas operações.",
                                "Performance O((V+E) log V) confirmada empiricamente.",
                                "Nenhum decrease em vértice expandido."
                              ],
                              "assessmentCriteria": [
                                "Correção: MST ótima produzida em todos testes.",
                                "Eficiência: Decrease-key O(log V), sem re-inserções.",
                                "Robustez: Lida com decreases múltiplos e grafos densos.",
                                "Código limpo: Handles/pos[] bem mantidos.",
                                "Documentação: Complexidades e trade-offs explicados.",
                                "Testes: Cobertura >90% incluindo edge cases."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e propriedades de MST.",
                                "Programação: Estruturas de dados avançadas (heaps custom).",
                                "Análise de Algoritmos: Amortized analysis e complexidades.",
                                "Engenharia de Software: Otimização e profiling.",
                                "Redes: Aplicações em roteamento e clustering."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações densas (ex: data centers), otimiza cálculo de árvores de transmissão mínimas custo, reduzindo latência em atualizações dinâmicas de links; usado em GPS para rotas mínimas em mapas densos urbanos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.3.3",
                        "name": "Análise de Complexidade e Corretude",
                        "description": "Análise assintótica das versões com array simples (O(V^2)) e com heap binário (O(E log V)), prova de corretude via invariante guloso e propriedades de AGM, além de exemplos práticos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.3.3.1",
                            "name": "Calcular complexidade temporal e espacial",
                            "description": "Derivar O(V^2) para implementação naive e O(E log V) com heap binário, considerando operações extract-min, decrease-key e inserções iniciais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a Implementação Naive do Algoritmo de Prim",
                                  "subSteps": [
                                    "Examine o pseudocódigo da versão naive, que usa um array para rastrear o vértice com menor peso.",
                                    "Identifique o loop externo que roda V vezes (uma por vértice adicionado à MST).",
                                    "Analise o loop interno que verifica todos os vértices não visitados para encontrar o mínimo.",
                                    "Note as operações de relaxação de arestas adjacentes ao vértice adicionado.",
                                    "Registre as estruturas de dados usadas: arrays para pesos mínimos e visitados."
                                  ],
                                  "verification": "Liste corretamente os loops principais e operações chave em um diagrama ou tabela.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Pseudocódigo do Prim naive, papel e caneta para anotações, editor de texto.",
                                  "tips": "Desenhe um grafo pequeno (3-4 vértices) e simule uma iteração para visualizar.",
                                  "learningObjective": "Compreender a estrutura algorítmica da implementação naive.",
                                  "commonMistakes": "Confundir o loop de seleção do mínimo com busca linear em todos os vértices a cada iteração."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Derivar Complexidade Temporal da Versão Naive",
                                  "subSteps": [
                                    "Calcule o loop externo: V iterações.",
                                    "Para cada iteração externa, o loop interno verifica até V vértices não visitados: O(V) por iteração.",
                                    "Total temporal: V * V = O(V^2).",
                                    "Considere relaxações: O(V) por iteração, ainda subsumido por O(V^2).",
                                    "Ignore constantes e focar em notação assintótica."
                                  ],
                                  "verification": "Escreva a derivação passo a passo resultando em O(V^2) com justificativa.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Pseudocódigo anotado, tabela de contagem de operações.",
                                  "tips": "Use uma tabela para somar custos: colunas para iterações e linhas para operações.",
                                  "learningObjective": "Dominar análise de loops aninhados para complexidade quadrática.",
                                  "commonMistakes": "Esquecer que o loop interno piora para O(V) em cada passo, não fixo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir a Versão com Heap Binário (Priority Queue)",
                                  "subSteps": [
                                    "Substitua o array por uma priority queue (min-heap) para pesos mínimos.",
                                    "Inicialize inserindo todos os V vértices com peso infinito (exceto source).",
                                    "Explique operações chave: extract-min (O(log V)), decrease-key (O(log V)), inserções iniciais O(V).",
                                    "Descreva o loop: extraia mínimo V vezes, relaxe arestas vizinhas com decrease-key.",
                                    "Note que arestas são relaxadas O(E) vezes no total."
                                  ],
                                  "verification": "Descreva o pseudocódigo modificado e liste as operações heap usadas.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Pseudocódigo do Prim com heap, documentação de heap binário.",
                                  "tips": "Implemente um heap pequeno manualmente para entender extract-min e decrease-key.",
                                  "learningObjective": "Entender como priority queues otimizam seleção de mínimos.",
                                  "commonMistakes": "Assumir heap fibonacci; foque em binário padrão com O(log V) para decrease-key."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar Complexidade Temporal e Espacial com Heap",
                                  "subSteps": [
                                    "Inserções iniciais: O(V).",
                                    "V extract-min: V * O(log V) = O(V log V).",
                                    "Relaxações: até O(E) decrease-key: O(E log V).",
                                    "Total temporal: O(E log V + V log V) = O(E log V).",
                                    "Espacial: O(V) para heap + arrays auxiliares; naive também O(V)."
                                  ],
                                  "verification": "Escreva derivação completa mostrando O(E log V) temporal e O(V) espacial.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Tabela de custos operacionais, grafo de exemplo com E arestas.",
                                  "tips": "Compare E vs V^2: para grafos densos E ~ V^2, mas log V economiza.",
                                  "learningObjective": "Analisar complexidade considerando múltiplas operações heap.",
                                  "commonMistakes": "Ignorar custo de inserções iniciais ou contar decrease-key como O(1)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Comparar e Verificar Ambas as Análises",
                                  "subSteps": [
                                    "Compare O(V^2) vs O(E log V): naive bom para grafos densos pequenos.",
                                    "Verifique corretude: ambas constroem MST válida.",
                                    "Confirme espacial: ambas O(V + E) efetivamente.",
                                    "Teste com grafo exemplo: conte operações reais.",
                                    "Discuta trade-offs: heap usa mais espaço mas tempo melhor para E >> V."
                                  ],
                                  "verification": "Crie tabela comparativa com cenários (V pequeno/grande, E denso/esparso).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabelas comparativas, grafo de teste.",
                                  "tips": "Use grafos com V=100, E=1000 vs E=5000 para ilustrar diferenças.",
                                  "learningObjective": "Sintetizar análises e identificar quando usar cada versão.",
                                  "commonMistakes": "Afirmar O(V log V) sem E; sempre inclua E para relaxações."
                                }
                              ],
                              "practicalExample": "Em um grafo com V=5 vértices e E=10 arestas (rede de cidades), naive: loop interno ~25 verificações totais → O(25). Com heap: 5 extract-min (~5 log5=12 ops), 10 decrease-key (~10 log5=20 ops) → total ~32 ops, mas escalável para V=1000 onde naive seria 1M ops vs ~20k log.",
                              "finalVerifications": [
                                "Deriva corretamente O(V^2) para naive, justificando loops aninhados.",
                                "Explica O(E log V) para heap, detalhando extract-min, decrease-key e inserções.",
                                "Identifica complexidade espacial O(V + E) para ambas.",
                                "Compara cenários onde uma é preferível à outra.",
                                "Verifica com exemplo numérico pequeno sem erros.",
                                "Discute assunções (grafos conectados, pesos positivos)."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de operações principais (loops, heap ops).",
                                "Uso correto de notação Big O, ignorando constantes.",
                                "Inclusão de todas operações relevantes (relax, init).",
                                "Clareza na derivação passo a passo.",
                                "Correta distinção temporal vs espacial.",
                                "Análise de trade-offs prática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Análise assintótica e recorrências.",
                                "Estruturas de Dados: Heaps e priority queues.",
                                "Matemática: Logaritmos e crescimento exponencial vs logarítmico.",
                                "Engenharia de Software: Otimização de algoritmos em projetos reais."
                              ],
                              "realWorldApplication": "Em planejamento de redes de telecomunicações ou estradas, onde grafos grandes (milhares de nós) demandam O(E log V) para minimizar custos de conexões sem timeouts computacionais, como no Google Maps para rotas ótimas ou em data centers para topologias eficientes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.2",
                            "name": "Provar corretude do algoritmo",
                            "description": "Demonstrar que a árvore gerada é mínima usando o lema do caminho seguro e o fato de que a aresta adicionada é sempre segura em qualquer corte da AGM parcial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Definições Básicas de AGM e Lema da Aresta Segura",
                                  "subSteps": [
                                    "Defina Árvore Geradora Mínima (AGM) como uma subárvore acíclica conectada de peso mínimo.",
                                    "Enuncie o Lema do Caminho Seguro: Em qualquer AGM parcial S, para qualquer corte (A, V-A) onde A contém S, a aresta de menor peso cruzando o corte é segura (pode ser adicionada sem invalidar a minimalidade).",
                                    "Explique o conceito de 'corte' em grafos e por que arestas seguras preservam a AGM.",
                                    "Discuta o fato de que o algoritmo de Prim constrói uma AGM parcial S começando de um vértice.",
                                    "Desenhe um grafo exemplo simples com 4 vértices para ilustrar."
                                  ],
                                  "verification": "Escreva as definições e o lema em suas palavras e valide com um grafo exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, pseudocódigo do Algoritmo de Prim, grafo exemplo impresso ou digital.",
                                  "tips": "Use diagramas para visualizar cortes; memorize o lema como base da prova.",
                                  "learningObjective": "Compreender os fundamentos teóricos necessários para a prova de corretude.",
                                  "commonMistakes": "Confundir AGM com caminho mínimo; ignorar que o lema aplica a AGM parciais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar o Passo de Expansão no Algoritmo de Prim",
                                  "subSteps": [
                                    "Descreva como Prim seleciona a aresta de menor peso u-v, onde u está em S (AGM parcial) e v não.",
                                    "Mostre que essa aresta cruza o corte (S, V-S) e é a de menor peso nesse corte específico.",
                                    "Argumente por que ela é segura nesse corte usando o lema diretamente.",
                                    "Verifique que adicionar essa aresta mantém S acíclica e conectada.",
                                    "Repita para múltiplos passos em um grafo exemplo."
                                  ],
                                  "verification": "Simule um passo do Prim em um grafo e identifique o corte e a aresta segura.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Grafo exemplo com pesos, calculadora para pesos, software de grafos opcional (ex: Graphviz).",
                                  "tips": "Sempre destaque o corte (S, V-S); prove minimalidade local primeiro.",
                                  "learningObjective": "Demonstrar que cada iteração adiciona uma aresta segura.",
                                  "commonMistakes": "Assumir que a aresta mínima global é segura; esquecer o corte específico do algoritmo."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Prova por Indução da Corretude Completa",
                                  "subSteps": [
                                    "Base da indução: S com 1 vértice é trivialmente AGM.",
                                    "Hipótese: Suponha S_k (k arestas) é subárvore de alguma AGM ótima T.",
                                    "Passo: Mostre que adicionar a aresta segura mantém como subárvore de T (usando lema em cortes de T).",
                                    "Conclusão: Quando |S| = n-1, S é AGM mínima.",
                                    "Formalize a prova escrita com notação matemática."
                                  ],
                                  "verification": "Escreva a prova por indução completa e cheque contra referências padrão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Folha de papel para prova formal, livro ou slides de Algoritmos (ex: Cormen).",
                                  "tips": "Use contraexemplo hipotético para testar hipótese; escreva equações de peso.",
                                  "learningObjective": "Aplicar indução para provar que a árvore final é mínima.",
                                  "commonMistakes": "Falhar no passo indutivo (não ligar à AGM ótima); confundir com Kruskal."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar e Reforçar a Prova com Exemplos e Contraexemplos",
                                  "subSteps": [
                                    "Aplique a prova a um grafo onde Prim difere de Kruskal.",
                                    "Considere um contraexemplo: suponha S não mínima e derive contradição via lema.",
                                    "Discuta generalizações (grafos densos/esparsos).",
                                    "Resuma a prova em um fluxograma.",
                                    "Ensine a outro (autoexplicação)."
                                  ],
                                  "verification": "Explique a prova oralmente ou em vídeo curto sem consultar notas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Grafo contraexemplo, gravador de voz ou espelho para autoexplicação.",
                                  "tips": "Use cores para arestas seguras vs. não seguras em diagramas.",
                                  "learningObjective": "Solidificar compreensão através de aplicação e ensino.",
                                  "commonMistakes": "Ignorar casos com múltiplas MSTs; não testar grafos desconectados."
                                }
                              ],
                              "practicalExample": "Considere o grafo com vértices A,B,C,D e arestas AB=1, AC=4, AD=3, BC=2, BD=5, CD=1. Inicie Prim em A: S={A}. Aresta mínima: AB=1 (corte {A},{B,C,D}). Adicione B. Nova mínima: BC=2 (corte {A,B},{C,D}, mas cheque AD=3>BC? Não, BC cruza). Continue provando cada adição segura via lema, resultando em MST {AB,BC,CD} peso 4.",
                              "finalVerifications": [
                                "Enuncie corretamente o lema da aresta segura e aplique a um corte.",
                                "Simule Prim em grafo de 5 vértices e identifique todas arestas seguras.",
                                "Escreva prova por indução sem erros lógicos.",
                                "Identifique por que a aresta escolhida é segura em QUALQUER corte da AGM parcial.",
                                "Prove que a árvore final tem peso mínimo comparando com outra AGM.",
                                "Explique diferenças com Kruskal na prova de corretude."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão no uso do lema do caminho seguro.",
                                "Corretude da prova por indução (base, hipótese, passo).",
                                "Identificação precisa de cortes e arestas seguras em exemplos.",
                                "Uso de notação matemática e diagramas adequados.",
                                "Capacidade de lidar com contraexemplos e generalizações.",
                                "Comunicação fluida da prova (escrita/oral).",
                                "Conexão explícita entre passos do Prim e propriedades de minimalidade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de grafos, indução matemática.",
                                "Lógica e Provas: Raciocínio por contradição e lemas auxiliares.",
                                "Programação: Implementação prática do Prim para validar prova.",
                                "Otimização: Aplicações em problemas de minimização combinatorial.",
                                "Física/Engenharia: Redes de distribuição mínima (ex: cabos elétricos)."
                              ],
                              "realWorldApplication": "Em telecomunicações, o Algoritmo de Prim otimiza o layout de cabos de fibra ótica conectando torres, garantindo custo mínimo; a prova de corretude assegura que a rede construída é sempre a mais econômica, evitando desperdícios em projetos de infraestrutura reais."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.3.3.3",
                            "name": "Executar exemplo manual passo a passo",
                            "description": "Aplicar o algoritmo manualmente em um grafo exemplo com 5-6 vértices, traçando chaves, pais e arestas selecionadas até formar a AGM completa.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar o algoritmo com o vértice A",
                                  "subSteps": [
                                    "Desenhe o grafo exemplo com vértices A, B, C, D, E e arestas: A-B(7), A-C(8), A-D(5), B-C(5), B-E(9), C-D(15), C-E(6), D-E(10).",
                                    "Crie uma tabela com colunas: Vértice, Key (inicial: A=0, outros=∞), Pai (todos null), inMST (A=true, outros=false).",
                                    "Liste todas as arestas adjacentes a A: B(7), C(8), D(5)."
                                  ],
                                  "verification": "Confirme que key[A]=0, inMST[A]=true, e todos outros vértices têm key=∞ e pai=null.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de desenho de grafos como Draw.io",
                                    "Lista impressa das arestas"
                                  ],
                                  "tips": "Use ∞ como símbolo para infinito e destaque o vértice inicial em negrito ou cor.",
                                  "learningObjective": "Configurar corretamente as estruturas de dados iniciais para o algoritmo de Prim.",
                                  "commonMistakes": [
                                    "Definir key inicial diferente de 0",
                                    "Esquecer de marcar apenas o vértice inicial como inMST"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Primeira iteração: Selecionar e adicionar D",
                                  "subSteps": [
                                    "Encontre o vértice não-inMST com menor key: D (5 de A).",
                                    "Adicione D à MST: defina pai[D]=A, inMST[D]=true, adicione aresta A-D(5).",
                                    "Atualize keys dos vizinhos de D não-inMST: C min(8,15)=8 (sem mudança), E=10 (de D-E)."
                                  ],
                                  "verification": "Verifique key[D]=5, pai[D]=A, inMST[D]=true, e keys atualizadas: B=7, C=8, E=10.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela atualizada da iteração anterior",
                                    "Lápis para riscar atualizações"
                                  ],
                                  "tips": "Sempre compare a nova key com a atual antes de atualizar.",
                                  "learningObjective": "Executar corretamente a seleção do mínimo e atualização de vizinhos.",
                                  "commonMistakes": [
                                    "Selecionar vértice errado como mínimo",
                                    "Atualizar key sem comparar com o valor atual"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Segunda iteração: Selecionar e adicionar B",
                                  "subSteps": [
                                    "Encontre mínimo não-inMST: B (7 de A).",
                                    "Adicione B: pai[B]=A, inMST[B]=true, aresta A-B(7).",
                                    "Atualize vizinhos de B: C min(8,5)=5 (pai=C=B), E min(10,9)=9 (pai=E=B)."
                                  ],
                                  "verification": "Confirme keys: C=5, E=9; pai[C]=B, pai[E]=B; inMST[A,B,D]=true.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela da iteração anterior",
                                    "Marcadores para destacar adições"
                                  ],
                                  "tips": "Rastreie explicitamente qual aresta atualizou cada key.",
                                  "learningObjective": "Manter precisão nas atualizações relaxadas das chaves.",
                                  "commonMistakes": [
                                    "Ignorar vizinhos já com key melhor",
                                    "Não atualizar pai ao relaxar key"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Terceira iteração: Selecionar e adicionar C",
                                  "subSteps": [
                                    "Mínimo não-inMST: C (5 de B).",
                                    "Adicione C: pai[C]=B, inMST[C]=true, aresta B-C(5).",
                                    "Atualize vizinhos de C: D já inMST, E min(9,6)=6 (pai=E=C)."
                                  ],
                                  "verification": "Keys: E=6; pai[E]=C; inMST[A,B,C,D]=true.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela atualizada",
                                    "Calculadora para comparações mínimas"
                                  ],
                                  "tips": "Verifique todos vizinhos mesmo se parecem inalterados.",
                                  "learningObjective": "Aplicar relaxações condicionais corretamente em iterações intermediárias.",
                                  "commonMistakes": [
                                    "Pular atualização de vizinhos inMST",
                                    "Erro em comparação de pesos"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Última iteração: Adicionar E e finalizar",
                                  "subSteps": [
                                    "Mínimo restante: E (6 de C).",
                                    "Adicione E: pai[E]=C, inMST[E]=true, aresta C-E(6).",
                                    "Calcule custo total: 5+7+5+6=23; verifique conectividade e ausência de ciclos."
                                  ],
                                  "verification": "Todos inMST=true, 4 arestas, soma=23, árvore conecta todos vértices.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela final",
                                    "Lista de arestas da MST"
                                  ],
                                  "tips": "Desenhe a MST final separadamente para visualizar.",
                                  "learningObjective": "Completar o algoritmo e validar a AGM gerada.",
                                  "commonMistakes": [
                                    "Adicionar aresta extra",
                                    "Cálculo errado do custo total"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com vértices A,B,C,D,E e arestas pesadas: A-B(7), A-C(8), A-D(5), B-C(5), B-E(9), C-D(15), C-E(6), D-E(10). Inicie em A. Sequência: Adicione D(5 de A), B(7 de A), C(5 de B), E(6 de C). AGM: A-D, A-B, B-C, C-E (custo 23).",
                              "finalVerifications": [
                                "Todos 5 vértices incluídos na MST.",
                                "Exatamente 4 arestas na árvore.",
                                "Soma dos pesos das arestas = 23.",
                                "Nenhum ciclo presente (verifique pais).",
                                "Cada vértice exceto raiz tem exatamente um pai.",
                                "Arestas selecionadas conectam todos os vértices."
                              ],
                              "assessmentCriteria": [
                                "Seleção correta do vértice de menor key em cada iteração.",
                                "Atualizações precisas de keys e pais apenas para vizinhos não-inMST.",
                                "Rastreamento consistente de estruturas (key, pai, inMST).",
                                "Ausência de ciclos e conectividade total na MST final.",
                                "Custo total mínimo calculado corretamente (23).",
                                "Documentação clara de cada passo e justificativa."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Otimização Combinatória.",
                                "Programação: Implementação de Algoritmos em Estruturas de Dados (grafos adjacentes).",
                                "Engenharia de Redes: Design de Redes de Menor Custo.",
                                "Economia: Problemas de Alocação de Recursos Mínimos.",
                                "Física: Modelagem de Conexões em Sistemas (ex: circuitos)."
                              ],
                              "realWorldApplication": "No planejamento de redes de telecomunicações, conectar cidades com cabos de fibra ótica minimizando o custo total de instalação, garantindo conectividade total sem loops desnecessários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.4",
                    "name": "Estrutura de Dados Union-Find",
                    "description": "Estrutura auxiliar para Kruskal que gerencia componentes conectados e detecta ciclos via união e busca.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.4.1",
                        "name": "Representação e Inicialização da Union-Find",
                        "description": "Definição da estrutura básica usando arrays para representar conjuntos disjuntos, inicializando cada elemento como seu próprio representante para gerenciar componentes conectados em grafos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.1.1",
                            "name": "Implementar array de pais (parent)",
                            "description": "Criar e inicializar um array 'parent' de tamanho n+1 onde parent[i] = i para cada nó i, representando n elementos isolados em seus próprios conjuntos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito do array parent na Union-Find",
                                  "subSteps": [
                                    "Estude a estrutura Union-Find e seu uso em algoritmos como Kruskal para Árvore Geradora Mínima.",
                                    "Identifique que cada nó inicialmente é seu próprio pai, representando conjuntos isolados.",
                                    "Revise exemplos de grafos com n nós e como eles começam desconectados.",
                                    "Anote o tamanho necessário: n+1 para índices de 0 a n (0 pode ser não usado).",
                                    "Desenhe um diagrama simples com 3 nós mostrando parent[i] = i."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito por que parent[i] = i representa conjuntos isolados.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Documentação de Union-Find",
                                    "Papel e caneta para diagrama",
                                    "Editor de código"
                                  ],
                                  "tips": "Visualize os nós como ilhas separadas; a união posterior as conectará.",
                                  "learningObjective": "Entender o papel fundamental do array parent na representação de conjuntos disjuntos.",
                                  "commonMistakes": [
                                    "Confundir com array de rank ou size",
                                    "Ignorar o índice 0",
                                    "Achar que inicialização é desnecessária"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Declarar o array parent",
                                  "subSteps": [
                                    "Escolha a linguagem (ex: C++, Python, Java).",
                                    "Defina n como parâmetro de entrada (ex: int n = 5;).",
                                    "Declare o array: em C++ 'vector<int> parent(n+1);', em Python 'parent = [0] * (n+1)'.",
                                    "Compile ou execute um teste vazio para verificar declaração.",
                                    "Adicione comentários explicando o tamanho n+1."
                                  ],
                                  "verification": "Compile o código sem erros e inspecione o tamanho do array via debug ou print(len(parent)).",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, PyCharm)",
                                    "Compilador/Interpretador"
                                  ],
                                  "tips": "Use vector em C++ para flexibilidade; liste sempre n+1 para evitar erros de índice.",
                                  "learningObjective": "Declarar corretamente um array dinâmico de tamanho baseado em n.",
                                  "commonMistakes": [
                                    "Usar tamanho n em vez de n+1",
                                    "Esquecer inicialização parcial em Python",
                                    "Índices off-by-one"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar o array com parent[i] = i",
                                  "subSteps": [
                                    "Implemente um loop for de i = 0 até n: parent[i] = i; (ou i=1 a n se 0 não usado).",
                                    "Em Python: for i in range(n+1): parent[i] = i",
                                    "Em C++: for(int i=0; i<=n; i++) parent[i] = i;",
                                    "Adicione uma função de impressão para visualizar: print(parent).",
                                    "Teste com n=3 e confirme saída [0,1,2,3]."
                                  ],
                                  "verification": "Execute e verifique se todos parent[i] == i via print ou debugger.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Terminal para execução"
                                  ],
                                  "tips": "Use range(n+1) inclusive; evite loops manuais para n grande.",
                                  "learningObjective": "Implementar inicialização eficiente via loop para representar n conjuntos isolados.",
                                  "commonMistakes": [
                                    "Loop de 1 a n esquecendo i=0",
                                    "Atribuir parent[i] = 0",
                                    "Loop infinito ou off-by-one"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e encapsular a inicialização",
                                  "subSteps": [
                                    "Crie uma função initParent(n) que retorna o array inicializado.",
                                    "Adicione asserções ou testes unitários: assert(parent[i] == i for all i).",
                                    "Teste com múltiplos n (1, 5, 10).",
                                    "Documente a função com Javadoc/Docstring.",
                                    "Integre em um esqueleto de Union-Find básico."
                                  ],
                                  "verification": "Todos testes passam e função retorna array correto para n variados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Framework de testes (unittest em Python, Google Test em C++)"
                                  ],
                                  "tips": "Encapsule em função para reutilização em find/union.",
                                  "learningObjective": "Criar código modular, testável e documentado para inicialização Union-Find.",
                                  "commonMistakes": [
                                    "Não testar edge cases como n=0 ou n=1",
                                    "Função mutando entrada",
                                    "Falta de documentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Para n=4 (4 nós), inicialize parent = [0, 1, 2, 3, 4]. Isso significa: nó 1 pai de si (conjunto {1}), nó 2 pai de si ({2}), etc. Código Python: def init_parent(n): parent = [0]*(n+1); for i in range(n+1): parent[i]=i; return parent. Resultado: [0,1,2,3,4].",
                              "finalVerifications": [
                                "Array possui exatamente n+1 elementos.",
                                "Para todo i de 0 a n, parent[i] == i.",
                                "Função initParent(n) retorna array correto para n=1,5,10.",
                                "Não há vazamentos de memória ou erros de alocação.",
                                "Tempo de execução O(n) linear.",
                                "Integração sem erros em estrutura Union-Find básica."
                              ],
                              "assessmentCriteria": [
                                "Correção: parent[i] == i para todos i.",
                                "Eficiência: Loop O(n) sem operações desnecessárias.",
                                "Robustez: Trata n=0, n=1 corretamente.",
                                "Clareza: Código comentado e legível.",
                                "Modularidade: Encapsulado em função reutilizável.",
                                "Testes: Cobertura de casos edge e normais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Conjuntos Disjuntos.",
                                "Programação Básica: Manipulação de Arrays e Loops.",
                                "Algoritmos: Preparação para Union-Find e Kruskal.",
                                "Engenharia de Software: Testes Unitários e Modularidade."
                              ],
                              "realWorldApplication": "Inicialização essencial em algoritmos de conectividade de redes, como encontrar Árvore Geradora Mínima em telecomunicações (roteamento eficiente), análise de redes sociais (grupos conectados) ou bioinformática (clusters de genes similares), otimizando processamento de grafos com milhões de nós."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.4.1.2",
                            "name": "Implementar array de rank ou tamanho",
                            "description": "Criar arrays auxiliares 'rank' ou 'size' inicializados com 1 ou 0 para cada nó, preparando otimizações para uniões balanceadas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o propósito dos arrays rank e size na Union-Find",
                                  "subSteps": [
                                    "Estude a estrutura básica da Union-Find e suas otimizações.",
                                    "Compare Union by Rank (altura da árvore) com Union by Size (tamanho da subárvore).",
                                    "Identifique como esses arrays evitam árvores desbalanceadas.",
                                    "Analise um exemplo simples de degradação sem otimizações.",
                                    "Anote as diferenças entre inicializar rank com 1 e size com 1."
                                  ],
                                  "verification": "Explique em voz alta ou por escrito por que rank inicia com 1 e size com 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Documentação de Union-Find, pseudocódigo de exemplos, quadro branco.",
                                  "tips": "Desenhe árvores antes e depois da união para visualizar o balanceamento.",
                                  "learningObjective": "Entender o impacto das otimizações na eficiência da Union-Find.",
                                  "commonMistakes": "Confundir rank (altura) com size (número de nós); ignorar que ambos iniciam em 1."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e declarar o array auxiliar",
                                  "subSteps": [
                                    "Decida entre usar 'rank' ou 'size' baseado no contexto (ex: rank para simplicidade).",
                                    "Declare o array no tamanho correto (n elementos para n nós).",
                                    "Escolha o tipo de dado (inteiro) e nomeie claramente (ex: rank[] ou size[]).",
                                    "Integre a declaração na classe ou estrutura da Union-Find.",
                                    "Adicione comentários explicando a escolha."
                                  ],
                                  "verification": "Compile o código sem erros e verifique se o array é acessível na classe.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Editor de código (VS Code, IntelliJ), linguagem de programação (Python/C++).",
                                  "tips": "Use rank se priorizar altura; size se quiser contagem exata de nós.",
                                  "learningObjective": "Selecionar e implementar corretamente a representação auxiliar.",
                                  "commonMistakes": "Declarar array com tamanho errado (ex: n-1 em vez de n); usar float em vez de int."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Inicializar o array com valores padrão",
                                  "subSteps": [
                                    "No método de inicialização (make_set ou construtor), defina todos os elementos como 1.",
                                    "Para rank: rank[i] = 1 para todo i.",
                                    "Para size: size[i] = 1 para todo i.",
                                    "Garanta que a inicialização ocorra antes de qualquer operação find/union.",
                                    "Teste com um loop para imprimir valores iniciais."
                                  ],
                                  "verification": "Execute um teste unitário que imprima o array e confirme todos os valores como 1.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Editor de código, framework de testes (unittest em Python).",
                                  "tips": "Use um loop for simples: for i in range(n): rank[i] = 1.",
                                  "learningObjective": "Implementar inicialização correta para preparar uniões balanceadas.",
                                  "commonMistakes": "Inicializar com 0 (incorreto para rank/size); esquecer algum índice."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar integração e preparar para uso em uniões",
                                  "subSteps": [
                                    "Atualize o método union para usar o array escolhido (ex: attach menor rank à maior).",
                                    "Implemente uma função auxiliar para atualizar rank/size após união.",
                                    "Crie um teste com 3-5 uniões e verifique balanceamento.",
                                    "Meça a altura da árvore resultante para validar.",
                                    "Documente o código com exemplos de uso."
                                  ],
                                  "verification": "Rode simulação completa de Union-Find e confirme que árvores permanecem rasas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Editor de código, exemplos de grafos para teste.",
                                  "tips": "Sempre una o nó de menor rank/size ao maior para balancear.",
                                  "learningObjective": "Integrar o array em operações reais da Union-Find.",
                                  "commonMistakes": "Não atualizar o rank/size após união; comparar incorretamente na union."
                                }
                              ],
                              "practicalExample": "Em Python, para 4 nós: class UnionFind: def __init__(self, n): self.parent = list(range(n)); self.rank = [1] * n. Teste: uf = UnionFind(4); print(uf.rank) → [1,1,1,1]. Após uf.union(0,1): rank pode ser [2,1,1,1] se atualizado.",
                              "finalVerifications": [
                                "Array rank/size inicializado corretamente com 1 para todos os nós.",
                                "Método union usa o array para balancear uniões.",
                                "Testes unitários passam sem erros de inicialização.",
                                "Altura da árvore permanece O(log n) em simulações.",
                                "Código comentado explica escolhas e inicializações.",
                                "Nenhum nó órfão ou valor incorreto no array."
                              ],
                              "assessmentCriteria": [
                                "Correção da inicialização (todos 1s).",
                                "Integração lógica no union/find.",
                                "Eficiência demonstrada em testes (sem degradação).",
                                "Clareza do código e comentários.",
                                "Escolha justificada entre rank e size.",
                                "Tratamento de casos edge (n=1, n=0)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Complexidade Assintótica.",
                                "Programação: Estruturas de Dados e Algoritmos de Disjoint Sets.",
                                "Engenharia de Software: Otimização e Testes Unitários.",
                                "Ciência de Dados: Processamento de Redes e Clustering."
                              ],
                              "realWorldApplication": "Usado em algoritmos como Kruskal para Árvore Geradora Mínima em redes de computadores, detecção de ciclos em grafos de estradas, agrupamento em machine learning e gerenciamento de conectividade em jogos multiplayer."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.1.3",
                            "name": "Entender componentes conectados",
                            "description": "Explicar como a estrutura modela florestas de árvores, onde cada árvore representa um componente conectado no grafo durante a execução de Kruskal.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender Conceitos Básicos de Componentes Conectados em Grafos",
                                  "subSteps": [
                                    "Defina grafo não direcionado e seus elementos (vértices e arestas).",
                                    "Explique o que é um componente conectado: subgrafo onde todo par de vértices é conectado por um caminho.",
                                    "Identifique componentes em um grafo exemplo simples com 4-6 vértices e poucas arestas.",
                                    "Diferencie grafo conexo de grafo desconexo."
                                  ],
                                  "verification": "Desenhe um grafo desconexo com 2 componentes e rotule os vértices de cada um.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta online como draw.io ou Graphviz"
                                  ],
                                  "tips": "Sempre desenhe o grafo para visualizar as conexões.",
                                  "learningObjective": "Dominar a definição e identificação de componentes conectados em grafos.",
                                  "commonMistakes": [
                                    "Confundir componente conectado com ciclo.",
                                    "Considerar arestas direcionadas em grafos não direcionados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender a Representação da Union-Find como Floresta de Árvores",
                                  "subSteps": [
                                    "Descreva a estrutura Union-Find: array parent[] e rank[] para cada vértice.",
                                    "Explique que inicialmente cada vértice é uma árvore singleton (floresta com n árvores).",
                                    "Mostre como find() segue pais até a raiz, representando a árvore do componente.",
                                    "Ilustre parent[] para um grafo inicial desconexo."
                                  ],
                                  "verification": "Implemente um array parent[] para 5 vértices isolados e execute find() em um deles.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código (Python ou pseudocódigo)",
                                    "Papel para diagramas de árvores"
                                  ],
                                  "tips": "Pense na raiz como o 'líder' do componente.",
                                  "learningObjective": "Associar a floresta de Union-Find aos componentes conectados.",
                                  "commonMistakes": [
                                    "Confundir parent[i] com o vértice i.",
                                    "Esquecer path compression no find()."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Analisar a Evolução dos Componentes Durante Kruskal",
                                  "subSteps": [
                                    "Revise Kruskal: ordena arestas por peso e adiciona se não formar ciclo (diferentes componentes).",
                                    "Explique union(): une raízes de duas árvores, reduzindo o número de componentes.",
                                    "Simule passo a passo: adicione arestas e atualize a floresta.",
                                    "Conte o número de árvores na floresta após cada union() bem-sucedida."
                                  ],
                                  "verification": "Simule Kruskal em um grafo de 4 vértices com 3 arestas, mostrando a floresta antes/depois de cada união.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Grafo exemplo impresso ou digital",
                                    "Pseudocódigo de Kruskal-Union-Find"
                                  ],
                                  "tips": "Use find() antes de union() para checar se já estão no mesmo componente.",
                                  "learningObjective": "Compreender como Union-Find modela dinamicamente os componentes em Kruskal.",
                                  "commonMistakes": [
                                    "Unir arestas que conectam o mesmo componente.",
                                    "Ignorar ordenação por peso."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Visualizar e Verificar a Modelagem Completa",
                                  "subSteps": [
                                    "Desenhe a evolução da floresta para um grafo exemplo completo.",
                                    "Compare o número final de componentes com o resultado da AGM.",
                                    "Explique por que a floresta final tem 1 árvore se o grafo é conexo.",
                                    "Discuta o papel dos componentes na detecção de ciclos."
                                  ],
                                  "verification": "Crie um diagrama mostrando florestas inicial, intermediária e final para Kruskal.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ferramenta de desenho (draw.io)",
                                    "Exemplo de grafo com pesos"
                                  ],
                                  "tips": "Anime a união visualmente para fixar o conceito.",
                                  "learningObjective": "Integrar a visão de florestas com a execução de Kruskal.",
                                  "commonMistakes": [
                                    "Assumir grafo sempre conexo.",
                                    "Confundir número de árvores com número de arestas na AGM."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo com vértices A,B,C,D e arestas: A-B(1), B-C(2), A-D(3), C-D(4). Inicialmente, 4 árvores: {A},{B},{C},{D}. Adicione A-B → {A-B},{C},{D}. Adicione B-C → {A-B-C},{D}. Adicione A-D → {A-B-C-D}. Floresta final: 1 árvore.",
                              "finalVerifications": [
                                "Explicar verbalmente como uma nova aresta une componentes se raízes diferem.",
                                "Simular find() e union() em um exemplo pequeno.",
                                "Identificar corretamente o número de componentes em qualquer estágio de Kruskal.",
                                "Desenhar a floresta para um grafo dado.",
                                "Diferenciar floresta inicial (n árvores) da final (1 para grafo conexo).",
                                "Prever se uma aresta forma ciclo baseado em componentes.",
                                "Contar reduções no número de árvores durante Kruskal."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de componente conectado (100%).",
                                "Correta representação de parent[] e evolução da floresta (90%).",
                                "Simulação passo a passo sem erros em Kruskal (85%).",
                                "Uso correto de find() e union() em exemplos (95%).",
                                "Visualizações claras e rotuladas (80%).",
                                "Explicação da modelagem de florestas (90%).",
                                "Identificação de ciclos via componentes iguais (100%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de Grafos e componentes.",
                                "Redes de Computadores: Detecção de loops em roteamento.",
                                "Biologia Computacional: Clustering de genes em redes.",
                                "Estatística: Análise de clusters em dados de rede.",
                                "Física: Modelagem de redes elétricas conectadas."
                              ],
                              "realWorldApplication": "Em telecomunicações, Union-Find otimiza redes minimizando cabos (AGM), modelando sub-redes conectadas durante planejamento para evitar loops e garantir conectividade mínima."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.2",
                        "name": "Operação Find (Busca de Raiz)",
                        "description": "Algoritmo para encontrar o representante (raiz) de um conjunto, essencial para detectar se dois vértices estão no mesmo componente e evitar ciclos.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.2.1",
                            "name": "Implementar Find recursivo simples",
                            "description": "Desenvolver função recursiva que segue os pais até a raiz: find(x) = x se parent[x] == x, senão find(parent[x]).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Básicos de Union-Find e Recursão",
                                  "subSteps": [
                                    "Estude a estrutura Union-Find: um array 'parent' onde parent[i] indica o pai de i, e raízes têm parent[i] = i.",
                                    "Visualize uma árvore de exemplo: parent = [1, 1, 3, 3] (raízes 1 e 3).",
                                    "Defina recursão: função chama a si mesma com subproblema menor até condição base.",
                                    "Identifique condição base: se parent[x] == x, retorne x.",
                                    "Desenhe o caminho de compressão para um nó folha até raiz."
                                  ],
                                  "verification": "Desenhe um diagrama da árvore e trace find(0) verbalmente, confirmando retorno da raiz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Editor de texto para pseudocódigo",
                                    "Referência Union-Find online"
                                  ],
                                  "tips": "Sempre comece visualizando a árvore para intuir o fluxo recursivo.",
                                  "learningObjective": "Dominar os fundamentos teóricos para implementação correta.",
                                  "commonMistakes": [
                                    "Assumir árvore balanceada inicialmente",
                                    "Confundir 'parent' com 'rank' ou 'size'",
                                    "Ignorar que raízes apontam para si mesmas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar a Estrutura de Dados e Ambiente",
                                  "subSteps": [
                                    "Crie um array 'parent' inicializado com parent[i] = i para i em 0 a n-1.",
                                    "Escolha uma linguagem (ex: Python) e configure um script de teste.",
                                    "Implemente uma função auxiliar para imprimir a árvore atual.",
                                    "Teste inicialização com n=5: parent deve ser [0,1,2,3,4].",
                                    "Simule uma union simples para criar profundidade: parent[0]=1."
                                  ],
                                  "verification": "Execute print(parent) e confirme que todos os nós são suas próprias raízes inicialmente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Python instalado"
                                  ],
                                  "tips": "Use listas mutáveis em Python para permitir modificações durante testes.",
                                  "learningObjective": "Preparar dados realistas para testar a recursão.",
                                  "commonMistakes": [
                                    "Índices off-by-one no array",
                                    "Não inicializar como identidade",
                                    "Esquecer importações básicas como sys para recursão profunda"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Função Find Recursiva",
                                  "subSteps": [
                                    "Defina def find(x): if parent[x] == x: return x else: return find(parent[x])",
                                    "Adicione print de debug para rastrear chamadas recursivas.",
                                    "Remova o array 'parent' como global ou passe como parâmetro para modularidade.",
                                    "Teste com nó raiz: find(1) deve retornar 1 imediatamente.",
                                    "Teste com nó folha: find(0) com parent[0]=1 deve chamar find(1) e retornar 1."
                                  ],
                                  "verification": "Chame find em vários nós e confirme que todos retornam suas raízes corretas sem erros.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do Step 2",
                                    "Console para depuração"
                                  ],
                                  "tips": "Use sys.setrecursionlimit(1000) em Python para testes iniciais profundos.",
                                  "learningObjective": "Codificar a lógica recursiva pura e funcional.",
                                  "commonMistakes": [
                                    "Retornar parent[x] em vez de find(parent[x])",
                                    "Loop infinito se parent[x] != x mas sem base",
                                    "Mutar parent acidentalmente na recursão simples"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar, Depurar e Verificar a Implementação",
                                  "subSteps": [
                                    "Crie casos de teste: árvore plana, cadeia profunda (ex: parent=[4,4,4,4,4]), árvore mista.",
                                    "Execute find em todos os nós e compare com raízes esperadas.",
                                    "Meça profundidade de recursão com contador de chamadas.",
                                    "Depure erros: verifique stack trace para overflow.",
                                    "Otimize removendo prints e confirmando performance."
                                  ],
                                  "verification": "Todos os testes passam: 100% de acerto em raízes, sem exceções.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Suite de testes unitários (pytest ou manual)",
                                    "Exemplos de árvores variadas"
                                  ],
                                  "tips": "Comece com casos pequenos e escale para n=100 para detectar issues.",
                                  "learningObjective": "Garantir robustez e corretude da função.",
                                  "commonMistakes": [
                                    "Testes insuficientes (só raízes)",
                                    "Ignorar profundidade levando a stack overflow",
                                    "Não validar entrada (x fora de range)"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado parent = [1, 3, 3, 3] (após unions: 0->1->3, 2->3):\n- find(0) → find(1) → find(3) → 3 (retorna 3)\n- find(2) → find(3) → 3\nImplemente e execute: print(find(0)) deve output 3.",
                              "finalVerifications": [
                                "Função retorna x corretamente quando parent[x] == x.",
                                "Para nós não-raiz, segue chain até raiz sem loops.",
                                "Nenhum erro de recursão profunda em árvores com profundidade < 100.",
                                "Função não modifica o array parent.",
                                "Testes em 10+ nós variados passam 100%.",
                                "Tempo de execução O(profundidade) observável."
                              ],
                              "assessmentCriteria": [
                                "Corretude: 100% acerto em raízes para casos variados.",
                                "Eficiência: Sem otimizações extras, mas recursão pura funciona.",
                                "Clareza de código: Nomes intuitivos, comentários na recursão.",
                                "Robustez: Trata índices válidos, sem crashes.",
                                "Modularidade: Função aceita parent como parâmetro.",
                                "Documentação: Inclui docstring com exemplo."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recursão modela indução matemática em árvores.",
                                "Algoritmos: Base para path compression e union-by-rank.",
                                "Programação Funcional: Conceitos de pureza e tail recursion.",
                                "Grafos: Encontra componentes conectados em redes sociais."
                              ],
                              "realWorldApplication": "Em algoritmos como Kruskal para Árvore Geradora Mínima (MST) em redes de telecomunicações, detecta ciclos e une componentes eficientemente; usado em clustering de dados e detecção de fraudes em transações."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.2",
                            "name": "Implementar compressão de caminho",
                            "description": "Modificar find para comprimir o caminho, definindo parent[x] = find(parent[x]) recursivamente, reduzindo a altura da árvore.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a operação find sem compressão de caminho",
                                  "subSteps": [
                                    "Revise a implementação básica da função find em Union-Find, que segue o parent até a raiz sem modificações.",
                                    "Identifique o problema: em árvores degeneradas (linhas longas), find leva O(n) tempo.",
                                    "Desenhe um exemplo de árvore degenerada com 5-6 nós para visualizar a altura elevada.",
                                    "Meça manualmente o número de saltos em uma find em um nó folha.",
                                    "Compare com árvores balanceadas para destacar a necessidade de compressão."
                                  ],
                                  "verification": "Você pode desenhar a árvore e contar os saltos corretamente sem compressão.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta para diagramas",
                                    "Pseudocódigo básico de Union-Find"
                                  ],
                                  "tips": [
                                    "Use setas para representar parents e destaque caminhos longos."
                                  ],
                                  "learningObjective": "Entender o gargalo de performance na find sem compressão.",
                                  "commonMistakes": [
                                    "Confundir find com union",
                                    "Ignorar o impacto da degenerescência"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Projetar a lógica de compressão de caminho recursiva",
                                  "subSteps": [
                                    "Estude a ideia: durante find(x), defina parent[x] = find(parent[x]) para comprimir.",
                                    "Escreva pseudocódigo recursivo: se parent[x] != x, parent[x] = find(parent[x]); retorne parent[x].",
                                    "Simule recursivamente em papel com uma árvore degenerada de 4 nós.",
                                    "Verifique que todos os nós no caminho apontam diretamente para a raiz após compressão.",
                                    "Discuta benefícios: reduz altura para O(1) em média com union-by-rank."
                                  ],
                                  "verification": "Simulação manual mostra compressão correta em um exemplo simples.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para simulações recursivas",
                                    "Exemplos de árvores em diagramas"
                                  ],
                                  "tips": [
                                    "Anote o estado de parent antes e depois de cada chamada recursiva."
                                  ],
                                  "learningObjective": "Dominar o algoritmo recursivo de path compression.",
                                  "commonMistakes": [
                                    "Esquecer de atualizar parent[x] antes do retorno",
                                    "Recursão infinita sem base case"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a função find com compressão em código",
                                  "subSteps": [
                                    "Crie uma classe ou estrutura UnionFind com array parent inicializado.",
                                    "Implemente find recursivo exatamente como no pseudocódigo.",
                                    "Adicione uma função auxiliar para imprimir o caminho e parent para depuração.",
                                    "Teste unitário básico: encontre raiz de um nó e verifique se parent foi atualizado.",
                                    "Integre com union básica para um ciclo completo."
                                  ],
                                  "verification": "Código compila e um teste unitário passa mostrando compressão.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código (Python/Java)",
                                    "Ambiente de testes unitários"
                                  ],
                                  "tips": [
                                    "Use print statements para rastrear chamadas recursivas durante debug."
                                  ],
                                  "learningObjective": "Codificar corretamente a compressão recursiva.",
                                  "commonMistakes": [
                                    "Stack overflow em árvores muito profundas sem rank",
                                    "Não tratar caso base parent[x] == x"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e analisar o impacto da compressão",
                                  "subSteps": [
                                    "Construa uma árvore degenerada via unions sequenciais.",
                                    "Execute múltiplas finds em nós folha e meça profundidade antes/depois.",
                                    "Compare tempos de execução com versão sem compressão em 1000 operações.",
                                    "Visualize a árvore comprimida e confirme altura reduzida.",
                                    "Teste edge cases: árvore de um nó, ciclo detectado."
                                  ],
                                  "verification": "Testes mostram redução de altura e performance melhorada.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código implementado",
                                    "Ferramentas de profiling (timeit em Python)"
                                  ],
                                  "tips": [
                                    "Repita finds 10x para medir amortizado O(α(n))."
                                  ],
                                  "learningObjective": "Validar empiricamente os benefícios da compressão.",
                                  "commonMistakes": [
                                    "Não repetir finds para ver efeito amortizado",
                                    "Usar árvores balanceadas onde efeito é mínimo"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere parent = [-1, 1, 2, 2, 2] (raiz 1, mas degenerada). Antes: find(4) faz 4->2->2->1 (3 saltos). Após: parent[4]=1, parent[2]=1, parent[3]=1. find(4) agora direto.",
                              "finalVerifications": [
                                "Função find comprime todos os nós no caminho para a raiz.",
                                "Altura da árvore reduz para 1-2 após múltiplas finds.",
                                "Nenhuma recursão infinita ou stack overflow em testes.",
                                "Correção mantida: find sempre retorna raiz correta.",
                                "Performance melhora em benchmarks com 1000 unions/finds.",
                                "Edge cases (n=1, todos conectados) funcionam."
                              ],
                              "assessmentCriteria": [
                                "Implementação recursiva exata do path compression.",
                                "Verificação de compressão via inspeção de parent.",
                                "Redução observável de profundidade em testes.",
                                "Eficiência amortizada demonstrada.",
                                "Código limpo, comentado e testado.",
                                "Tratamento correto de casos base."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Recursão e análise assintótica (O(α(n))).",
                                "Algoritmos de grafos: Aplicação em Kruskal e MST.",
                                "Estruturas de dados: Otimização de árvores e heurísticas.",
                                "Programação funcional: Padrões recursivos.",
                                "Ciência de Computação: Análise de performance empírica."
                              ],
                              "realWorldApplication": "Usado em algoritmos Union-Find para Minimum Spanning Tree (Kruskal), clustering em ML (DBSCAN), detecção de componentes conectados em redes sociais, e processamento de grafos em bancos de dados distribuídos como no Google ou Facebook."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.2.3",
                            "name": "Implementar Find iterativo",
                            "description": "Criar versão iterativa do find com compressão, percorrendo o caminho até a raiz e atualizando pais ao retornar.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar a estrutura de dados Union-Find",
                                  "subSteps": [
                                    "Crie um array 'parent' onde cada índice representa um nó e o valor é o pai inicial (inicialmente parent[i] = i).",
                                    "Defina a função find_iterativo que recebe um nó x como parâmetro.",
                                    "Inicialize variáveis auxiliares como 'current = x' para percorrer iterativamente.",
                                    "Planeje o loop while que continua até current ser sua própria raiz (parent[current] == current).",
                                    "Retorne a raiz encontrada."
                                  ],
                                  "verification": "Verifique se parent[0..n-1] está inicializado corretamente e se a função retorna o nó correto para raízes simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code)",
                                    "Linguagem Python ou JavaScript",
                                    "Array de exemplo com 5-10 nós"
                                  ],
                                  "tips": "Sempre inicialize parent como identidade para testes iniciais.",
                                  "learningObjective": "Compreender e configurar a base da estrutura Union-Find para operações de find.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar parent[i] = i",
                                    "Confundir nó com índice no array"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar find iterativo básico sem compressão",
                                  "subSteps": [
                                    "No loop while, avance current = parent[current] até parent[current] == current.",
                                    "Registre o caminho percorrido em uma lista temporária para depuração.",
                                    "Retorne current como raiz sem alterar o array parent.",
                                    "Teste com um exemplo linear: parent = [1, 2, 2], find(0) deve retornar 2.",
                                    "Meça o número de iterações para verificar profundidade."
                                  ],
                                  "verification": "Execute find em uma cadeia longa e confirme que retorna a raiz sem modificar parent.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Exemplos de árvores com profundidade 3-5"
                                  ],
                                  "tips": "Use print statements para rastrear current em cada iteração.",
                                  "learningObjective": "Implementar busca iterativa simples até a raiz.",
                                  "commonMistakes": [
                                    "Loop infinito se parent[current] != current não for checado",
                                    "Retornar current antes do loop terminar"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar path compression durante a subida iterativa",
                                  "subSteps": [
                                    "Armazene o nó original x e a raiz final em variáveis.",
                                    "Durante a subida, atualize parent do nó original para apontar diretamente à raiz.",
                                    "Para compressão completa, use dois ponteiros: um para raiz e outro para comprimir ao retornar.",
                                    "Implemente: while percorrendo, colete nós no caminho; ao final, set parent[caminho[i]] = raiz.",
                                    "Teste: parent = [1,2,3,2], após find(0), deve virar parent = [2,2,3,2]."
                                  ],
                                  "verification": "Após find(4) em cadeia longa, verifique se parent[4] agora aponta diretamente à raiz.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código dos Steps anteriores",
                                    "Exemplos com caminhos longos (profundidade >3)"
                                  ],
                                  "tips": "Use uma lista para armazenar o caminho reverso e comprima em uma segunda passada.",
                                  "learningObjective": "Otimizar a estrutura com path compression para reduzir altura da árvore.",
                                  "commonMistakes": [
                                    "Atualizar parent antes de encontrar raiz (causa loops)",
                                    "Não comprimir nós intermediários"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e otimizar a implementação completa",
                                  "subSteps": [
                                    "Crie casos de teste: cadeia longa, árvore balanceada, nós isolados.",
                                    "Meça tempo de execução antes/depois de múltiplos finds com compressão.",
                                    "Integre com union básica para simular uso real.",
                                    "Adicione docstrings e comentários explicando compressão.",
                                    "Compare com versão recursiva para validar resultados."
                                  ],
                                  "verification": "Todos testes passam e altura média da árvore diminui após finds repetidos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Framework de testes (ex: unittest em Python)",
                                    "Exemplos de Union-Find completo"
                                  ],
                                  "tips": "Repita find no mesmo nó 10x e meça iterações decrescentes.",
                                  "learningObjective": "Validar corretude, eficiência e integração da operação find iterativa.",
                                  "commonMistakes": [
                                    "Ignorar casos de nó raiz (x==parent[x])",
                                    "Não testar com n=1"
                                  ]
                                }
                              ],
                              "practicalExample": "Dado parent = [1, 4, 4, 4, 5, 5] (duas árvores: 0->1->4->5 e 2->4->5, 3->4->5), chame find_iterativo(0): percorre 0->1->4->5 (raiz=5), comprime setando parent[0]=5, parent[1]=5, parent[4]=5. Resultado: parent = [5,5,4,4,5,5].",
                              "finalVerifications": [
                                "Função retorna raiz correta para qualquer nó.",
                                "Após find, todos nós no caminho apontam diretamente à raiz.",
                                "Sem loops infinitos ou modificações indevidas.",
                                "Eficiência: O(1) amortizado em chamadas múltiplas.",
                                "Funciona com n=1 e árvores degeneradas.",
                                "Integra corretamente com union."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Raiz sempre identificada precisamente.",
                                "Compressão: Altura da árvore reduzida após finds.",
                                "Eficiência: Implementação O(α(n)) amortizado.",
                                "Robustez: Trata casos edge (raiz, ciclos ausentes).",
                                "Clareza: Código legível com comentários.",
                                "Testes: Cobertura de cenários variados."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos de Grafos: Usado em Kruskal para MST.",
                                "Análise de Complexidade: Entender α(n) inverso de Ackermann.",
                                "Estruturas de Dados: Comparação com árvores binárias.",
                                "Programação Competitiva: Otimização em DSU.",
                                "Matemática Discreta: Partições e equivalências."
                              ],
                              "realWorldApplication": "Em algoritmos de Árvore Geradora Mínima (Kruskal), detecção de ciclos em redes, clustering em machine learning e gerenciamento de conectividade em jogos ou sistemas distribuídos, reduzindo tempo de consultas de conectividade de O(n) para quase O(1)."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.3",
                        "name": "Operação Union (União de Conjuntos)",
                        "description": "Unir dois conjuntos disjuntos ligando raízes, usando heurísticas para manter árvores balanceadas e detectar ciclos via mesma raiz.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.3.1",
                            "name": "Verificar se dois nós estão conectados",
                            "description": "Usar find(u) == find(v) para determinar se u e v pertencem ao mesmo conjunto antes de uma união.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar os Conceitos Básicos da Estrutura Union-Find",
                                  "subSteps": [
                                    "Estude a representação da estrutura Union-Find com array parent[] e rank[] para otimização.",
                                    "Entenda a função find(u): percorre os pais até a raiz, aplicando path compression.",
                                    "Revise a operação union(u, v): une as raízes de u e v usando union by rank ou size.",
                                    "Identifique o propósito de checar find(u) == find(v) antes da union para evitar ciclos.",
                                    "Implemente um esboço simples da classe UnionFind em pseudocódigo."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como find(u) retorna a raiz e por que path compression é útil.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Documentação de Union-Find",
                                    "Editor de código ou papel para pseudocódigo"
                                  ],
                                  "tips": "Visualize a estrutura como uma floresta de árvores, onde cada árvore é um conjunto conectado.",
                                  "learningObjective": "Compreender os componentes fundamentais da Union-Find e o papel da função find.",
                                  "commonMistakes": [
                                    "Confundir parent[] com rank[]",
                                    "Ignorar path compression na implementação de find"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a Função Find com Path Compression",
                                  "subSteps": [
                                    "Crie a função find(u) recursiva: se parent[u] != u, parent[u] = find(parent[u]).",
                                    "Implemente versão iterativa para eficiência: use um loop para comprimir o caminho.",
                                    "Teste find em um array simples: parent = [0,1,2,2] para u=0,1,3.",
                                    "Verifique que após chamadas múltiplas, o path está comprimido (todos apontam para raiz).",
                                    "Adicione logging para visualizar as mudanças no array parent."
                                  ],
                                  "verification": "Execute find(3) e confirme que parent[3] agora aponta diretamente para a raiz 2.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Linguagem de programação como Python ou Java",
                                    "Ambiente de execução online como Replit"
                                  ],
                                  "tips": "Use recursão para simplicidade inicial, mas prefira iterativa para grandes conjuntos.",
                                  "learningObjective": "Dominar a implementação correta de find com otimização de path compression.",
                                  "commonMistakes": [
                                    "Loop infinito se parent[u] == u não for checado",
                                    "Não atualizar parent durante compressão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar Conexão Entre Dois Nós Usando Find",
                                  "subSteps": [
                                    "Defina a função isConnected(u, v): retorne find(u) == find(v).",
                                    "Crie um grafo de exemplo com 5 nós e adicione unions: union(0,1), union(2,3).",
                                    "Teste isConnected(0,1) → true; isConnected(0,2) → false.",
                                    "Simule adição de aresta (1,3): cheque isConnected antes de union para detectar ciclo.",
                                    "Registre resultados em uma tabela: nós, raízes, conectados?"
                                  ],
                                  "verification": "Para um conjunto de 3 pares de nós, acerte 100% das verificações de conexão.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código da Union-Find do step anterior",
                                    "Gráfico para visualizar nós e arestas"
                                  ],
                                  "tips": "Sempre chame find em ambos antes de comparar para garantir raízes atualizadas.",
                                  "learningObjective": "Aplicar find(u) == find(v) para determinar conectividade eficientemente.",
                                  "commonMistakes": [
                                    "Comparar u == v diretamente sem find",
                                    "Esquecer path compression afetando resultados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Verificação na Operação Union Completa",
                                  "subSteps": [
                                    "Modifique union(u,v): se find(u) == find(v), retorne sem unir (evita ciclo).",
                                    "Caso contrário, una por rank: se rank[rootU] > rank[rootV], parent[rootV] = rootU.",
                                    "Implemente union by size alternativa para balanceamento.",
                                    "Teste em algoritmo como Kruskal: só adicione aresta se !isConnected.",
                                    "Meça tempo de execução para 1000 nós para validar eficiência."
                                  ],
                                  "verification": "Execute union em grafo com ciclo possível e confirme que não une componentes já conectados.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Código completo Union-Find",
                                    "Dataset de arestas para Kruskal simulado"
                                  ],
                                  "tips": "Union by rank mantém árvores rasas, essencial para performance O(α(n)).",
                                  "learningObjective": "Integrar checagem de conexão na union para aplicações como MST.",
                                  "commonMistakes": [
                                    "Unir sempre sem checar, criando ciclos desnecessários",
                                    "Erro em link por rank sem atualizar"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Kruskal's Algorithm para Árvore Geradora Mínima: para cada aresta (u,v) ordenada por peso, cheque if (!isConnected(u,v)) então union(u,v). Isso garante N-1 arestas sem ciclos, conectando todos os nós.",
                              "finalVerifications": [
                                "Implementação de find retorna raiz correta com path compression em 95% dos casos.",
                                "isConnected(u,v) acerta conectividade em testes com 10+ nós e unions aleatórias.",
                                "Union só une se necessário, mantendo número de componentes correto.",
                                "Tempo de execução para 1000 operações < 1 segundo.",
                                "Código passa em unit tests para casos edge (nós isolados, fully connected).",
                                "Explicação oral correta do porquê find(u) == find(v) detecta mesmo conjunto."
                              ],
                              "assessmentCriteria": [
                                "Precisão da função find: path compression aplicada corretamente (peso 25%).",
                                "Correção de isConnected: 100% em testes variados (peso 25%).",
                                "Eficiência da union: evita unions redundantes e usa heurística (peso 20%).",
                                "Clareza do código: comentado, modular e legível (peso 15%).",
                                "Testes abrangentes: inclui casos edge e performance (peso 10%).",
                                "Compreensão conceitual: explica trade-offs de Union-Find (peso 5%)."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos: Detectar conectividade e ciclos em redes.",
                                "Algoritmos de Otimização: Aplicação em MST (Kruskal) e clustering.",
                                "Estruturas de Dados: Comparação com DFS/BFS para conectividade.",
                                "Ciência da Computação: Modelagem de redes sociais ou union de eventos.",
                                "Matemática Discreta: Equivalência de classes e relações de partição."
                              ],
                              "realWorldApplication": "Em redes de computadores, verificar se dois dispositivos estão na mesma sub-rede antes de rotear tráfego; em processamento de imagens, unir pixels conectados em componentes; em jogos, detectar se ilhas estão conectadas para geração procedural."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.2",
                            "name": "Implementar Union by Rank",
                            "description": "Unir raiz de menor rank à de maior rank, incrementando rank apenas se iguais, garantindo altura O(log n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Rank na Union-Find",
                                  "subSteps": [
                                    "Revise a estrutura básica de Union-Find com path compression e union por link simples.",
                                    "Introduza o array 'rank' onde cada raiz inicia com rank 1.",
                                    "Explique que rank aproxima a altura da árvore e guia a união para manter árvores balanceadas.",
                                    "Discuta por que unir menor rank ao maior previne degeneração para lista ligada.",
                                    "Analise matematicamente: união por rank garante altura O(log n)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como o rank previne altura linear, com um exemplo de 4 nós.",
                                  "estimatedTime": "20 min",
                                  "materials": [
                                    "Documentação Union-Find",
                                    "Papel e caneta para diagramas de árvores"
                                  ],
                                  "tips": "Desenhe árvores antes e depois da união para visualizar o balanceamento.",
                                  "learningObjective": "Compreender o papel do rank na otimização da altura da floresta.",
                                  "commonMistakes": [
                                    "Confundir rank com tamanho do conjunto.",
                                    "Incrementar rank sempre, ignorando comparação."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a Estrutura com Array de Rank",
                                  "subSteps": [
                                    "Crie o array 'parent[]' e 'rank[]' no construtor da classe UnionFind.",
                                    "Inicialize parent[i] = i e rank[i] = 1 para todos i de 0 a n-1.",
                                    "Implemente a função find() com path compression para localizar raízes.",
                                    "Teste find() em um conjunto isolado para confirmar raízes corretas.",
                                    "Verifique que rank só é acessado para raízes."
                                  ],
                                  "verification": "Execute código de inicialização e imprima parent e rank; todos devem ser identidade e 1.",
                                  "estimatedTime": "25 min",
                                  "materials": [
                                    "Editor de código (VS Code/Python)",
                                    "Ambiente Jupyter para testes"
                                  ],
                                  "tips": "Use asserts para validar inicialização automática.",
                                  "learningObjective": "Configurar corretamente os arrays parent e rank na classe UnionFind.",
                                  "commonMistakes": [
                                    "Inicializar rank como 0 em vez de 1.",
                                    "Esquecer path compression no find()."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a Lógica de União por Rank",
                                  "subSteps": [
                                    "Na função union(x, y): encontre rootX = find(x) e rootY = find(y).",
                                    "Se rootX == rootY, retorne sem união.",
                                    "Compare rank[rootX] e rank[rootY]: se rank[rootX] > rank[rootY], parent[rootY] = rootX.",
                                    "Se rank[rootX] < rank[rootY], parent[rootX] = rootY.",
                                    "Se iguais, defina parent[rootX] = rootY e rank[rootY] += 1."
                                  ],
                                  "verification": "Implemente e teste com pares (0,1) e (2,3); verifique ranks atualizados apenas quando iguais.",
                                  "estimatedTime": "40 min",
                                  "materials": [
                                    "Código base UnionFind sem rank",
                                    "Casos de teste pré-definidos"
                                  ],
                                  "tips": "Use if-elif para comparações claras; debugue imprimindo roots e ranks pré-união.",
                                  "learningObjective": "Codificar a heurística de união que prioriza maior rank e incrementa só em empate.",
                                  "commonMistakes": [
                                    "Incrementar rank em toda união.",
                                    "Não tratar caso de roots iguais."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar a Implementação",
                                  "subSteps": [
                                    "Crie testes unitários: uniões desbalanceadas, balanceadas e empates.",
                                    "Meça altura máxima da floresta após múltiplas uniões aleatórias.",
                                    "Compare performance com union sem rank (deve ser mais lenta em chains).",
                                    "Execute 1000 uniões e verifique se altura <= log2(n) +1.",
                                    "Adicione logging para rastrear mudanças de rank."
                                  ],
                                  "verification": "Todos testes passam e altura média < 5 para n=1000.",
                                  "estimatedTime": "30 min",
                                  "materials": [
                                    "Framework de testes (pytest/unittest)",
                                    "Gerador de uniões randômicas"
                                  ],
                                  "tips": "Use heapq para medir altura recursivamente.",
                                  "learningObjective": "Validar empiricamente que union by rank mantém O(log n) altura.",
                                  "commonMistakes": [
                                    "Testes só em casos felizes.",
                                    "Medir altura sem path compression."
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Otimizar e Integrar em Aplicação Real",
                                  "subSteps": [
                                    "Combine com path compression para full almost O(1) por operação.",
                                    "Integre em algoritmo Kruskal para MST em grafo de 100 nós.",
                                    "Meça tempo total vs union sem heurísticas.",
                                    "Refatore código para legibilidade (comentários, docstrings).",
                                    "Documente complexidade: Ackermann invertida ~ O(alpha(n))."
                                  ],
                                  "verification": "Kruskal com esta union roda em <1s para grafo denso n=1000.",
                                  "estimatedTime": "35 min",
                                  "materials": [
                                    "Grafo sample para Kruskal",
                                    "Biblioteca networkx opcional"
                                  ],
                                  "tips": "Profile com timeit para quantificar ganhos.",
                                  "learningObjective": "Aplicar union by rank em contexto prático como MST.",
                                  "commonMistakes": [
                                    "Ignorar compressão de caminho.",
                                    "Não ordenar arestas em Kruskal."
                                  ]
                                }
                              ],
                              "practicalExample": "Em algoritmo Kruskal para Árvore Geradora Mínima: para unir vértices 1 e 2 (rank 1 cada), link 1->2 e rank[2]=2; unir 2 e 3 (rank2=2 > rank3=1), link 3->2, rank inalterado. Resultado: árvore balanceada.",
                              "finalVerifications": [
                                "Função union corretamente evita ciclos (find(x)==find(y) retorna cedo).",
                                "Rank incrementa só em raízes de rank igual.",
                                "Altura da floresta <= log2(n) após n-1 uniões.",
                                "Path compression + rank by dá performance quase constante.",
                                "Código passa 20+ testes unitários variados.",
                                "Integração em Kruskal produz MST correto."
                              ],
                              "assessmentCriteria": [
                                "Precisão da lógica: união sempre menor rank ao maior (100%).",
                                "Eficiência: altura comprovadamente O(log n) em testes (90%).",
                                "Código limpo: comentários, nomes variáveis intuitivos (80%).",
                                "Testes abrangentes: cobre empates, desbalanceamento (85%).",
                                "Documentação: explica heurística e complexidade (75%).",
                                "Performance: <10ms para 10k operações (95%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica O(log n) e funções Ackermann.",
                                "Grafos: Aplicação em Kruskal/Prim para MST.",
                                "Estruturas de Dados: Comparação com balanced BSTs.",
                                "Programação Competitiva: Uso em disjoint set para flows.",
                                "Teoria da Computação: Amortized analysis."
                              ],
                              "realWorldApplication": "Em redes de computadores para detectar ciclos em roteamento dinâmico (OSPF); clustering em machine learning (DBSCAN); processamento de transações bancárias para fraudes em grafos de contas conectadas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.2",
                              "10.1.6.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.3.3",
                            "name": "Implementar Union by Size",
                            "description": "Unir raiz do menor conjunto ao maior, atualizando size da nova raiz, alternativa ao rank para balanceamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar a estrutura de dados Union-Find com array de sizes",
                                  "subSteps": [
                                    "Crie arrays parent[] e size[] com tamanho n (número de elementos).",
                                    "Inicialize parent[i] = i e size[i] = 1 para todo i de 0 a n-1.",
                                    "Defina uma função make_set(i) que inicializa um novo conjunto singleton.",
                                    "Teste a inicialização criando 4 elementos e verificando os arrays.",
                                    "Adicione comentários explicando o propósito de cada array."
                                  ],
                                  "verification": "Imprima parent e size; todos parent[i]==i e size[i]==1.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Linguagem Python ou pseudocódigo"
                                  ],
                                  "tips": "Use listas em Python para simplicidade; evite usar dicionários para performance.",
                                  "learningObjective": "Compreender e implementar a inicialização básica da estrutura Union-Find com tracking de tamanhos.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar size[i]=1",
                                    "Índices fora do range 0 a n-1"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a função find com compressão de caminho",
                                  "subSteps": [
                                    "Escreva find(x): enquanto parent[x] != x, defina x = parent[x] (iterativa).",
                                    "Implemente compressão: armazene raiz em uma variável root e atualize todos parent ao longo do caminho para root.",
                                    "Versão recursiva alternativa: if parent[x] != x: parent[x] = find(parent[x]); return parent[x].",
                                    "Teste find em um conjunto não unido e um com path longo.",
                                    "Meça o comprimento do path antes/depois da compressão."
                                  ],
                                  "verification": "Após find em um path longo, todos nós apontam diretamente para a raiz.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de grafos pequenos para teste"
                                  ],
                                  "tips": "Prefira versão iterativa para evitar stack overflow em paths muito longos.",
                                  "learningObjective": "Dominar a busca da raiz com otimização de path compression para balanceamento.",
                                  "commonMistakes": [
                                    "Não implementar compressão, levando a paths longos",
                                    "Loop infinito sem condição parent[x] == x"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a operação union by size",
                                  "subSteps": [
                                    "Em union(x, y): encontre rootX = find(x), rootY = find(y); se iguais, retorne.",
                                    "Se size[rootX] < size[rootY]: parent[rootX] = rootY; size[rootY] += size[rootX].",
                                    "Senão: parent[rootY] = rootX; size[rootX] += size[rootY].",
                                    "Caso empate, escolha arbitrariamente e incremente size da nova raiz.",
                                    "Adicione logging para mostrar tamanhos antes/depois."
                                  ],
                                  "verification": "Após union, menor raiz linka à maior; size da nova raiz é soma correta.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Casos de teste com tamanhos desiguais"
                                  ],
                                  "tips": "Sempre compare sizes das raízes, não dos elementos originais.",
                                  "learningObjective": "Implementar união heurística por tamanho para manter árvore balanceada.",
                                  "commonMistakes": [
                                    "Linkar elementos diretamente sem find",
                                    "Não atualizar size da raiz pai"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Otimizar e encapsular em uma classe UnionFind",
                                  "subSteps": [
                                    "Crie classe UnionFind com __init__(self, n), self.parent = list(range(n)), self.size = [1]*n.",
                                    "Métodos: find(self, x), union(self, x, y).",
                                    "Adicione método connected(self, x, y) que checa se find(x) == find(y).",
                                    "Implemente count_components() somando sizes ou rastreando.",
                                    "Refatore código anterior para usar a classe."
                                  ],
                                  "verification": "Instancie classe e execute unions; verifique conectividade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Documentação Python classes"
                                  ],
                                  "tips": "Use self para encapsular; isso facilita reutilização.",
                                  "learningObjective": "Criar uma implementação orientada a objetos limpa e otimizada.",
                                  "commonMistakes": [
                                    "Não usar self corretamente",
                                    "Esquecer inicialização em __init__"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar e debugar a implementação completa",
                                  "subSteps": [
                                    "Crie testes unitários: inicialização, unions desiguais, empates, paths longos.",
                                    "Simule grafo com edges e verifique ausência de ciclos prematuros.",
                                    "Meça tempo de execução para n=10000 unions aleatórias.",
                                    "Compare com union by rank para validar balanceamento.",
                                    "Corrija bugs baseados em falhas nos testes."
                                  ],
                                  "verification": "Todos testes passam; altura média da árvore < 5 para n grande.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor com pytest ou unittest",
                                    "Gerador de testes aleatórios"
                                  ],
                                  "tips": "Use assert para automação; teste casos edge como n=1 ou todos conectados.",
                                  "learningObjective": "Validar implementação com testes robustos e análise de performance.",
                                  "commonMistakes": [
                                    "Não testar empates de size",
                                    "Ignorar path compression nos testes"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo de 5 vértices (0-4), execute: uf = UnionFind(5); uf.union(0,1); uf.union(2,3); uf.union(1,3); uf.union(4,0). Verifique: raiz de 0-1-3-4 é uma com size=4, raiz de 2 é 2 com size=1 (após unions). Imprima trees para visualizar balanceamento.",
                              "finalVerifications": [
                                "Size da raiz é sempre a soma correta dos tamanhos dos subconjuntos.",
                                "Menor árvore sempre linka à maior durante union.",
                                "Find retorna raiz correta com path comprimido.",
                                "Número de componentes diminui corretamente após unions.",
                                "Altura da árvore permanece baixa (O(α(n))).",
                                "Função connected detecta corretamente conjuntos unidos."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todas unions linkam menor a maior e atualizam size.",
                                "Eficiência: Path compression + union by size garante quase O(1) por operação.",
                                "Robustez: Lida com n grande sem degradação.",
                                "Clareza: Código comentado, classe bem estruturada.",
                                "Testes: Cobertura de casos edge e performance.",
                                "Otimização: Sem vazamentos ou loops infinitos."
                              ],
                              "crossCurricularConnections": [
                                "Algoritmos de Grafos: Essencial para Kruskal em Árvore Geradora Mínima.",
                                "Análise de Complexidade: Entender ackermann inversa α(n).",
                                "Ciência de Dados: Clustering hierárquico e detecção de comunidades.",
                                "Redes: Verificação de conectividade em redes sociais.",
                                "Programação Competitiva: Problemas de união de conjuntos no Codeforces."
                              ],
                              "realWorldApplication": "Implementado em algoritmos como Kruskal para encontrar MST em redes de telecomunicações, detecção de ciclos em compiladores, agrupamento de pixels em visão computacional e gerenciamento de conectividade em jogos multiplayer."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.1.2",
                              "10.1.6.4.2.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.4.4",
                        "name": "Integração com Algoritmo de Kruskal",
                        "description": "Aplicar Union-Find para gerenciar arestas ordenadas, adicionando à AGM apenas se não formarem ciclo, construindo árvore geradora mínima.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.4.4.1",
                            "name": "Integrar Union-Find no loop de Kruskal",
                            "description": "Para cada aresta em ordem crescente de peso, se find(u) != find(v), union(u,v) e adicionar à AGM.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Inicializar Union-Find e ordenar arestas por peso",
                                  "subSteps": [
                                    "Implemente a estrutura Union-Find com parent[] e rank[] arrays para um grafo com n vértices.",
                                    "Ordene a lista de arestas em ordem crescente de peso usando sort() ou similar.",
                                    "Inicialize contadores: mstEdges = 0 e totalWeight = 0.",
                                    "Crie uma lista vazia para armazenar as arestas da AGM.",
                                    "Teste a ordenação imprimindo as arestas ordenadas."
                                  ],
                                  "verification": "Verifique se parent[i] = i para todos i, rank[i] = 0 ou 1, e arestas estão ordenadas corretamente por peso.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (Python/Java)",
                                    "Grafo exemplo com 4-5 vértices e 6 arestas"
                                  ],
                                  "tips": "Use path compression e union by rank desde o início para eficiência.",
                                  "learningObjective": "Configurar corretamente as estruturas de dados necessárias para o loop de Kruskal.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar parent e rank adequadamente",
                                    "Ordenar incorretamente (não por peso crescente)",
                                    "Não considerar grafos desconexos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o loop principal através das arestas ordenadas",
                                  "subSteps": [
                                    "Inicie um loop for sobre cada aresta na lista ordenada.",
                                    "Para cada aresta (u, v, weight), extraia u, v e weight.",
                                    "Chame find(u) e find(v) para obter representantes raiz.",
                                    "Compare os representantes: if find(u) != find(v).",
                                    "Registre logs ou prints para depuração em cada iteração."
                                  ],
                                  "verification": "Execute o loop sem adicionar arestas ainda e confirme que find(u) e find(v) são chamados corretamente para todas as arestas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Debugger ou console para prints"
                                  ],
                                  "tips": "Sempre use find() com path compression para evitar ciclos longos.",
                                  "learningObjective": "Entender o fluxo iterativo do algoritmo Kruskal com Union-Find.",
                                  "commonMistakes": [
                                    "Loop em ordem errada (não crescente)",
                                    "Não chamar find() antes da comparação",
                                    "Confundir u e v nas arestas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar verificação e union quando componentes diferentes",
                                  "subSteps": [
                                    "Se find(u) != find(v), prossiga para union(u, v).",
                                    "Implemente union_by_rank: se rank[rootU] < rank[rootV], parent[rootU] = rootV, etc.",
                                    "Adicione a aresta atual à lista de AGM e incremente mstEdges.",
                                    "Atualize totalWeight += weight.",
                                    "Caso find(u) == find(v), ignore a aresta (evita ciclo)."
                                  ],
                                  "verification": "Simule manualmente: para um grafo exemplo, confira que unions só ocorrem quando componentes distintos e mstEdges aumenta corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para simulação manual",
                                    "Código com grafo teste"
                                  ],
                                  "tips": "Desenhe o grafo à mão para visualizar componentes conectados.",
                                  "learningObjective": "Aplicar corretamente a lógica de detecção de ciclos via Union-Find no loop.",
                                  "commonMistakes": [
                                    "Executar union sem verificar find(u) != find(v)",
                                    "Não atualizar rank corretamente",
                                    "Adicionar aresta que forma ciclo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar e validar a AGM gerada",
                                  "subSteps": [
                                    "Continue o loop até processar todas as arestas ou mstEdges == n-1.",
                                    "Após o loop, verifique se mstEdges == n-1 (grafo conexo).",
                                    "Calcule e imprima o peso total da AGM.",
                                    "Visualize ou imprima a lista de arestas da AGM.",
                                    "Teste com grafos variados: conexo, desconexo, com ciclos."
                                  ],
                                  "verification": "Confirme que a AGM tem exatamente n-1 arestas, peso mínimo e conecta todos vértices.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Ferramenta de visualização de grafos (Graphviz ou online)",
                                    "Múltiplos grafos de teste"
                                  ],
                                  "tips": "Para grafos desconexos, detecte florestas geradoras mínimas.",
                                  "learningObjective": "Validar a integração completa e corretude da AGM.",
                                  "commonMistakes": [
                                    "Parar loop cedo demais",
                                    "Não validar conectividade final",
                                    "Erro em soma de pesos"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com 4 vértices A,B,C,D. Arestas: A-B:1, A-C:3, B-C:1, B-D:4, C-D:2. Ordenadas: A-B:1, B-C:1, C-D:2, A-C:3, B-D:4. Loop: Adiciona A-B (union A,B), adiciona B-C (union com C), adiciona C-D (union com D). AGM: A-B, B-C, C-D (peso 4). Ignora A-C e B-D por mesmo componente.",
                              "finalVerifications": [
                                "O código processa todas arestas em ordem crescente sem erros.",
                                "Union só chamado quando find(u) != find(v).",
                                "Número de arestas na AGM é n-1 para grafo conexo.",
                                "Peso total é mínimo comparado a outras spanning trees.",
                                "Estrutura Union-Find mantém componentes corretos após unions.",
                                "Funciona com path compression e union by rank (O(α(n)) por operação)."
                              ],
                              "assessmentCriteria": [
                                "Correção: AGM gerada tem peso mínimo e n-1 arestas.",
                                "Eficiência: Uso otimizado de Union-Find (não O(n) por find).",
                                "Clareza: Código comentado e legível com logs de depuração.",
                                "Robustez: Trata grafos desconexos e casos extremos (n=1, sem arestas).",
                                "Testes: Pelo menos 3 grafos testados com saídas validadas.",
                                "Documentação: Explica cada passo do loop em comentários."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e otimização combinatória.",
                                "Ciência da Computação: Estruturas de dados dinâmicas (Disjoint Set).",
                                "Engenharia: Otimização de redes (roteamento mínimo em telecom).",
                                "Física: Modelagem de clusters em sistemas complexos.",
                                "Economia: Problemas de custo mínimo em logística."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações para conectar torres com cabo mínimo custo; em clustering de dados para agrupar pontos sem ciclos caros; em design de circuitos elétricos para layout mínimo de fios."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.1",
                              "10.1.6.4.3.2"
                            ]
                          },
                          {
                            "id": "10.1.6.4.4.2",
                            "name": "Analisar complexidade amortizada",
                            "description": "Explicar tempo quase O(α(n)) por operação com path compression e union by rank, onde α é inversa de Ackermann, quase constante.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Estrutura Union-Find e Operações Básicas",
                                  "subSteps": [
                                    "Implementar find sem path compression (iterativo ou recursivo)",
                                    "Implementar union sem rank (simples por tamanho ou índice)",
                                    "Executar uma sequência de 10 operações make-set, union e find",
                                    "Medir altura das árvores resultantes sem otimizações",
                                    "Comparar com implementações otimizadas iniciais"
                                  ],
                                  "verification": "Executar código e confirmar que find leva O(n) no pior caso com exemplos de cadeias longas",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Pseudocódigo Union-Find básico",
                                    "Editor de código (Python ou C++)",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Use arrays para parent e rank; visualize árvores com desenhos manuais",
                                  "learningObjective": "Compreender o problema de degeneração em listas ligadas sem otimizações",
                                  "commonMistakes": [
                                    "Confundir find com union",
                                    "Ignorar inicialização de make-set",
                                    "Usar recursão profunda sem limite"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e Analisar Union by Rank",
                                  "subSteps": [
                                    "Adicionar array rank[] inicializado em 0",
                                    "Modificar union para ligar raiz de menor rank à maior, incrementando rank se igual",
                                    "Provar que rank nunca excede log n + 1",
                                    "Simular unions com n=16 elementos e medir altura máxima",
                                    "Comparar tempo de find antes/depois em sequências adversárias"
                                  ],
                                  "verification": "Confirmar que altura das árvores fica ≤ log n via inspeção de simulações",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código Python com visualização de árvores",
                                    "Gráficos de altura vs. n",
                                    "Teorema de rank"
                                  ],
                                  "tips": "Sempre linke menor rank para maior; teste com unions sequenciais 1-2,2-3,...",
                                  "learningObjective": "Dominar como union by rank garante altura O(log n)",
                                  "commonMistakes": [
                                    "Incrementar rank sempre",
                                    "Usar tamanho em vez de rank",
                                    "Esquecer compressão parcial"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Path Compression e Analisar Seu Impacto",
                                  "subSteps": [
                                    "Implementar find com path compression recursiva (pai = find(pai))",
                                    "Executar finds em cadeias longas e observar achatamento",
                                    "Analisar número de saltos por nó em múltiplas operações",
                                    "Simular 100 finds consecutivos e medir redução de profundidade",
                                    "Discutir trade-off recursão vs. iterativa (halving ou splitting)"
                                  ],
                                  "verification": "Após finds, todas árvores devem ter altura 1 ou 2; medir via código",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Implementação recursiva/iterativa",
                                    "Profiler de chamadas recursivas",
                                    "Exemplos visuais de compressão"
                                  ],
                                  "tips": "Use recursão para simplicidade inicial; evite stack overflow com n pequeno",
                                  "learningObjective": "Entender como path compression reduz caminhos para O(α(n))",
                                  "commonMistakes": [
                                    "Não propagar compressão aos ancestrais",
                                    "Confundir compressão total com parcial",
                                    "Aplicar rank no find"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Derivar Complexidade Amortizada com Função Potencial",
                                  "subSteps": [
                                    "Definir função potencial Φ = ∑ log(rank[i]) sobre componentes",
                                    "Analisar custo de union: O(1) + ΔΦ ≤ O(1) + 1",
                                    "Analisar custo de find: O(log n) sem compressão, mas amortizado via compressão",
                                    "Provar bound total T(m,n) ≤ m α(n) + O(n) para m operações",
                                    "Calcular α(n) para n até 10^80 e plotar (quase constante)"
                                  ],
                                  "verification": "Derivar matematicamente que α(n) < 5 para n prático; simular m=10^6 ops",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigo Tarjan/Scherer sobre análise",
                                    "Python para plot α(n)",
                                    "Notas matemáticas"
                                  ],
                                  "tips": "Lembre: α(n) cresce mais devagar que log* n; foque em intuição antes de prova",
                                  "learningObjective": "Explicar por que cada operação é quase O(1) amortizado",
                                  "commonMistakes": [
                                    "Confundir pior caso com amortizado",
                                    "Ignorar potencial na compressão",
                                    "Achar α(n) = log n"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Verificar e Aplicar em Contexto de Kruskal",
                                  "subSteps": [
                                    "Implementar Union-Find otimizado completo",
                                    "Rodar Kruskal em grafo denso (n=1000, m=10^5)",
                                    "Medir tempo total e comparar com naive",
                                    "Analisar por que Union-Find é bottleneck resolvido",
                                    "Discutir extensões como union by size vs. rank"
                                  ],
                                  "verification": "Tempo total < 1s para n=10^4; explicar bound teórico",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Grafo de teste para MST",
                                    "Biblioteca NetworkX ou código custom"
                                  ],
                                  "tips": "Use union by rank + path compression para melhor prática",
                                  "learningObjective": "Integrar análise em algoritmo real como Kruskal",
                                  "commonMistakes": [
                                    "Não sortear arestas",
                                    "Find sem compressão em loop",
                                    "Overflow em rank"
                                  ]
                                }
                              ],
                              "practicalExample": "Em Kruskal para MST de rede com 10^5 arestas: execute 10^5 unions/finds; total tempo ~10^5 * α(10^5) ≈ 10^5 * 4 = quase linear, permitindo escalabilidade para redes reais.",
                              "finalVerifications": [
                                "Explicar verbalmente path compression + union by rank em 2 minutos",
                                "Implementar Union-Find otimizado e rodar 10^6 ops em <1s",
                                "Derivar T(m,n) ≤ m α(n) + 2n α(n)",
                                "Plotar α(n) para n=2^k até k=100 e confirmar <5",
                                "Identificar erro em prova incompleta de complexidade",
                                "Aplicar em Kruskal e medir speedup vs. sem otimizações"
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de α(n) como inversa de Ackermann",
                                "Correta implementação de find com compressão (testes passam)",
                                "Compreensão de análise potencial (ΔΦ correto)",
                                "Explicação intuitiva de 'quase constante'",
                                "Aplicação correta em contexto Union-Find/Kruskal",
                                "Identificação de erros comuns em provas"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Funções de crescimento lento (Ackermann, log*)",
                                "Teoria da Computação: Análise amortizada e funções potenciais",
                                "Algoritmos Gráficos: Integração em MST e detecção de ciclos",
                                "Programação Competitiva: Otimizações em DSU on-line",
                                "Análise de Algoritmos: Comparação com outros bounds (ex: Hopcroft-Ullman)"
                              ],
                              "realWorldApplication": "Em computação distribuída (ex: Google Spanner para transações consistentes), redes sociais (detecção de comunidades via MST), bioinformática (clustering de genes) e compiladores (análise de dependências), onde Union-Find otimizado processa bilhões de operações eficientemente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.4.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.4.3",
                            "name": "Implementar Union-Find completa para Kruskal",
                            "description": "Codificar classe UnionFind com inicialização, find otimizado e union, testando em grafo exemplo para AGM.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar o construtor da classe UnionFind",
                                  "subSteps": [
                                    "Crie uma classe UnionFind em Python.",
                                    "No método __init__, receba o número de vértices n e inicialize dois arrays: parent = [i for i in range(n)] e rank = [0] * n.",
                                    "Defina métodos find e union como placeholders vazios inicialmente.",
                                    "Adicione um atributo size = [1] * n para futura otimização opcional."
                                  ],
                                  "verification": "Instancie a classe com n=5 e verifique se parent == [0,1,2,3,4] e rank == [0,0,0,0,0].",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter Notebook)",
                                    "Python 3.x"
                                  ],
                                  "tips": "Use listas para parent e rank por eficiência em Python.",
                                  "learningObjective": "Entender a inicialização básica da estrutura para representar componentes conectados.",
                                  "commonMistakes": [
                                    "Inicializar parent incorretamente (não como identidade)",
                                    "Esquecer de importar módulos necessários como typing para type hints."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método find com compressão de caminho",
                                  "subSteps": [
                                    "Defina o método find(self, x: int) -> int.",
                                    "Use recursão: if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]).",
                                    "Retorne self.parent[x] após compressão.",
                                    "Teste find(0) em uma instância nova, deve retornar 0.",
                                    "Teste após algumas unions para verificar compressão."
                                  ],
                                  "verification": "Após union(0,1), chame find(1) e verifique se parent[1] aponta diretamente para root.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python 3.x",
                                    "Exemplo de grafo simples"
                                  ],
                                  "tips": "Recursão é elegante para path compression; considere iteração para evitar stack overflow em n grande.",
                                  "learningObjective": "Dominar path compression para amortizar find para O(α(n)).",
                                  "commonMistakes": [
                                    "Não atualizar parent durante recursão",
                                    "Retornar x em vez de root sem compressão"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método union otimizado por rank",
                                  "subSteps": [
                                    "Defina union(self, x: int, y: int) -> None.",
                                    "Encontre roots: rootX = self.find(x), rootY = self.find(y).",
                                    "Se rootX == rootY, retorne (já conectados).",
                                    "Caso contrário, compare ranks: se rank[rootX] > rank[rootY], parent[rootY] = rootX; elif rank[rootX] < rank[rootY], parent[rootX] = rootY; senão, parent[rootY] = rootX e rank[rootX] += 1.",
                                    "Teste union(0,1) e union(1,2), verifique componentes."
                                  ],
                                  "verification": "Após unions sequenciais, find(2) deve retornar mesmo root que find(0), e rank aumentado corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python 3.x"
                                  ],
                                  "tips": "Union by rank garante altura O(log n); prefira union by size para melhor prática.",
                                  "learningObjective": "Implementar linking por rank para manter árvore balanceada.",
                                  "commonMistakes": [
                                    "Não checar se já conectados antes de link",
                                    "Incrementar rank incorretamente em ambos os lados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Union-Find no algoritmo de Kruskal",
                                  "subSteps": [
                                    "Defina uma função kruskal(edges, n) que recebe lista de arestas [(u,v,w)] e n vértices.",
                                    "Ordene edges por peso w.",
                                    "Instancie uf = UnionFind(n).",
                                    "Inicialize mst_cost = 0 e mst_edges = [].",
                                    "Para cada edge em ordem: se uf.find(u) != uf.find(v), uf.union(u,v), adicione w a mst_cost e edge a mst_edges.",
                                    "Retorne mst_cost e mst_edges."
                                  ],
                                  "verification": "Execute kruskal em grafo exemplo e verifique se custo da AGM é correto.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python 3.x",
                                    "Biblioteca sorted para edges"
                                  ],
                                  "tips": "Represente edges como tuplas (w, u, v) para sort natural por peso.",
                                  "learningObjective": "Aplicar Union-Find para detectar ciclos e construir AGM eficientemente.",
                                  "commonMistakes": [
                                    "Esquecer de ordenar edges",
                                    "Adicionar edges sem checar ciclo"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar implementação com grafo exemplo",
                                  "subSteps": [
                                    "Crie grafo exemplo: n=4, edges = [(0,1,1), (0,2,2), (1,2,3), (1,3,4), (2,3,5)].",
                                    "Execute kruskal(edges, 4), espere mst_cost=6 e edges [(0,1,1),(0,2,2),(1,3,4)].",
                                    "Escreva testes unitários com assert para find, union e kruskal.",
                                    "Teste casos edge: grafo desconectado, n=1, ciclo imediato.",
                                    "Meça tempo para n=1000 para verificar eficiência."
                                  ],
                                  "verification": "Todos testes passam e output matches expected AGM.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Python 3.x",
                                    "Pytest opcional"
                                  ],
                                  "tips": "Use print(uf.parent) para debug visual da estrutura.",
                                  "learningObjective": "Validar implementação completa via testes práticos.",
                                  "commonMistakes": [
                                    "Índices off-by-one em vértices",
                                    "Não tratar grafos desconectados"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com 4 vértices: arestas (0-1:1), (0-2:2), (1-2:3), (1-3:4), (2-3:5). Após Kruskal com UnionFind: AGM com arestas (0-1), (0-2), (1-3), custo total 1+2+4=7. Verifique parent final: [0,0,0,1] ou similar.",
                              "finalVerifications": [
                                "Classe UnionFind possui construtor com parent e rank corretos.",
                                "find implementa path compression (verificado por flatten após chains).",
                                "union liga por rank e evita ciclos.",
                                "Kruskal produz AGM correta em grafo exemplo.",
                                "Testes unitários passam para 100% cobertura básica.",
                                "Eficiência: find/union em O(α(n)) comprovado empiricamente."
                              ],
                              "assessmentCriteria": [
                                "Correção funcional: todos métodos produzem outputs esperados.",
                                "Eficiência: path compression e union by rank implementados.",
                                "Robustez: trata casos edge (n=0,1; ciclos; desconectado).",
                                "Clareza de código: nomes descritivos, comentários, type hints.",
                                "Testes: pelo menos 5 asserts cobrindo cenários principais.",
                                "Integração: Kruskal usa UnionFind sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria dos Grafos e Árvores Geradoras.",
                                "Programação: Estruturas de Dados e Algoritmos com Python.",
                                "Análise de Algoritmos: Complexidade Amortizada O(α(n)).",
                                "Engenharia de Software: Testes Unitários e Integração.",
                                "Ciência da Computação: Aplicações em Otimização de Redes."
                              ],
                              "realWorldApplication": "Usado em roteamento de redes (SPF com MST aproximado), clustering em ML (agrupamento hierárquico), design de circuitos elétricos minimizando custo de conexões, e detecção de comunidades em redes sociais."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.4.1"
                            ]
                          },
                          {
                            "id": "10.1.6.4.4.4",
                            "name": "Detectar e rejeitar ciclos",
                            "description": "Demonstrar como find evita adição de arestas que conectam mesmo componente, garantindo aciclicidade na AGM.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o conceito de detecção de ciclos usando Union-Find",
                                  "subSteps": [
                                    "Estude a estrutura Union-Find e suas operações básicas: makeSet, union e find.",
                                    "Analise como componentes conectados representam subárvores no grafo.",
                                    "Identifique que um ciclo ocorre quando uma aresta conecta vértices já no mesmo componente.",
                                    "Revise o algoritmo de Kruskal: ordenar arestas por peso e adicionar se não formar ciclo.",
                                    "Discuta por que aciclicidade é essencial para formar uma Árvore Geradora Mínima (AGM)."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito como find(u) == find(v) detecta um ciclo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Documentação de Union-Find",
                                    "Exemplo de grafo simples com 4 vértices"
                                  ],
                                  "tips": "Desenhe o grafo à mão para visualizar componentes antes e após unions.",
                                  "learningObjective": "Entender o mecanismo teórico de detecção de ciclos via componentes conectados.",
                                  "commonMistakes": "Confundir union com find; achar que ciclo só ocorre com arestas de mesmo peso."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar e otimizar a operação find",
                                  "subSteps": [
                                    "Implemente a função find com compressão de caminho (path compression) para eficiência.",
                                    "Teste find em um conjunto de vértices isolados e conectados.",
                                    "Compare find sem e com path compression em termos de tempo de execução.",
                                    "Integre find à estrutura de dados parent[] e rank[] do Union-Find.",
                                    "Verifique recursivamente ou iterativamente para evitar stack overflow."
                                  ],
                                  "verification": "Execute find em vértices conhecidos conectados e confirme retorno do mesmo root.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Editor de código (Python/Java)",
                                    "Array parent e rank inicializados"
                                  ],
                                  "tips": "Use recursão com memoização para path compression: if parent[x] != x, parent[x] = find(parent[x]).",
                                  "learningObjective": "Dominar a implementação eficiente de find para detecção rápida de componentes.",
                                  "commonMistakes": "Esquecer path compression, levando a chains longos e lentidão; não tratar vértice raiz corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Integrar verificação de ciclo no loop de Kruskal",
                                  "subSteps": [
                                    "Ordene as arestas por peso em uma lista.",
                                    "No loop principal, para cada aresta (u,v,w): se find(u) != find(v), adicione à AGM e chame union(u,v).",
                                    "Implemente a condição de rejeição: skip se find(u) == find(v).",
                                    "Registre arestas rejeitadas em um log para análise.",
                                    "Garanta que o número final de arestas seja V-1 para uma AGM válida."
                                  ],
                                  "verification": "Simule o loop em papel e confirme que arestas de ciclo são puladas.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Lista de arestas ordenadas",
                                    "Código base de Kruskal com Union-Find"
                                  ],
                                  "tips": "Sempre chame find antes de union para evitar unions desnecessários.",
                                  "learningObjective": "Aplicar a detecção de ciclo diretamente na lógica de adição de arestas.",
                                  "commonMistakes": "Adicionar aresta mesmo com find(u) == find(v); não ordenar arestas corretamente."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a detecção de ciclos",
                                  "subSteps": [
                                    "Crie um grafo de teste com ciclo conhecido (ex: triângulo).",
                                    "Execute Kruskal e verifique se a aresta que fecha o ciclo é rejeitada.",
                                    "Meça o custo total da AGM e compare com o esperado.",
                                    "Teste casos extremos: grafo completo, desconectado, com V=1.",
                                    "Profile o tempo de execução com path compression ativado."
                                  ],
                                  "verification": "A AGM resultante tem V-1 arestas, é conexa e sem ciclos (use DFS para checar).",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Grafos de teste prontos",
                                    "Ferramenta de visualização de grafos (Graphviz)"
                                  ],
                                  "tips": "Use asserts no código: assert(find(u) != find(v)) antes de union.",
                                  "learningObjective": "Validar empiricamente que o algoritmo produz AGM acíclica.",
                                  "commonMistakes": "Não testar grafos com múltiplos ciclos; ignorar grafos desconectados (floresta)."
                                }
                              ],
                              "practicalExample": "Grafo com vértices A,B,C,D. Arestas ordenadas: AB(1), BC(3), AD(4), AC(2). Inicial: todos isolados. Adiciona AB (union A,B). Adiciona AC (find(A)=A, find(C)=C, union A,C; agora A,B,C juntos). Ao tentar BC: find(B)=A, find(C)=A, rejeita (ciclo). Adiciona AD (union A,D). AGM: AB,AC,AD. Total: 7.",
                              "finalVerifications": [
                                "Explica corretamente por que find(u) == find(v) indica ciclo?",
                                "Implementa find com path compression?",
                                "Rejeita arestas que formariam ciclo em exemplo prático?",
                                "AGM final tem exatamente V-1 arestas e é acíclica?",
                                "Código roda em O(E α(V)) tempo?",
                                "Testa casos com grafos desconectados?"
                              ],
                              "assessmentCriteria": [
                                "Precisão da função find (100% acerto em testes unitários)",
                                "Correta rejeição de todas as arestas cíclicas",
                                "Eficiência: path compression e union by rank implementados",
                                "Validação da AGM: conexidade e aciclicidade comprovadas",
                                "Clareza do código com comentários na lógica de detecção",
                                "Tratamento de edge cases (V=1, grafo vazio)"
                              ],
                              "crossCurricularConnections": [
                                "Teoria de Grafos (Matemática Discreta): Conceitos de ciclos e árvores",
                                "Redes de Computadores: Spanning Trees em protocolos de roteamento (STP)",
                                "Otimização Combinatória: Problemas de MST em logística",
                                "Estruturas de Dados: Disjoint Set Union em clustering",
                                "Análise de Algoritmos: Amortized analysis de Union-Find"
                              ],
                              "realWorldApplication": "Em telecomunicações, o algoritmo de Kruskal com Union-Find otimiza redes de fibra ótica conectando torres sem loops redundantes, minimizando custos de cabos e evitando falhas em circuitos."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.4.3.1",
                              "10.1.6.4.4.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.6.5",
                    "name": "Propriedades e Corretude dos Algoritmos",
                    "description": "Teoremas como propriedade de corte e ciclo que garantem a optimalidade dos algoritmos de Kruskal e Prim.",
                    "individualConcepts": [
                      {
                        "id": "10.1.6.5.1",
                        "name": "Propriedade de Corte",
                        "description": "Teorema que afirma que, para qualquer corte de um grafo, a aresta de menor peso que cruza o corte pode ser incluída de forma segura em qualquer árvore geradora mínima (AGM), sem comprometer a optimalidade.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.1.1",
                            "name": "Definir e identificar cortes em grafos",
                            "description": "Explicar o conceito de corte em um grafo não direcionado e ponderado, identificando vértices em dois conjuntos disjuntos e arestas que os conectam.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Conceitos Básicos de Grafos Não Direcionados",
                                  "subSteps": [
                                    "Estudar a definição de grafo não direcionado: conjunto de vértices V e arestas E sem direção.",
                                    "Identificar vértices como nós e arestas como conexões entre eles.",
                                    "Diferenciar grafos simples (sem laços ou múltiplas arestas) de grafos ponderados (arestas com pesos).",
                                    "Desenhar um grafo simples com 4 vértices e 5 arestas.",
                                    "Explicar a representação matricial ou de lista de adjacência."
                                  ],
                                  "verification": "Desenhar e rotular corretamente um grafo não direcionado simples e ponderado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta online como Graphviz ou Draw.io"
                                  ],
                                  "tips": "Sempre rotule vértices claramente para evitar confusões.",
                                  "learningObjective": "Compreender os componentes fundamentais de grafos não direcionados e ponderados.",
                                  "commonMistakes": [
                                    "Confundir direção em grafos não direcionados",
                                    "Ignorar pesos em arestas ponderadas",
                                    "Desenhar laços em grafos simples"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir Formalmente o Conceito de Corte",
                                  "subSteps": [
                                    "Aprender que um corte é uma partição dos vértices em dois conjuntos disjuntos S e T, onde S ∪ T = V e S ∩ T = ∅.",
                                    "Identificar as arestas do corte como {(u,v) ∈ E | u ∈ S e v ∈ T}.",
                                    "Estudar a notação formal: corte(S,T).",
                                    "Exemplificar com um grafo pequeno: escolher S e T e listar arestas do corte.",
                                    "Diferenciar corte mínimo (menor número ou peso de arestas)."
                                  ],
                                  "verification": "Escrever a definição formal e aplicar em um grafo exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Quadro ou papel para diagramas",
                                    "Exemplos de grafos impressos"
                                  ],
                                  "tips": "Verifique sempre se S e T cobrem todos os vértices sem sobreposição.",
                                  "learningObjective": "Dominar a definição precisa de um corte em grafos.",
                                  "commonMistakes": [
                                    "Incluir vértices em ambos S e T",
                                    "Listar arestas internas a S ou T",
                                    "Esquecer arestas que cruzam a partição"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar Cortes em Grafos Simples",
                                  "subSteps": [
                                    "Dado um grafo, escolher partições S e T válidas.",
                                    "Listar todas as arestas que cruzam de S para T.",
                                    "Praticar com 3 exemplos de grafos com 5-7 vértices.",
                                    "Identificar o corte com menor número de arestas.",
                                    "Verificar se a partição é válida (disjuntos e cobertura total)."
                                  ],
                                  "verification": "Identificar corretamente pelo menos 3 cortes diferentes em um grafo dado.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Grafos de exemplo impressos ou digitais",
                                    "Calculadora para contagem"
                                  ],
                                  "tips": "Comece com partições desbalanceadas (ex: |S|=1) para simplicidade.",
                                  "learningObjective": "Aplicar a identificação de cortes em grafos não ponderados.",
                                  "commonMistakes": [
                                    "Contar arestas dentro de S ou T",
                                    "Partições que não cobrem V",
                                    "Confundir com caminhos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Cortes em Grafos Ponderados e Propriedades",
                                  "subSteps": [
                                    "Calcular o peso total de um corte: soma dos pesos das arestas cruzantes.",
                                    "Identificar cortes mínimos em grafos ponderados.",
                                    "Relacionar com propriedades de AGM (ex: Kruskal não inclui arestas de corte mínimo).",
                                    "Praticar com 2 grafos ponderados, calculando pesos de cortes.",
                                    "Discutir conectividade: corte vazio implica grafo desconexo."
                                  ],
                                  "verification": "Calcular pesos de cortes e identificar o mínimo em um grafo ponderado.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Software como NetworkX (Python) ou GeoGebra",
                                    "Tabela de pesos"
                                  ],
                                  "tips": "Use cores diferentes para S e T ao desenhar.",
                                  "learningObjective": "Entender e calcular cortes em contextos ponderados e suas propriedades.",
                                  "commonMistakes": [
                                    "Somar pesos errados",
                                    "Ignorar sinal dos pesos",
                                    "Confundir com fluxo máximo"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede de estradas entre cidades (grafo ponderado por km), definir S como cidades do norte e T do sul; as arestas do corte são as pontes principais, e o corte mínimo indica o gargalo de tráfego mais fraco.",
                              "finalVerifications": [
                                "Definir formalmente um corte(S,T).",
                                "Identificar todas as arestas de um corte em grafo simples.",
                                "Calcular o peso de um corte em grafo ponderado.",
                                "Reconhecer um corte mínimo.",
                                "Explicar relação com AGM.",
                                "Verificar partição válida em exemplo dado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição formal (100% correta).",
                                "Correta identificação de arestas cruzantes (sem erros).",
                                "Cálculo exato de pesos em grafos ponderados.",
                                "Explicação clara de propriedades.",
                                "Aplicação correta em exemplos práticos.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Conjuntos e Partições.",
                                "Programação: Implementação com bibliotecas como NetworkX.",
                                "Física: Modelagem de redes elétricas e fluxos.",
                                "Economia: Otimização de supply chains.",
                                "Engenharia: Design de redes de comunicação."
                              ],
                              "realWorldApplication": "Em algoritmos de Árvore Geradora Mínima (Kruskal/Prim), cortes mínimos garantem corretude; aplicado em telecomunicações para particionar redes, em logística para identificar gargalos e em computação paralela para balanceamento de carga."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.2",
                            "name": "Provar a propriedade de corte",
                            "description": "Demonstrar por contradição que a aresta de menor peso cruzando um corte pertence a toda AGM, assumindo uma AGM ótima que a exclui e trocando por uma aresta equivalente.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir o corte e identificar a aresta de menor peso",
                                  "subSteps": [
                                    "Escolha um grafo não conexo G=(V,E) com pesos positivos nas arestas.",
                                    "Defina um corte (S, V-S) onde S é um subconjunto próprio não vazio de V.",
                                    "Identifique todas as arestas que cruzam o corte (de S para V-S).",
                                    "Selecione a aresta e de menor peso entre essas arestas cruzadoras.",
                                    "Registre o peso w(e) e confirme que nenhuma outra aresta cruzadora tem peso menor."
                                  ],
                                  "verification": "Verifique se e é realmente a menor peso cruzando o corte listando todas as arestas cruzadoras e seus pesos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, diagrama de grafo impresso ou software como Graphviz",
                                  "tips": "Desenhe o grafo claramente destacando o conjunto S e as arestas cruzadoras com cores diferentes.",
                                  "learningObjective": "Compreender a definição precisa de corte e a seleção da aresta de menor peso.",
                                  "commonMistakes": "Confundir arestas cruzadoras com todas as arestas do grafo; ignorar pesos iguais."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Assumir uma AGM ótima T que não inclui e",
                                  "subSteps": [
                                    "Lembre-se que uma AGM conecta todos os vértices sem ciclos e com peso mínimo total.",
                                    "Assuma que existe uma AGM ótima T ⊆ E tal que e ∉ T.",
                                    "Confirme que T é conexa e sem ciclos, e seu peso total é mínimo entre todas as AGMs.",
                                    "Note que, como T conecta V, deve haver pelo menos uma aresta em T que cruza o corte (S, V-S).",
                                    "Denote essa aresta como f ∈ T, com w(f) ≥ w(e) por definição de e."
                                  ],
                                  "verification": "Escreva a hipótese de contradição explicitamente: 'Suponha T AGM ótima com e ∉ T'. Liste arestas de T cruzando o corte.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Diagrama da AGM T desenhado à mão",
                                  "tips": "Use notação formal: T é AGM ótima ⇒ ∀ T' AGM, w(T) ≤ w(T').",
                                  "learningObjective": "Estabelecer a hipótese de contradição corretamente para prova por absurdum.",
                                  "commonMistakes": "Esquecer que T deve cruzar o corte; assumir w(f) < w(e) prematuramente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a nova árvore T' trocando f por e",
                                  "subSteps": [
                                    "Remova f de T, resultando em dois componentes: um contendo S e outro V-S (pois f cruzava o corte).",
                                    "Adicione e a T - {f}, reconectando os componentes.",
                                    "Verifique que T' = (T - {f}) ∪ {e} é uma árvore: |E(T')| = |V|-1, conexa e sem ciclos.",
                                    "Calcule w(T') = w(T) - w(f) + w(e) ≤ w(T), pois w(e) ≤ w(f).",
                                    "Se w(e) < w(f), então w(T') < w(T), contradizendo otimalidade de T."
                                  ],
                                  "verification": "Desenhe T' e confirme: conexa, sem ciclos, e w(T') ≤ w(T).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Dois diagramas: T e T' lado a lado",
                                  "tips": "Prove ausência de ciclos: ciclo em T' implicaria ciclo em T ou uso de e isolado.",
                                  "learningObjective": "Demonstrar que T' é uma AGM válida com peso não maior que T.",
                                  "commonMistakes": "Criar ciclo ao adicionar e; errar na desconexão ao remover f."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir a prova por contradição",
                                  "subSteps": [
                                    "Se w(e) < w(f), T' tem peso menor, impossível para T ótima.",
                                    "Se w(e) = w(f), T' ainda é ótima, mas a propriedade diz 'pertence a toda AGM' em contexto de unicidade ou generalidade.",
                                    "Portanto, a assunção e ∉ T é falsa: e deve estar em toda AGM ótima.",
                                    "Generalize: isso vale para qualquer corte onde e é a menor peso cruzadora.",
                                    "Escreva a conclusão formal da prova."
                                  ],
                                  "verification": "Reescreva a prova completa em parágrafos lógicos sem lacunas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Folha para rascunho da prova final",
                                  "tips": "Use 'por absurdum': assunção leva a contradição ⇒ assunção falsa.",
                                  "learningObjective": "Finalizar a prova logicamente e generalizá-la.",
                                  "commonMistakes": "Ignorar caso w(e)=w(f); falhar em generalizar para toda AGM."
                                }
                              ],
                              "practicalExample": "Considere G com vértices {A,B,C,D}, arestas: A-B(1), A-C(2), B-C(3), B-D(4), C-D(1). Corte S={A,B}, V-S={C,D}. Arestas cruzadoras: B-C(3), B-D(4). e=B-D? Não, menor é C-D(1)? C-D não cruza. Correto: S={A}, V-S={B,C,D}, cruzadoras A-B(1),A-C(2), e=A-B(1). Assuma T={A-C(2),B-C(3),C-D(1)} w=6 sem A-B. f=A-C(2), T'={A-B(1),B-C(3),C-D(1)} w=5<6, contradição.",
                              "finalVerifications": [
                                "Pode identificar corretamente a aresta e de menor peso em um corte dado?",
                                "Consegue assumir T ótima sem e e encontrar f cruzadora?",
                                "Constrói T' válida e compara pesos corretamente?",
                                "Explica a contradição sem falhas lógicas?",
                                "Generaliza a prova para qualquer grafo conectado?",
                                "Aplica a prova em um exemplo numérico completo?"
                              ],
                              "assessmentCriteria": [
                                "Correção lógica: ausência de erros na contradição (40%)",
                                "Clareza na definição de corte e seleção de e (20%)",
                                "Precisão na construção e verificação de T' (20%)",
                                "Generalização e conclusão formal (10%)",
                                "Uso de notação e diagramas adequados (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Provas por contradição e indução.",
                                "Programação: Implementação de Kruskal/Prim verificando propriedades.",
                                "Lógica: Estruturas de prova formal.",
                                "Otimização: Aplicações em problemas de minimização."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações, prova garante que algoritmos como Kruskal selecionem corretamente cabos de menor custo cruzando partições geográficas, otimizando infraestrutura sem loops desnecessários."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.1.3",
                            "name": "Aplicar propriedade de corte em exemplos",
                            "description": "Analisar um grafo exemplo, identificar cortes relevantes e justificar a inclusão segura de arestas mínimas cruzando esses cortes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Analisar e representar o grafo exemplo",
                                  "subSteps": [
                                    "Desenhe o grafo com todos os vértices e arestas rotuladas pelos pesos.",
                                    "Liste todas as arestas em ordem crescente de peso.",
                                    "Identifique o conjunto completo de vértices e verifique se o grafo está conectado.",
                                    "Marque inicialmente nenhuma aresta como parte da AGM.",
                                    "Confirme que não há ciclos iniciais."
                                  ],
                                  "verification": "Grafo desenhado corretamente com pesos visíveis e lista de arestas ordenada.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel quadriculado, lápis, borracha, software de grafos como Graphviz (opcional).",
                                  "tips": "Use cores diferentes para vértices e arestas para melhor visualização.",
                                  "learningObjective": "Compreender a estrutura inicial do grafo e preparar para análise de cortes.",
                                  "commonMistakes": "Esquecer de ordenar as arestas por peso ou desenhar conexões incorretas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e identificar um corte relevante",
                                  "subSteps": [
                                    "Escolha um subconjunto S de vértices não vazio e próprio (S ≠ ∅, S ≠ V).",
                                    "Defina o corte como a partição (S, V-S).",
                                    "Verifique se o corte é relevante: pelo menos uma aresta cruza de S para V-S.",
                                    "Desenhe o corte no grafo destacando as arestas que o cruzam.",
                                    "Priorize cortes onde S tem um único vértice para simplicidade inicial."
                                  ],
                                  "verification": "Corte desenhado com S e V-S claramente separados e arestas cruzadoras listadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Mesmo do passo 1, caneta colorida para destacar o corte.",
                                  "tips": "Comece com |S| = 1 para cortes simples e expanda gradualmente.",
                                  "learningObjective": "Selecionar cortes que demonstrem a propriedade de forma clara.",
                                  "commonMistakes": "Escolher S vazio ou todo V, ou ignorar arestas que não cruzam."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar a aresta de menor peso cruzando o corte",
                                  "subSteps": [
                                    "Liste todas as arestas que cruzam o corte (de S para V-S).",
                                    "Compare os pesos dessas arestas e selecione a de menor peso.",
                                    "Verifique se essa aresta mínima não forma ciclo com arestas já selecionadas (inicialmente nenhuma).",
                                    "Marque essa aresta como incluída na AGM.",
                                    "Confirme que ela conecta componentes disjuntos."
                                  ],
                                  "verification": "Aresta mínima corretamente selecionada e marcada no grafo.",
                                  "estimatedTime": "12 minutos",
                                  "materials": "Papel, régua para medir distâncias visuais de pesos.",
                                  "tips": "Ordene as arestas cruzadoras em uma tabela para facilitar comparação.",
                                  "learningObjective": "Aplicar critério de minimização no corte específico.",
                                  "commonMistakes": "Selecionar aresta que não cruza o corte ou ignorar pesos iguais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar a inclusão segura e verificar consistência",
                                  "subSteps": [
                                    "Explique por que a aresta mínima deve estar na AGM: qualquer outra aresta cruzadora teria peso maior, violando minimalidade.",
                                    "Prove que sua inclusão não cria ciclo (pois conecta S e V-S).",
                                    "Repita para um segundo corte relevante no grafo atualizado.",
                                    "Verifique se as arestas selecionadas formam parte de uma AGM conhecida.",
                                    "Documente a justificativa em texto curto."
                                  ],
                                  "verification": "Justificativa escrita e pelo menos duas arestas justificadas sem ciclos.",
                                  "estimatedTime": "18 minutos",
                                  "materials": "Papel para anotações, exemplo de AGM resolvida para comparação.",
                                  "tips": "Use contra-prova: suponha que a AGM não inclua essa aresta e derive contradição.",
                                  "learningObjective": "Justificar matematicamente a corretude da propriedade de corte.",
                                  "commonMistakes": "Não provar ausência de ciclo ou justificativa vaga sem referência ao corte."
                                }
                              ],
                              "practicalExample": "Considere o grafo não direcionado com vértices A, B, C, D e arestas: A-B (peso 2), A-C (3), B-C (1), B-D (4), C-D (2). Tome corte S={A}, V-S={B,C,D}. Arestas cruzando: A-B(2), A-C(3). A mínima é A-B(2), que deve estar na AGM pois conecta A ao resto sem ciclo e menor peso.",
                              "finalVerifications": [
                                "Todos os cortes definidos dividem corretamente os vértices em S e V-S.",
                                "Arestas mínimas cruzadoras identificadas com pesos corretos.",
                                "Justificativas incluem prova de não-ciclo e minimalidade.",
                                "Arestas selecionadas não formam ciclos no grafo parcial.",
                                "Exemplo resolvido coincide com AGM conhecida (ex: Kruskal).",
                                "Documentação completa com desenhos e textos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cortes e arestas cruzadoras (25%).",
                                "Correta seleção da aresta mínima por corte (20%).",
                                "Qualidade da justificativa matemática (25%).",
                                "Ausência de ciclos nas seleções acumuladas (15%).",
                                "Clareza nos desenhos e documentação (10%).",
                                "Cobertura de múltiplos cortes relevantes (5%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de Grafos e Otimização.",
                                "Programação: Implementação de algoritmos Kruskal e Prim.",
                                "Logística e Engenharia: Design de redes de transporte mínimas.",
                                "Economia: Modelagem de custos em infraestrutura.",
                                "Ciência de Dados: Análise de clustering e conectividade."
                              ],
                              "realWorldApplication": "Na construção de redes de telecomunicações ou estradas, a propriedade de corte garante a seleção de links de menor custo para conectar regiões isoladas sem loops desnecessários, otimizando orçamentos em projetos como a rede 5G ou rodovias interestaduais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.2",
                        "name": "Propriedade de Ciclo",
                        "description": "Teorema que estabelece que, para qualquer ciclo em um grafo, a aresta de maior peso nesse ciclo não pode pertencer a nenhuma árvore geradora mínima (AGM).",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.2.1",
                            "name": "Definir e detectar ciclos em grafos",
                            "description": "Explicar o conceito de ciclo em grafos não direcionados e métodos para identificá-los, como busca em profundidade ou Union-Find.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o Conceito de Ciclo em Grafos Não Direcionados",
                                  "subSteps": [
                                    "Defina um grafo não direcionado como um conjunto de vértices conectados por arestas sem direção.",
                                    "Explique que um caminho é uma sequência de vértices conectados por arestas distintas.",
                                    "Defina ciclo como um caminho simples onde o primeiro e último vértice são iguais, com pelo menos 3 vértices.",
                                    "Diferencie ciclo de caminho simples e dê exemplos visuais em grafos pequenos.",
                                    "Discuta por que ciclos são importantes em contextos como árvores geradoras mínimas."
                                  ],
                                  "verification": "Desenhe 3 grafos: um acíclico, um com ciclo e um com múltiplos ciclos, e rotule corretamente.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhos",
                                    "Ferramenta online como Graphviz ou draw.io"
                                  ],
                                  "tips": "Use cores diferentes para vértices e arestas para visualizar melhor os caminhos.",
                                  "learningObjective": "Compreender precisamente a definição formal de ciclo em grafos não direcionados.",
                                  "commonMistakes": [
                                    "Confundir ciclo com aresta de volta em grafos direcionados",
                                    "Considerar grafos com laços como sem ciclo",
                                    "Ignorar que ciclos precisam de pelo menos 3 vértices"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Representar Grafos para Detecção de Ciclos",
                                  "subSteps": [
                                    "Escolha uma representação: lista de adjacência para eficiência em grafos esparsos.",
                                    "Implemente a lista de adjacência em Python ou pseudocódigo para um grafo exemplo.",
                                    "Adicione métodos para inserir vértices e arestas, garantindo não direcionado (adicionar bidirecional).",
                                    "Teste a representação com um grafo pequeno, imprimindo a estrutura.",
                                    "Valide se a representação captura corretamente conexões para detecção posterior."
                                  ],
                                  "verification": "Crie e imprima a lista de adjacência de um grafo com 5 vértices e verifique vizinhos corretos.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Jupyter)",
                                    "Biblioteca networkx para Python (opcional para visualização)"
                                  ],
                                  "tips": "Sempre inicialize listas vazias para cada vértice para evitar erros de índice.",
                                  "learningObjective": "Dominar a representação eficiente de grafos não direcionados para algoritmos de detecção.",
                                  "commonMistakes": [
                                    "Esquecer de adicionar arestas bidirecionais",
                                    "Usar índices inválidos para vértices",
                                    "Confundir matriz de adjacência com lista"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Detecção de Ciclos com Busca em Profundidade (DFS)",
                                  "subSteps": [
                                    "Revise DFS recursivo: visite vértice, marque como visitando, explore vizinhos.",
                                    "Identifique back edge: aresta para vértice ancestro na pilha de recursão (indicando ciclo).",
                                    "Implemente função hasCycle com rastreamento de visitados e pilha (recursion stack).",
                                    "Aplique DFS a partir de cada vértice não visitado para grafos desconexos.",
                                    "Teste com grafos acíclicos e cíclicos, retornando true/false adequadamente."
                                  ],
                                  "verification": "Execute o algoritmo em 3 grafos diferentes e confirme detecção correta de ciclos.",
                                  "estimatedTime": "40-50 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplos de grafos prontos em código"
                                  ],
                                  "tips": "Use três estados: não visitado, visitando, visitado para detectar back edges precisamente.",
                                  "learningObjective": "Implementar e entender DFS para detecção de ciclos em grafos não direcionados.",
                                  "commonMistakes": [
                                    "Marcar vértice como visitado antes de explorar vizinhos",
                                    "Não tratar componentes desconexas",
                                    "Confundir back edge com cross edge"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Explorar Union-Find para Detecção de Ciclos e Verificação Final",
                                  "subSteps": [
                                    "Entenda Union-Find: estrutura para união de conjuntos e encontrar raiz.",
                                    "Implemente find com path compression e union por rank.",
                                    "Detecte ciclo: se union de u e v com mesma raiz, há ciclo.",
                                    "Simule adição de arestas e detecte quando ciclo é formado.",
                                    "Compare eficiência com DFS para grafos dinâmicos."
                                  ],
                                  "verification": "Use Union-Find para adicionar arestas sequencialmente e identifique a aresta que cria ciclo.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Papel para simular unions"
                                  ],
                                  "tips": "Sempre verifique find(u) == find(v) antes de union para detecção precoce.",
                                  "learningObjective": "Aplicar Union-Find como alternativa eficiente para detecção de ciclos durante construção de grafos.",
                                  "commonMistakes": [
                                    "Não implementar path compression, causando lentidão",
                                    "Union sem verificar raízes iguais",
                                    "Ignorar rank na union"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo de cidades (vértices) conectadas por estradas (arestas), use DFS para detectar se adicionar uma nova estrada criaria um ciclo, evitando rotas redundantes em planejamento de infraestrutura.",
                              "finalVerifications": [
                                "Defina corretamente ciclo em um grafo não direcionado com exemplo.",
                                "Implemente lista de adjacência sem erros para grafo de 6 vértices.",
                                "DFS detecta ciclos em grafos acíclicos e cíclicos corretamente.",
                                "Union-Find identifica ciclo ao adicionar aresta entre mesmos componentes.",
                                "Explique diferença entre DFS e Union-Find em cenários práticos.",
                                "Desenhe pilha de recursão DFS mostrando back edge."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição conceitual (100% correta).",
                                "Corretude do código DFS e Union-Find (passa em todos testes).",
                                "Eficiência: O(n) para DFS, quase O(1) por operação em Union-Find.",
                                "Clareza no código com comentários e estrutura modular.",
                                "Capacidade de debugar erros comuns em detecção.",
                                "Aplicação correta em grafos desconexos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Combinatória.",
                                "Programação: Recursão, Estruturas de Dados e Algoritmos.",
                                "Engenharia de Software: Análise de Dependências e Ciclos em Builds.",
                                "Redes: Detecção de Loops em Protocolos de Roteamento.",
                                "Lógica Discreta: Provas de Corretude de Algoritmos."
                              ],
                              "realWorldApplication": "Detecção de ciclos em redes elétricas para evitar sobrecargas, em sistemas de recomendação para identificar loops em grafos de usuários, e em algoritmos de Árvore Geradora Mínima (Kruskal/Prim) para garantir aciclicidade em roteamento de dados ou logística."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.2",
                            "name": "Provar a propriedade de ciclo",
                            "description": "Demonstrar por contradição que incluir a aresta máxima de um ciclo em uma AGM levaria a uma árvore de peso maior que uma AGM ótima.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Relembrar definições de AGM e enuncionar a Propriedade de Ciclo",
                                  "subSteps": [
                                    "Defina Árvore Geradora Mínima (AGM) como uma árvore que conecta todos os vértices com peso total mínimo.",
                                    "Enuncie a Propriedade de Ciclo: Em qualquer ciclo C do grafo, a aresta de maior peso não pertence a nenhuma AGM ótima.",
                                    "Explique o contexto: Essa propriedade é fundamental para a corretude de algoritmos como Kruskal.",
                                    "Desenhe um grafo simples com ciclo para ilustrar.",
                                    "Discuta assunção de pesos distintos para simplificar a prova."
                                  ],
                                  "verification": "Escreva as definições e o enunciado da propriedade corretamente em um papel.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, caneta, diagrama de grafo exemplo.",
                                  "tips": "Use um grafo pequeno (ex: triângulo com pesos 1,2,3) para visualizar.",
                                  "learningObjective": "Compreender os conceitos fundamentais antes da prova.",
                                  "commonMistakes": "Confundir AGM com árvore geradora qualquer ou ignorar pesos distintos."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Assumir a contradição: T é AGM ótima contendo a aresta máxima e de um ciclo C",
                                  "subSteps": [
                                    "Assuma que T é uma AGM ótima do grafo G.",
                                    "Suponha que existe um ciclo C em G tal que a aresta e de maior peso em C pertence a T.",
                                    "Desenhe T e destaque e e o ciclo C contendo e.",
                                    "Anote formalmente: 'Suponha ∃ C ciclo com w(e) = max{w(f) | f ∈ C} e e ∈ T'.",
                                    "Verifique que essa assunção viola a propriedade a ser provada."
                                  ],
                                  "verification": "Descreva a assunção em notação formal e desenhe o grafo com ciclo destacado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel, caneta, grafo desenhado.",
                                  "tips": "Sempre rotule arestas com pesos para clareza visual.",
                                  "learningObjective": "Estabelecer a hipótese de contradição de forma precisa.",
                                  "commonMistakes": "Esquecer que C é ciclo no grafo completo G, não só em T."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Remover e de T e identificar os componentes desconectados A e B",
                                  "subSteps": [
                                    "Remova a aresta e de T, resultando em dois componentes conectados: A e B.",
                                    "Identifique os vértices em A e B (um extremo de e em A, outro em B).",
                                    "Confirme que T - e não é mais conexo.",
                                    "Desenhe T sem e, mostrando A e B.",
                                    "Explique que qualquer aresta entre A e B reconecta T."
                                  ],
                                  "verification": "Desenhe T - e e circule os componentes A e B corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, lápis para apagar/redesenhar.",
                                  "tips": "Use cores diferentes para A e B para facilitar visualização.",
                                  "learningObjective": "Entender o efeito da remoção de uma aresta em uma árvore.",
                                  "commonMistakes": "Assumir mais de dois componentes ou errar a partição."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Identificar aresta e' em C conectando A e B com peso menor",
                                  "subSteps": [
                                    "No ciclo C, além de e, há um caminho de A para B via outras arestas.",
                                    "Selecione uma aresta e' em C - {e} que cruza de A para B.",
                                    "Verifique que w(e') < w(e), pois e é máxima em C.",
                                    "Desenhe o caminho em C destacando e'.",
                                    "Confirme que e' não está em T (senão ciclo em T)."
                                  ],
                                  "verification": "Apontar e' no desenho e provar w(e') < w(e).",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Diagrama do grafo com ciclo.",
                                  "tips": "Liste todas arestas de C e compare pesos explicitamente.",
                                  "learningObjective": "Reconhecer conexões entre componentes via ciclo.",
                                  "commonMistakes": "Escolher e' que não cruza A-B ou assumir w(e') >= w(e)."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Construir T' = T - e + e' e mostrar peso menor, levando à contradição",
                                  "subSteps": [
                                    "Forme T' adicionando e' a T - e.",
                                    "Verifique que T' é acíclica (sem ciclo novo) e conexa (spanning tree).",
                                    "Calcule peso(T') = peso(T) - w(e) + w(e') < peso(T).",
                                    "Conclua que T' é AGM com peso menor, contradizendo otimalidade de T.",
                                    "Rejeite a assunção inicial."
                                  ],
                                  "verification": "Calcule pesos e desenhe T' confirmando ser árvore geradora.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel para novo desenho de T'.",
                                  "tips": "Some pesos numericamente em exemplo para validar.",
                                  "learningObjective": "Completar a prova demonstrando contradição.",
                                  "commonMistakes": "Esquecer provar que T' é acíclica ou conexa."
                                }
                              ],
                              "practicalExample": "Considere grafo completo K3: vértices A,B,C; arestas AB=1, BC=2, AC=3. Ciclo C={AB,BC,AC}, e=AC (peso 3 máx). Suponha T={AB,AC} (peso 4). Remova AC: componentes {A,B} e {C}. e'=BC (peso 2<3) conecta. T'={AB,BC} peso 3<4. Contradição, logo AC não em AGM.",
                              "finalVerifications": [
                                "Enuncie corretamente a Propriedade de Ciclo.",
                                "Descreva a assunção de contradição sem erros.",
                                "Identifique componentes A e B após remoção de e.",
                                "Selecione e' válida e prove w(e') < w(e).",
                                "Mostre que T' é AGM com peso menor.",
                                "Conclua a contradição logicamente."
                              ],
                              "assessmentCriteria": [
                                "Clareza na assunção inicial (20%).",
                                "Correta identificação de componentes e e' (25%).",
                                "Cálculo preciso de pesos e comparação (20%).",
                                "Verificação de que T' é spanning tree (15%).",
                                "Lógica da contradição sem falhas (10%).",
                                "Uso de notação formal e desenhos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Provas por contradição e indução.",
                                "Lógica: Raciocínio dedutivo e refutação.",
                                "Programação: Implementação de Kruskal com checagem de ciclos (Union-Find).",
                                "Otimização: Princípios de algoritmos gulosos."
                              ],
                              "realWorldApplication": "Essa propriedade valida algoritmos como Kruskal em redes reais, como planejamento de cabos de fibra ótica em telecomunicações, minimizando custos totais sem loops desnecessários, economizando milhões em infraestrutura."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.2.3",
                            "name": "Aplicar propriedade de ciclo em exemplos",
                            "description": "Em um grafo exemplo, identificar ciclos e excluir arestas de maior peso para construir uma AGM parcial.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar o grafo exemplo visualmente",
                                  "subSteps": [
                                    "Desenhe os vértices do grafo em um papel ou software.",
                                    "Adicione todas as arestas com seus respectivos pesos rotulados claramente.",
                                    "Liste todas as arestas em uma tabela ordenada por peso crescente.",
                                    "Verifique se o grafo está conectado e sem arestas duplicadas.",
                                    "Anote o número total de vértices e arestas."
                                  ],
                                  "verification": "Confirme que o desenho corresponde à descrição do grafo e que todos os pesos estão corretos.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Software de grafos (ex: draw.io ou Graphviz)",
                                    "Descrição do grafo exemplo"
                                  ],
                                  "tips": "Use cores diferentes para arestas de pesos baixos e altos para facilitar a visualização.",
                                  "learningObjective": "Dominar a representação precisa de grafos ponderados para análise posterior.",
                                  "commonMistakes": [
                                    "Esquecer de rotular pesos nas arestas",
                                    "Desenhar grafos desconectados incorretamente",
                                    "Confundir vértices semelhantes"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar ciclos no grafo",
                                  "subSteps": [
                                    "Percorra o grafo a partir de um vértice arbitrário usando DFS ou BFS manualmente.",
                                    "Marque vértices visitados e detecte back-edges que indicam ciclos.",
                                    "Liste explicitamente os vértices e arestas que formam cada ciclo encontrado.",
                                    "Priorize ciclos curtos (3-4 vértices) para simplicidade inicial.",
                                    "Valide cada ciclo percorrendo-o de volta ao vértice inicial."
                                  ],
                                  "verification": "Descreva verbalmente ou anote um ciclo completo, confirmando que ele retorna ao ponto de partida sem repetições desnecessárias.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Representação do grafo do Step 1",
                                    "Folha de rascunho para anotações"
                                  ],
                                  "tips": "Comece por vértices de alto grau para encontrar ciclos mais rapidamente.",
                                  "learningObjective": "Aprender a detectar ciclos em grafos não direcionados de forma sistemática.",
                                  "commonMistakes": [
                                    "Confundir caminhos simples com ciclos",
                                    "Ignorar ciclos que envolvem mais de 3 vértices",
                                    "Marcar arestas erradas como back-edges"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar a propriedade de ciclo: identificar aresta de maior peso",
                                  "subSteps": [
                                    "Para cada ciclo identificado, liste os pesos das arestas envolvidas.",
                                    "Compare os pesos e selecione a aresta com o maior peso no ciclo.",
                                    "Marque essa aresta como 'excluível' para a AGM.",
                                    "Justifique por que essa aresta não pode estar na AGM final.",
                                    "Repita para todos os ciclos principais detectados."
                                  ],
                                  "verification": "Anote a aresta máxima para cada ciclo e confirme que seu peso é o maior entre as listadas.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Lista de ciclos do Step 2",
                                    "Tabela de pesos"
                                  ],
                                  "tips": "Em caso de empate de pesos, escolha qualquer uma, mas anote a decisão.",
                                  "learningObjective": "Compreender e aplicar a propriedade de ciclo na exclusão de arestas desnecessárias.",
                                  "commonMistakes": [
                                    "Selecionar peso mínimo em vez de máximo",
                                    "Considerar arestas fora do ciclo",
                                    "Ignorar múltiplos ciclos sobrepostos"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Construir AGM parcial excluindo arestas identificadas",
                                  "subSteps": [
                                    "Remova as arestas de maior peso de cada ciclo da lista de candidatas.",
                                    "Adicione as arestas restantes de menor peso, verificando se formam ciclos.",
                                    "Desenhe a estrutura parcial da AGM resultante.",
                                    "Conte o número de arestas na AGM parcial (deve ser V-1 para completa, menos para parcial).",
                                    "Compare com o peso total esperado de uma AGM."
                                  ],
                                  "verification": "A AGM parcial não contém ciclos e conecta todos os vértices processados.",
                                  "estimatedTime": "15-20 minutos",
                                  "materials": [
                                    "Grafo modificado dos steps anteriores",
                                    "União-Find mental ou tabela para ciclos"
                                  ],
                                  "tips": "Use o algoritmo de Kruskal como guia para ordenação.",
                                  "learningObjective": "Construir iterativamente uma AGM parcial usando a propriedade de ciclo.",
                                  "commonMistakes": [
                                    "Manter arestas excluídas acidentalmente",
                                    "Criar novos ciclos na adição",
                                    "Não ordenar arestas por peso"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo com vértices A, B, C, D e arestas: A-B(1), A-C(4), B-C(2), B-D(5), C-D(3). Ciclo A-B-C-A: pesos 1,2,4 → exclua A-C(4). Ciclo B-C-D-B: pesos 2,3,5 → exclua B-D(5). AGM parcial: A-B(1), B-C(2), C-D(3), total peso 6.",
                              "finalVerifications": [
                                "Todos os ciclos foram identificados corretamente no grafo.",
                                "Arestas de maior peso foram excluídas de cada ciclo.",
                                "A AGM parcial não contém ciclos e tem peso mínimo possível.",
                                "Número de arestas na AGM parcial é V-1 ou apropriado para parcial.",
                                "Justificativa escrita para cada exclusão.",
                                "Desenho final da AGM parcial coincide com o esperado."
                              ],
                              "assessmentCriteria": [
                                "Precisão na detecção de ciclos (100% dos ciclos principais).",
                                "Correta identificação de arestas máximas em ciclos.",
                                "Construção válida de AGM parcial sem ciclos.",
                                "Eficiência na ordenação e exclusão de arestas.",
                                "Clareza nas anotações e desenhos.",
                                "Compreensão demonstrada na justificativa da propriedade."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Otimização Combinatória.",
                                "Programação: Implementação de Kruskal/Prim em linguagens como Python.",
                                "Engenharia: Design de redes elétricas ou de transporte.",
                                "Economia: Minimização de custos em projetos de infraestrutura."
                              ],
                              "realWorldApplication": "Em telecomunicações, otimizar o layout de cabos em uma rede urbana evitando loops caros, reduzindo custos totais ao excluir as conexões mais dispendiosas em ciclos detectados."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.3",
                        "name": "Corretude do Algoritmo de Kruskal",
                        "description": "Prova de que o algoritmo guloso de Kruskal, que adiciona arestas de menor peso sem formar ciclos, produz uma AGM usando a propriedade de ciclo.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.3.1",
                            "name": "Descrever o algoritmo de Kruskal",
                            "description": "Explicar os passos: ordenar arestas por peso crescente, adicionar se não formar ciclo usando Union-Find, até ter n-1 arestas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os Conceitos Fundamentais",
                                  "subSteps": [
                                    "Estudar a definição de Árvore Geradora Mínima (MST): subgrafo acíclico conectado com mínimo peso total.",
                                    "Revisar Union-Find: estrutura para gerenciar partições disjuntas e detectar ciclos.",
                                    "Entender representação do grafo como lista de arestas com pesos."
                                  ],
                                  "verification": "Explicar em 3 frases o que é MST e o papel do Union-Find em detectar ciclos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Diagrama de grafo exemplo",
                                    "Código básico de Union-Find",
                                    "Video tutorial sobre MST"
                                  ],
                                  "tips": [
                                    "Visualize grafos pequenos para intuitar conexões.",
                                    "Pratique find/union em papel antes de código."
                                  ],
                                  "learningObjective": "Dominar pré-requisitos teóricos para descrever Kruskal.",
                                  "commonMistakes": [
                                    "Confundir MST com menor caminho entre dois pontos.",
                                    "Esquecer que Union-Find usa path compression para eficiência."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever a Ordenação das Arestas",
                                  "subSteps": [
                                    "Listar todas as arestas do grafo não direcionado e ponderado.",
                                    "Ordená-las em ordem crescente pelo peso da aresta.",
                                    "Explicar a propriedade gulosa: escolher a menor aresta viável primeiro garante otimalidade."
                                  ],
                                  "verification": "Para um grafo dado, fornecer a lista de arestas ordenada corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Lista de arestas exemplo",
                                    "Ferramenta de ordenação online ou papel"
                                  ],
                                  "tips": [
                                    "Use stable sort se pesos iguais; priorize arestas mais leves sempre."
                                  ],
                                  "learningObjective": "Descrever precisamente o primeiro passo do algoritmo.",
                                  "commonMistakes": [
                                    "Ordenar por vértices em vez de pesos.",
                                    "Ignorar arestas de peso zero ou negativo (assumir pesos positivos)."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Seleção de Arestas com Union-Find",
                                  "subSteps": [
                                    "Inicializar Union-Find com cada vértice em seu próprio conjunto.",
                                    "Para cada aresta ordenada: se find(u) != find(v), executar union(u,v) e adicionar à MST.",
                                    "Descrever implementações: find com path compression, union by rank/size."
                                  ],
                                  "verification": "Simular seleção em um grafo pequeno, mostrando estados do Union-Find.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel para simular Union-Find",
                                    "Pseudocódigo de Kruskal"
                                  ],
                                  "tips": [
                                    "Desenhe árvores de pais para visualizar unions.",
                                    "Sempre verifique ciclo antes de adicionar."
                                  ],
                                  "learningObjective": "Articular o mecanismo central de seleção sem ciclos.",
                                  "commonMistakes": [
                                    "Adicionar aresta mesmo se find(u) == find(v).",
                                    "Confundir union com merge sem verificação."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Condições de Parada e Verificação",
                                  "subSteps": [
                                    "Continuar até ter n-1 arestas (para n vértices) ou todas arestas processadas.",
                                    "Verificar conectividade: grafo original conexo garante MST completa.",
                                    "Calcular e reportar peso total da MST formada."
                                  ],
                                  "verification": "Descrever verbalmente quando parar e como validar a saída.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Exemplo completo de grafo resolvido"
                                  ],
                                  "tips": [
                                    "Se menos de n-1 arestas, grafo não é conexo (floresta)."
                                  ],
                                  "learningObjective": "Completar a descrição do algoritmo com critérios finais.",
                                  "commonMistakes": [
                                    "Parar cedo sem n-1 arestas.",
                                    "Não mencionar caso de grafo desconexo."
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com vértices A,B,C,D. Arestas: A-B(1), B-C(1), C-D(2), A-C(3), B-D(4). Ordenar: A-B(1), B-C(1), C-D(2), A-C(3), B-D(4). Inicializar Union-Find: {A}, {B}, {C}, {D}. Adicionar A-B (union A,B), B-C (union B,C), C-D (union C,D). Agora 3 arestas (n-1=3), MST: A-B, B-C, C-D, peso 4. A-C e B-D formariam ciclos.",
                              "finalVerifications": [
                                "Lista corretamente os 3 passos principais: ordenar, selecionar com Union-Find, parar em n-1.",
                                "Explica detecção de ciclo via find(u) != find(v).",
                                "Identifica corretamente saída para grafo exemplo.",
                                "Menciona pré-condições: grafo conexo, não direcionado, ponderado.",
                                "Descreve pseudocódigo básico sem erros."
                              ],
                              "assessmentCriteria": [
                                "Precisão na sequência dos passos (ordenar primeiro).",
                                "Clareza na explicação do Union-Find e detecção de ciclos.",
                                "Correta identificação de condições de parada.",
                                "Uso de terminologia técnica apropriada (MST, Union-Find, guloso).",
                                "Capacidade de aplicar a um exemplo concreto sem falhas.",
                                "Compreensão da corretude: por que produz MST ótima."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Otimização Combinatória.",
                                "Programação: Implementação de Estruturas de Dados (Union-Find em Python/Java).",
                                "Engenharia: Design de Redes e Infraestrutura.",
                                "Ciência de Dados: Clustering Hierárquico.",
                                "Economia: Problemas de Alocação de Recursos Mínimos."
                              ],
                              "realWorldApplication": "Projeto de redes de telecomunicações para conectar cidades com mínimo custo de cabos; agrupamento de dados em machine learning; planejamento de circuitos elétricos; logística para rotas de menor custo total em transportes."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.3.2",
                            "name": "Provar corretude usando propriedade de ciclo",
                            "description": "Mostrar que cada aresta adicionada é segura pela propriedade de ciclo e que o resultado é uma árvore conectada de peso mínimo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender a Propriedade de Ciclo para Árvores Geradoras Mínimas",
                                  "subSteps": [
                                    "Defina formalmente uma árvore geradora mínima (AGM) em um grafo ponderado conexo.",
                                    "Enuncie a Propriedade de Ciclo: Em qualquer AGM, para todo ciclo no grafo, a aresta de maior peso nesse ciclo não pertence à AGM.",
                                    "Explique por que essa propriedade é essencial para provar corretude de algoritmos gulosos como Kruskal.",
                                    "Analise um exemplo simples de grafo com ciclo e identifique a aresta mais pesada.",
                                    "Discuta a implicação inversa: se uma aresta viola a propriedade, não pode estar em nenhuma AGM."
                                  ],
                                  "verification": "Escreva a definição e enuncie a propriedade corretamente, com um diagrama de exemplo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e lápis para diagramas",
                                    "Referência: Livro de Algoritmos (ex: Cormen et al., Capítulo 23)"
                                  ],
                                  "tips": "Use setas para destacar a aresta mais pesada no ciclo e memorize a propriedade como 'máximo no ciclo fora da AGM'.",
                                  "learningObjective": "Compreender e enunciar precisamente a Propriedade de Ciclo como base para a prova.",
                                  "commonMistakes": [
                                    "Confundir com propriedade de corte",
                                    "Esquecer que aplica a qualquer AGM, não só Kruskal"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Provar que Cada Aresta Adicionada no Kruskal é Segura",
                                  "subSteps": [
                                    "Revise o critério de adição no Kruskal: adicionar aresta de menor peso se não formar ciclo (Union-Find).",
                                    "Assuma que uma aresta e adicionada viola a Prop. de Ciclo; derive contradição mostrando que conecta componentes iguais.",
                                    "Mostre que, se e conectasse vértices no mesmo componente, formaria ciclo imediatamente rejeitado.",
                                    "Conclua que toda aresta adicionada satisfaz a Prop. de Ciclo em qualquer ciclo futuro contendo-a.",
                                    "Formalize: No momento da adição, não há caminho alternativo, logo e não é máxima em nenhum ciclo."
                                  ],
                                  "verification": "Escreva a prova por contradição para uma aresta específica em um grafo exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Union-Find simulator online",
                                    "Grafo exemplo com 4-5 vértices"
                                  ],
                                  "tips": "Pense em componentes como 'ilhas'; só liga ilhas diferentes, evitando ciclos instantâneos.",
                                  "learningObjective": "Provar o invariante de segurança para cada iteração do algoritmo.",
                                  "commonMistakes": [
                                    "Ignorar o estado das componentes no momento da adição",
                                    "Confundir ciclo formado com ciclo existente"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar que o Resultado é uma Árvore Conectada (Spanning Tree)",
                                  "subSteps": [
                                    "Mostre ausência de ciclos: pelo invariante do Step 2, nenhuma aresta viola Prop. de Ciclo.",
                                    "Prove aciclicidade: suponha ciclo final; a aresta mais pesada nele não foi adicionada (contradição).",
                                    "Prove conectividade: Kruskal para com n-1 arestas em grafo conexo; floresta com n-1 arestas é árvore.",
                                    "Verifique que todos vértices estão conectados via Union-Find no final.",
                                    "Confirme que o número de componentes reduz de n para 1."
                                  ],
                                  "verification": "Simule Kruskal em um grafo e confirme n-1 arestas sem ciclos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Software de grafos como Gephi ou papel para simulação"
                                  ],
                                  "tips": "Conte componentes após cada união; pare quando 1 componente.",
                                  "learningObjective": "Estabelecer que o output é uma árvore geradora válida.",
                                  "commonMistakes": [
                                    "Esquecer prova de conectividade em grafos desconexos",
                                    "Confundir floresta com árvore"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar Minimalidade do Peso Total",
                                  "subSteps": [
                                    "Assuma por contradição: existe outra AGM T' com peso menor que T (Kruskal).",
                                    "Considere a primeira aresta e em T não em T'; existe aresta e' em T' no mesmo corte de e.",
                                    "Pelo corte, e' cruza o corte; se peso(e') < peso(e), Kruskal teria pego e' primeiro (contradição).",
                                    "Conclua que nenhum T' tem peso menor; T é mínimo.",
                                    "Generalize usando Prop. de Ciclo/Corte para troca de arestas."
                                  ],
                                  "verification": "Escreva a prova completa de minimalidade com exemplo numérico.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Exemplo de grafo com pesos: V1-V2(1), V1-V3(2), V2-V3(3)",
                                    "Folha de anotações para cortes"
                                  ],
                                  "tips": "Visualize cortes como 'fronteiras entre componentes'; foque na menor cruzando.",
                                  "learningObjective": "Completar a prova de otimalidade via argumento de troca.",
                                  "commonMistakes": [
                                    "Não especificar 'primeira diferença'",
                                    "Ignorar ordenação por peso no Kruskal"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere grafo G: vértices A,B,C,D; arestas AB(1), AC(3), BD(2), CD(4), BC(5). Kruskal adiciona AB(1), BD(2), AC(3). Prova: AB não em ciclo; BD liga B-D; AC liga A-C sem ciclo (componentes {A,B},{C},{D} -> {A,B,D},{C}). Ciclo ABC: max BC(5) fora. Total 6, mínimo vs alternativa AD(?? ausente).",
                              "finalVerifications": [
                                "Enuncie corretamente a Prop. de Ciclo.",
                                "Prove segurança para cada aresta em exemplo.",
                                "Confirme aciclicidade e conectividade com n-1 arestas.",
                                "Escreva prova de minimalidade sem gaps.",
                                "Simule Kruskal e verifique invariantes.",
                                "Identifique violações potenciais em grafo errado."
                              ],
                              "assessmentCriteria": [
                                "Clareza na enunciação da Prop. de Ciclo (20%)",
                                "Rigor matemático na prova de segurança (25%)",
                                "Correção na prova de spanning tree (20%)",
                                "Profundidade na prova de minimalidade (25%)",
                                "Uso preciso de termos (Union-Find, corte, ciclo) (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de Grafos e Indução",
                                "Programação: Implementação de Union-Find e Ordenação",
                                "Otimização: Algoritmos Gulosos e Programação Linear Inteira",
                                "Engenharia: Redes de Computadores e Protocolos de Roteamento"
                              ],
                              "realWorldApplication": "Em telecomunicações, otimizar rede de cabos minimizando custo total sem loops (ex: Kruskal para backbones de fibra ótica); em logística, conectar armazéns com menor custo de estradas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.2"
                            ]
                          },
                          {
                            "id": "10.1.6.5.3.3",
                            "name": "Verificar corretude em grafo exemplo",
                            "description": "Executar Kruskal em um grafo e validar que o resultado satisfaz propriedades de corte e ciclo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o grafo exemplo e listar arestas",
                                  "subSteps": [
                                    "Escolha um grafo não direcionado ponderado com 4-6 vértices e 8-12 arestas, garantindo múltiplas AGMs possíveis.",
                                    "Liste todas as arestas em ordem crescente de peso, anotando vértices conectados e pesos.",
                                    "Inicialize a estrutura Union-Find com cada vértice em seu próprio componente.",
                                    "Desenhe o grafo inicial para visualização clara.",
                                    "Confirme que o grafo é conexo."
                                  ],
                                  "verification": "Lista de arestas ordenada está completa e Union-Find inicializado com n componentes isolados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, lápis, calculadora; software como Graphviz ou Draw.io opcional.",
                                  "tips": "Use pesos distintos para simplificar comparações; label arestas claramente.",
                                  "learningObjective": "Entender a representação inicial do grafo para aplicação do Kruskal.",
                                  "commonMistakes": "Esquecer de ordenar arestas por peso; assumir grafo desconexo."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar o algoritmo Kruskal passo a passo",
                                  "subSteps": [
                                    "Comece pela aresta de menor peso: verifique se conecta componentes diferentes via Union-Find (find(u) != find(v)).",
                                    "Se sim, adicione à AGM e una os componentes (union(u,v)); registre o estado dos componentes.",
                                    "Prossiga para próxima aresta, repetindo até ter n-1 arestas ou nenhuma mais viável.",
                                    "Registre todas decisões: arestas adicionadas/rejeitadas e estados intermediários.",
                                    "Calcule o peso total da AGM resultante."
                                  ],
                                  "verification": "Registro completo mostra n-1 arestas adicionadas sem violações iniciais, com peso total anotado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel para rastrear Union-Find; tabela para arestas e estados.",
                                  "tips": "Mantenha uma tabela de 'pai' para Union-Find para rastreio visual rápido.",
                                  "learningObjective": "Executar Kruskal corretamente, rastreando estados de componentes.",
                                  "commonMistakes": "Adicionar aresta que forma ciclo cedo; não ordenar arestas corretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar propriedade de corte para arestas selecionadas",
                                  "subSteps": [
                                    "Para cada aresta adicionada, reconstrua o estado dos componentes imediatamente antes de sua adição.",
                                    "Confirme que find(u) != find(v), significando que a aresta cruza um corte entre componentes.",
                                    "Visualize o corte: destaque componentes e confirme que a aresta é a mais leve cruzando aquele corte.",
                                    "Anote para cada aresta: 'corte cruzado' e peso mínimo confirmado.",
                                    "Compare com propriedade de corte ótima: nenhuma aresta mais leve foi rejeitada por ciclo."
                                  ],
                                  "verification": "Todas arestas adicionadas satisfazem propriedade de corte no estado histórico.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Registros do passo 2; desenhos de estados intermediários.",
                                  "tips": "Use setas para mostrar evolução de componentes; volte passo a passo.",
                                  "learningObjective": "Validar que Kruskal sempre escolhe aresta de corte mínimo sem ciclos.",
                                  "commonMistakes": "Verificar corte no estado final em vez de histórico; ignorar pesos."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar ausência de ciclos, conectividade e minimalidade",
                                  "subSteps": [
                                    "Confirme ausência de ciclos: rode DFS/BFS na AGM final para detectar ciclos (deve ser árvore).",
                                    "Verifique conectividade: todos vértices no mesmo componente via Union-Find final.",
                                    "Conte arestas: exatamente n-1.",
                                    "Para minimalidade, calcule outra AGM manualmente ou compare soma de pesos.",
                                    "Documente: 'Sem ciclos, conexo, n-1 arestas, peso mínimo confirmado.'"
                                  ],
                                  "verification": "AGM final é árvore conexa com peso mínimo, sem ciclos detectados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "AGM desenhada; Union-Find final; calculadora para soma.",
                                  "tips": "Implemente Union-Find com path compression para eficiência, mas manual aqui.",
                                  "learningObjective": "Confirmar que resultado satisfaz definições de AGM e corretude global.",
                                  "commonMistakes": "Confundir conectividade com ausência de ciclos; erro em contagem de arestas."
                                }
                              ],
                              "practicalExample": "Grafo com vértices A,B,C,D. Arestas: A-B:1, C-D:2, A-C:3, B-D:4, A-D:5, B-C:6. Kruskal adiciona A-B (corte A/B vs C/D), C-D (corte AB vs CD), A-C (corte ABCD, mas A-C:3 < B-D:4). Resultado: A-B, C-D, A-C (peso 6). Verificações: Cada adição cruza corte mínimo; final: árvore sem ciclos.",
                              "finalVerifications": [
                                "Todas arestas adicionadas cruzavam cortes distintos no momento da adição.",
                                "Nenhuma aresta adicionada formou ciclo (Union-Find confirmado).",
                                "AGM tem exatamente n-1 arestas e conecta todos vértices.",
                                "Peso total é mínimo comparado a outras possíveis AGMs.",
                                "Estados intermediários documentados sem inconsistências.",
                                "Propriedades de corte e ciclo preservadas em todos passos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na execução de Kruskal (sem erros de Union-Find): 25%.",
                                "Corretude na verificação de cortes (histórico correto): 25%.",
                                "Validação completa de ciclos/conectividade/minimalidade: 20%.",
                                "Documentação clara de passos e estados: 15%.",
                                "Uso correto de propriedades teóricas: 15%."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e propriedades de matroides.",
                                "Programação: Implementação de Union-Find e algoritmos greedy.",
                                "Análise de dados: Otimização em redes sociais ou transporte.",
                                "Lógica: Provas de corretude e invariantes de loop."
                              ],
                              "realWorldApplication": "Em telecomunicações, verificar se o algoritmo de Kruskal para cabos de rede (menor custo sem loops) produz rede conectada mínima, validando cortes para eficiência orçamentária e ausência de redundâncias."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.6.5.4",
                        "name": "Corretude do Algoritmo de Prim",
                        "description": "Prova de que o algoritmo de Prim, que cresce a árvore a partir de um vértice adicionando a aresta mínima para o conjunto atual, produz uma AGM usando a propriedade de corte.",
                        "specificSkills": [
                          {
                            "id": "10.1.6.5.4.1",
                            "name": "Descrever o algoritmo de Prim",
                            "description": "Explicar os passos: iniciar com um vértice, repetidamente adicionar a aresta de menor peso conectando o conjunto crescido ao resto do grafo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender os Pré-requisitos e Inicializar o Algoritmo",
                                  "subSteps": [
                                    "Revise conceitos básicos de grafos: vértices, arestas ponderadas e grafos conexos.",
                                    "Escolha um vértice inicial arbitrário para começar o conjunto S (conjunto crescido).",
                                    "Inicialize uma estrutura de chaves (key) com infinito para todos os vértices exceto o inicial (0), e um array de pais (parent) como nulo.",
                                    "Marque o vértice inicial como visitado e inclua-o no conjunto S.",
                                    "Prepare uma fila de prioridade para gerenciar as chaves mínimas."
                                  ],
                                  "verification": "Confirme que o conjunto S contém apenas o vértice inicial, chaves estão inicializadas corretamente e fila de prioridade reflete o estado inicial.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e lápis, diagrama de um grafo exemplo com 4-5 vértices, quadro branco.",
                                  "tips": "Sempre desenhe o grafo para visualizar melhor a inicialização.",
                                  "learningObjective": "Compreender a configuração inicial necessária para o algoritmo de Prim funcionar corretamente.",
                                  "commonMistakes": "Esquecer de definir a chave do vértice inicial como 0 ou não marcar como visitado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Selecionar o Vértice com a Chave Mínima",
                                  "subSteps": [
                                    "Use uma fila de prioridade para extrair o vértice u não visitado com a menor chave.",
                                    "Adicione u ao conjunto S.",
                                    "Registre o pai de u como o vértice que levou à sua inclusão.",
                                    "Atualize o peso da aresta (u, pai(u)) como a chave de u.",
                                    "Marque u como visitado."
                                  ],
                                  "verification": "Verifique se o vértice extraído tem a menor chave entre os não visitados e foi corretamente adicionado a S.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Fila de prioridade simulada em papel ou software como Python heapq, grafo desenhado.",
                                  "tips": "Simule a fila de prioridade manualmente com uma lista ordenada para pequenos grafos.",
                                  "learningObjective": "Dominar a extração do vértice de menor custo conectável ao conjunto S.",
                                  "commonMistakes": "Selecionar um vértice já visitado ou ignorar a fila de prioridade."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atualizar Chaves dos Vértices Adjacentes",
                                  "subSteps": [
                                    "Para cada vértice v adjacente a u que ainda não está em S, calcule o peso da aresta (u, v).",
                                    "Se peso(u, v) < chave atual de v, atualize a chave de v para peso(u, v) e defina pai(v) = u.",
                                    "Atualize a fila de prioridade com as novas chaves.",
                                    "Repita até que todos os vértices estejam em S.",
                                    "Ignore atualizações para vértices já em S."
                                  ],
                                  "verification": "Confirme que todas as chaves adjacentes foram verificadas e atualizadas apenas se menores, sem ciclos introduzidos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Tabela de adjacência ou lista de adjacência do grafo, calculadora para pesos.",
                                  "tips": "Acompanhe mudanças nas chaves com setas no diagrama do grafo.",
                                  "learningObjective": "Aprender a relaxar arestas para encontrar conexões de menor custo.",
                                  "commonMistakes": "Atualizar chaves de vértices já em S ou não usar o mínimo entre múltiplas opções."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar e Verificar a Árvore Geradora Mínima",
                                  "subSteps": [
                                    "Pare quando todos os vértices estiverem em S (n-1 iterações para n vértices).",
                                    "Construa a AGM rastreando os pais: para cada vértice, adicione aresta (pai(v), v).",
                                    "Some os pesos das arestas selecionadas para obter o custo total mínimo.",
                                    "Verifique conectividade e ausência de ciclos na árvore resultante.",
                                    "Compare com o grafo original para confirmar minimalidade."
                                  ],
                                  "verification": "A árvore tem n-1 arestas, conecta todos os vértices, sem ciclos e custo mínimo comprovado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Lista final de pais e chaves, software de visualização de grafos como Graphviz.",
                                  "tips": "Liste as arestas em ordem de adição para reconstruir a árvore facilmente.",
                                  "learningObjective": "Reconhecer o resultado final como uma AGM válida e eficiente.",
                                  "commonMistakes": "Parar prematuramente ou incluir arestas desnecessárias criando ciclos."
                                }
                              ],
                              "practicalExample": "Considere um grafo com vértices A, B, C, D e arestas: A-B(2), A-C(3), B-C(1), B-D(4), C-D(5). Inicie em A (S={A}, keys: A=0, B=2, C=3, D=∞). Extraia A, atualize B=2, C=3. Extraia B (menor), atualize C=min(3,1)=1, D=4. Extraia C, atualize D=min(4,5)=4. Extraia D. AGM: A-B(2), B-C(1), B-D(4), custo total 7.",
                              "finalVerifications": [
                                "Pode listar os 4 passos principais do algoritmo de Prim em ordem?",
                                "Descreve corretamente a inicialização das chaves e pais?",
                                "Explica o uso da fila de prioridade para extração mínima?",
                                "Identifica a condição de parada (todos vértices em S)?",
                                "Verifica que a saída é uma árvore sem ciclos conectando todos os vértices?",
                                "Calcula corretamente o custo total da AGM em um exemplo?"
                              ],
                              "assessmentCriteria": [
                                "Precisão na descrição dos passos iterativos (atualização de chaves e extração mínima).",
                                "Correta distinção entre conjunto S e vértices restantes.",
                                "Uso apropriado de estruturas de dados como fila de prioridade.",
                                "Explicação clara da corretude (sem ciclos, custo mínimo).",
                                "Capacidade de aplicar em exemplo concreto com traçado passo a passo.",
                                "Identificação de complexidade temporal O(E log V) ou similar."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Otimização Linear.",
                                "Programação: Implementação com Heaps e Estruturas de Dados.",
                                "Física: Modelagem de redes elétricas ou de transporte.",
                                "Economia: Problemas de custo mínimo em alocação de recursos."
                              ],
                              "realWorldApplication": "O algoritmo de Prim é usado em telecomunicações para conectar cidades com cabos de fibra ótica de menor custo total, em redes clustering para agrupar dados em machine learning, e em planejamento de rotas logísticas eficientes em GPS e supply chain."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.6.5.4.2",
                            "name": "Provar corretude usando propriedade de corte",
                            "description": "Demonstrar que cada aresta escolhida é a mínima cruzando o corte definido pelo conjunto atual, garantindo optimalidade.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender a Propriedade de Corte para Árvores Geradoras Mínimas",
                                  "subSteps": [
                                    "Defina um corte como uma partição dos vértices em dois conjuntos disjuntos S e V-S.",
                                    "Explique que uma aresta cruza o corte se conecta um vértice de S a um de V-S.",
                                    "Enuncie o lema: Para qualquer corte, a aresta de menor peso cruzando-o pertence a alguma AGM.",
                                    "Discuta por que isso garante 'segurança' na construção da AGM.",
                                    "Forneça um exemplo simples de grafo com cortes destacados."
                                  ],
                                  "verification": "Escreva a definição do lema de corte e aplique-o a um grafo exemplo sem erros.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Diagrama de grafo impresso ou digital"
                                  ],
                                  "tips": "Visualize o corte desenhando uma linha divisória entre S e V-S.",
                                  "learningObjective": "Entender o conceito fundamental de corte e seu papel na corretude de algoritmos de AGM.",
                                  "commonMistakes": "Confundir corte com ciclo ou esquecer que S e V-S são disjuntos e cobrem todos os vértices."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir o Corte no Contexto do Algoritmo de Prim",
                                  "subSteps": [
                                    "Descreva o estado do Prim após k iterações: conjunto S com k+1 vértices conectados.",
                                    "Identifique o corte natural: S (vértices na árvore parcial) vs V-S (vértices restantes).",
                                    "Liste todas as arestas cruzando esse corte.",
                                    "Explique como o Prim seleciona a aresta de menor peso entre S e V-S.",
                                    "Desenhe o grafo mostrando S destacado e o corte."
                                  ],
                                  "verification": "Marque o conjunto S e liste corretamente as arestas cruzando o corte em um exemplo dado.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Grafo exemplo com 5-6 vértices",
                                    "Ferramenta de desenho como Draw.io ou papel"
                                  ],
                                  "tips": "Sempre inicie com |S|=1 (vértice arbitrário) e expanda iterativamente.",
                                  "learningObjective": "Mapear o estado iterativo do Prim ao conceito de corte.",
                                  "commonMistakes": "Escolher corte arbitrário em vez do corte definido por S atual."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar que a Aresta Escolhida é a Mínima Cruzando o Corte",
                                  "subSteps": [
                                    "No algoritmo Prim, compare pesos de todas as arestas de S para V-S.",
                                    "Mostre que a aresta e=(u,v) com u∈S, v∈V-S, de menor peso, é selecionada.",
                                    "Prove por contradição: suponha outra aresta f cruzando com peso(f) < peso(e); contradiz seleção do Prim.",
                                    "Calcule explicitamente os pesos no exemplo.",
                                    "Atualize S adicionando v após seleção."
                                  ],
                                  "verification": "Demonstre com cálculos que nenhuma outra aresta tem peso menor no corte.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Tabela de pesos das arestas",
                                    "Calculadora ou planilha"
                                  ],
                                  "tips": "Mantenha uma fila de prioridade para simular a seleção eficiente.",
                                  "learningObjective": "Confirmar matematicamente a minimalidade da aresta escolhida.",
                                  "commonMistakes": "Ignorar arestas não-adjacentes ou confundir peso com grau."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aplicar o Lema de Corte para Provar Corretude e Optimalidade",
                                  "subSteps": [
                                    "Aplique o lema: como e é mínima no corte, e pertence a alguma AGM ótima T.",
                                    "Por indução: assuma árvore parcial ótima até k; após adicionar e, permanece ótima.",
                                    "Mostre que qualquer AGM ótima deve incluir e ou uma equivalente sem aumentar o peso total.",
                                    "Conclua que o Prim constrói uma AGM ótima ao final.",
                                    "Verifique em exemplo completo que o peso total é mínimo."
                                  ],
                                  "verification": "Escreva a prova por indução usando o lema, sem lacunas lógicas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha para prova formal",
                                    "Exemplo de grafo resolvido pelo Prim"
                                  ],
                                  "tips": "Use notação: w(e) ≤ w(f) para toda f cruzando o corte.",
                                  "learningObjective": "Construir prova rigorosa de corretude ligando Prim ao lema de corte.",
                                  "commonMistakes": "Pular base da indução ou falhar na hipótese indutiva para árvores parciais."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Sintetizar a Prova Completa e Testar em Exemplo",
                                  "subSteps": [
                                    "Resuma a prova: em cada iteração, e é segura pelo lema de corte.",
                                    "Execute Prim passo a passo em um grafo exemplo, provando cada adição.",
                                    "Compare com AGM conhecida para validar.",
                                    "Discuta generalização para grafos densos/esparsos.",
                                    "Registre a prova em pseudocódigo comentado."
                                  ],
                                  "verification": "Apresente prova completa que convence um par de estudo da optimalidade.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Grafo exemplo final",
                                    "Pseudocódigo do Prim"
                                  ],
                                  "tips": "Grave vídeo ou anote para revisão rápida.",
                                  "learningObjective": "Integrar todos os elementos em uma prova coesa e verificável.",
                                  "commonMistakes": "Generalizar prematuramente sem verificar passos individuais."
                                }
                              ],
                              "practicalExample": "Grafo com vértices A,B,C,D. Arestas: AB=2, AC=3, AD=6, BC=1, BD=4, CD=5. Inicie com A (S={A}). Corte: {A} vs {B,C,D}. Mínima: AB=2 (menor que AC=3, AD=6). Adicione B (S={A,B}). Corte: {A,B} vs {C,D}. Arestas: AC=3, BC=1, BD=4. Mínima: BC=1. Continue provando cada passo pelo lema.",
                              "finalVerifications": [
                                "Define corretamente o corte S vs V-S em qualquer iteração do Prim.",
                                "Identifica a aresta de menor peso cruzando o corte.",
                                "Aplica o lema de corte para justificar que a aresta é 'segura'.",
                                "Constrói prova por indução sem falhas lógicas.",
                                "Valida em exemplo numérico que o Prim produz AGM ótima.",
                                "Explica por que isso garante optimalidade global."
                              ],
                              "assessmentCriteria": [
                                "Clareza e precisão na definição de corte e lema (20%)",
                                "Correção na verificação da minimalidade da aresta (25%)",
                                "Rigor lógico na aplicação do lema e indução (30%)",
                                "Uso de exemplos concretos para ilustração (15%)",
                                "Conclusão sobre optimalidade do Prim (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Provas por indução e contradição",
                                "Teoria dos Grafos: Propriedades de árvores e cortes",
                                "Algoritmos: Análise de corretude e complexidade",
                                "Programação: Implementação e depuração de Prim"
                              ],
                              "realWorldApplication": "Em design de redes de telecomunicações ou distribuição elétrica, provar a corretude do Prim usando cortes garante que a infraestrutura mínima seja ótima em custo, evitando desperdícios milionários em cabos ou fios."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.6.5.1"
                            ]
                          },
                          {
                            "id": "10.1.6.5.4.3",
                            "name": "Verificar corretude em grafo exemplo",
                            "description": "Executar Prim em um grafo e confirmar que todas as arestas selecionadas satisfazem a propriedade de corte.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar o grafo exemplo e revisar o algoritmo de Prim",
                                  "subSteps": [
                                    "Escolha um grafo não direcionado ponderado com 4-6 vértices e pelo menos 8 arestas, garantindo que tenha uma MST única.",
                                    "Desenhe o grafo em papel ou software, listando todos os vértices, arestas e pesos.",
                                    "Revise as etapas do algoritmo de Prim: iniciar com um vértice, selecionar a aresta mínima para o conjunto atual, repetir até todos os vértices incluídos.",
                                    "Defina o corte como a partição entre vértices no MST parcial e os restantes.",
                                    "Anote o vértice inicial para a execução."
                                  ],
                                  "verification": "Grafo desenhado corretamente com todos os pesos listados e algoritmo revisado em notas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Papel, lápis, calculadora, software de grafos opcional (ex: Graphviz ou Draw.io)",
                                  "tips": "Use um grafo pequeno para facilitar a visualização manual dos cortes.",
                                  "learningObjective": "Entender a representação do grafo e os fundamentos do Prim para verificação posterior.",
                                  "commonMistakes": "Ignorar pesos duplicados ou escolher grafo desconectado."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar o algoritmo de Prim passo a passo",
                                  "subSteps": [
                                    "Inicie com um vértice arbitrário no conjunto S (MST parcial).",
                                    "Identifique todas as arestas conectando S ao resto (V-S).",
                                    "Selecione e adicione a aresta de menor peso, incluindo o novo vértice em S.",
                                    "Repita o processo até |S| = n (número de vértices).",
                                    "Registre cada aresta adicionada, o peso e o estado de S em cada iteração."
                                  ],
                                  "verification": "Lista completa de arestas da MST gerada, com sequência de adição e pesos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Grafo preparado, tabela para registrar iterações",
                                  "tips": "Mantenha uma tabela com colunas: Iteração, S, Arestas candidatas, Aresta escolhida.",
                                  "learningObjective": "Simular a execução precisa do Prim e capturar os cortes em cada passo.",
                                  "commonMistakes": "Selecionar aresta incorreta por não considerar apenas arestas de S para V-S."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar a propriedade de corte para cada aresta da MST",
                                  "subSteps": [
                                    "Para cada aresta e = (u,v) adicionada na iteração i, recrie o corte: S_i (antes de adicionar v) e V - S_i.",
                                    "Liste todas as arestas cruzando esse corte.",
                                    "Confirme que e tem o menor peso entre elas.",
                                    "Registre o peso mínimo cruzando o corte e compare com peso(e).",
                                    "Repita para todas as arestas da MST."
                                  ],
                                  "verification": "Tabela por aresta mostrando corte, arestas cruzantes, pesos e confirmação de mínimo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Registros da execução anterior, lista de todas as arestas do grafo",
                                  "tips": "Desenhe o corte visualmente no grafo para cada iteração para evitar confusão.",
                                  "learningObjective": "Aplicar a propriedade de corte para provar que cada escolha foi ótima.",
                                  "commonMistakes": "Confundir o corte com o estado após adicionar a aresta."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Concluir e validar a MST completa",
                                  "subSteps": [
                                    "Verifique se a MST tem exatamente n-1 arestas e conecta todos os vértices (sem ciclos).",
                                    "Calcule o peso total da MST.",
                                    "Compare com uma MST conhecida ou execute Kruskal para confirmação cruzada.",
                                    "Documente qualquer discrepância e resolva.",
                                    "Resuma a prova de corretude."
                                  ],
                                  "verification": "Relatório final confirmando conectividade, aciclicidade, n-1 arestas e propriedades de corte.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "MST gerada e verificações anteriores",
                                  "tips": "Use DFS ou BFS manual para checar conectividade.",
                                  "learningObjective": "Integrar todas as verificações para afirmar a corretude global do Prim.",
                                  "commonMistakes": "Esquecer de verificar aciclicidade ou conectividade."
                                }
                              ],
                              "practicalExample": "Considere o grafo com vértices A,B,C,D. Arestas: A-B:1, A-C:3, B-C:2, B-D:4, C-D:1. Inicie em A. Iteração 1: Corte {A}|{B,C,D}, min A-B:1, adicione B. Iteração 2: Corte {A,B}|{C,D}, mins B-C:2, C-D:1 (mas C-D não cruza), adicione B-C:2. Iteração 3: Corte {A,B,C}|{D}, min C-D:1, adicione. Verificações: Para A-B, único cruzante min; para B-C, menor que A-C:3; para C-D, único.",
                              "finalVerifications": [
                                "Todas as arestas da MST satisfazem a propriedade de corte mínima.",
                                "MST tem exatamente n-1 arestas.",
                                "Grafo MST é conexo e acíclico.",
                                "Peso total corresponde a uma MST ótima.",
                                "Nenhuma discrepância nas verificações de cortes.",
                                "Execução do Prim registrada sem erros de seleção."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de cortes para cada iteração (100% corretos).",
                                "Correta listagem e comparação de pesos cruzando cada corte.",
                                "Execução completa do Prim sem erros na sequência de arestas.",
                                "Verificação de propriedades globais da MST (conexidade, aciclicidade).",
                                "Documentação clara com tabelas e desenhos.",
                                "Capacidade de explicar verbalmente a prova de corretude."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e propriedades de otimização.",
                                "Programação: Implementação de Prim em Python/Java para automação.",
                                "Análise de dados: Aplicação em clustering hierárquico.",
                                "Engenharia: Otimização de redes em telecomunicações."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações, verificar se o algoritmo de Prim gera a infraestrutura de cabos mais barata conectando cidades, garantindo que cada adição de cabo seja a mais econômica cruzando a fronteira da rede atual, evitando desperdícios em projetos reais."
                            },
                            "estimatedTime": "0.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  }
                ]
              },
              {
                "id": "10.1.7",
                "name": "Algoritmos em Grafos",
                "description": "Algoritmos para caminho mais curto (Dijkstra, Bellman-Ford), fluxo máximo (Ford-Fulkerson) e problemas de emparelhamento em grafos.",
                "totalSkills": 36,
                "atomicTopics": [
                  {
                    "id": "10.1.7.1",
                    "name": "Algoritmo de Dijkstra",
                    "description": "Algoritmo para encontrar o caminho mais curto em grafos com pesos não negativos usando programação dinâmica.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.1.1",
                        "name": "Representação de Grafos Ponderados",
                        "description": "Conceitos fundamentais para representar grafos com pesos não negativos, incluindo listas de adjacência e inicialização de distâncias.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.1.1",
                            "name": "Implementar grafo com listas de adjacência ponderadas",
                            "description": "Criar uma estrutura de dados para representar um grafo direcionado ou não direcionado usando listas de adjacência, onde cada aresta armazena o vértice destino e o peso não negativo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a classe Grafo e inicializar listas de adjacência",
                                  "subSteps": [
                                    "Escolha uma linguagem de programação orientada a objetos, como Python.",
                                    "Crie a classe 'Grafo' com um atributo 'adj' inicializado como uma lista vazia ou dicionário.",
                                    "No método __init__, defina o número de vértices ou use um dicionário para vértices dinâmicos.",
                                    "Inicialize 'adj' como [[] for _ in range(num_vertices)] para listas de adjacência.",
                                    "Adicione atributos para direcionado (True/False) e pesos não negativos."
                                  ],
                                  "verification": "Execute o construtor e imprima o grafo vazio; deve mostrar listas vazias sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": "Use lista de listas para grafos com vértices numerados de 0 a n-1; dicionário para rótulos arbitrários.",
                                  "learningObjective": "Compreender a representação matricial vs. listal para eficiência em grafos esparsos.",
                                  "commonMistakes": [
                                    "Usar matriz de adjacência em vez de listas para grafos densos.",
                                    "Não considerar vértices isolados."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar método para adicionar vértices",
                                  "subSteps": [
                                    "Crie o método 'adicionar_vertice(self, vertice)' que aceita rótulo ou índice.",
                                    "Se usando lista, redimensione 'adj' para incluir nova lista vazia.",
                                    "Se usando dicionário, inicialize adj[vertice] = [].",
                                    "Valide se o vértice já existe para evitar duplicatas.",
                                    "Registre o total de vértices em um atributo 'num_vertices'."
                                  ],
                                  "verification": "Adicione 3 vértices e imprima len(adj); deve retornar 3.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Console Python para testes"
                                  ],
                                  "tips": "Para grafos dinâmicos, prefira dicionário com chaves como strings (ex: 'A', 'B').",
                                  "learningObjective": "Aprender a gerenciar vértices dinamicamente sem redimensionamento custoso.",
                                  "commonMistakes": [
                                    "Não tratar rótulos não numéricos.",
                                    "Permitir duplicatas sem verificação."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar método para adicionar arestas ponderadas",
                                  "subSteps": [
                                    "Crie 'adicionar_aresta(self, origem, destino, peso)' com peso >= 0.",
                                    "Valide entrada: origem e destino existem, peso não negativo.",
                                    "Adicione tupla (destino, peso) à lista adj[origem].",
                                    "Se não direcionado, adicione também (origem, peso) em adj[destino].",
                                    "Atualize contadores de arestas se necessário."
                                  ],
                                  "verification": "Adicione aresta (0,1,5); verifique adj[0] == [(1,5)] ou equivalente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Unittest ou asserts para validação"
                                  ],
                                  "tips": "Use tuplas imutáveis para (destino, peso); ordene listas se necessário para Dijkstra.",
                                  "learningObjective": "Dominar inserção eficiente O(1) de arestas em listas de adjacência.",
                                  "commonMistakes": [
                                    "Esquecer aresta reversa em grafos não direcionados.",
                                    "Permitir pesos negativos sem aviso."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar visualização e testes do grafo",
                                  "subSteps": [
                                    "Crie método 'imprimir_grafo(self)' que itera e printa adjacência.",
                                    "Teste com grafo exemplo: vértices 0-3, arestas (0,1,4), (0,2,2), etc.",
                                    "Verifique vizinhos de cada vértice com get_vizinhos(vertice).",
                                    "Adicione método para remover aresta ou vértice opcionalmente.",
                                    "Execute testes unitários para cobertura completa."
                                  ],
                                  "verification": "Imprima grafo; saída deve mostrar todas arestas e pesos corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Biblioteca unittest do Python"
                                  ],
                                  "tips": "Formate saída como '0: [(1,4), (2,2)]' para clareza.",
                                  "learningObjective": "Garantir corretude e depuração da implementação.",
                                  "commonMistakes": [
                                    "Índices fora de range.",
                                    "Não ordenar vizinhos para consistência."
                                  ]
                                }
                              ],
                              "practicalExample": "Crie um grafo não direcionado com 4 vértices (A=0, B=1, C=2, D=3). Adicione arestas: A-B peso 5, A-C peso 9, B-C peso 6, B-D peso 3. Imprima: A: [(B,5),(C,9)], etc. Use para preparar Dijkstra em rede de estradas.",
                              "finalVerifications": [
                                "Listas de adjacência armazenam tuplas (destino, peso) corretamente.",
                                "Adição de aresta em O(1) sem vazamentos de memória.",
                                "Tratamento correto de grafos direcionados vs. não direcionados.",
                                "Validação de pesos não negativos e vértices existentes.",
                                "Visualização imprime estrutura exata sem erros.",
                                "Testes com 5+ arestas passam sem exceções."
                              ],
                              "assessmentCriteria": [
                                "Eficiência: Espaço O(V+E), tempo inserção O(1).",
                                "Corretude: Todas arestas bidirecionais em grafos não direcionados.",
                                "Robustez: Tratamento de erros (vértice inexistente, peso negativo).",
                                "Clareza: Código comentado, nomes intuitivos.",
                                "Testabilidade: Métodos públicos para verificação.",
                                "Extensibilidade: Fácil adicionar remoção ou busca."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Matrizes de Adjacência.",
                                "Física: Modelagem de redes elétricas ou fluidodinâmicas.",
                                "Economia: Otimização de rotas logísticas e supply chain.",
                                "Biologia: Redes de interações genéticas ou neurais."
                              ],
                              "realWorldApplication": "Essencial para algoritmos de roteamento em GPS (Dijkstra/A*), redes sociais (amigos com forças), telecomunicações (caminhos mínimos com latência) e jogos (pathfinding em mapas ponderados)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.2",
                            "name": "Inicializar array de distâncias",
                            "description": "Configurar um array de distâncias onde a distância do nó fonte é 0 e todas as outras são infinito, preparando para o algoritmo de relaxação.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Propósito do Array de Distâncias",
                                  "subSteps": [
                                    "Estude o algoritmo de Dijkstra e identifique a fase de inicialização.",
                                    "Explique por que a distância da fonte deve ser 0: representa o ponto de partida.",
                                    "Entenda o conceito de infinito: indica nós ainda não alcançados.",
                                    "Relacione com a relaxação: atualizações futuras comparam com infinito.",
                                    "Anote o impacto no pseudocódigo do Dijkstra."
                                  ],
                                  "verification": "Escreva uma explicação de 3-5 frases resumindo o propósito e confirme com um colega ou autoavaliação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Pseudocódigo de Dijkstra",
                                    "Diagrama de grafo exemplo",
                                    "Notebook para anotações"
                                  ],
                                  "tips": "Visualize o array como um 'mapa de distâncias desconhecidas' exceto a origem.",
                                  "learningObjective": "Dominar o racional conceitual da inicialização para shortest paths.",
                                  "commonMistakes": [
                                    "Confundir infinito com um valor finito grande (use float('inf') em Python).",
                                    "Ignorar que isso prepara para todas as relaxações subsequentes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Identificar Nós, Nó Fonte e Estrutura do Array",
                                  "subSteps": [
                                    "Liste todos os nós do grafo (ex: A, B, C, D).",
                                    "Selecione e indexe o nó fonte (ex: A como índice 0).",
                                    "Defina o tamanho do array como o número de nós.",
                                    "Crie um mapeamento nó-índice para referência futura.",
                                    "Desenhe o array vazio com labels dos nós."
                                  ],
                                  "verification": "Crie uma tabela ou diagrama mostrando nós, índices e array vazio; verifique se cobre todos os nós.",
                                  "estimatedTime": "8 minutos",
                                  "materials": [
                                    "Representação do grafo ponderado",
                                    "Papel ou ferramenta de diagramação como Draw.io"
                                  ],
                                  "tips": "Mantenha índices consistentes com a representação de adjacência ou matriz.",
                                  "learningObjective": "Mapear corretamente a estrutura do grafo ao array de distâncias.",
                                  "commonMistakes": [
                                    "Índices fora de ordem ou duplicados.",
                                    "Esquecer nós isolados no grafo."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar e Preencher Array com Infinito",
                                  "subSteps": [
                                    "Inicialize um array vazio do tamanho correto (ex: dist = [ ] * num_nos em Python).",
                                    "Preencha todos os elementos com infinito (dist[i] = float('inf') para todo i).",
                                    "Use loop ou método vetorizado para eficiência.",
                                    "Imprima ou visualize o array para inspeção inicial.",
                                    "Confirme que nenhum valor finito foi atribuído ainda."
                                  ],
                                  "verification": "Execute código e imprima o array: todos devem ser 'inf' ou equivalente.",
                                  "estimatedTime": "12 minutos",
                                  "materials": [
                                    "Editor de código (Python/Jupyter)",
                                    "Grafo de teste com 4-6 nós"
                                  ],
                                  "tips": "Em linguagens sem float('inf'), use um valor grande como 999999, mas prefira nativo.",
                                  "learningObjective": "Implementar inicialização uniforme com valor sentinel (infinito).",
                                  "commonMistakes": [
                                    "Usar 0 ou valor finito inicial para não-fonte.",
                                    "Erro de off-by-one no tamanho do array."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir Distância da Fonte como Zero e Validar",
                                  "subSteps": [
                                    "Identifique o índice da fonte no mapeamento.",
                                    "Atribua dist[fonte_index] = 0.",
                                    "Reimprima o array para confirmar a mudança única.",
                                    "Teste com um grafo pequeno rodando o passo no contexto de Dijkstra.",
                                    "Documente o array final em um comentário de código."
                                  ],
                                  "verification": "Array final mostra exatamente um 0 na posição da fonte e inf nos demais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código do Step 3",
                                    "Console para debug"
                                  ],
                                  "tips": "Sempre valide imediatamente após atribuição para evitar bugs silenciosos.",
                                  "learningObjective": "Completar a inicialização com precisão e verificação.",
                                  "commonMistakes": [
                                    "Setar múltiplos zeros acidentalmente.",
                                    "Índice errado da fonte."
                                  ]
                                }
                              ],
                              "practicalExample": "Em Python, para grafo com nós ['A', 'B', 'C', 'D'] e fonte 'A' (índice 0): dist = [float('inf')] * 4; dist[0] = 0; print(dist) → [0, inf, inf, inf]. Isso prepara para relaxações como atualizar dist[1] se aresta A→B existir.",
                              "finalVerifications": [
                                "Array possui tamanho exato igual ao número de nós.",
                                "dist[fonte_index] == 0.",
                                "Todos os outros elementos == infinito.",
                                "Mapeamento nó-índice está documentado e correto.",
                                "Código roda sem erros e imprime array correto.",
                                "Integração teste: primeira iteração de Dijkstra não crasha."
                              ],
                              "assessmentCriteria": [
                                "Correção conceitual: explicação precisa do propósito.",
                                "Implementação precisa: array inicializado corretamente.",
                                "Eficiência: uso de loop ou inicialização vetorizada.",
                                "Verificação robusta: testes e impressões incluídos.",
                                "Clareza: código comentado e mapeamento explícito.",
                                "Generalidade: funciona para grafos de tamanhos variados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Conceito de infinito e limites em otimização.",
                                "Estruturas de Dados: Arrays/listas e indexação.",
                                "Programação: Loops, condicionais e valores sentinel.",
                                "Algoritmos: Preparação para priority queues em Dijkstra.",
                                "Lógica Computacional: Estados iniciais em buscas."
                              ],
                              "realWorldApplication": "Em apps de navegação como Waze ou Google Maps, inicializa distâncias de um ponto de partida (0) e infinito para destinos, permitindo calcular rotas mais curtas em tempo real considerando tráfego."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.1.3",
                            "name": "Marcar nós visitados",
                            "description": "Implementar um conjunto ou array para rastrear nós já processados permanentemente no algoritmo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Selecionar e Inicializar a Estrutura de Dados para Nós Visitados",
                                  "subSteps": [
                                    "Analise o algoritmo de Dijkstra e identifique a necessidade de rastrear nós processados permanentemente para evitar reprocessamento infinito.",
                                    "Compare opções: array/lista (simples, mas O(n) lookup) vs. conjunto/set (O(1) lookup em média).",
                                    "Escolha set para eficiência em grafos grandes; em Python: visited = set().",
                                    "Inicialize a estrutura vazia antes do loop principal do algoritmo.",
                                    "Defina convenções de nomenclatura claras, como 'visited_nodes'."
                                  ],
                                  "verification": "Execute print(len(visited)) no início; deve retornar 0. Inspecione tipo com isinstance(visited, set).",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou Jupyter)",
                                    "Documentação de sets na linguagem escolhida (ex: Python docs)"
                                  ],
                                  "tips": "Prefira hash sets para grafos com até 10^5 nós; teste com dados representativos.",
                                  "learningObjective": "Selecionar e configurar estrutura de dados otimizada para rastreamento eficiente de nós visitados.",
                                  "commonMistakes": [
                                    "Usar lista/array sem hash, causando lentidão O(n); inicializar com todos os nós do grafo."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Integrar Marcação de Nós Visitados Após Extração do Priority Queue",
                                  "subSteps": [
                                    "Localize o loop principal: while priority_queue não vazia.",
                                    "Após extrair nó u = heapq.heappop(pq): verifique if u in visited: continue.",
                                    "Caso contrário, adicione visited.add(u) imediatamente após confirmação de distância mínima.",
                                    "Garanta que a marcação ocorra apenas uma vez por nó, quando sua distância é finalizada.",
                                    "Atualize pseudocódigo ou código com comentários explicativos."
                                  ],
                                  "verification": "Simule execução manual: nó deve ser adicionado a visited exatamente uma vez após extração.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Pseudocódigo de Dijkstra padrão",
                                    "Ferramenta de depuração (pdb em Python)"
                                  ],
                                  "tips": "Use priority queue com pares (distância, nó) para evitar entradas duplicadas desnecessárias.",
                                  "learningObjective": "Implementar marcação precisa de nós no momento exato de finalização de processamento.",
                                  "commonMistakes": [
                                    "Marcar visitado antes de relaxar arestas, perdendo atualizações; marcar múltiplas vezes."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar Verificação de Visitados Antes de Processar Vizinhos",
                                  "subSteps": [
                                    "No loop for v in vizinhos(u): insira if v in visited: continue no início.",
                                    "Isso previne relaxamento desnecessário de arestas de vizinhos já processados.",
                                    "Integre com relaxação: if dist[v] > dist[u] + peso(u,v): atualize.",
                                    "Teste incremental: rode algoritmo em grafo pequeno sem/with verificação.",
                                    "Otimize: combine com decrease-key se usando Fibonacci heap avançado."
                                  ],
                                  "verification": "Logue acessos a vizinhos; nenhum vizinho visitado deve ser relaxado.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Grafo de exemplo em formato adjacente (lista ou dict)",
                                    "Visualizador de grafos (Graphviz)"
                                  ],
                                  "tips": "Verificação O(1) com set mantém complexidade O((V+E) log V).",
                                  "learningObjective": "Evitar processamento redundante de vizinhos já finalizados.",
                                  "commonMistakes": [
                                    "Esquecer verificação, causando loops ou distâncias incorretas; verificar após relaxar."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e Validar a Implementação Completa",
                                  "subSteps": [
                                    "Crie grafo teste com 5-10 nós, pesos positivos, sem ciclos negativos.",
                                    "Execute Dijkstra e compare distâncias com execução manual.",
                                    "Meça: todos nós visitados? Nenhum reprocessado? Tempos corretos?",
                                    "Teste casos edge: grafo desconexo, nó fonte isolado.",
                                    "Profile performance: verifique se |visited| == número de nós alcançáveis."
                                  ],
                                  "verification": "Assert len(visited) == len(nós alcançáveis) e distâncias mínimas corretas.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Biblioteca heapq (Python)",
                                    "Grafo de teste hardcoded"
                                  ],
                                  "tips": "Use unit tests com pytest para automação.",
                                  "learningObjective": "Garantir corretude e eficiência da marcação de visitados no contexto full Dijkstra.",
                                  "commonMistakes": [
                                    "Ignorar nós inacessíveis; não testar grafos densos."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo com nós A,B,C,D (A->B:2, A->C:4, B->D:1, C->D:1), inicialize visited=set(). Extraia A (add A), relaxa B/C. Extraia B (add B), relaxa D. Extraia C (if C not visited, add C, mas D já melhor). Extraia D (add D). Resultado: dist[D]=3, visited={A,B,C,D}, sem reprocessamento.",
                              "finalVerifications": [
                                "Estrutura visited contém exatamente os nós processados uma vez cada.",
                                "Nenhum vizinho visitado é relaxado desnecessariamente.",
                                "Distâncias finais coincidem com caminho mínimo manual.",
                                "Algoritmo termina em tempo finito sem loops infinitos.",
                                "Performance: O(1) checks em lookups de visited.",
                                "Funciona com grafos desconexos (visited só nós alcançáveis)."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Nós marcados apenas quando distância finalizada (100%).",
                                "Eficiência: Uso de set/hash para O(1) operações (90-100%).",
                                "Integração: Verificações corretas no fluxo Dijkstra (85-95%).",
                                "Testes: Cobertura de casos edge e validação manual (80-90%).",
                                "Código limpo: Comentários, nomenclatura e legibilidade (70-80%).",
                                "Otimização: Sem violações de invariantes do algoritmo."
                              ],
                              "crossCurricularConnections": [
                                "Estruturas de Dados: Conjuntos e tabelas hash para eficiência.",
                                "Matemática Discreta: Teoria de grafos e caminhos mínimos.",
                                "Programação Competitiva: Otimizações em algoritmos de roteamento.",
                                "Análise de Algoritmos: Complexidade temporal com priority queues."
                              ],
                              "realWorldApplication": "Em apps de navegação como Google Maps, marcação de interseções visitadas otimiza cálculo de rotas mais curtas em tempo real, evitando recomputações em redes urbanas massivas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.2",
                        "name": "Fila de Prioridade com Heap",
                        "description": "Uso de estruturas de dados para selecionar eficientemente o nó com menor distância conhecida.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.2.1",
                            "name": "Implementar min-heap para fila de prioridade",
                            "description": "Construir uma fila de prioridade baseada em heap binário mínimo para armazenar nós com suas distâncias provisórias, suportando inserção e extração do mínimo em O(log n).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura básica da classe MinHeap",
                                  "subSteps": [
                                    "Crie uma classe MinHeap em Python (ou linguagem escolhida).",
                                    "Inicialize um atributo heap como lista vazia.",
                                    "Adicione atributos para rastrear o tamanho atual do heap.",
                                    "Implemente funções auxiliares: swap(pos1, pos2), getParentIndex(i), getLeftChildIndex(i), getRightChildIndex(i)."
                                  ],
                                  "verification": "Instancie a classe sem erros e verifique se os atributos heap e size estão definidos corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código (VS Code ou similar)",
                                    "Python 3.x instalado"
                                  ],
                                  "tips": [
                                    "Use índices baseados em 0 para o array; pai de i é (i-1)//2, filho esquerdo 2*i+1, direito 2*i+2."
                                  ],
                                  "learningObjective": "Compreender a representação em array de um heap binário mínimo.",
                                  "commonMistakes": [
                                    "Índices incorretos para pai/filhos",
                                    "Não inicializar size como 0"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar o método de inserção (insert)",
                                  "subSteps": [
                                    "Adicione o novo nó (distância e identificador do nó) ao final do heap.",
                                    "Aplique heapify-up: compare com pai e troque se menor, até a raiz.",
                                    "Atualize o tamanho do heap após inserção.",
                                    "Teste inserindo 3 elementos e verificando a propriedade de heap mínimo."
                                  ],
                                  "verification": "Após inserir [5,'A'], [3,'B'], [7,'C'], o heap deve ser [3,'B',5,'A',7,'C'] ou equivalente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Código da classe MinHeap do step 1",
                                    "Console para testes"
                                  ],
                                  "tips": [
                                    "Sempre incremente size antes de heapify-up para evitar off-by-one."
                                  ],
                                  "learningObjective": "Dominar a inserção em O(log n) mantendo a propriedade de min-heap.",
                                  "commonMistakes": [
                                    "Esquecer de atualizar size",
                                    "Troca errada no heapify-up (comparar com filho ao invés de pai)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o método de extração do mínimo (extractMin)",
                                  "subSteps": [
                                    "Retorne e remova o elemento na raiz (heap[0]).",
                                    "Mova o último elemento para a raiz e diminua o tamanho.",
                                    "Aplique heapify-down: compare com filhos menores e troque até folha.",
                                    "Teste extraindo o mínimo após inserções anteriores."
                                  ],
                                  "verification": "Extrair mínimo deve retornar 3 ('B'), e heap restante mantém propriedade mínima.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código completo dos steps anteriores"
                                  ],
                                  "tips": [
                                    "No heapify-down, escolha o menor filho para trocar."
                                  ],
                                  "learningObjective": "Implementar remoção do mínimo em O(log n) preservando o heap.",
                                  "commonMistakes": [
                                    "Não trocar com o menor filho",
                                    "Índice inválido após remover último elemento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e validar a fila de prioridade completa",
                                  "subSteps": [
                                    "Crie uma instância e insira múltiplos nós com distâncias.",
                                    "Execute várias extrações e verifique ordem crescente dos mínimos.",
                                    "Meça o tempo de inserções/extrações para confirmar O(log n).",
                                    "Adicione prints para visualizar o heap em cada operação."
                                  ],
                                  "verification": "Sequência de inserts e extractMin produz mínimos na ordem correta sem violações de heap.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código completo da MinHeap"
                                  ],
                                  "tips": [
                                    "Use heapq do Python como referência, mas implemente do zero."
                                  ],
                                  "learningObjective": "Validar a implementação como fila de prioridade eficiente para Dijkstra.",
                                  "commonMistakes": [
                                    "Não limpar heap entre testes",
                                    "Ignorar casos edge como heap vazio"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo com nós A(∞), B(∞), C(∞), insira (A,7), (B,3), (C,5). Extraia min: B(3), então C(5), depois A(7). O heap mantém distâncias provisórias ordenadas.",
                              "finalVerifications": [
                                "Propriedade de min-heap mantida após 10 inserções e 5 extrações.",
                                "Extrações retornam elementos em ordem não-decrescente.",
                                "Tempo de insert/extractMin é O(log n) em testes com 100 elementos.",
                                "Heap vazio é tratado sem erros (is_empty retorna true).",
                                "Visualização do array reflete estrutura de árvore mínima."
                              ],
                              "assessmentCriteria": [
                                "Correção: Todas operações preservam min-heap property.",
                                "Eficiência: Complexidade temporal O(log n) comprovada.",
                                "Robustez: Trata casos edge (vazio, um elemento, full).",
                                "Clareza: Código legível com comentários em funções auxiliares.",
                                "Integração: Funciona como priority queue para simulação de Dijkstra."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de árvores binárias completas e desigualdades heap.",
                                "Engenharia de Software: Estruturas de dados eficientes para otimização.",
                                "Ciência de Dados: Heaps em algoritmos de ML como k-NN ou A*.",
                                "Física/Química: Simulações de partículas com prioridades de processamento."
                              ],
                              "realWorldApplication": "No algoritmo de Dijkstra para roteamento GPS, armazena distâncias provisórias de rotas, permitindo extração rápida da melhor rota parcial em redes de tráfego ou telecomunicações."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.2.2",
                            "name": "Atualizar prioridade em heap",
                            "description": "Realizar operação de decrease-key para atualizar a distância de um nó na fila de prioridade quando uma melhor rota é encontrada.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito de Decrease-Key em Heaps Binários",
                                  "subSteps": [
                                    "Revise a estrutura de um min-heap binário e suas propriedades (pai menor que filhos).",
                                    "Identifique quando decrease-key é necessário: quando uma nova distância menor é encontrada para um nó já no heap.",
                                    "Estude o papel no Dijkstra: atualizar dist[v] e priorizar v para extração futura.",
                                    "Analise pseudocódigo básico de decrease-key: reduzir valor e 'bubble up' até restaurar heap property.",
                                    "Compare com insert e extract-min para entender diferenças."
                                  ],
                                  "verification": "Explique em suas palavras o que acontece se não usarmos decrease-key no Dijkstra e desenhe um heap antes/depois de uma atualização.",
                                  "estimatedTime": "20-30 minutos",
                                  "materials": [
                                    "Documentação de heaps binários",
                                    "Pseudocódigo de Dijkstra com heap",
                                    "Papel e caneta para diagramas"
                                  ],
                                  "tips": [
                                    "Visualize o heap como uma árvore completa; foque na propriedade min-heap.",
                                    "Use índices de array para navegação pai/filho (pai = i//2, filhos = 2i+1, 2i+2)."
                                  ],
                                  "learningObjective": "Entender o propósito e pré-condições da operação decrease-key em contextos de grafos.",
                                  "commonMistakes": [
                                    "Confundir min-heap com max-heap.",
                                    "Ignorar que nós podem estar duplicados no heap Fibonacci (mas aqui é binário simples)."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Localizar e Acessar o Nó no Heap",
                                  "subSteps": [
                                    "Mantenha um mapa (dicionário) de vértices para seus índices atuais no heap array.",
                                    "Para um vértice v, busque seu índice atual no mapa.",
                                    "Verifique se o vértice já está no heap (dist[v] < INF).",
                                    "Atualize temporariamente o valor no heap array na posição do índice.",
                                    "Confirme que o novo valor é menor que o antigo para prosseguir."
                                  ],
                                  "verification": "Implemente uma função para localizar índice de um nó e teste com um heap de exemplo de 5 elementos.",
                                  "estimatedTime": "25-35 minutos",
                                  "materials": [
                                    "Editor de código (Python/Java)",
                                    "Exemplo de heap array: [INF, 5, 10, 15, 20]",
                                    "Mapa de índices: {A:1, B:2}"
                                  ],
                                  "tips": [
                                    "Use um array separado para heap e outro para posições: pos[v] = índice.",
                                    "Atualize pos[u] sempre em insert, decrease-key e extract-min."
                                  ],
                                  "learningObjective": "Dominar o mapeamento eficiente de vértices para posições no heap.",
                                  "commonMistakes": [
                                    "Perder a rastreabilidade do índice após swaps.",
                                    "Não atualizar o mapa após movimentações."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a Atualização e Heapify Up",
                                  "subSteps": [
                                    "Após atualizar o valor no índice i, compare com pai (i//2).",
                                    "Se filho < pai, troque com pai e repita do novo índice do filho.",
                                    "Continue 'bubble up' até raiz ou filho >= pai.",
                                    "Atualize o mapa pos para o vértice após cada swap.",
                                    "Teste com valores: heap = [INF, 10, 15, 20], decrease-key índice 3 para 5."
                                  ],
                                  "verification": "Simule manualmente heapify up em papel e verifique se min-heap property é restaurada.",
                                  "estimatedTime": "30-40 minutos",
                                  "materials": [
                                    "Simulador de heap online ou código interativo",
                                    "Array heap impresso para anotações"
                                  ],
                                  "tips": [
                                    "Loop while i > 0 and heap[i] < heap[parent]: swap and i = parent.",
                                    "O(n) worst-case, mas O(log n) médio."
                                  ],
                                  "learningObjective": "Implementar corretamente o bubble up para manter integridade do heap.",
                                  "commonMistakes": [
                                    "Esquecer de swapar valores E atualizar posições.",
                                    "Comparar incorretamente durante bubble up (use < para min-heap)."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Integrar Decrease-Key no Algoritmo de Dijkstra",
                                  "subSteps": [
                                    "No loop de relaxamento: if dist[v] > dist[u] + w, então dist[v] = dist[u] + w; decrease-key(v, dist[v]).",
                                    "Implemente a função decrease-key usando os passos anteriores.",
                                    "Execute Dijkstra completo em um grafo pequeno com pelo menos uma atualização.",
                                    "Compare tempo sem vs. com decrease-key (naive re-insert).",
                                    "Debugue casos onde múltiplas atualizações ocorrem para o mesmo v."
                                  ],
                                  "verification": "Rode Dijkstra em grafo exemplo e confirme distâncias corretas com heap atualizado.",
                                  "estimatedTime": "40-50 minutos",
                                  "materials": [
                                    "Código base de Dijkstra com heap",
                                    "Grafo exemplo: 4 nós com arestas que causem updates"
                                  ],
                                  "tips": [
                                    "Evite decrease-key se nova dist >= atual (otimização).",
                                    "Teste com grafos desconexos ou ciclos."
                                  ],
                                  "learningObjective": "Aplicar decrease-key fluidamente no fluxo de Dijkstra para eficiência O((V+E) log V).",
                                  "commonMistakes": [
                                    "Chamar decrease-key sem verificar se v está no heap.",
                                    "Não lidar com dist[v] já ótima."
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo: A(0) -> B(4), A -> C(2), C -> B(1), C -> D(5), B -> D(2). Inicial: heap=[A:0]. Relaxa C:2, insere. Relaxa B de C: 2+1=3 <4, decrease-key B para 3. Bubble up B acima de outros. Dist final: A0,B3,C2,D5.",
                              "finalVerifications": [
                                "O valor da prioridade do nó foi reduzido corretamente no heap.",
                                "Propriedade min-heap é mantida (todo pai <= filhos).",
                                "Mapa de posições reflete índices atuais após swaps.",
                                "Distâncias no Dijkstra coincidem com o ótimo após updates.",
                                "Nenhuma violação em extract-min subsequentes.",
                                "Tempo de execução escala logarithmicamente com V."
                              ],
                              "assessmentCriteria": [
                                "Explicação precisa do decrease-key e seu papel no Dijkstra (80%+ acerto em quiz).",
                                "Implementação correta sem bugs em heapify up (testes passam).",
                                "Tratamento edge cases: raiz, múltiplos updates (100% cobertura).",
                                "Eficiência: complexidade O(log V) demonstrada.",
                                "Integração seamless no código Dijkstra completo.",
                                "Análise de exemplo prático com diagramas corretos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Propriedades de árvores binárias completas e desigualdades heap.",
                                "Estruturas de Dados: Heaps, mapas hash para rastreamento.",
                                "Algoritmos: Comparação com Prim's MST, A* search.",
                                "Programação: Gerenciamento de estado mutável em arrays.",
                                "Otimização: Redução de complexidade em buscas guiadas."
                              ],
                              "realWorldApplication": "Em navegação GPS (Google Maps), atualiza distâncias em tempo real quando tráfego muda, priorizando rotas melhores em heaps para recomputar caminhos ótimos rapidamente em redes de milhões de nós."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.1.3",
                        "name": "Relaxação de Arestas e Loop Principal",
                        "description": "Mecanismo de programação dinâmica para atualizar distâncias e reconstruir caminhos mais curtos.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.1.3.1",
                            "name": "Executar relaxação de arestas",
                            "description": "Para cada vizinho de um nó selecionado, verificar se a distância via esse nó é menor que a conhecida, atualizando se necessário: dist[v] = dist[u] + w(u,v).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar o nó u selecionado e listar seus vizinhos adjacentes",
                                  "subSteps": [
                                    "Localize o nó u no grafo, que foi selecionado como o de menor distância tentadora no algoritmo de Dijkstra.",
                                    "Liste todos os vizinhos v conectados diretamente a u por uma aresta.",
                                    "Anote o peso w(u,v) de cada aresta u-v.",
                                    "Confirme que dist[u] está atualizado e fixo.",
                                    "Prepare uma tabela temporária com colunas: v, w(u,v), dist[u] + w(u,v)."
                                  ],
                                  "verification": "Lista completa de vizinhos com pesos anotados e sem duplicatas ou arestas inexistentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Representação do grafo (matriz ou lista de adjacência)",
                                    "Papel e lápis ou editor de texto"
                                  ],
                                  "tips": "Sempre verifique a direção das arestas se o grafo for direcionado.",
                                  "learningObjective": "Compreender a estrutura local do grafo em torno do nó u para preparar a relaxação.",
                                  "commonMistakes": [
                                    "Incluir nós não adjacentes",
                                    "Esquecer pesos das arestas",
                                    "Confundir u com outro nó"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a distância candidata para cada vizinho v",
                                  "subSteps": [
                                    "Para cada vizinho v, compute candidate_dist = dist[u] + w(u,v).",
                                    "Registre o valor de candidate_dist ao lado de dist[v] atual na tabela.",
                                    "Garanta que dist[u] seja o valor fixo mais recente.",
                                    "Se dist[v] for infinito (∞), note que qualquer candidate_dist finita é menor.",
                                    "Calcule para todos os vizinhos sequencialmente."
                                  ],
                                  "verification": "Todos candidate_dist calculados corretamente e registrados na tabela.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela preparada do Step 1",
                                    "Calculadora se pesos forem fracionários"
                                  ],
                                  "tips": "Use ∞ como símbolo para distâncias não alcançadas inicialmente.",
                                  "learningObjective": "Dominar o cálculo da soma de distâncias em grafos ponderados.",
                                  "commonMistakes": [
                                    "Usar dist[v] em vez de dist[u] no cálculo",
                                    "Erros aritméticos em somas",
                                    "Ignorar pesos zero ou negativos (Dijkstra assume não-negativos)"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Comparar distâncias e atualizar se necessário",
                                  "subSteps": [
                                    "Para cada v, compare se candidate_dist < dist[v] atual.",
                                    "Se verdadeiro, atualize dist[v] = candidate_dist.",
                                    "Opcionalmente, atualize o predecessor de v para u (para reconstruir caminho).",
                                    "Se falso, não altere dist[v].",
                                    "Marque na tabela se houve atualização (sim/não)."
                                  ],
                                  "verification": "dist[v] atualizado apenas quando candidate_dist é estritamente menor, com marcas corretas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Tabela atualizada do Step 2"
                                  ],
                                  "tips": "Use '<' estrito; igualdade não atualiza para evitar loops desnecessários.",
                                  "learningObjective": "Aplicar corretamente a condição de relaxação para otimização de caminhos.",
                                  "commonMistakes": [
                                    "Atualizar com <= em vez de <",
                                    "Atualizar predecessor incorretamente",
                                    "Pular vizinhos sem ∞"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Verificar integridade da relaxação e registrar mudanças",
                                  "subSteps": [
                                    "Confira que todas as distâncias foram processadas sem alterações indevidas.",
                                    "Verifique se dist[u] permaneceu inalterado.",
                                    "Registre o número de atualizações realizadas.",
                                    "Atualize a lista de distâncias tentadoras se necessário para iterações futuras.",
                                    "Confirme que nenhuma distância aumentou (propriedade de Dijkstra)."
                                  ],
                                  "verification": "Relatório final com contagem de atualizações e distâncias consistentes.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Tabela final e array dist global"
                                  ],
                                  "tips": "Após relaxação, o grafo mantém a propriedade de distâncias não-crescentes.",
                                  "learningObjective": "Garantir a corretamente e atomicidade da operação de relaxação no contexto do algoritmo.",
                                  "commonMistakes": [
                                    "Alterar dist[u] acidentalmente",
                                    "Não registrar predecessores",
                                    "Ignorar verificação de não-aumento"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo com nó u='A' (dist[A]=5), vizinhos B (w=3, dist[B]=10) e C (w=2, dist[C]=∞). Cálculos: candidate_B=5+3=8 <10 → dist[B]=8; candidate_C=5+2=7 <∞ → dist[C]=7. Atualizações: B e C.",
                              "finalVerifications": [
                                "Todos vizinhos de u foram processados.",
                                "dist[v] atualizado apenas se menor que anterior.",
                                "Nenhuma distância foi aumentada.",
                                "Predecessores corretamente atribuídos (se aplicável).",
                                "Array dist reflete mudanças precisamente.",
                                "Relaxação idempotente: repetir não altera mais."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de candidate_dist (100% correto).",
                                "Aplicação correta da condição de comparação (<).",
                                "Completude: todos vizinhos tratados.",
                                "Ausência de erros comuns como uso de <=.",
                                "Registro claro de mudanças e verificações.",
                                "Eficiência: sem operações redundantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Inequações e otimização linear.",
                                "Programação: Implementação de loops e condicionais.",
                                "Física: Modelagem de caminhos mínimos em redes.",
                                "Economia: Custos mínimos em redes de suprimentos."
                              ],
                              "realWorldApplication": "No GPS de rotas (ex: Google Maps), relaxa distâncias via novo nó intermediário para encontrar o caminho mais curto, atualizando tempos de viagem em tempo real durante navegação."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.2",
                            "name": "Implementar loop principal do Dijkstra",
                            "description": "Executar o ciclo principal: enquanto a fila não estiver vazia, extrair o nó com menor distância, marcar como visitado e relaxar suas arestas adjacentes.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Implementar a condição de parada do loop while",
                                  "subSteps": [
                                    "Inicialize a fila de prioridade (PQ) com heapq em Python se não feita anteriormente: import heapq; pq = []",
                                    "Escreva a estrutura do loop: while pq:",
                                    "Garanta que a PQ funcione como min-heap, onde o menor elemento é (distância, nó)",
                                    "Adicione um comentário explicando que o loop continua até todos os nós acessíveis serem processados",
                                    "Teste a condição vazia manualmente com pq = [] para verificar parada imediata"
                                  ],
                                  "verification": "Execute o código com PQ vazia; o loop não deve iterar. Com elementos, deve entrar.",
                                  "estimatedTime": "10-15 minutos",
                                  "materials": [
                                    "Editor de código (VSCode ou PyCharm)",
                                    "Biblioteca heapq do Python",
                                    "Grafo de exemplo em dicionário"
                                  ],
                                  "tips": [
                                    "Sempre use tuplas (dist, nó) na PQ para quebra de desempate por nó ID se distâncias iguais.",
                                    "Evite listas simples; heapq garante O(log V) pop."
                                  ],
                                  "learningObjective": "Compreender o critério de término do algoritmo Dijkstra, garantindo processamento completo do grafo conectado.",
                                  "commonMistakes": [
                                    "Esquecer import heapq",
                                    "Usar while len(pq) > 0 sem heapq",
                                    "Não tratar grafos desconectados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Extrair o nó com a menor distância da fila",
                                  "subSteps": [
                                    "Dentro do loop, extraia o mínimo: dist_u, u = heapq.heappop(pq)",
                                    "Armazene dist_u e u em variáveis locais para uso posterior",
                                    "Adicione verificação opcional: if dist_u > distances[u]: continue  (para entradas obsoletas)",
                                    "Registre o nó extraído em um log ou print para depuração",
                                    "Confirme que u é um índice válido do grafo (0 a n-1)"
                                  ],
                                  "verification": "Simule com PQ pequena; o nó extraído deve ter a menor distância atual entre candidatos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Código do Step 1",
                                    "Array distances inicializado com inf exceto source=0",
                                    "Função heapq.heappop"
                                  ],
                                  "tips": [
                                    "Use nó ID como segundo elemento na tupla para evitar comparações de nós.",
                                    "A verificação de dist_u > distances[u] previne processamento de entradas antigas."
                                  ],
                                  "learningObjective": "Dominar a extração eficiente do próximo nó candidato via priority queue.",
                                  "commonMistakes": [
                                    "Pop incorreto sem desempacotamento",
                                    "Ignorar entradas duplicadas na PQ",
                                    "Não verificar distâncias atualizadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Marcar o nó extraído como visitado",
                                  "subSteps": [
                                    "Inicialize array visited = [False] * num_nodes antes do loop",
                                    "Após extrair u, verifique if visited[u]: continue",
                                    "Defina visited[u] = True apenas após confirmação",
                                    "Atualize distances[u] = dist_u se necessário (para consistência)",
                                    "Adicione print('Processando nó:', u) para rastrear ordem de visita"
                                  ],
                                  "verification": "Todos os nós processados têm visited=True; nenhum revisitado.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Array visited booleano",
                                    "Grafo de teste com 4-5 nós"
                                  ],
                                  "tips": [
                                    "Visited previne reprocessamento em impl. com múltiplas entradas na PQ.",
                                    "Coloque o check logo após pop para eficiência."
                                  ],
                                  "learningObjective": "Implementar controle de visita para evitar loops infinitos e redundâncias.",
                                  "commonMistakes": [
                                    "Marcar visited antes do pop",
                                    "Não inicializar visited",
                                    "Usar visited sem check no loop"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relaxar as arestas adjacentes do nó atual",
                                  "subSteps": [
                                    "Itere sobre vizinhos: for v, weight in graph[u].items():",
                                    "Calcule nova_dist = distances[u] + weight",
                                    "Se nova_dist < distances[v]: atualize distances[v] = nova_dist",
                                    "Insira/atualize na PQ: heapq.heappush(pq, (nova_dist, v))",
                                    "Repita para todos vizinhos e teste com print de atualizações"
                                  ],
                                  "verification": "Após relaxação, distances[v] deve refletir o menor caminho conhecido; PQ atualizada.",
                                  "estimatedTime": "20-25 minutos",
                                  "materials": [
                                    "Grafo representado como dict of dicts {u: {v: w}}",
                                    "Arrays distances e visited",
                                    "heapq.heappush"
                                  ],
                                  "tips": [
                                    "Sempre push nova entrada mesmo se v já na PQ; check visited cuida do resto.",
                                    "Use float('inf') para distâncias iniciais."
                                  ],
                                  "learningObjective": "Executar relaxação correta para propagar distâncias mínimas via arestas.",
                                  "commonMistakes": [
                                    "Atualizar sem check <",
                                    "Esquecer push na PQ após update",
                                    "Índices errados em graph[u]"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo de cidades (A=0->B=1 peso2, A->D=3 peso5, B->C=2 peso3, C->D=3 peso1), implemente o loop: PQ inicia [(0,0)], pop A, relax B(2),D(5); pop B, relax C(5); pop C, relax D(4); pop D final. Código Python: while pq: dist_u, u = heappop(pq); if visited[u]: continue; visited[u]=True; for v,w in graph[u].items(): if distances[v] > distances[u]+w: distances[v]=distances[u]+w; heappush(pq,(distances[v],v)). Resultado: dist[D]=4.",
                              "finalVerifications": [
                                "O loop termina quando PQ vazia e todos nós acessíveis processados.",
                                "Array visited marca exatamente os nós alcançados como True.",
                                "Distâncias finais são corretas e não-infinito para nós conectados.",
                                "Nenhum nó processado múltiplas vezes (ver logs).",
                                "Código executa sem erros de índice ou heap.",
                                "Teste com grafo desconectado: nós isolados mantêm inf."
                              ],
                              "assessmentCriteria": [
                                "Correção: distâncias finais idênticas ao Dijkstra manual.",
                                "Eficiência: Complexidade O((V+E) log V) via heap operations.",
                                "Robustez: Lida com múltiplas entradas na PQ sem reprocessar.",
                                "Clareza: Código comentado com indentação correta.",
                                "Testabilidade: Inclui prints/logs para depuração.",
                                "Generalidade: Funciona para grafos densos/esparsos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e desigualdades triangulares.",
                                "Otimização: Problemas de caminho mínimo e programação dinâmica.",
                                "Ciência de Dados: Análise de redes sociais ou transporte.",
                                "Engenharia de Software: Estruturas de dados heap e grafos.",
                                "Física: Modelagem de redes elétricas ou fluidos."
                              ],
                              "realWorldApplication": "Roteamento em GPS (Google Maps calcula rotas mais curtas considerando tráfego), redes de computadores (roteamento de pacotes BGP), logística (otimização de entregas Amazon), jogos (pathfinding de NPCs em mundos abertos)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.3",
                            "name": "Reconstruir caminho mais curto",
                            "description": "Usar array de predecessores para rastrear e reconstruir o caminho do nó fonte até qualquer destino após a execução do algoritmo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o array de predecessores (prev)",
                                  "subSteps": [
                                    "Revise o resultado do algoritmo de Dijkstra: distâncias e array prev.",
                                    "Identifique que prev[i] armazena o predecessor imediato do nó i no caminho mais curto.",
                                    "Analise um exemplo simples: para nó destino D, prev[D] aponta para o nó anterior.",
                                    "Note que prev[fonte] é None ou -1, marcando o início.",
                                    "Desenhe o grafo e anote os prev para visualização."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o que cada entrada no array prev representa, usando um exemplo.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta para desenhar grafo",
                                    "Código de Dijkstra executado com print do prev"
                                  ],
                                  "tips": "Sempre comece pela fonte: prev[fonte] deve ser None.",
                                  "learningObjective": "Entender o papel do array prev na rastreabilidade do caminho ótimo.",
                                  "commonMistakes": [
                                    "Confundir prev com distâncias",
                                    "Ignorar que prev é construído durante relaxações"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Iniciar rastreamento reverso do nó destino",
                                  "subSteps": [
                                    "Selecione o nó destino (ex: nó D).",
                                    "Crie uma lista vazia para o caminho.",
                                    "Adicione o nó destino à lista.",
                                    "Defina current = destino.",
                                    "Entre em loop: enquanto current != fonte, faça current = prev[current] e adicione à lista."
                                  ],
                                  "verification": "Liste os nós adicionados até alcançar a fonte, confirmando que parou corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Array prev impresso",
                                    "Editor de código ou planilha para simular"
                                  ],
                                  "tips": "Use um debugger ou prints para rastrear current passo a passo.",
                                  "learningObjective": "Implementar o loop reverso para coletar predecessores.",
                                  "commonMistakes": [
                                    "Loop infinito se prev[fonte] não for None",
                                    "Esquecer de adicionar o nó atual à lista"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir e reverter o caminho completo",
                                  "subSteps": [
                                    "Após o loop, a lista está invertida (destino primeiro).",
                                    "Adicione a fonte manualmente se necessário.",
                                    " Reverta a lista: use reverse() em código ou inverta manualmente.",
                                    "Calcule o custo total somando pesos das arestas no caminho.",
                                    "Compare com dist[destino] para validar."
                                  ],
                                  "verification": "O caminho revertido vai da fonte ao destino e soma das distâncias equals dist[destino].",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Código Python com grafo exemplo",
                                    "Calculadora para somar pesos"
                                  ],
                                  "tips": "Em Python: path = path[::-1] para reverter lista.",
                                  "learningObjective": "Transformar caminho reverso em sequência correta e validar custo.",
                                  "commonMistakes": [
                                    "Esquecer de reverter a lista",
                                    "Erro na soma de pesos das arestas erradas"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar e testar a função de reconstrução",
                                  "subSteps": [
                                    "Escreva uma função reconstruct_path(prev, destino, fonte).",
                                    "Teste com o grafo exemplo, imprimindo o caminho.",
                                    "Teste casos edge: destino = fonte, grafo desconectado (dist infinito).",
                                    "Integre à implementação completa de Dijkstra.",
                                    "Documente a função com comentários."
                                  ],
                                  "verification": "Execute a função em 3 grafos diferentes e confirme caminhos corretos.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Ambiente de programação (Python/Jupyter)",
                                    "Grafos de teste prontos"
                                  ],
                                  "tips": "Sempre valide se dist[destino] é finito antes de reconstruir.",
                                  "learningObjective": "Codificar e depurar a reconstrução completa.",
                                  "commonMistakes": [
                                    "Não tratar prev[destino] = None (inacessível)",
                                    "Índices off-by-one em arrays"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo: A(0)->B(4), A->C(2), B->D(5), C->D(8). Após Dijkstra (fonte A): dist=[0,4,2,7], prev=[None,A,C,B]. Para destino D: current=D, path=[D]; current=B, path=[D,B]; current=A, path=[D,B,A]. Reverter: [A,B,D]. Custo: 4+5=9? Espera, dist[D]=7? Correção exemplo: arestas A-B:4, B-D:3 (total7), etc. Caminho A-B-D.",
                              "finalVerifications": [
                                "Reconstruir corretamente o caminho em um grafo de 5 nós.",
                                "Explicar por que usamos prev em vez de armazenar caminhos completos.",
                                "Identificar e corrigir bug em código com loop reverso.",
                                "Validar custo do caminho contra dist[destino].",
                                "Tratar caso onde destino não é alcançável.",
                                "Implementar função em <10 linhas de código limpo."
                              ],
                              "assessmentCriteria": [
                                "Precisão: Caminho correto em todos testes (100%).",
                                "Eficiência: Tempo O(|V|) no pior caso.",
                                "Robustez: Trata casos edge sem crash.",
                                "Clareza: Código comentado e explicação verbal.",
                                "Validação: Custo matches dist[destino].",
                                "Generalidade: Funciona para qualquer grafo válido."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Caminhos Ótimos.",
                                "Programação: Estruturas de Dados (arrays, listas) e Algoritmos.",
                                "Otimização: Problemas de Roteamento e Planejamento.",
                                "Engenharia de Software: Depuração e Validação de Algoritmos."
                              ],
                              "realWorldApplication": "Em apps de navegação como Google Maps ou Waze, reconstruir o caminho mais curto de rotas GPS usando predecessores para exibir direções passo a passo, otimizando tempo e combustível em tempo real."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.1.3.4",
                            "name": "Analisar complexidade temporal e espacial",
                            "description": "Calcular a complexidade O((V+E) log V) com heap binário e discutir limitações para pesos não negativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Estrutura do Algoritmo de Dijkstra com Heap Binário",
                                  "subSteps": [
                                    "Identifique os componentes principais: grafo representado por V vértices e E arestas, distâncias iniciais, heap de prioridade mínima.",
                                    "Descreva o loop principal: enquanto heap não vazio, extraia mínimo e relaxe arestas adjacentes.",
                                    "Liste operações chave: extract-min, decrease-key para atualizações de prioridade.",
                                    "Anote pseudocódigo focando em relaxação de arestas e uso do heap.",
                                    "Desenhe um grafo simples de exemplo com 4-5 vértices para ilustrar."
                                  ],
                                  "verification": "Pseudocódigo anotado corretamente e grafo desenhado com labels de distâncias iniciais.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis, pseudocódigo de Dijkstra impresso ou digital.",
                                  "tips": "Use setas para mostrar fluxo de relaxações no grafo.",
                                  "learningObjective": "Compreender os componentes que impactam a complexidade.",
                                  "commonMistakes": "Confundir heap binário com lista simples; ignorar decrease-key."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Complexidade das Operações no Heap Binário",
                                  "subSteps": [
                                    "Recapitule custos: extract-min O(log V), decrease-key O(log V), insert O(log V).",
                                    "Conte quantas vezes cada operação ocorre: V extract-min, até E decrease-key.",
                                    "Some custos: V * log V para extracts + E * log V para decreases.",
                                    "Ignore constantes para notação assintótica.",
                                    "Registre em tabela: Operação | Ocorrências | Custo por vez | Total."
                                  ],
                                  "verification": "Tabela completa com totais corretos em O((V+E) log V).",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Planilha ou papel quadriculado para tabela.",
                                  "tips": "Pense em pior caso: grafo denso onde todas arestas são relaxadas.",
                                  "learningObjective": "Dominar custos operacionais do heap binário em Dijkstra.",
                                  "commonMistakes": "Contar decrease-key como O(1); esquecer log V em inserts iniciais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular Complexidade Temporal e Espacial Total",
                                  "subSteps": [
                                    "Combine análises: temporal O((V+E) log V) dominado pelo heap.",
                                    "Espacial: O(V) para distâncias e predecessores + O(V) para heap = O(V).",
                                    "Compare com implementações ingênuas: O(V^2) vs. O((V+E) log V).",
                                    "Teste com grafo exemplo: conte operações manualmente.",
                                    "Escreva equação final: T(n) = O((V+E) log V)."
                                  ],
                                  "verification": "Equações escritas corretamente e comparação com grafo exemplo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Calculadora para logs, grafo exemplo do Step 1.",
                                  "tips": "Use V=100, E=1000 para estimar numericamente.",
                                  "learningObjective": "Derivar notação Big O precisa para Dijkstra otimizado.",
                                  "commonMistakes": "Incluir E log E erroneamente; subestimar espaço do heap."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Discutir Limitações e Condições de Uso",
                                  "subSteps": [
                                    "Explique requisito: pesos não negativos (senão, Bellman-Ford).",
                                    "Limitações: não lida com negativos; heap pode degradar se muitas decreases.",
                                    "Alternativas: Fibonacci heap para O(E + V log V), mas prático heap binário.",
                                    "Casos ruins: grafos com muitas atualizações de prioridade.",
                                    "Resuma prós/cons em bullet points."
                                  ],
                                  "verification": "Lista de limitações com exemplos e alternativas citadas.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Notas anteriores, tabela de comparação de algoritmos.",
                                  "tips": "Pense em GPS: pesos sempre positivos (distâncias).",
                                  "learningObjective": "Avaliar quando usar Dijkstra e suas restrições.",
                                  "commonMistakes": "Ignorar impacto de pesos negativos; superestimar Fibonacci em prática."
                                }
                              ],
                              "practicalExample": "Em um grafo de rotas urbanas com V=10 interseções e E=25 ruas (pesos em km), execute Dijkstra: 10 extract-min (cada log10≈3 ops), 25 decreases (cada log10), total ~215 ops heap vs. 100 em versão ingênua, provando eficiência para grafos esparsos.",
                              "finalVerifications": [
                                "Derivação correta de O((V+E) log V) com justificativa por operação.",
                                "Cálculo espacial O(V) confirmado com breakdown de estruturas.",
                                "Identificação precisa de limitação: pesos não negativos com contraexemplo.",
                                "Comparação numérica em grafo exemplo bate com teoria.",
                                "Resumo escrito explica trade-offs vs. Prim/Kruskal.",
                                "Tabela de operações completa e sem erros aritméticos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na contagem de ocorrências de extract-min (V) e decrease-key (E).",
                                "Correta aplicação de log V a todas operações heap.",
                                "Análise espacial inclui todas estruturas (dist[], heap, etc.).",
                                "Discussão de limitações cita Bellman-Ford e casos negativos.",
                                "Exemplo prático usa grafo realista com cálculos verificáveis.",
                                "Clareza na derivação assintótica, ignorando constantes."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica Big O e logaritmos.",
                                "Física: Modelagem de redes como grafos em simulações de partículas.",
                                "Economia: Otimização de rotas em logística e supply chain.",
                                "Engenharia de Software: Complexidade em design de algoritmos eficientes."
                              ],
                              "realWorldApplication": "Em apps de navegação como Google Maps, Dijkstra com heap binário calcula rotas mais curtas em tempo real para milhões de nós (cidades/estradas), otimizando tráfego e entregas, poupando combustível e tempo em logística global."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.2",
                    "name": "Algoritmo de Bellman-Ford",
                    "description": "Algoritmo para calcular caminhos mais curtos em grafos com pesos negativos, detectando ciclos negativos.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.2.1",
                        "name": "Princípios Básicos e Inicialização do Bellman-Ford",
                        "description": "Fundamentos do algoritmo de Bellman-Ford baseado em programação dinâmica para encontrar caminhos mais curtos em grafos direcionados com pesos negativos, incluindo a representação do grafo por lista de arestas e inicialização das distâncias.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.1.1",
                            "name": "Representar grafo por lista de arestas",
                            "description": "Construir uma estrutura de dados para representar um grafo direcionado com pesos negativos utilizando uma lista de arestas, onde cada aresta contém origem, destino e peso, preparando para iterações de relaxamento.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os componentes de um grafo direcionado ponderado",
                                  "subSteps": [
                                    "Identifique os vértices (nós) do grafo e atribua IDs numéricos sequenciais.",
                                    "Liste todas as arestas direcionadas, notando origem, destino e peso (incluindo negativos).",
                                    "Revise propriedades: direcionado (setas importam), ponderado (pesos em arestas).",
                                    "Desenhe o grafo manualmente para visualizar conexões e pesos.",
                                    "Confirme ausência de auto-loops ou arestas múltiplas iniciais."
                                  ],
                                  "verification": "Crie um diagrama manual do grafo e liste vértices e arestas em papel ou ferramenta de desenho.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou ferramenta como Draw.io",
                                    "Descrição do grafo de exemplo"
                                  ],
                                  "tips": "Comece com grafos pequenos (3-5 vértices) para evitar confusão.",
                                  "learningObjective": "Entender a representação conceitual de grafos direcionados ponderados com pesos negativos.",
                                  "commonMistakes": [
                                    "Confundir direção das arestas",
                                    "Ignorar pesos negativos",
                                    "Esquecer vértices isolados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir a estrutura de dados para uma aresta",
                                  "subSteps": [
                                    "Crie uma classe Edge com atributos: source (origem), dest (destino), weight (peso).",
                                    "Implemente um método __init__ para inicializar os atributos.",
                                    "Adicione um método __repr__ ou __str__ para exibição clara.",
                                    "Teste a classe criando 2-3 instâncias com pesos positivos e negativos.",
                                    "Valide tipos: inteiros para source/dest, float ou int para weight."
                                  ],
                                  "verification": "Instancie Edges e imprima para confirmar atributos corretos.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (VS Code, Jupyter)",
                                    "Python 3.x"
                                  ],
                                  "tips": "Use dataclass para simplicidade se Python 3.7+: @dataclass class Edge: ...",
                                  "learningObjective": "Modelar uma aresta como objeto reutilizável em Python.",
                                  "commonMistakes": [
                                    "Usar strings em vez de números para IDs",
                                    "Esquecer suporte a pesos negativos (float)",
                                    "Não definir __repr__ levando a saídas confusas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Construir a lista de arestas a partir do grafo",
                                  "subSteps": [
                                    "Colete todas as arestas do grafo em uma lista Python vazia: edges = [].",
                                    "Para cada aresta conhecida, crie uma instância Edge e append à lista.",
                                    "Garanta que a lista inclua todas as arestas, sem duplicatas desnecessárias.",
                                    "Imprima a lista para inspeção visual.",
                                    "Ordene opcionalmente por origem para facilitar depuração."
                                  ],
                                  "verification": "Len(edges) deve igualar o número total de arestas; inspecione itens aleatórios.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo de grafo hardcoded"
                                  ],
                                  "tips": "Hardcode arestas inicialmente; depois leia de input ou arquivo.",
                                  "learningObjective": "Populare uma lista de objetos Edge representando o grafo completo.",
                                  "commonMistakes": [
                                    "Duplicar arestas",
                                    "Inverter origem/destino",
                                    "Omitir arestas com peso zero ou negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Inicializar estruturas auxiliares para Bellman-Ford",
                                  "subSteps": [
                                    "Determine o número de vértices (V) contando IDs únicos ou de input.",
                                    "Crie array dist: [float('inf')] * V, com dist[0] = 0 (fonte).",
                                    "Confirme que lista de arestas está pronta para relaxamento.",
                                    "Teste acessando edges[0].weight para validar.",
                                    "Documente V e len(edges) em comentários."
                                  ],
                                  "verification": "Imprima dist e confirme inf em todos exceto origem; len(edges) correto.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Biblioteca math para inf"
                                  ],
                                  "tips": "Use sys.maxsize como alternativa a float('inf') se preferir inteiros.",
                                  "learningObjective": "Preparar dados para iterações de relaxamento no Bellman-Ford.",
                                  "commonMistakes": [
                                    "Índice errado na origem",
                                    "Usar 0 em todos dist",
                                    "Não importar math/sys"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com 4 vértices (0,1,2,3). Arestas: Edge(0,1,4), Edge(0,2,10), Edge(1,2,-3), Edge(1,3,5), Edge(2,3,2), Edge(3,2,7). Lista: [Edge(0,1,4), Edge(0,2,10), ...]. Inicialize dist = [0, inf, inf, inf].",
                              "finalVerifications": [
                                "Lista de arestas contém exatamente todas as arestas do grafo com origem, destino e pesos corretos.",
                                "Estrutura Edge acessível: edges[i].source, .dest, .weight funcionam.",
                                "Array dist inicializado com 0 na fonte e inf nos demais.",
                                "Número de vértices (V) e arestas (|E|) batem com o grafo.",
                                "Suporte explícito a pesos negativos testado com exemplo.",
                                "Código roda sem erros e imprime representação corretamente."
                              ],
                              "assessmentCriteria": [
                                "Completude: Todas arestas incluídas sem omissões ou duplicatas (30%).",
                                "Correção: Atributos source/dest/weight exatos, incluindo negativos (25%).",
                                "Estrutura: Classe Edge bem definida e usada consistentemente (20%).",
                                "Inicialização: dist array correto para Bellman-Ford (15%).",
                                "Clareza: Código comentado, repr legível e testes básicos (10%)."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de grafos e matrizes de adjacência vs. listas.",
                                "Programação Orientada a Objetos: Definição de classes e encapsulamento.",
                                "Análise de Algoritmos: Complexidade O(VE) do Bellman-Ford.",
                                "Ciência de Dados: Representações de redes em bibliotecas como NetworkX."
                              ],
                              "realWorldApplication": "Em sistemas de roteamento de rede (ex: OSPF com custos variáveis), finanças para detectar arbitragem em ciclos negativos de moedas, ou otimização de logística com penalidades (pesos negativos por restrições)."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.2",
                            "name": "Inicializar vetor de distâncias",
                            "description": "Inicializar um vetor de distâncias com infinito para todos os vértices exceto a fonte (distância 0), e preparar um vetor de predecessores para reconstruir caminhos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os conceitos de vetores de distâncias e predecessores",
                                  "subSteps": [
                                    "Identifique o grafo direcionado com pesos e selecione a fonte (vértice inicial).",
                                    "Defina o valor de infinito (INF) como um número grande, como 999999 ou float('inf') em Python.",
                                    "Explique o propósito: vetor de distâncias armazena o menor caminho da fonte; vetor de predecessores rastreia o caminho.",
                                    "Liste todos os vértices do grafo para dimensionar os vetores.",
                                    "Esboce um exemplo simples no papel com 4 vértices."
                                  ],
                                  "verification": "Resuma verbalmente ou por escrito os papéis dos dois vetores e o valor de INF usado.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Diagrama do grafo de exemplo"
                                  ],
                                  "tips": "Sempre use o mesmo índice para vértices (ex: A=0, B=1) para evitar confusões.",
                                  "learningObjective": "Entender o papel fundamental dos vetores na inicialização do Bellman-Ford.",
                                  "commonMistakes": [
                                    "Confundir distâncias com predecessores",
                                    "Escolher INF muito pequeno que cause overflow"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Criar e inicializar o vetor de distâncias",
                                  "subSteps": [
                                    "Crie um array do tamanho do número de vértices (n).",
                                    "Defina dist[fonte] = 0.",
                                    "Para todos os outros vértices i ≠ fonte, defina dist[i] = INF.",
                                    "Imprima ou visualize o vetor para confirmação.",
                                    "Teste com um grafo pequeno (3-5 vértices)."
                                  ],
                                  "verification": "Execute código e verifique se dist[fonte] == 0 e outros == INF.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (Python, C++ ou Java)",
                                    "Grafo de exemplo"
                                  ],
                                  "tips": "Em Python, use list comprehension: dist = [float('inf')] * n; dist[fonte] = 0.",
                                  "learningObjective": "Implementar corretamente o vetor de distâncias com exceção da fonte.",
                                  "commonMistakes": [
                                    "Inicializar todos como 0",
                                    "Índices errados para vértices"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Criar e inicializar o vetor de predecessores",
                                  "subSteps": [
                                    "Crie um array pred do tamanho n, inicializado com -1 ou None.",
                                    "Não altere nada ainda; todos os predecessores são desconhecidos inicialmente.",
                                    "Associe pred[i] ao vértice que leva ao menor caminho para i (será atualizado depois).",
                                    "Imprima o vetor pred para visualização.",
                                    "Integre com o vetor dist no mesmo código."
                                  ],
                                  "verification": "Confirme que todos os elementos de pred são -1 ou None.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Código do passo anterior"
                                  ],
                                  "tips": "Use -1 como sentinel para indicar 'sem predecessor' em linguagens como C++.",
                                  "learningObjective": "Preparar estrutura para rastreamento de caminhos no algoritmo.",
                                  "commonMistakes": [
                                    "Inicializar pred com 0 ou valores aleatórios",
                                    "Tamanho errado do array"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e testar a inicialização completa",
                                  "subSteps": [
                                    "Execute o código com um grafo de teste completo.",
                                    "Verifique manualmente os valores dos vetores.",
                                    "Adicione asserts ou prints para automação de checagem.",
                                    "Simule uma iteração do Bellman-Ford para ver se inicialização está correta.",
                                    "Documente o código com comentários."
                                  ],
                                  "verification": "Todos asserts passam e vetores atendem aos critérios iniciais.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código completo dos passos anteriores",
                                    "Grafo de teste"
                                  ],
                                  "tips": "Sempre teste com fonte em posição não-zero para evitar viés.",
                                  "learningObjective": "Garantir robustez da inicialização antes de prosseguir no algoritmo.",
                                  "commonMistakes": [
                                    "Esquecer de testar com múltiplas fontes",
                                    "Não tratar grafos desconexos"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo com vértices 0(A),1(B),2(C),3(D); fonte=0. Após inicialização: dist = [0, ∞, ∞, ∞]; pred = [-1, -1, -1, -1]. Em Python: n=4; fonte=0; INF=float('inf'); dist=[INF]*n; dist[fonte]=0; pred=[-1]*n.",
                              "finalVerifications": [
                                "dist[fonte] é exatamente 0.",
                                "Todos dist[i] para i≠fonte são iguais a INF.",
                                "Vetor pred tem tamanho n e todos elementos são -1 ou None.",
                                "Código roda sem erros para grafos de 3-10 vértices.",
                                "Visualização ou print confirma estrutura correta.",
                                "Não há overflows ou valores inválidos em INF."
                              ],
                              "assessmentCriteria": [
                                "Correta definição e uso de INF (sem overflow).",
                                "Inicialização precisa do dist[fonte]=0 e demais=INF.",
                                "Vetor pred totalmente inicializado com sentinel.",
                                "Código limpo, comentado e testável.",
                                "Compreensão demonstrada via explicação ou teste.",
                                "Eficiência: O(1) tempo para inicialização."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Vetores e representação matricial de grafos.",
                                "Programação: Manipulação de arrays e estruturas de dados lineares.",
                                "Engenharia de Software: Inicialização de estados em algoritmos iterativos.",
                                "Redes de Computadores: Fundamento para protocolos de roteamento."
                              ],
                              "realWorldApplication": "Em roteamento de redes (ex: protocolo RIP usa Bellman-Ford), GPS para distâncias mais curtas em mapas, e otimização de custos em logística de entregas."
                            },
                            "estimatedTime": "0.5 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.2.1.3",
                            "name": "Explicar base em programação dinâmica",
                            "description": "Descrever como o Bellman-Ford utiliza o princípio de otimalidade da programação dinâmica, relaxando arestas |V|-1 vezes para garantir distâncias mínimas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Conceito Básico de Programação Dinâmica e Princípio de Otimalidade",
                                  "subSteps": [
                                    "Defina Programação Dinâmica (DP) como uma técnica para resolver problemas complexos dividindo-os em subproblemas sobrepostos.",
                                    "Explique o Princípio de Otimalidade de Bellman: uma solução ótima para o problema contém soluções ótimas para subproblemas.",
                                    "Dê exemplos simples, como a soma máxima em uma sequência ou o problema da mochila.",
                                    "Relacione DP com problemas de otimização em grafos, focando em caminhos mais curtos.",
                                    "Anote a equação geral de recorrência em DP: dp[i] = min/max sobre opções de subproblemas."
                                  ],
                                  "verification": "Escreva uma definição clara do princípio de otimalidade e um exemplo não-grafo em um papel.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Notebook com definições de DP"
                                  ],
                                  "tips": "Use analogias cotidianas, como planejar uma viagem dividindo em etapas ótimas.",
                                  "learningObjective": "Entender os fundamentos teóricos da DP e seu princípio chave.",
                                  "commonMistakes": [
                                    "Confundir DP com recursão simples",
                                    "Ignorar a sobreposição de subproblemas"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Aplicar o Princípio de Otimalidade ao Problema de Caminhos Mais Curtos em Grafos",
                                  "subSteps": [
                                    "Descreva o problema de caminhos mais curtos: encontrar a distância mínima de uma fonte s a todos os vértices.",
                                    "Explique que um caminho ótimo de s a v pode ser decomposto em um prefixo ótimo até u e a aresta (u,v).",
                                    "Formalize: dist[v] = min(dist[u] + w(u,v)) para todas as arestas (u,v).",
                                    "Discuta como isso satisfaz o princípio de otimalidade: subcaminhos são ótimos.",
                                    "Desenhe um grafo simples com 3 vértices para ilustrar."
                                  ],
                                  "verification": "Desenhe um grafo e rotule manualmente os caminhos ótimos parciais.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Exemplo de grafo impresso ou digital"
                                  ],
                                  "tips": "Sempre verifique se subcaminhos mantêm otimalidade ao adicionar arestas.",
                                  "learningObjective": "Conectar o princípio de DP especificamente ao problema de shortest paths.",
                                  "commonMistakes": [
                                    "Assumir que todos os caminhos são diretos",
                                    "Esquecer detecção de ciclos negativos"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explicar a Implementação via Relaxações no Algoritmo Bellman-Ford",
                                  "subSteps": [
                                    "Inicialize dist[s] = 0 e dist[outros] = infinito.",
                                    "Descreva uma relaxação: para cada aresta (u,v), se dist[v] > dist[u] + w(u,v), atualize dist[v].",
                                    "Explique que uma iteração relaxa todas as arestas uma vez, construindo soluções para caminhos de tamanho 1,2,...",
                                    "Mostre como após k iterações, dist[v] é o menor caminho com no máximo k arestas.",
                                    "Relacione à DP: cada iteração resolve subproblemas de tamanho crescente."
                                  ],
                                  "verification": "Simule 2 iterações em um grafo pequeno e compare distâncias.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Pseudocódigo do Bellman-Ford",
                                    "Calculadora ou spreadsheet para simulações"
                                  ],
                                  "tips": "Pense nas relaxações como 'propagação' de distâncias mínimas iterativamente.",
                                  "learningObjective": "Dominar como Bellman-Ford operacionaliza a DP via relaxações.",
                                  "commonMistakes": [
                                    "Relaxar arestas em ordem errada",
                                    "Parar antes de |V|-1 iterações"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Justificar o Número de |V|-1 Iterações e Garantia de Otimalidade",
                                  "subSteps": [
                                    "Argumente que em um grafo sem ciclos negativos, o caminho mais curto tem no máximo |V|-1 arestas.",
                                    "Explique que após |V|-1 relaxações, todas as distâncias mínimas são garantidas (pelo princípio de indução).",
                                    "Discuta a iteração extra para detectar ciclos negativos alcançáveis.",
                                    "Formalize a prova: base (0 arestas), passo indutivo (adicionar uma aresta mantém otimalidade).",
                                    "Resuma: Bellman-Ford é DP bottom-up para shortest paths."
                                  ],
                                  "verification": "Escreva uma prova curta por indução para um grafo com n vértices.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Folha para prova matemática",
                                    "Referência teórica de grafos"
                                  ],
                                  "tips": "Use indução: assuma para k arestas, prove para k+1.",
                                  "learningObjective": "Compreender a convergência e corretude teórica do algoritmo.",
                                  "commonMistakes": [
                                    "Confundir |V|-1 com |E|",
                                    "Ignorar ciclos negativos na justificativa"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo com V={A,B,C}, arestas: A->B(2), A->C(5), B->C(1). Inicial: dist[A]=0, B=inf, C=inf. Iteração 1: relaxa A-B → dist[B]=2; A-C → dist[C]=5. Iteração 2: B-C → dist[C]=min(5,2+1)=3. Após 2=|V|-1 iterações, distâncias ótimas: A=0, B=2, C=3. Cada relaxação usa sub-otimalidades anteriores.",
                              "finalVerifications": [
                                "Defina corretamente o princípio de otimalidade e dê um exemplo.",
                                "Explique por que Bellman-Ford relaxa |V|-1 vezes.",
                                "Simule relaxações em um grafo de 4 vértices sem erros.",
                                "Justifique a corretude por indução.",
                                "Diferencie DP em Bellman-Ford de Dijkstra.",
                                "Identifique quando uma iteração extra é necessária."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição de DP e princípio de otimalidade (30%)",
                                "Correta aplicação a shortest paths e relaxações (25%)",
                                "Justificativa clara de |V|-1 iterações com prova (20%)",
                                "Uso de exemplo prático sem erros (15%)",
                                "Conexão explícita entre teoria DP e algoritmo (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Indução matemática e otimização discreta.",
                                "Economia: Modelagem de custos marginais em redes de suprimentos.",
                                "Física: Propagação de ondas ou caminhos mínimos em redes.",
                                "Engenharia de Software: Design de algoritmos iterativos bottom-up."
                              ],
                              "realWorldApplication": "No roteamento de pacotes em redes de computadores (ex: protocolos como RIP), cálculo de rotas GPS em mapas com tráfego variable, ou otimização de custos em logística com restrições de capacidade, onde relaxações iterativas garantem caminhos mínimos mesmo com pesos negativos simulando penalidades."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.2",
                        "name": "Relaxamento de Arestas",
                        "description": "Mecanismo central do algoritmo: iterativamente relaxar todas as arestas do grafo para atualizar distâncias mais curtas.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.2.1",
                            "name": "Implementar operação de relaxamento",
                            "description": "Para uma aresta (u, v) com peso w, verificar se dist[v] > dist[u] + w e atualizar dist[v] e predecessor de v se verdadeiro.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Preparar estruturas de dados para distâncias e predecessores",
                                  "subSteps": [
                                    "Crie um array ou dicionário dist para armazenar as distâncias mínimas conhecidas de cada nó à fonte.",
                                    "Inicialize dist[source] = 0 e dist[outros] = infinito (ex: float('inf') em Python).",
                                    "Crie um array ou dicionário pred para rastrear o predecessor de cada nó.",
                                    "Inicialize pred com None ou -1 para todos os nós.",
                                    "Garanta que u e v sejam índices válidos no grafo."
                                  ],
                                  "verification": "Verifique se dist e pred estão inicializados corretamente imprimindo-os antes da operação.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código (ex: VS Code, Jupyter Notebook)",
                                    "Linguagem de programação (Python ou pseudocódigo)"
                                  ],
                                  "tips": "Use um valor grande como 10^9 para infinito em vez de float('inf') se trabalhar com inteiros.",
                                  "learningObjective": "Compreender e implementar as estruturas essenciais para o relaxamento no Bellman-Ford.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar dist[source] como 0",
                                    "Não tratar infinito corretamente",
                                    "Índices fora do range dos nós"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e validar a aresta de entrada",
                                  "subSteps": [
                                    "Defina a aresta como uma tupla ou estrutura (u, v, w), onde u é origem, v é destino e w é peso.",
                                    "Valide que u e v são nós válidos no grafo.",
                                    "Confirme que w é um número finito e não negativo (ou negativo se permitir ciclos negativos).",
                                    "Armazene temporariamente o valor candidato: candidate = dist[u] + w.",
                                    "Verifique se dist[u] é infinito; se sim, pule o relaxamento."
                                  ],
                                  "verification": "Imprima a aresta e o candidate para confirmar valores corretos.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Exemplo de grafo simples"
                                  ],
                                  "tips": "Sempre valide entradas para evitar erros de runtime em grafos grandes.",
                                  "learningObjective": "Saber representar e validar arestas para relaxamento seguro.",
                                  "commonMistakes": [
                                    "Não checar se dist[u] é infinito",
                                    "Confundir u e v na tupla da aresta",
                                    "Ignorar pesos negativos sem verificação"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar a verificação da condição de relaxamento",
                                  "subSteps": [
                                    "Escreva a condição if dist[v] > dist[u] + w.",
                                    "Use operadores de comparação numérica adequados (>, == para floats com cuidado).",
                                    "Se verdadeiro, prossiga para atualização; caso contrário, não altere nada.",
                                    "Registre logs ou flags para depuração da condição.",
                                    "Teste a condição com valores conhecidos (ex: dist[v]=10, dist[u]+w=8)."
                                  ],
                                  "verification": "Execute com dados de teste e confirme se a condição ativa/desativa corretamente via prints.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Casos de teste pré-definidos"
                                  ],
                                  "tips": "Para floats, use uma tolerância epsilon em comparações para precisão.",
                                  "learningObjective": "Dominar a lógica condicional central do relaxamento de Bellman-Ford.",
                                  "commonMistakes": [
                                    "Usar >= em vez de >",
                                    "Esquecer parênteses em dist[u] + w",
                                    "Comparar strings em vez de números"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Executar atualização e testar a operação completa",
                                  "subSteps": [
                                    "Se condição verdadeira, defina dist[v] = dist[u] + w.",
                                    "Atualize pred[v] = u.",
                                    "Retorne True se houve relaxamento, False caso contrário (útil para detecção de ciclos).",
                                    "Integre em uma função relax(u, v, w, dist, pred).",
                                    "Teste com grafo exemplo: nó 0->1 peso 3, dist[0]=0, dist[1]=inf -> atualiza para 3."
                                  ],
                                  "verification": "Rode a função e verifique se dist[v] e pred[v] mudaram corretamente após chamada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de código",
                                    "Grafo de teste com 3-5 nós"
                                  ],
                                  "tips": "Sempre retorne um booleano indicando mudança para uso em loops do Bellman-Ford.",
                                  "learningObjective": "Implementar e verificar a atualização atômica de relaxamento.",
                                  "commonMistakes": [
                                    "Atualizar sem checar condição",
                                    "Não atualizar pred[v]",
                                    "Sobrescrever dist[u] por engano"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo com nós 0,1,2; aresta (0,1,4); dist inicial: dist[0]=0, dist[1]=inf; Após relax(0,1,4): dist[1]=4, pred[1]=0. Chame novamente com (1,2,3): se dist[2]>7, atualiza dist[2]=7, pred[2]=1.",
                              "finalVerifications": [
                                "dist[v] é atualizado apenas se dist[u] + w < dist[v] original.",
                                "pred[v] aponta corretamente para u após atualização.",
                                "Função retorna True se houve mudança, False caso contrário.",
                                "Não há overflow ou perda de precisão em pesos grandes.",
                                "Funciona com dist[u] = inf (não atualiza).",
                                "Preserva valores quando condição falsa."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Condição e atualizações exatas conforme algoritmo.",
                                "Eficiência: O(1) tempo por relaxamento.",
                                "Robustez: Trata inf, negativos e validações.",
                                "Clareza: Código legível com comentários.",
                                "Testabilidade: Inclui casos de borda (inf, igualdade).",
                                "Modularidade: Função isolada e reutilizável."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Desigualdade triangular e otimização linear.",
                                "Programação: Estruturas condicionais, arrays/dicionários e funções.",
                                "Ciência da Computação: Análise de complexidade em grafos.",
                                "Engenharia: Otimização de caminhos em redes.",
                                "Lógica: Raciocínio condicional e depuração."
                              ],
                              "realWorldApplication": "No roteamento de pacotes em redes (ex: OSPF usa variantes), GPS para trajetos mais curtos considerando tráfego (pesos dinâmicos), ou logística para minimizar custos de entrega em grafos de transportes."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.2",
                            "name": "Executar loop de relaxamento |V|-1 vezes",
                            "description": "Implementar o loop principal que relaxa todas as arestas |V|-1 vezes, onde |V| é o número de vértices, garantindo convergência em grafos sem ciclos negativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Determinar o número de vértices |V| e preparar estruturas de dados",
                                  "subSteps": [
                                    "Identifique o número total de vértices no grafo (|V|).",
                                    "Verifique se o grafo está representado adequadamente (lista de arestas ou matriz de adjacência).",
                                    "Confirme que as distâncias iniciais (dist[]) estão inicializadas (ex: infinito exceto origem = 0).",
                                    "Prepare uma lista ou array com todas as arestas do grafo (u, v, w)."
                                  ],
                                  "verification": "Confirme que |V| está correto contando vértices e dist[] tem tamanho |V| com valores iniciais adequados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Representação do grafo (JSON ou lista)",
                                    "Editor de código ou papel para esboço"
                                  ],
                                  "tips": "Sempre use 1-based ou 0-based indexing consistentemente para vértices.",
                                  "learningObjective": "Compreender a importância de |V| para garantir convergência do algoritmo.",
                                  "commonMistakes": [
                                    "Confundir |V| com número de arestas |E|",
                                    "Inicializar dist[] incorretamente (ex: todos zero)"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Configurar o loop externo para |V|-1 iterações",
                                  "subSteps": [
                                    "Inicie um contador de iterações i = 1.",
                                    "Implemente a condição de loop: enquanto i <= |V|-1 ou for i de 1 a |V|-1.",
                                    "Defina o escopo interno para relaxamento de arestas.",
                                    "Prepare logging opcional para rastrear iterações."
                                  ],
                                  "verification": "Execute o loop vazio e confirme que roda exatamente |V|-1 vezes via contador ou logs.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Editor de código (Python, C++, etc.)",
                                    "Exemplo de grafo pequeno"
                                  ],
                                  "tips": "Use 'range(1, V)' em Python para precisão no número de iterações.",
                                  "learningObjective": "Implementar corretamente o loop principal que garante relaxamento suficiente.",
                                  "commonMistakes": [
                                    "Rodar |V| vezes em vez de |V|-1",
                                    "Usar loop while sem condição de parada clara"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar relaxamento de todas as arestas dentro de cada iteração",
                                  "subSteps": [
                                    "Para cada aresta (u, v, w) no grafo:",
                                    "Verifique se dist[v] > dist[u] + w.",
                                    "Se verdadeiro, atualize dist[v] = dist[u] + w.",
                                    "Opcionalmente, marque que houve relaxamento para debug.",
                                    "Prossiga para próxima aresta."
                                  ],
                                  "verification": "Após uma iteração, compare dist[] antes/depois e confirme atualizações onde aplicável.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Código do grafo com arestas",
                                    "Debugger ou prints para dist[]"
                                  ],
                                  "tips": "Evite atualizar dist[] em paralelo; use cópia se necessário para evitar propagação imediata.",
                                  "learningObjective": "Dominar a operação de relaxamento e sua repetição para propagar distâncias mínimas.",
                                  "commonMistakes": [
                                    "Esquecer de iterar TODAS as arestas",
                                    "Usar > em vez de >= na condição de relaxamento"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Finalizar o loop e validar execução",
                                  "subSteps": [
                                    "Incremente o contador i após cada iteração completa.",
                                    "Saia do loop quando i > |V|-1.",
                                    "Registre as distâncias finais.",
                                    "Confirme ausência de erros ou loops infinitos."
                                  ],
                                  "verification": "Verifique logs ou contador: total de iterações == |V|-1 e dist[] estabilizadas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Código completo do loop",
                                    "Teste com grafo conhecido"
                                  ],
                                  "tips": "Adicione prints por iteração para visualizar convergência gradual.",
                                  "learningObjective": "Garantir terminação correta do algoritmo após relaxamentos suficientes.",
                                  "commonMistakes": [
                                    "Não incrementar contador corretamente",
                                    "Ignorar off-by-one errors em |V|-1"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo com |V|=4 vértices (A=0, B=1, C=2, D=3), arestas: (0,1,4), (0,2,2), (1,3,3), (2,3,1). Inicial: dist=[0,inf,inf,inf]. Após 1ª iteração: [0,4,2,inf] -> 2ª: [0,4,2,3] -> 3ª: [0,4,2,3] (estável). Pseudocódigo: for i in 1 to 3: for each edge: if dist[v] > dist[u]+w: dist[v]=dist[u]+w",
                              "finalVerifications": [
                                "O loop executou exatamente |V|-1 iterações.",
                                "Todas as arestas foram processadas em cada iteração.",
                                "Distâncias finais são não-crescentes e convergiram.",
                                "Não há atualizações desnecessárias após estabilização.",
                                "Código roda sem erros para grafos válidos.",
                                "Teste com grafo de 3 vértices confirma 2 iterações."
                              ],
                              "assessmentCriteria": [
                                "Precisão no número de iterações (|V|-1).",
                                "Correta implementação da condição de relaxamento.",
                                "Eficiência: O(|V| * |E|) complexidade.",
                                "Robustez contra grafos com caminhos longos.",
                                "Clareza do código com comentários.",
                                "Validação com exemplos conhecidos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e desigualdades triangulares.",
                                "Programação: Loops aninhados e estruturas de dados (listas de arestas).",
                                "Otimização: Algoritmos de caminho mínimo e convergência.",
                                "Ciência da Computação: Análise de complexidade temporal."
                              ],
                              "realWorldApplication": "No protocolo de roteamento RIP (Routing Information Protocol), usado para calcular distâncias mínimas em redes IP, relaxando rotas |V|-1 vezes para convergência em redes sem loops negativos, otimizando tráfego em internetworks."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.2.2.3",
                            "name": "Reconstruir caminho mais curto",
                            "description": "Usar o vetor de predecessores para reconstruir e exibir o caminho mais curto da fonte a um vértice destino após as iterações.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e preparar o vetor de predecessores",
                                  "subSteps": [
                                    "Revise o algoritmo Bellman-Ford e identifique como o vetor de predecessores (pred[]) é preenchido durante as relaxações de arestas.",
                                    "Verifique se o algoritmo completou todas as iterações sem detecção de ciclo negativo.",
                                    "Liste os vértices do grafo, a fonte (s) e o destino (t), e examine os valores no vetor pred[] para cada vértice.",
                                    "Confirme que pred[s] = null ou -1, indicando a origem.",
                                    "Anote distâncias finais (dist[]) para validação posterior."
                                  ],
                                  "verification": "O vetor pred[] está completo e pred[s] indica a fonte corretamente.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Pseudocódigo do Bellman-Ford",
                                    "Exemplo de grafo com dist[] e pred[] preenchidos"
                                  ],
                                  "tips": "Sempre comece pela inspeção visual dos arrays para entender o estado final.",
                                  "learningObjective": "Entender o papel do vetor de predecessores na rastreabilidade do caminho ótimo.",
                                  "commonMistakes": [
                                    "Ignorar ciclos negativos que invalidam os predecessores",
                                    "Confundir pred[] com dist[]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar a lista do caminho no vértice destino",
                                  "subSteps": [
                                    "Crie uma lista vazia (path) para armazenar os vértices do caminho.",
                                    "Adicione o vértice destino (t) ao final da lista.",
                                    "Defina uma variável current = t para rastrear o vértice atual.",
                                    "Verifique se t é alcançável (dist[t] != infinito).",
                                    "Registre o comprimento inicial da lista (deve ser 1)."
                                  ],
                                  "verification": "Lista path contém apenas o destino e current aponta para t.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Estrutura de lista ou array em pseudocódigo",
                                    "Valores de dist[] e pred[] do exemplo"
                                  ],
                                  "tips": "Use uma lista reversível como deque ou array para facilitar a inserção no início depois.",
                                  "learningObjective": "Configurar o ponto de partida para a reconstrução backward.",
                                  "commonMistakes": [
                                    "Adicionar destino no início em vez do final",
                                    "Prosseguir se dist[t] for infinito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Reconstruir o caminho seguindo os predecessores até a fonte",
                                  "subSteps": [
                                    "Inicie um loop: enquanto current != s e pred[current] != null.",
                                    "Adicione pred[current] à lista path (no final, pois estamos indo para trás).",
                                    "Atualize current = pred[current].",
                                    "Saia do loop quando current == s ou null.",
                                    "Adicione a fonte s à lista se ainda não estiver presente."
                                  ],
                                  "verification": "A lista path contém todos os vértices do caminho da fonte ao destino em ordem reversa.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo do loop de reconstrução",
                                    "Grafo desenhado com setas de predecessores"
                                  ],
                                  "tips": "Implemente o loop com condição de parada clara para evitar loops infinitos.",
                                  "learningObjective": "Aplicar rastreamento backward para formar a sequência de vértices.",
                                  "commonMistakes": [
                                    "Loop infinito por pred[s] não tratado",
                                    "Inserir predecessores no lugar errado"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Reverter a lista e exibir o caminho mais curto",
                                  "subSteps": [
                                    "Reverta a ordem da lista path para obter o caminho da fonte ao destino.",
                                    "Calcule a soma das distâncias ao longo do caminho e compare com dist[t].",
                                    "Exiba o caminho como sequência de vértices (ex: s -> v1 -> v2 -> t).",
                                    "Inclua o custo total do caminho.",
                                    "Teste com um vértice intermediário para validar."
                                  ],
                                  "verification": "Caminho exibido está na ordem correta e soma das arestas == dist[t].",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Função de reversão em pseudocódigo",
                                    "Ferramenta de visualização de grafos como Graphviz"
                                  ],
                                  "tips": "Use funções built-in de reverse em linguagens como Python para simplicidade.",
                                  "learningObjective": "Finalizar e validar a apresentação do caminho ótimo.",
                                  "commonMistakes": [
                                    "Esquecer de reverter, exibindo caminho invertido",
                                    "Erro na soma de custos"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo com vértices A(s), B, C, D(t). Arestas: A->B(4), A->C(2), B->D(5), C->D(8), C->B(1). Após Bellman-Ford: dist[D]=6, pred[D]=B, pred[B]=C, pred[C]=A. Reconstrução: Inicie em D, pred[D]=B → path=[D,B], pred[B]=C → [D,B,C], pred[C]=A → [D,B,C,A]. Reverta: A->C->B->D (custo 2+1+5=8? Espera, otimizado é A->C->B->D custo 2+1+5=8, mas exemplo ajustado para 6? Corrija: assuma dist[D]=6 via A->B->D? Exemplo padrão: path final A -> B -> D.",
                              "finalVerifications": [
                                "O caminho inicia na fonte e termina no destino.",
                                "Todos os vértices no caminho têm pred apontando corretamente.",
                                "Soma dos pesos das arestas consecutivas equals dist[destino].",
                                "Nenhum ciclo negativo detectado previamente.",
                                "Caminho funciona para múltiplos destinos.",
                                "Lista não contém vértices extras ou faltantes."
                              ],
                              "assessmentCriteria": [
                                "Correção: Caminho reconstruído é ótimo e válido.",
                                "Eficiência: Tempo O(V) no pior caso.",
                                "Clareza: Exibição legível com custos.",
                                "Robustez: Trata casos de destino não alcançável.",
                                "Validação: Verificação automática de soma de distâncias.",
                                "Implementação limpa sem bugs comuns."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Programação Linear.",
                                "Programação: Manipulação de arrays e loops iterativos.",
                                "Engenharia de Software: Algoritmos de roteamento em redes.",
                                "Ciências da Computação: Otimização e Estruturas de Dados.",
                                "Matemática Aplicada: Problemas de caminho mínimo em logística."
                              ],
                              "realWorldApplication": "Em aplicativos de GPS como Waze ou Google Maps para reconstruir rotas mais curtas após relaxações de tráfego; em roteamento de pacotes em redes de computadores (ex: OSPF com Bellman-Ford modificado); otimização de supply chain em logística para entregas eficientes."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.2.3",
                        "name": "Detecção de Ciclos Negativos e Análise",
                        "description": "Verificação final para ciclos negativos e análise de complexidade do algoritmo.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.2.3.1",
                            "name": "Detectar ciclo negativo",
                            "description": "Após |V|-1 iterações, realizar uma iteração adicional de relaxamento; se alguma distância for atualizada, existe um ciclo negativo alcançável da fonte.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o Princípio Teórico da Detecção de Ciclos Negativos",
                                  "subSteps": [
                                    "Revise o algoritmo Bellman-Ford: relaxamento de todas as arestas |V|-1 vezes para encontrar caminhos mais curtos em grafos com pesos negativos.",
                                    "Entenda que |V|-1 iterações são suficientes sem ciclos negativos, pois o caminho mais curto tem no máximo |V|-1 arestas.",
                                    "Aprenda que um ciclo negativo alcançável permite atualizações infinitas; a iteração |V| detecta isso se alguma distância diminuir.",
                                    "Estude o conceito de 'alcançável da fonte': o ciclo deve ser acessível a partir do vértice fonte.",
                                    "Visualize com um diagrama: desenhe um grafo simples com e sem ciclo negativo."
                                  ],
                                  "verification": "Explique em 3 frases por que a iteração extra detecta ciclos negativos alcançáveis.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Notas do Bellman-Ford",
                                    "Papel e lápis para diagramas de grafos",
                                    "Exemplo de grafo padrão"
                                  ],
                                  "tips": "Lembre-se: ciclos não alcançáveis da fonte não afetam as distâncias da fonte.",
                                  "learningObjective": "Dominar a teoria por trás da detecção de ciclos negativos no Bellman-Ford.",
                                  "commonMistakes": [
                                    "Confundir ciclos negativos com pesos negativos simples",
                                    "Ignorar a condição 'alcançável da fonte'",
                                    "Achar que |V| iterações sempre detectam ciclos"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Executar as |V|-1 Iterações Iniciais de Relaxamento",
                                  "subSteps": [
                                    "Inicialize array de distâncias: dist[fonte] = 0, dist[outros] = infinito.",
                                    "Para cada iteração de 1 até |V|-1: percorra todas as arestas e relaxe (se dist[v] > dist[u] + w, atualize dist[v]).",
                                    "Registre as distâncias após cada iteração em uma tabela para observar estabilização.",
                                    "Verifique se as distâncias não mudam nas últimas iterações (indicando ausência de ciclo).",
                                    "Teste com um grafo sem ciclo negativo para validar."
                                  ],
                                  "verification": "Confirme que distâncias estabilizam após |V|-1 iterações em um grafo sem ciclo.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Grafo exemplo impresso ou digital",
                                    "Planilha ou papel para tabela de distâncias",
                                    "Calculadora"
                                  ],
                                  "tips": "Use pseudocódigo para guiar: for i in 1 to |V|-1: for each edge (u,v,w): relax.",
                                  "learningObjective": "Executar corretamente as iterações padrão do Bellman-Ford.",
                                  "commonMistakes": [
                                    "Errar a inicialização de infinito",
                                    "Relaxar arestas na ordem errada (não importa, mas rastreie todas)",
                                    "Parar cedo se distâncias estabilizarem"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Realizar a Iteração Adicional e Detectar Atualizações",
                                  "subSteps": [
                                    "Após |V|-1 iterações, execute uma iteração extra de relaxamento em todas as arestas.",
                                    "Monitore cada relaxamento: marque arestas onde dist[v] foi atualizada (dist[v] > dist[u] + w).",
                                    "Se nenhuma atualização, conclua ausência de ciclo negativo alcançável.",
                                    "Se houver atualização, identifique o vértice v atualizado como parte de um ciclo negativo.",
                                    "Repita o teste em um grafo com ciclo negativo conhecido."
                                  ],
                                  "verification": "Identifique pelo menos uma aresta que causa atualização na iteração extra.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo grafo do passo anterior com ciclo negativo adicionado",
                                    "Tabela de distâncias estendida"
                                  ],
                                  "tips": "Implemente uma flag 'updated = false'; set true se qualquer relaxamento ocorrer.",
                                  "learningObjective": "Implementar e interpretar a iteração de detecção de ciclos.",
                                  "commonMistakes": [
                                    "Executar menos de |V| iterações",
                                    "Não checar todas as arestas na iteração extra",
                                    "Confundir atualização com estabilização"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar Resultados e Confirmar Presença de Ciclo Negativo",
                                  "subSteps": [
                                    "Se atualização ocorreu, trace o caminho: do vértice atualizado, siga predecessores até encontrar o ciclo.",
                                    "Calcule o peso do ciclo: some pesos das arestas no ciclo para confirmar negativo.",
                                    "Discuta implicações: problema de caminhos mais curtos não tem solução finita.",
                                    "Compare com grafo sem ciclo: valide ausência de atualizações.",
                                    "Documente o processo em um relatório curto."
                                  ],
                                  "verification": "Descreva o ciclo negativo encontrado ou confirme ausência corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Grafo com predecessores marcados",
                                    "Ferramenta de desenho de grafos (opcional)"
                                  ],
                                  "tips": "Para encontrar o ciclo: do v atualizado, volte via predecessores até repetir vértice.",
                                  "learningObjective": "Analisar e validar a detecção de ciclos negativos no contexto prático.",
                                  "commonMistakes": [
                                    "Não distinguir ciclos não alcançáveis",
                                    "Erro no cálculo de peso do ciclo",
                                    "Assumir ciclo sem verificação de alcançabilidade"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere o grafo com V={A(sFonte),B,C}, arestas: A->B:4, A->C:5, B->C:-2, C->B:1 (ciclo B-C peso -1 negativo). Após 2 iterações (|V|-1=2): dist[A]=0, dist[B]=4, dist[C]=2. Iteração 3: relaxa C->B: dist[B] > dist[C]+1? 4 > 2+1 sim, atualiza dist[B]=3. Atualização detectada → ciclo negativo alcançável.",
                              "finalVerifications": [
                                "Executa todas as iterações corretamente em um grafo dado.",
                                "Detecta corretamente presença/ausência de ciclo negativo.",
                                "Identifica vértice ou aresta responsável pela atualização.",
                                "Explica por que o ciclo é alcançável da fonte.",
                                "Calcula peso do ciclo negativo corretamente.",
                                "Valida com grafo sem ciclo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas relaxações de arestas (100% corretas).",
                                "Correta contagem e execução de |V|-1 +1 iterações.",
                                "Interpretação precisa de atualizações na iteração extra.",
                                "Rastreamento correto de predecessores para ciclo.",
                                "Explicação clara da teoria e implicações.",
                                "Eficiência no tempo estimado sem erros."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Otimização Linear Inteira.",
                                "Programação: Implementação de Algoritmos em Python/Java com listas de arestas.",
                                "Economia: Detecção de arbitragem em grafos de câmbio (pesos negativos como lucros).",
                                "Redes: Análise de protocolos de roteamento com custos variáveis."
                              ],
                              "realWorldApplication": "Em finanças, detecta oportunidades de arbitragem cambial (ciclos negativos em grafos de taxas de câmbio); em redes, identifica configurações inválidas com loops de custo negativo que causariam roteamento infinito."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.2",
                            "name": "Analisar complexidade temporal e espacial",
                            "description": "Calcular e explicar a complexidade O(|V| * |E|) temporal e O(|V|) espacial, comparando com Dijkstra para grafos sem pesos negativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar a estrutura do Algoritmo de Bellman-Ford",
                                  "subSteps": [
                                    "Escreva o pseudocódigo completo do Bellman-Ford, destacando o loop principal de |V|-1 iterações e a relaxação de todas as arestas em cada iteração.",
                                    "Identifique as variáveis principais: dist[] (array de distâncias), |V| (número de vértices) e |E| (número de arestas).",
                                    "Explique verbalmente o propósito de cada parte do algoritmo, focando na detecção de ciclos negativos.",
                                    "Desenhe um grafo de exemplo pequeno (4 vértices, 5 arestas) e simule uma iteração manual.",
                                    "Anote as operações principais: inicialização, relaxações e verificação de ciclo."
                                  ],
                                  "verification": "Pseudocódigo escrito corretamente e simulação de uma iteração no grafo de exemplo sem erros.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Pseudocódigo impresso ou digital do Bellman-Ford",
                                    "Editor de texto ou quadro branco"
                                  ],
                                  "tips": "Use notação assintótica desde o início para facilitar a transição para análise de complexidade.",
                                  "learningObjective": "Compreender a estrutura iterativa do algoritmo para basear cálculos de complexidade.",
                                  "commonMistakes": [
                                    "Confundir |V|-1 iterações com |V| iterações",
                                    "Ignorar a relaxação de todas as arestas por iteração",
                                    "Esquecer a fase de detecção de ciclo negativo"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular a complexidade temporal O(|V| * |E|)",
                                  "subSteps": [
                                    "Conte o número de iterações do loop principal: |V|-1 vezes.",
                                    "Em cada iteração, relaxe todas as |E| arestas, onde cada relaxação é O(1).",
                                    "Some a inicialização O(|V|) e a detecção de ciclo O(|E|), mostrando que são dominadas por O(|V| * |E|).",
                                    "Aplique a regra da soma: T(n) = |V| * O(|E|) = O(|V| * |E|).",
                                    "Teste com o grafo de exemplo: calcule contagens exatas de operações para |V|=4, |E|=5."
                                  ],
                                  "verification": "Equação temporal derivada corretamente e contada no exemplo com total aproximado de 4*5=20 relaxações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Calculadora simples",
                                    "Tabela de contagem de operações"
                                  ],
                                  "tips": "Pense em termos de 'pior caso': assuma grafo denso onde |E| ≈ |V|^2.",
                                  "learningObjective": "Derivar matematicamente a complexidade temporal passo a passo.",
                                  "commonMistakes": [
                                    "Contar apenas uma iteração",
                                    "Confundir relaxação O(1) com operações mais caras",
                                    "Ignorar constantes ocultas na notação Big O"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a complexidade espacial O(|V|)",
                                  "subSteps": [
                                    "Liste as estruturas de dados: array dist[] de tamanho |V|, array pred[] opcional de |V|.",
                                    "Note que a lista de arestas é entrada, não conta como espaço extra.",
                                    "Ignore variáveis auxiliares constantes.",
                                    "Some: O(|V|) para dist[] + O(|V|) para pred[] = O(|V|).",
                                    "Compare com representação do grafo (adjacência não afeta espaço do algoritmo)."
                                  ],
                                  "verification": "Lista de estruturas espaciais identificadas e soma resultando em O(|V|).",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel",
                                    "Diagrama de memória simulada"
                                  ],
                                  "tips": "Foquem apenas no espaço usado pelo algoritmo, não pela entrada.",
                                  "learningObjective": "Identificar e somar o espaço de todas as estruturas principais.",
                                  "commonMistakes": [
                                    "Incluir |E| no espaço",
                                    "Contar o grafo inteiro como espaço do algoritmo",
                                    "Esquecer array de predecessores"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com o Algoritmo de Dijkstra para grafos sem pesos negativos",
                                  "subSteps": [
                                    "Revise complexidades: Dijkstra com heap binário O((|V| + |E|) log |V|), sem heap O(|V|^2).",
                                    "Compare temporal: Bellman-Ford O(|V|*|E|) vs. Dijkstra O((|V| + |E|) log |V|); Bellman pior em grafos esparsos.",
                                    "Compare espacial: ambos O(|V|), mas Dijkstra pode precisar de heap O(|V|).",
                                    "Discuta cenários: Bellman-Ford para pesos negativos/ciclos; Dijkstra para não-negativos e eficiência.",
                                    "Crie tabela comparativa com exemplos numéricos para |V|=100, |E|=1000."
                                  ],
                                  "verification": "Tabela comparativa completa com explicações qualitativas e quantitativas.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Planilha ou papel para tabela",
                                    "Pseudocódigo de Dijkstra"
                                  ],
                                  "tips": "Use grafos esparsos/densos para ilustrar diferenças práticas.",
                                  "learningObjective": "Avaliar trade-offs entre algoritmos baseados em complexidade.",
                                  "commonMistakes": [
                                    "Afirmar Dijkstra lida com negativos",
                                    "Ignorar pré-condições de Dijkstra",
                                    "Comparar apenas temporal sem espacial"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo com 5 vértices e 8 arestas representando rotas de rede com alguns pesos negativos simulando custos variáveis. Execute Bellman-Ford: 4 iterações * 8 relaxações = 32 operações principais (temporal O(5*8)=O(40)). Espaço: array dist[5]. Compare com Dijkstra (não aplicável por negativos): se positivos, O((5+8)log5)≈O(50), mas Bellman detecta ciclo negativo ausente.",
                              "finalVerifications": [
                                "Capacidade de escrever e justificar O(|V|*|E|) temporal corretamente.",
                                "Explicação precisa de O(|V|) espacial com estruturas listadas.",
                                "Tabela de comparação com Dijkstra incluindo cenários de uso.",
                                "Cálculo numérico em grafo exemplo sem erros aritméticos.",
                                "Identificação correta de limitações (ex: Bellman para negativos).",
                                "Explicação verbal fluida de trade-offs."
                              ],
                              "assessmentCriteria": [
                                "Precisão matemática nas derivações de complexidade (90% correto).",
                                "Profundidade nos subpassos e exemplos práticos.",
                                "Correta distinção entre casos de uso de Bellman-Ford e Dijkstra.",
                                "Uso adequado de notação Big O sem confusões.",
                                "Clareza na tabela comparativa e verificações.",
                                "Identificação de erros comuns evitados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e funções de crescimento (Big O).",
                                "Física: Otimização de caminhos em redes (ex: circuitos elétricos).",
                                "Economia: Modelagem de custos em grafos com restrições negativas.",
                                "Engenharia de Software: Escolha de algoritmos por eficiência."
                              ],
                              "realWorldApplication": "Em roteamento de pacotes em redes (ex: protocolos como RIP usam Bellman-Ford para detectar loops negativos), análise de arbitragem em finanças (ciclos negativos em taxas de câmbio) e otimização de rotas em logística com penalidades variáveis."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.2.3.3",
                            "name": "Implementar algoritmo completo em pseudocódigo",
                            "description": "Escrever o pseudocódigo completo do Bellman-Ford, incluindo tratamento de erros como grafos desconexos e ciclos negativos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir estrutura de dados e parâmetros de entrada",
                                  "subSteps": [
                                    "Represente o grafo como lista de arestas (cada aresta: origem, destino, peso).",
                                    "Defina variáveis: V (número de vértices), E (número de arestas), s (vértice fonte).",
                                    "Inclua tratamento para grafos desconexos: inicialize distâncias como infinito exceto fonte.",
                                    "Declare arrays dist[] e pred[] para distâncias e predecessores.",
                                    "Adicione flag para ciclos negativos."
                                  ],
                                  "verification": "Verifique se o pseudocódigo define corretamente grafo como lista de arestas e inicializa variáveis essenciais.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Editor de texto ou papel para pseudocódigo",
                                    "Diagrama de exemplo de grafo"
                                  ],
                                  "tips": "Use notação clara como 'dist[v] ← ∞' para infinito.",
                                  "learningObjective": "Compreender representação de grafos para Bellman-Ford e preparar entradas.",
                                  "commonMistakes": [
                                    "Usar matriz de adjacência em vez de lista de arestas",
                                    "Esquecer de declarar pred[]"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Inicializar distâncias e predecessores",
                                  "subSteps": [
                                    "Sete dist[s] = 0 e pred[s] = null.",
                                    "Para todos v ≠ s, dist[v] = ∞ e pred[v] = null.",
                                    "Confirme que ∞ é representado adequadamente (ex: um valor grande ou símbolo).",
                                    "Adicione comentário explicando por que fonte é 0.",
                                    "Teste mentalmente com grafo desconexo."
                                  ],
                                  "verification": "Execute inicialização manual em um grafo pequeno e confirme distâncias corretas.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Exemplo de grafo impresso"
                                  ],
                                  "tips": "Sempre inicialize pred para reconstruir caminhos.",
                                  "learningObjective": "Dominar inicialização que permite detecção de desconexões.",
                                  "commonMistakes": [
                                    "Setar dist[s] como ∞",
                                    "Ignorar pred[]"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar loop principal de relaxação (V-1 iterações)",
                                  "subSteps": [
                                    "Para i de 1 a V-1:",
                                    "  Para cada aresta (u, v, w) na lista de arestas:",
                                    "    Se dist[u] + w < dist[v], então dist[v] = dist[u] + w e pred[v] = u.",
                                    "Adicione contador de iterações para otimização opcional.",
                                    "Comente sobre relaxação em grafos com pesos negativos."
                                  ],
                                  "verification": "Simule 2 iterações em um grafo de exemplo e verifique atualizações.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Calculadora para simulações",
                                    "Lista de arestas exemplo"
                                  ],
                                  "tips": "Use laços aninhados claros; evite dependência de ordem de vértices.",
                                  "learningObjective": "Implementar corretamente o coração do algoritmo Bellman-Ford.",
                                  "commonMistakes": [
                                    "Loop apenas V vezes em vez de V-1",
                                    "Atualizar sem checar dist[u] finito"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Detectar ciclos negativos e tratar erros",
                                  "subSteps": [
                                    "Após V-1 iterações, faça uma iteração extra: para cada aresta, cheque se dist[u] + w < dist[v].",
                                    "Se encontrar relaxação possível, setar flag ciclo_negativo = true e reporte erro.",
                                    "Para grafos desconexos, marque dist[v] = ∞ se não alcançável (pred[v] = null).",
                                    "Adicione saída: se ciclo_negativo, 'Ciclo negativo detectado'; senão, imprimir dist[] e caminhos.",
                                    "Inclua tratamento para fonte isolada."
                                  ],
                                  "verification": "Teste com grafo contendo ciclo negativo e confirme detecção.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Grafos de teste: com ciclo neg., desconexo"
                                  ],
                                  "tips": "A iteração V detecta ciclos alcançáveis da fonte.",
                                  "learningObjective": "Implementar detecção robusta de ciclos e desconexões.",
                                  "commonMistakes": [
                                    "Não checar ∞ + w",
                                    "Reportar ciclos não alcançáveis"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Validar e formatar saída do pseudocódigo",
                                  "subSteps": [
                                    "Adicione função para reconstruir caminhos usando pred[].",
                                    "Formate saída: distâncias finais, caminhos ou 'Inacessível' para ∞.",
                                    "Inclua mensagens de erro claras para ciclos e desconexões.",
                                    "Comente complexidade: O(V*E).",
                                    "Revise todo pseudocódigo por completude."
                                  ],
                                  "verification": "Execute pseudocódigo completo em 2-3 casos teste e valide resultados.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Casos teste variados"
                                  ],
                                  "tips": "Use recursão ou loop para imprimir caminhos.",
                                  "learningObjective": "Finalizar algoritmo com saída acionável e robusta.",
                                  "commonMistakes": [
                                    "Não reconstruir caminhos",
                                    "Saídas confusas para erros"
                                  ]
                                }
                              ],
                              "practicalExample": "Grafo: V=4, s=A. Arestas: A->B:6, A->D:7, B->C:-5, C->D:9, D->B:-2 (ciclo neg. B-C-D). Pseudocódigo deve detectar ciclo negativo após relaxações e reportar distâncias parciais até B/C/D inacessíveis sem ciclo.",
                              "finalVerifications": [
                                "Pseudocódigo relaxa exatamente V-1 vezes todas arestas.",
                                "Detecção de ciclo negativo na V-ésima iteração funciona.",
                                "Distâncias ∞ mantidas para vértices desconexos.",
                                "Predecessores permitem reconstrução de caminhos.",
                                "Saídas claras para casos normais, ciclos e desconexões.",
                                "Comentários explicam cada seção."
                              ],
                              "assessmentCriteria": [
                                "Corretude: Algoritmo produz distâncias mínimas corretas sem ciclos neg.",
                                "Robustez: Trata corretamente ciclos negativos e grafos desconexos.",
                                "Clareza: Pseudocódigo legível com notação padrão e comentários.",
                                "Completude: Inclui inicialização, relaxação, detecção e saída.",
                                "Eficiência: Representação O(V*E) sem otimizações desnecessárias.",
                                "Testabilidade: Fácil simular manualmente."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Programação Linear.",
                                "Programação: Estruturas de Dados (listas, arrays) e Loops Aninhados.",
                                "Análise de Algoritmos: Complexidade Temporal e Correção por Indução.",
                                "Engenharia de Software: Tratamento de Erros e Validação.",
                                "Economia: Modelagem de Arbitragem e Otimização de Custos."
                              ],
                              "realWorldApplication": "Implementado em protocolos de roteamento de rede como RIP para calcular rotas mais curtas com métricas negativas; detecção de arbitragem em mercados financeiros (ex: diferenças de câmbio criando ciclos negativos de lucro infinito)."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.2.3.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.3",
                    "name": "Algoritmo de Ford-Fulkerson",
                    "description": "Método para determinar o fluxo máximo em redes de fluxo através de augmenting paths.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.3.1",
                        "name": "Redes de Fluxo",
                        "description": "Conceitos fundamentais de redes de fluxo, incluindo grafos direcionados com capacidades, vértice fonte e sumidouro.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.1.1",
                            "name": "Definir uma rede de fluxo",
                            "description": "Identificar e descrever os componentes de uma rede de fluxo: vértices, arestas direcionadas com capacidades não negativas, vértice fonte (s) e vértice sumidouro (t).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender os vértices em uma rede de fluxo",
                                  "subSteps": [
                                    "Defina vértices como os nós ou pontos fundamentais de um grafo.",
                                    "Explique que vértices representam entidades como cidades, reservatórios ou servidores em contextos de fluxo.",
                                    "Identifique que vértices não possuem direção inerente, mas conectam-se via arestas.",
                                    "Desenhe um exemplo simples com 4 vértices rotulados (A, B, C, D).",
                                    "Discuta como vértices são finitos e enumerados em uma rede."
                                  ],
                                  "verification": "Desenhar um grafo com pelo menos 4 vértices rotulados corretamente e explicar seu papel verbalmente ou por escrito.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta",
                                    "Ferramenta online como draw.io ou Graphviz"
                                  ],
                                  "tips": "Sempre rotule vértices com letras ou números para clareza.",
                                  "learningObjective": "Dominar o conceito de vértices como base estrutural da rede de fluxo.",
                                  "commonMistakes": [
                                    "Confundir vértices com arestas",
                                    "Ignorar que vértices podem ser múltiplos além de s e t"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Entender arestas direcionadas com capacidades não negativas",
                                  "subSteps": [
                                    "Defina arestas como conexões direcionadas entre vértices, indicadas por setas.",
                                    "Explique capacidades como valores numéricos ≥ 0 associados a cada aresta, representando o fluxo máximo possível.",
                                    "Desenhe arestas com setas e anote capacidades (ex: (A→B, 5)).",
                                    "Verifique que capacidades são não negativas e finitas.",
                                    "Crie um grafo pequeno com 3 arestas e capacidades variadas."
                                  ],
                                  "verification": "Construir um grafo com 3 vértices e 4 arestas direcionadas com capacidades anotadas corretamente.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel quadriculado",
                                    "Software de edição de grafos"
                                  ],
                                  "tips": "Use setas grossas para capacidades altas e finas para baixas para visualização.",
                                  "learningObjective": "Compreender arestas como canais de fluxo limitados por capacidades.",
                                  "commonMistakes": [
                                    "Esquecer a direção das arestas",
                                    "Usar capacidades negativas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Identificar vértice fonte (s) e vértice sumidouro (t)",
                                  "subSteps": [
                                    "Defina o vértice fonte (s) como o ponto de origem do fluxo, com arestas saindo mas nenhuma entrando.",
                                    "Defina o vértice sumidouro (t) como o ponto final, com arestas entrando mas nenhuma saindo.",
                                    "Marque s e t em um grafo existente com círculos especiais.",
                                    "Explique que s inicia o fluxo máximo e t o recebe.",
                                    "Crie um exemplo onde s envia fluxo para múltiplos caminhos até t."
                                  ],
                                  "verification": "Rotular s e t em um grafo dado e justificar por que não há arestas invertidas neles.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplos impressos de grafos",
                                    "Editor gráfico online"
                                  ],
                                  "tips": "Rotule s com uma seta de entrada externa e t com saída externa para ênfase.",
                                  "learningObjective": "Reconhecer s e t como extremidades especiais da rede.",
                                  "commonMistakes": [
                                    "Permitir arestas entrando em s ou saindo de t",
                                    "Confundir s e t com vértices comuns"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Definir e representar uma rede de fluxo completa",
                                  "subSteps": [
                                    "Combine vértices, arestas com capacidades, s e t em uma definição formal.",
                                    "Escreva a definição: 'Rede de fluxo G = (V, E) com capacidades c: E → R≥0, vértice s ∈ V e t ∈ V'.",
                                    "Desenhe uma rede completa com todos os componentes.",
                                    "Verifique propriedades: direcionado, capacidades ≥0, único s e t.",
                                    "Compare com um grafo comum para destacar diferenças."
                                  ],
                                  "verification": "Produzir uma definição escrita e um diagrama completo de uma rede de fluxo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Folha de exercícios",
                                    "Ferramentas digitais para exportar diagrama"
                                  ],
                                  "tips": "Use notação matemática padrão para formalidade.",
                                  "learningObjective": "Sintetizar todos os componentes em uma definição precisa de rede de fluxo.",
                                  "commonMistakes": [
                                    "Omitir capacidades nas arestas",
                                    "Não especificar s e t claramente"
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede de distribuição de água: vértices são reservatórios (A, B, C) e cidades (D); arestas são tubos direcionados como A→B (capacidade 10 L/s), B→D (8 L/s); s = A (fonte principal), t = D (sumidouro/consumidor final). Desenhe e anote para visualizar o fluxo máximo possível.",
                              "finalVerifications": [
                                "Desenhar corretamente uma rede de fluxo com vértices, arestas, capacidades, s e t.",
                                "Escrever a definição formal sem erros.",
                                "Identificar componentes em um grafo dado como rede de fluxo.",
                                "Explicar diferenças entre rede de fluxo e grafo direcionado comum.",
                                "Verificar que todas capacidades são não negativas.",
                                "Demonstrar ausência de arestas em s ou saindo de t."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de todos os componentes (vértices, arestas, capacidades, s, t).",
                                "Correção formal da definição escrita.",
                                "Clareza e legibilidade dos diagramas desenhados.",
                                "Compreensão demonstrada em explicações verbais ou escritas.",
                                "Ausência de erros comuns como capacidades negativas ou direções erradas.",
                                "Capacidade de aplicar em um exemplo prático simples."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e otimização linear.",
                                "Física: Modelagem de fluxos em fluidos e circuitos elétricos.",
                                "Economia: Redes de suprimentos e logística de transporte.",
                                "Computação: Implementação em algoritmos como Ford-Fulkerson.",
                                "Engenharia: Otimização de redes de comunicação e tráfego."
                              ],
                              "realWorldApplication": "Redes de fluxo modelam problemas como maximizar o tráfego em estradas (vértices=cidades, arestas=rodovias com capacidades), distribuição de energia em redes elétricas ou roteamento de dados em internet, permitindo otimizar fluxos máximos com algoritmos como Ford-Fulkerson."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.3.1.2",
                            "name": "Calcular fluxo válido",
                            "description": "Verificar se um fluxo em uma rede é válido, respeitando as capacidades das arestas e a conservação de fluxo em vértices intermediários, e calcular o valor total do fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar a rede de fluxo e o fluxo atribuído",
                                  "subSteps": [
                                    "Identifique a fonte (S), o sumidouro (T) e todos os vértices intermediários.",
                                    "Liste todas as arestas com suas capacidades (c(u,v)) e fluxos atribuídos (f(u,v)).",
                                    "Desenhe o grafo direcionado rotulando capacidades e fluxos em cada aresta.",
                                    "Confirme que não há fluxos em arestas ausentes ou retroativas não definidas.",
                                    "Anote o conjunto de vértices intermediários (excluindo S e T)."
                                  ],
                                  "verification": "Verifique se o diagrama está completo e rotulado corretamente, sem discrepâncias entre lista e desenho.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Papel e caneta ou software de grafos (ex: Graphviz, Draw.io)",
                                    "Definição da rede fornecida"
                                  ],
                                  "tips": "Use setas duplas para arestas bidirecionais e cor diferente para fluxos vs. capacidades.",
                                  "learningObjective": "Construir uma representação visual e tabular precisa da rede para análise subsequente.",
                                  "commonMistakes": [
                                    "Esquecer arestas retroativas",
                                    "Confundir direção das arestas",
                                    "Não rotular fluxos e capacidades claramente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Verificar a conservação de fluxo em vértices intermediários",
                                  "subSteps": [
                                    "Para cada vértice intermediário v, calcule o fluxo entrante: soma de f(u,v) para todos u adjacentes a v.",
                                    "Calcule o fluxo saindo: soma de f(v,w) para todos w adjacentes a v.",
                                    "Verifique se fluxo entrante == fluxo saindo para cada v intermediário.",
                                    "Registre desvios, se houver, com cálculos detalhados.",
                                    "Ignore S (fluxo sai > entra) e T (fluxo entra > sai)."
                                  ],
                                  "verification": "Tabela com vértices, inflow, outflow e status 'válido/inválido' para cada um.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Planilha ou tabela em papel",
                                    "Representação do Step 1"
                                  ],
                                  "tips": "Use equação: ∑_{u→v} f(u,v) = ∑_{v→w} f(v,w) para cada v ≠ S,T.",
                                  "learningObjective": "Aplicar o princípio de conservação de fluxo (Kirchhoff's law adaptado) em redes.",
                                  "commonMistakes": [
                                    "Incluir S ou T na verificação",
                                    "Erros aritméticos em somas",
                                    "Confundir inflow com outflow"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Verificar o respeito às capacidades das arestas",
                                  "subSteps": [
                                    "Para cada aresta (u,v), compare f(u,v) ≤ c(u,v).",
                                    "Verifique arestas retroativas: f(v,u) ≤ c(v,u) se existirem.",
                                    "Garanta f(u,v) ≥ 0 para todas as arestas.",
                                    "Liste todas as arestas violadoras com valores exatos.",
                                    "Confirme que fluxos não excedem capacidades em nenhum sentido."
                                  ],
                                  "verification": "Lista exaustiva de arestas com status 'OK' ou 'violado (f= X > c= Y)'.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Lista de arestas do Step 1",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Crie uma tabela: Aresta | f | c | f ≤ c? | Observação.",
                                  "learningObjective": "Garantir que o fluxo atribuído seja fisicamente viável dentro dos limites de capacidade.",
                                  "commonMistakes": [
                                    "Ignorar fluxos negativos",
                                    "Não checar arestas retroativas",
                                    "Comparar errado: usar > em vez de ≤"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Calcular o valor total do fluxo",
                                  "subSteps": [
                                    "Calcule o valor do fluxo saindo da fonte S: soma de f(S,v) para todos v adjacentes a S.",
                                    "Calcule o valor entrando no sumidouro T: soma de f(u,T) para todos u adjacentes a T.",
                                    "Verifique se os dois valores são iguais (deve ser, se conservação válida).",
                                    "Registre o valor total como o menor dos dois, se houver discrepância.",
                                    "Anuncie o fluxo como 'válido' apenas se todos os checks anteriores passarem."
                                  ],
                                  "verification": "Valor total calculado e confirmado igual em S e T, com status final de validade.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Resultados dos Steps 2-3"
                                  ],
                                  "tips": "Valor do fluxo φ = ∑ f(S,v) = ∑ f(u,T).",
                                  "learningObjective": "Determinar a magnitude efetiva do fluxo na rede válida.",
                                  "commonMistakes": [
                                    "Usar fluxos intermediários para total",
                                    "Não comparar S e T",
                                    "Arredondamentos errados"
                                  ]
                                }
                              ],
                              "practicalExample": "Rede: S→A (cap=10, f=5), S→B (cap=5, f=3), A→T (cap=8, f=4), B→T (cap=6, f=4), A→B (cap=2, f=1). Verificação: Conservação em A (in=5, out=5), B (in=4, out=4); Capacidades OK; Total φ=8 (5+3 de S, 4+4 em T). Fluxo válido.",
                              "finalVerifications": [
                                "Conservação confirmada em todos vértices intermediários.",
                                "Fluxo ≤ capacidade em todas as arestas (incluindo retroativas).",
                                "Fluxos não-negativos.",
                                "Valor total igual saindo de S e entrando em T.",
                                "Representação gráfica/tabular precisa.",
                                "Status final de validade explicitado."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de inflow/outflow (100% correto).",
                                "Cobertura completa de todas arestas e vértices.",
                                "Uso correto das condições de validade (conservação e capacidade).",
                                "Clareza na documentação (tabelas, diagramas).",
                                "Identificação correta de violações, se presentes.",
                                "Cálculo exato do valor total do fluxo."
                              ],
                              "crossCurricularConnections": [
                                "Física: Lei de conservação de massa em fluidos (fluxo de líquidos em tubulações).",
                                "Economia: Fluxo de bens em cadeias de suprimentos com capacidades limitadas.",
                                "Ciência da Computação: Balanceamento de carga em redes de servidores.",
                                "Matemática: Sistemas lineares e desigualdades em otimização."
                              ],
                              "realWorldApplication": "Em logística, verificar se um plano de roteamento de caminhões respeita capacidades de estradas e conservação de carga em hubs intermediários, calculando o throughput total diário."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.1.3",
                            "name": "Entender cortes mínimos",
                            "description": "Definir um corte (S,T) em uma rede de fluxo e calcular sua capacidade, relacionando com o teorema máximo-minímo de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar Conceitos Básicos de Redes de Fluxo",
                                  "subSteps": [
                                    "Lembre-se da definição de uma rede de fluxo: grafo direcionado com capacidades nas arestas e fonte/sumidouro.",
                                    "Identifique o fluxo máximo como o maior fluxo da fonte ao sumidouro respeitando capacidades.",
                                    "Entenda partições S e T onde fonte está em S e sumidouro em T.",
                                    "Discuta o papel dos cortes na limitação do fluxo.",
                                    "Desenhe um grafo simples de rede de fluxo para fixar ideias."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os componentes básicos de uma rede de fluxo com um diagrama simples.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou software de desenho de grafos como Graphviz ou Draw.io",
                                  "tips": "Use cores diferentes para fonte (verde), sumidouro (vermelho) e nós intermediários.",
                                  "learningObjective": "Compreender os fundamentos de redes de fluxo como base para cortes.",
                                  "commonMistakes": "Confundir fluxo com capacidade ou ignorar direções das arestas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir e Identificar um Corte (S,T)",
                                  "subSteps": [
                                    "Defina formalmente um corte (S,T): partição dos vértices onde s ∈ S, t ∈ T, e S ∪ T = V, S ∩ T = ∅.",
                                    "Identifique arestas que cruzam de S para T (arestas do corte).",
                                    "Diferencie cortes de caminhos ou ciclos no grafo.",
                                    "Classifique cortes como finitos ou infinitos baseados em capacidades.",
                                    "Pratique particionando um grafo pequeno em S e T."
                                  ],
                                  "verification": "Marque S e T em um grafo exemplo e liste as arestas do corte corretamente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Exemplos de grafos impressos ou digitais",
                                  "tips": "Comece com grafos pequenos (4-6 nós) para visualização fácil.",
                                  "learningObjective": "Dominar a definição precisa de um corte (S,T) em redes de fluxo.",
                                  "commonMistakes": "Incluir fonte em T ou sumidouro em S, invalidando o corte."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Calcular a Capacidade de um Corte",
                                  "subSteps": [
                                    "Some as capacidades das arestas que vão de S para T (não considere fluxo atual).",
                                    "Ignore arestas de T para S na soma da capacidade.",
                                    "Calcule para múltiplos cortes no mesmo grafo e compare.",
                                    "Verifique se o fluxo atual não excede a capacidade do corte.",
                                    "Use fórmula: c(S,T) = Σ c(u,v) para u∈S, v∈T."
                                  ],
                                  "verification": "Compute c(S,T) para 3 cortes diferentes em um grafo e confira com valores conhecidos.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Calculadora, planilha ou Python com NetworkX para automação",
                                  "tips": "Liste arestas explicitamente antes de somar para evitar erros de contagem.",
                                  "learningObjective": "Calcular com precisão a capacidade de qualquer corte dado.",
                                  "commonMistakes": "Incluir capacidades de arestas reversas ou confundir com fluxo residual."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Relacionar com o Teorema Máximo-Mínimo de Fluxo",
                                  "subSteps": [
                                    "Enuncie o teorema: fluxo máximo = capacidade do corte mínimo.",
                                    "Prove intuitivamente: fluxo não pode exceder qualquer corte.",
                                    "Use Ford-Fulkerson para encontrar corte mínimo via grafo residual saturado.",
                                    "Identifique o corte mínimo a partir de um fluxo máximo computado.",
                                    "Aplique em exemplo: encontre fluxo max e corte min correspondente."
                                  ],
                                  "verification": "Dado um grafo, compute fluxo max e encontre corte min com capacidade igual.",
                                  "estimatedTime": "50 minutos",
                                  "materials": "Implementação de Ford-Fulkerson em Python ou ferramenta online como NetworkFlow.js",
                                  "tips": "Execute algoritmo passo a passo manualmente antes de código.",
                                  "learningObjective": "Conectar cortes mínimos ao teorema fundamental das redes de fluxo.",
                                  "commonMistakes": "Confundir corte mínimo com menor número de arestas, ignorando capacidades."
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Praticar Identificação de Cortes Mínimos",
                                  "subSteps": [
                                    "Gere ou use 3-5 redes de fluxo variadas.",
                                    "Liste todos os cortes possíveis e seus capacidades.",
                                    "Identifique o mínimo e verifique com fluxo máximo.",
                                    "Analise por que certos cortes não são mínimos.",
                                    "Discuta otimizações para encontrar cortes min sem enumerar todos."
                                  ],
                                  "verification": "Resolva 3 problemas independentes corretamente, com fluxos e cortes validados.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Conjunto de exercícios de redes de fluxo (livro ou online)",
                                  "tips": "Foque em grafos com capacidades variadas para realismo.",
                                  "learningObjective": "Aplicar conceitos para resolver problemas reais de cortes mínimos.",
                                  "commonMistakes": "Parar em cortes óbvios sem verificar se há menores."
                                }
                              ],
                              "practicalExample": "Em uma rede de fluxo com fonte s, sumidouro t, nós a,b,c. Arestas: s-a:3, s-b:2, a-b:1, a-c:2, b-t:3, c-t:4. Corte mínimo (S={s,a}, T={b,c,t}) tem capacidade 2+3=5, igual ao fluxo máximo encontrado por Ford-Fulkerson.",
                              "finalVerifications": [
                                "Define corretamente um corte (S,T) com s em S e t em T.",
                                "Calcula capacidade de corte somando apenas arestas S→T.",
                                "Enuncia e explica o teorema max-flow min-cut.",
                                "Identifica corte mínimo em grafo simples via inspeção ou algoritmo.",
                                "Relaciona fluxo residual saturado a corte mínimo.",
                                "Resolve exemplo completo: grafo → fluxo max → corte min."
                              ],
                              "assessmentCriteria": [
                                "Precisão na definição e identificação de cortes (100% correto).",
                                "Correção nos cálculos de capacidade (erro <1%).",
                                "Compreensão demonstrada do teorema via explicação ou prova intuitiva.",
                                "Capacidade de aplicar em novos grafos sem erros.",
                                "Eficiência na identificação de cortes mínimos (sem enumerar todos desnecessariamente).",
                                "Uso correto de terminologia técnica."
                              ],
                              "crossCurricularConnections": [
                                "Teoria da Otimização: dualidade em programação linear.",
                                "Algoritmos e Estruturas de Dados: grafos e buscas em grafos residuais.",
                                "Matemática Discreta: teoremas de min-max em teoria dos grafos.",
                                "Engenharia de Computação: modelagem de redes de comunicação."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações, cortes mínimos determinam a largura de banda máxima entre roteadores sem gargalos; em logística, maximizam fluxo de suprimentos em cadeias de transporte limitadas por capacidades de estradas/portos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1",
                              "10.1.7.3.1.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.2",
                        "name": "Grafos Residuais e Caminhos Aumentantes",
                        "description": "Construção do grafo residual a partir de um fluxo atual e identificação de caminhos aumentantes para incrementar o fluxo.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.2.1",
                            "name": "Construir grafo residual",
                            "description": "Dado um fluxo em uma rede, construir o grafo residual, incluindo arestas forward com capacidade residual e backward com fluxo atual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender o grafo de fluxo original e o fluxo atual",
                                  "subSteps": [
                                    "Identifique todos os vértices, arestas, capacidades originais (c(u,v)) e fluxos atuais (f(u,v)).",
                                    "Desenhe o grafo original destacando fonte (s) e sumidouro (t).",
                                    "Verifique a conservação de fluxo: para cada vértice intermediário, fluxo entrante = fluxo saindo.",
                                    "Anote o valor total do fluxo atual do grafo.",
                                    "Confirme que 0 ≤ f(u,v) ≤ c(u,v) para todas as arestas."
                                  ],
                                  "verification": "Grafo original reproduzido corretamente com todas as capacidades e fluxos anotados, e conservação verificada.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Papel e caneta ou quadro branco",
                                    "Software de desenho de grafos (ex: draw.io, Graphviz)"
                                  ],
                                  "tips": [
                                    "Use setas duplas para indicar direção e rotule sempre c(u,v)/f(u,v).",
                                    "Comece pela fonte para facilitar a visualização."
                                  ],
                                  "learningObjective": "Compreender a configuração inicial do problema de fluxo máximo e validar os dados de entrada.",
                                  "commonMistakes": [
                                    "Confundir capacidade com fluxo.",
                                    "Ignorar a conservação de fluxo em vértices intermediários.",
                                    "Permitir fluxos negativos ou acima da capacidade."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular capacidades residuais para arestas forward",
                                  "subSteps": [
                                    "Para cada aresta existente (u,v), calcule a capacidade residual forward: cf(u,v) = c(u,v) - f(u,v).",
                                    "Mantenha a aresta forward no grafo residual apenas se cf(u,v) > 0.",
                                    "Anote cf(u,v) em cada aresta forward mantida.",
                                    "Remova ou ignore arestas onde cf(u,v) = 0.",
                                    "Liste todas as arestas forward qualificadas em uma tabela auxiliar."
                                  ],
                                  "verification": "Tabela ou anotações mostram cf(u,v) corretas para todas as arestas originais, com arestas cf=0 excluídas.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Folha de cálculo ou tabela em papel",
                                    "Calculadora para somas rápidas"
                                  ],
                                  "tips": [
                                    "Use cor vermelha para arestas saturadas (cf=0).",
                                    "Verifique cálculos duplos para evitar erros aritméticos."
                                  ],
                                  "learningObjective": "Dominar o cálculo de capacidades residuais forward, base do algoritmo Ford-Fulkerson.",
                                  "commonMistakes": [
                                    "Calcular cf(u,v) = f(u,v) - c(u,v) (sinal invertido).",
                                    "Manter arestas com cf=0 no grafo.",
                                    "Esquecer arestas sem fluxo inicial."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Adicionar arestas backward para fluxos positivos",
                                  "subSteps": [
                                    "Identifique todas as arestas (u,v) onde f(u,v) > 0.",
                                    "Para cada uma, adicione a aresta backward (v,u) com cf(v,u) = f(u,v), mesmo se não existia originalmente.",
                                    "Se já existir aresta original (v,u), some o fluxo à sua capacidade residual: cf(v,u) += f(u,v).",
                                    "Anote cf(v,u) nas novas arestas backward.",
                                    "Verifique que não há cf negativa em backward."
                                  ],
                                  "verification": "Todas as arestas backward adicionadas corretamente onde f>0, com capacidades exatas iguais ao fluxo original.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Mesmo desenho do passo anterior",
                                    "Marcadores coloridos para backward (ex: azul)"
                                  ],
                                  "tips": [
                                    "Backward permite 'desfazer' fluxo em caminhos alternativos.",
                                    "Priorize arestas com alto fluxo para backward potentes."
                                  ],
                                  "learningObjective": "Entender o papel das arestas backward na reversão de fluxos para maximização.",
                                  "commonMistakes": [
                                    "Não adicionar backward quando f>0.",
                                    "Confundir cf backward com capacidade original.",
                                    "Adicionar backward para f=0."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Montar, validar e finalizar o grafo residual",
                                  "subSteps": [
                                    "Combine todas as arestas forward e backward no grafo residual único.",
                                    "Verifique capacidades totais de saída da fonte e entrada no sumidouro.",
                                    "Confirme ausência de ciclos negativos ou cf<0.",
                                    "Desenhe o grafo residual completo com todas as anotações.",
                                    "Teste com um caminho simples s-t para validar estrutura."
                                  ],
                                  "verification": "Grafo residual completo desenhado, com todas cf corretas e pelo menos um caminho s-t visível se possível.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Desenho final limpo",
                                    "Checklist de validação"
                                  ],
                                  "tips": [
                                    "Use espessura de linha proporcional a cf para visualização.",
                                    "Salve versão digital para reutilização."
                                  ],
                                  "learningObjective": "Construir e validar um grafo residual pronto para busca de caminhos aumentantes.",
                                  "commonMistakes": [
                                    "Duplicar arestas.",
                                    "Esquecer backward em grafos assimétricos.",
                                    "Não validar conservação residual."
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo simples: S -> A (c=10, f=6), S -> B (c=5, f=4), A -> T (c=8, f=6), B -> T (c=9, f=4). Fluxo atual=10. Grafo residual: S->A cf=4, A->S cf=6 (backward), S->B cf=1, B->S cf=4, A->T cf=2, T->A cf=6, B->T cf=5, T->B cf=4. Agora há caminhos como S->A->T ou S->B->T.",
                              "finalVerifications": [
                                "Todas as cf forward = c - f corretas.",
                                "Arestas backward adicionadas exatamente onde f>0 com cf=f.",
                                "Nenhuma cf < 0 ou aresta inválida.",
                                "Soma de cf saindo de S >= fluxo atual.",
                                "Conservação residual mantida em vértices intermediários.",
                                "Pelo menos um caminho s-t existe se fluxo não máximo."
                              ],
                              "assessmentCriteria": [
                                "Precisão nos cálculos de cf forward e backward (100% correto).",
                                "Identificação completa de todas as arestas qualificadas.",
                                "Desenho claro e rotulado do grafo residual.",
                                "Validação de propriedades (conservação, não-negatividade).",
                                "Explicação correta do propósito de cada aresta.",
                                "Eficiência: tempo dentro do estimado sem erros graves."
                              ],
                              "crossCurricularConnections": [
                                "Programação: Implementação com bibliotecas como NetworkX em Python.",
                                "Matemática: Modelagem como programa linear de maximização.",
                                "Engenharia de Software: Otimização de fluxos em pipelines de dados.",
                                "Economia: Alocação de recursos em redes de suprimentos."
                              ],
                              "realWorldApplication": "Em logística para redes de transporte, onde após alocar caminhões iniciais (fluxo), o grafo residual identifica rotas alternativas para aumentar capacidade total sem exceder limites de estradas."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.2",
                            "name": "Identificar caminho aumentante",
                            "description": "Usar BFS ou DFS para encontrar um caminho simples da fonte ao sumidouro no grafo residual com capacidades residuais positivas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Construir e Visualizar o Grafo Residual",
                                  "subSteps": [
                                    "Liste todas as arestas do grafo original com suas capacidades atuais.",
                                    "Para cada aresta com fluxo f > 0, adicione aresta reversa com capacidade residual c_f - f.",
                                    "Para cada aresta com fluxo f = 0, mantenha capacidade residual c_f se positiva.",
                                    "Marque a fonte (s) e o sumidouro (t) claramente.",
                                    "Desenhe o grafo residual destacando apenas arestas com capacidade residual > 0."
                                  ],
                                  "verification": "Confirme que todas arestas residuais positivas estão presentes e sem arestas com capacidade zero.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel e lápis ou software como Graphviz/Draw.io",
                                  "tips": "Use cores diferentes para arestas forward (azul) e backward (vermelho).",
                                  "learningObjective": "Entender como o grafo residual representa o estado atual do fluxo máximo possível.",
                                  "commonMistakes": "Esquecer de adicionar arestas reversas para fluxos existentes ou incluir arestas com capacidade residual zero."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Escolher e Inicializar o Algoritmo de Busca",
                                  "subSteps": [
                                    "Decida entre BFS (para caminho mais curto) ou DFS (para exploração profunda).",
                                    "Crie uma fila/pilha vazia para BFS/DFS e marque a fonte como visitada.",
                                    "Inicialize um array/pai para rastrear o caminho de volta à fonte.",
                                    "Defina visited[s] = true.",
                                    "Enfileire/empilhe a fonte."
                                  ],
                                  "verification": "Verifique se a estrutura de dados de busca está pronta e fonte está enfileirada/marcada.",
                                  "estimatedTime": "5 minutos",
                                  "materials": "Folha de papel para rastrear visited e parent ou simulador online de grafos.",
                                  "tips": "Prefira BFS para garantir o caminho mais curto em termos de número de arestas.",
                                  "learningObjective": "Selecionar o método de busca apropriado e preparar estruturas de dados para rastreamento.",
                                  "commonMistakes": "Não marcar a fonte como visitada, causando loops infinitos."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Executar a Busca no Grafo Residual",
                                  "subSteps": [
                                    "Enquanto a fila/pilha não estiver vazia, desinfileire/desempilhe u.",
                                    "Para cada vizinho v de u com capacidade residual > 0 e não visitado, marque visited[v]=true e defina parent[v]=u, enfileire/empilhe v.",
                                    "Se encontrar o sumidouro (t), pare a busca.",
                                    "Continue até esgotar a fila/pilha ou encontrar t.",
                                    "Se t não visitado, não há caminho aumentante."
                                  ],
                                  "verification": "Traçar o caminho usando o array parent da fonte até o sumidouro.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Tabela para visited/parent ou ferramenta interativa como Python NetworkX.",
                                  "tips": "Anote o parent de cada nó para reconstruir o caminho facilmente.",
                                  "learningObjective": "Aplicar BFS/DFS exclusivamente em arestas com capacidade residual positiva.",
                                  "commonMistakes": "Percorrer arestas com capacidade residual zero ou visitar nós já processados."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Validar e Registrar o Caminho Aumentante",
                                  "subSteps": [
                                    "Se t visitado, reconstrua o caminho: t <- parent[t] <- ... <- s.",
                                    "Verifique que todas arestas no caminho têm capacidade residual > 0.",
                                    "Calcule o gargalo: mínimo das capacidades residuais no caminho.",
                                    "Registre o caminho como aumentante simples (sem ciclos).",
                                    "Se não encontrado, declare ausência de caminho aumentante."
                                  ],
                                  "verification": "O caminho é simples, conecta s a t e todas capacidades > 0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": "Papel para listar o caminho e capacidades.",
                                  "tips": "Sempre verifique simplicidade evitando ciclos no parent.",
                                  "learningObjective": "Confirmar que o caminho encontrado é válido para augmentação no Ford-Fulkerson.",
                                  "commonMistakes": "Aceitar caminhos com capacidade zero ou caminhos cíclicos."
                                }
                              ],
                              "practicalExample": "Em um grafo com s->A (cap=3), A->B (cap=2), B->t (cap=4), fluxo atual s->A=1, A->B=1. Grafo residual: s->A(2), A->B(1), B->t(4), B->A(1), A->s(1). BFS encontra s->A->B->t com gargalo 1.",
                              "finalVerifications": [
                                "Caminho reconstruído conecta fonte ao sumidouro sem repetições.",
                                "Todas arestas no caminho têm capacidade residual positiva.",
                                "Método BFS/DFS usado corretamente sem visitar nós inválidos.",
                                "Gargalo calculado como mínimo das capacidades residuais.",
                                "Ausência de caminho declarada corretamente se t não alcançável."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção do grafo residual (100% arestas corretas).",
                                "Execução correta de BFS/DFS com rastreamento de parent/visited.",
                                "Validação completa do caminho (simples, capacidades >0).",
                                "Identificação correta de gargalo mínimo.",
                                "Explicação clara do processo em termos de Ford-Fulkerson."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos grafos e propriedades de caminhos simples.",
                                "Programação: Implementação de BFS/DFS em linguagens como Python (NetworkX).",
                                "Otimização: Conceitos de fluxos máximos em problemas de transporte.",
                                "Lógica Computacional: Estruturas de dados para busca em grafos."
                              ],
                              "realWorldApplication": "Em redes de transporte, identificar caminhos aumentantes otimiza o fluxo de mercadorias de armazéns (fonte) para clientes (sumidouro), maximizando entrega sem exceder capacidades de estradas."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.2.3",
                            "name": "Augmentar o fluxo ao longo de um caminho",
                            "description": "Calcular o gargalo (bottleneck) em um caminho aumentante e atualizar o fluxo no grafo original e residual.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Identificar e listar as capacidades residuais ao longo do caminho aumentante",
                                  "subSteps": [
                                    "Examine o grafo residual atual e trace o caminho aumentante do source ao sink.",
                                    "Para cada aresta forward no caminho, anote a capacidade residual atual (capacidade original menos fluxo atual).",
                                    "Ignore arestas backward por enquanto, focando apenas nas forward do caminho.",
                                    "Confirme que todas as capacidades residuais forward são positivas.",
                                    "Registre o caminho como uma sequência de vértices e suas capacidades residuais associadas."
                                  ],
                                  "verification": "Lista completa de capacidades residuais forward para cada aresta no caminho, todas >0.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Grafo residual impresso ou digital",
                                    "Lápis e papel para anotações",
                                    "Calculadora opcional"
                                  ],
                                  "tips": "Sempre comece do source e siga setas forward no residual; use cores para destacar o caminho.",
                                  "learningObjective": "Compreender como ler capacidades residuais em um grafo residual.",
                                  "commonMistakes": "Confundir capacidade original com residual; incluir arestas backward no cálculo inicial."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Calcular o gargalo (bottleneck) do caminho",
                                  "subSteps": [
                                    "Colete todas as capacidades residuais forward listadas no step anterior.",
                                    "Identifique o valor mínimo entre elas (min(cf(u,v) para todas arestas (u,v) no caminho).",
                                    "Registre o bottleneck como δ = min(cf(u,v)).",
                                    "Verifique se δ > 0; se não, o caminho não é aumentante.",
                                    "Anote δ claramente para uso nos próximos steps."
                                  ],
                                  "verification": "Valor de δ calculado corretamente como o mínimo das capacidades residuais forward.",
                                  "estimatedTime": "5 minutos",
                                  "materials": [
                                    "Lista do step 1",
                                    "Calculadora"
                                  ],
                                  "tips": "Use a função MIN em uma planilha ou mentalmente para caminhos curtos; destaque o gargalo.",
                                  "learningObjective": "Dominar o conceito de bottleneck como limitante do aumento de fluxo.",
                                  "commonMistakes": "Usar capacidades originais em vez de residuais; arredondar incorretamente valores decimais."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Atualizar o fluxo no grafo original",
                                  "subSteps": [
                                    "Para cada aresta (u,v) no caminho aumentante, adicione δ ao fluxo atual f(u,v).",
                                    "Atualize f(u,v) ← f(u,v) + δ para todas forward.",
                                    "Não altere fluxos em outras arestas.",
                                    "Some os fluxos de saída do source para calcular o novo fluxo total.",
                                    "Registre os novos valores de fluxo em uma cópia do grafo original."
                                  ],
                                  "verification": "Todos fluxos forward no caminho aumentados exatamente por δ; fluxo total aumentou por δ.",
                                  "estimatedTime": "10 minutos",
                                  "materials": [
                                    "Grafo original com fluxos atuais",
                                    "Cópia do grafo para anotações"
                                  ],
                                  "tips": "Trabalhe sequencialmente ao longo do caminho para evitar erros de soma.",
                                  "learningObjective": "Aplicar o aumento de fluxo conservando a conservação de fluxo em nós intermediários.",
                                  "commonMistakes": "Adicionar δ a arestas erradas; esquecer de atualizar o fluxo total."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Atualizar o grafo residual",
                                  "subSteps": [
                                    "Para cada aresta forward (u,v) no caminho: cf(u,v) ← cf(u,v) - δ.",
                                    "Para cada aresta forward (u,v), adicione ou atualize aresta backward (v,u): cf(v,u) ← cf(v,u) + δ (crie se não existir).",
                                    "Verifique que soma de forward e backward em cada par é igual à capacidade original.",
                                    "Confirme que não há capacidades residuais negativas.",
                                    "Teste se o caminho ainda existe no novo residual (deve ter cf=0 nas forward usadas)."
                                  ],
                                  "verification": "Grafo residual atualizado: forward reduzidas por δ, backward aumentadas por δ; sem negativos.",
                                  "estimatedTime": "15 minutos",
                                  "materials": [
                                    "Grafo residual atualizado",
                                    "Ferramenta de desenho de grafos como draw.io"
                                  ],
                                  "tips": "Use setas duplas para pares forward/backward; sempre verifique conservação c(u,v) = f(u,v) + cf(u,v) - cf(v,u).",
                                  "learningObjective": "Manter a consistência entre grafos original e residual após augmentação.",
                                  "commonMistakes": "Esquecer de criar arestas backward; subtrair em vez de adicionar no backward."
                                }
                              ],
                              "practicalExample": "Considere grafo: s→a(c=3,f=0), a→t(c=2,f=0), s→b(c=2,f=0), b→t(c=4,f=0). Caminho aumentante: s→a→t. Capacidades residuais: s-a=3, a-t=2. Bottleneck δ=2. Atualizar: f(s-a)=2, f(a-t)=2. Novo residual: s-a=1, a-s=2 (nova), a-t=0, t-a=2 (nova). Fluxo total=2.",
                              "finalVerifications": [
                                "δ calculado corretamente como min das cf forward.",
                                "Fluxos originais aumentados exatamente por δ em todas arestas do caminho.",
                                "Grafo residual: cf forward reduzidas por δ, cf backward aumentadas por δ.",
                                "Fluxo total aumentou por δ.",
                                "Nenhuma cf negativa no residual; conservação de capacidade preservada."
                              ],
                              "assessmentCriteria": [
                                "Precisão no cálculo de δ (100% correto).",
                                "Atualizações de fluxo original sem erros em arestas (verificação manual).",
                                "Grafo residual consistente com regras forward/backward (teste com exemplo).",
                                "Tempo de execução eficiente dentro dos estimados.",
                                "Explicação clara do processo em palavras próprias."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização e minimização linear.",
                                "Programação: Implementação de grafos com adjacência/matrices em Python/Java.",
                                "Engenharia: Modelagem de redes de fluxo em logística.",
                                "Economia: Alocação de recursos limitados em cadeias de suprimento.",
                                "Física: Fluxo de fluidos em tubulações com gargalos."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações, maximiza a largura de banda alocada a uma rota específica (caminho aumentante), atualizando capacidades residuais para roteamento subsequente, otimizando tráfego de dados sem exceder links físicos."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1",
                              "10.1.7.3.2.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.3",
                        "name": "Algoritmo de Ford-Fulkerson",
                        "description": "Implementação completa do método iterativo para encontrar o fluxo máximo através de repetição de buscas por caminhos aumentantes.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.3.1",
                            "name": "Descrever o pseudocódigo do algoritmo",
                            "description": "Explicar o loop principal: enquanto existir caminho aumentante, augmentar o fluxo; retornar quando não houver mais caminhos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Entender e descrever a estrutura geral do algoritmo de Ford-Fulkerson",
                                  "subSteps": [
                                    "Revise os conceitos básicos: grafo de fluxo, capacidades de arestas, fluxo inicial zero e grafo residual.",
                                    "Identifique os componentes principais: função de capacidade c(u,v), fluxo f(u,v) e grafo residual Gf.",
                                    "Desenhe um fluxograma simples mostrando inicialização, loop principal e saída.",
                                    "Escreva uma visão de alto nível do pseudocódigo: inicializar fluxo, while loop para caminhos aumentantes, retornar fluxo máximo.",
                                    "Explique verbalmente o propósito de cada seção principal."
                                  ],
                                  "verification": "Você pode desenhar o fluxograma e recitar a estrutura geral sem consultar notas?",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e caneta para fluxograma",
                                    "Diagrama de grafo de fluxo de exemplo",
                                    "Editor de texto para pseudocódigo inicial"
                                  ],
                                  "tips": "Comece com um esboço visual para fixar a lógica sequencial antes de codificar.",
                                  "learningObjective": "Compreender a arquitetura geral do algoritmo para descrever seu fluxo lógico de forma clara.",
                                  "commonMistakes": [
                                    "Confundir grafo original com grafo residual desde o início.",
                                    "Ignorar a inicialização do fluxo como zero.",
                                    "Esquecer que o loop é condicional a caminhos aumentantes."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Descrever a fase de inicialização do pseudocódigo",
                                  "subSteps": [
                                    "Defina o grafo G = (V, E) com fonte s e sink t.",
                                    "Inicialize o fluxo f(u,v) = 0 para todas as arestas.",
                                    "Construa o grafo residual inicial Gf onde c_f(u,v) = c(u,v) se f(u,v)=0.",
                                    "Escreva as linhas de pseudocódigo: 'fluxo = 0; construir Gf inicial'.",
                                    "Verifique com um exemplo pequeno se o residual está correto."
                                  ],
                                  "verification": "Escreva o pseudocódigo de inicialização e aplique a um grafo de 3 nós para confirmar.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Exemplo de grafo simples impresso ou digital",
                                    "Ferramenta de desenho de grafos como Draw.io"
                                  ],
                                  "tips": "Sempre represente o grafo residual com setas bidirecionais para fluxos forward e backward.",
                                  "learningObjective": "Dominar a configuração inicial necessária para o algoritmo funcionar corretamente.",
                                  "commonMistakes": [
                                    "Inicializar fluxo com valores não-zero sem justificativa.",
                                    "Esquecer arestas reversas no residual (v,u) com capacidade -f(u,v).",
                                    "Não distinguir capacidade residual c_f de capacidade original c."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Descrever o loop principal: encontrar e augmentar caminhos aumentantes",
                                  "subSteps": [
                                    "Implemente busca de caminho aumentante usando BFS ou DFS no grafo residual de s a t.",
                                    "Se caminho p encontrado, calcule o gargalo δ = min {c_f(u,v) ao longo de p}.",
                                    "Augmente o fluxo: para cada aresta em p, f(u,v) += δ; atualize residual forward e backward.",
                                    "Escreva pseudocódigo: 'while existe caminho p em Gf: δ = min c_f em p; augmentar f por δ; atualizar Gf'.",
                                    "Simule uma iteração completa em um grafo de exemplo."
                                  ],
                                  "verification": "Simule o loop em um grafo com pelo menos 2 augmentações e verifique se o fluxo aumenta corretamente.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Grafo de exemplo com capacidades numéricas",
                                    "Planilha ou calculadora para gargalos",
                                    "Pseudocódigo template"
                                  ],
                                  "tips": "Use BFS para Edmonds-Karp (versão eficiente) e destaque o gargalo como limitante.",
                                  "learningObjective": "Explicar precisamente como o loop principal itera até saturar o fluxo máximo.",
                                  "commonMistakes": [
                                    "Não atualizar corretamente as capacidades residuais reversas.",
                                    "Calcular gargalo errado (usar max em vez de min).",
                                    "Parar o loop prematuramente sem verificar ausência de caminhos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Descrever a condição de parada e retorno do resultado",
                                  "subSteps": [
                                    "Defina condição de parada: não existe mais caminho aumentante de s a t no Gf.",
                                    "Retorne o valor do fluxo máximo: valor(f) = soma de fluxos saindo de s (ou entrando em t).",
                                    "Escreva a linha final: 'retornar valor(f)'.",
                                    "Compile o pseudocódigo completo e revise por completude.",
                                    "Teste verbalmente explicando por que o algoritmo termina (teorema de integridade do fluxo)."
                                  ],
                                  "verification": "Escreva o pseudocódigo completo e explique por que para quando não há caminhos aumentantes.",
                                  "estimatedTime": "20 minutos",
                                  "materials": [
                                    "Pseudocódigo dos steps anteriores",
                                    "Teorema de fluxo máximo-mínimo resumido"
                                  ],
                                  "tips": "Lembre que pela teorema max-flow min-cut, o fluxo é máximo quando não há caminhos aumentantes.",
                                  "learningObjective": "Concluir o pseudocódigo com parada correta e saída do fluxo máximo.",
                                  "commonMistakes": [
                                    "Retornar sem somar o fluxo total corretamente.",
                                    "Confundir parada com número fixo de iterações.",
                                    "Esquecer teorema justificando a corretude."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo de rede de tubulações com s conectado a A (cap=10), A a t (cap=5), e s a B (cap=15), B a t (cap=20): Inicialize f=0; encontre p1=s-A-t (δ=5), augmenta para f=5; p2=s-B-t (δ=15), augmenta para f=20; sem mais caminhos, retorne 20.",
                              "finalVerifications": [
                                "Pode escrever o pseudocódigo completo de memória?",
                                "Simula corretamente 2-3 iterações em um grafo dado?",
                                "Explica o papel do grafo residual em cada augmentação?",
                                "Identifica gargalo corretamente em caminhos complexos?",
                                "Justifica por que o algoritmo retorna o máximo usando teorema?",
                                "Descreve diferenças entre Ford-Fulkerson genérico e Edmonds-Karp?"
                              ],
                              "assessmentCriteria": [
                                "Pseudocódigo cobre inicialização, loop, augmentação e parada corretamente.",
                                "Uso preciso de notação: c_f, f, δ, caminhos p.",
                                "Explicação clara do grafo residual e atualizações.",
                                "Simulação prática sem erros aritméticos.",
                                "Conexão com teorema max-flow min-cut.",
                                "Linguagem acionável e sequencial nos steps."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos e teoremas de fluxo máximo-mínimo.",
                                "Programação: Implementação em linguagens como Python com bibliotecas NetworkX.",
                                "Otimização: Problemas de programação linear e alocação de recursos.",
                                "Engenharia: Modelagem de redes de transporte e comunicação."
                              ],
                              "realWorldApplication": "O algoritmo é usado em roteamento de tráfego em redes de computadores, planejamento de suprimentos em logística (ex: maximizar fluxo de mercadorias), alocação de banda em telecomunicações e simulações de redes elétricas para distribuição de energia eficiente."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.2.1",
                              "10.1.7.3.2.2"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.2",
                            "name": "Provar a correção do algoritmo",
                            "description": "Demonstrar que o algoritmo termina com fluxo máximo usando o teorema dos cortes e propriedades dos grafos residuais.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Teorema Fundamental dos Fluxos Máximos (Teorema dos Cortes)",
                                  "subSteps": [
                                    "Defina formalmente um fluxo válido em uma rede de fluxo.",
                                    "Explique o conceito de corte (S, T) em uma rede, com S contendo a fonte e T o sumidouro.",
                                    "Enuncie o teorema: o valor de qualquer fluxo máximo é igual ao valor do corte mínimo.",
                                    "Demonstre com um exemplo simples como calcular o valor de um corte.",
                                    "Discuta a conservação de fluxo e saturação de arestas."
                                  ],
                                  "verification": "Enuncie o teorema corretamente e calcule o valor de um corte em um grafo dado.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Notas de aula sobre redes de fluxo",
                                    "Diagrama de grafo de exemplo",
                                    "Ferramenta de desenho de grafos como Graphviz"
                                  ],
                                  "tips": "Sempre verifique se o corte separa fonte e sumidouro corretamente.",
                                  "learningObjective": "Compreender a equivalência entre fluxos máximos e cortes mínimos.",
                                  "commonMistakes": [
                                    "Confundir o valor do corte com a soma de capacidades de arestas internas ao S.",
                                    "Ignorar arestas de volta no cálculo do corte."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Propriedades dos Grafos Residuais",
                                  "subSteps": [
                                    "Construa o grafo residual G_f a partir de um grafo G com fluxo f.",
                                    "Explique capacidades residuais: c_f(u,v) = c(u,v) - f(u,v) para arestas forward e f(v,u) para backward.",
                                    "Identifique caminhos aumentantes no grafo residual.",
                                    "Descreva como um caminho aumentante aumenta o fluxo sem violar restrições.",
                                    "Verifique propriedades: o grafo residual preserva a estrutura de fluxo válido."
                                  ],
                                  "verification": "Construa o grafo residual para um fluxo dado e identifique um caminho aumentante.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Exemplo de rede de fluxo impressa",
                                    "Papel e lápis para desenhar grafos",
                                    "Software como NetworkX (Python)"
                                  ],
                                  "tips": "Lembre-se: arestas backward só existem se houver fluxo positivo na direção oposta.",
                                  "learningObjective": "Dominar a construção e interpretação de grafos residuais.",
                                  "commonMistakes": [
                                    "Esquecer de adicionar arestas backward quando f(u,v) > 0.",
                                    "Calcular mal as capacidades residuais."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Provar a Terminação do Algoritmo",
                                  "subSteps": [
                                    "Mostre que cada iteração encontra um caminho aumentante ou para.",
                                    "Argumente que não há ciclos infinitos pois cada augmentação aumenta o fluxo em δ > 0.",
                                    "Prove que o fluxo total é acotado pela capacidade do corte fonte-sumidouro.",
                                    "Discuta que o número de augmentações é finito (até o valor do corte mínimo).",
                                    "Considere o caso de capacidades inteiras para bounding explícito."
                                  ],
                                  "verification": "Escreva uma prova curta mostrando que o algoritmo termina em tempo finito.",
                                  "estimatedTime": "35 minutos",
                                  "materials": [
                                    "Pseudocódigo do Ford-Fulkerson",
                                    "Exemplo numérico com múltiplas augmentações",
                                    "Folha de cálculo para rastrear fluxos"
                                  ],
                                  "tips": "Use indução sobre o valor do fluxo para provar finitude.",
                                  "learningObjective": "Demonstrar que o algoritmo não entra em loop infinito.",
                                  "commonMistakes": [
                                    "Assumir capacidades reais sem bounding, ignorando casos não-inteiros.",
                                    "Não considerar que δ pode ser fracionário mas ainda positivo."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Provar a Otimalidade (Fluxo Máximo)",
                                  "subSteps": [
                                    "Ao final, não há caminhos aumentantes no grafo residual.",
                                    "Construa o conjunto S como nós alcançáveis da fonte no residual.",
                                    "Mostre que (S, T) é um corte saturado: toda aresta de S para T está saturada.",
                                    "Pelo teorema dos cortes, o fluxo atual é máximo pois ≤ valor do corte.",
                                    "Conclua que f é um fluxo máximo."
                                  ],
                                  "verification": "Para um grafo residual sem caminhos aumentantes, identifique o corte mínimo correspondente.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Grafo de exemplo final do algoritmo",
                                    "Marcadores para BFS no residual",
                                    "Referência ao teorema dos cortes"
                                  ],
                                  "tips": "Use BFS para encontrar S precisamente.",
                                  "learningObjective": "Conectar ausência de caminhos aumentantes com cortes mínimos.",
                                  "commonMistakes": [
                                    "Não verificar saturação das arestas de corte forward.",
                                    "Confundir S com o conjunto de todos os nós."
                                  ]
                                }
                              ],
                              "practicalExample": "Em uma rede de tubulações com fonte S (fábrica), sumidouro T (mercado), capacidades {S-A:3, S-B:2, A-T:2, B-T:3, A-B:1}. Execute Ford-Fulkerson: augmentações levam a fluxo 4. No residual final, S alcança S,A,B mas não T; corte (S,A,B | T) tem valor 4+1(saturado efetivo), provando máximo.",
                              "finalVerifications": [
                                "Enuncie corretamente o teorema dos cortes.",
                                "Construa grafo residual e identifique ausência de caminhos aumentantes.",
                                "Prove terminação com bounding pelo corte mínimo.",
                                "Identifique corte mínimo a partir do residual final.",
                                "Aplique a prova em um exemplo numérico completo.",
                                "Explique por que o fluxo é máximo sem caminhos aumentantes."
                              ],
                              "assessmentCriteria": [
                                "Precisão na enunciação do teorema fundamental.",
                                "Correção na construção e análise do grafo residual.",
                                "Rigor lógico na prova de terminação.",
                                "Identificação correta do corte saturado.",
                                "Integração coerente de propriedades residuais com teorema dos cortes.",
                                "Clareza na explicação de exemplos práticos."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria dos grafos e provas por indução.",
                                "Otimização Linear: Dualidade entre fluxos e cortes.",
                                "Programação: Implementação de BFS/DFS em grafos residuais.",
                                "Engenharia de Transporte: Modelagem de redes de fluxo."
                              ],
                              "realWorldApplication": "Em logística, prova que o algoritmo otimiza o fluxo máximo de carga em redes de estradas/ferrovias, garantindo eficiência e evitando desperdícios em supply chains globais."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.1.3",
                              "10.1.7.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.3",
                            "name": "Analisar complexidade temporal",
                            "description": "Discutir a complexidade do Ford-Fulkerson genérico (exponencial em casos ruins) e melhorias como Edmonds-Karp (O(VE²)).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo Ford-Fulkerson Genérico",
                                  "subSteps": [
                                    "Relembre o funcionamento básico: encontrar caminhos aumentantes usando qualquer método de busca (DFS ou BFS genérico).",
                                    "Identifique que a complexidade depende da escolha do caminho aumentante.",
                                    "Discuta o número máximo de iterações: no máximo o valor do fluxo máximo.",
                                    "Analise o custo por iteração: O(E) para encontrar um caminho em grafos não ponderados."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito o pseudocódigo do Ford-Fulkerson e calcule o número de iterações para um exemplo simples.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Notas de aula sobre Ford-Fulkerson, grafo de exemplo com capacidades.",
                                  "tips": "Desenhe o grafo residual para visualizar caminhos aumentantes.",
                                  "learningObjective": "Compreender os componentes fundamentais do algoritmo genérico.",
                                  "commonMistakes": "Confundir grafo original com grafo residual."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Complexidade Temporal no Pior Caso do Ford-Fulkerson",
                                  "subSteps": [
                                    "Construa um grafo de exemplo com capacidades unitárias onde caminhos ruins levam a muitas iterações.",
                                    "Demonstre que o número de iterações pode ser exponencial em V (número de vértices).",
                                    "Calcule a complexidade geral: O(F * E), onde F pode ser exponencial.",
                                    "Discuta exemplos clássicos como grafos com capacidades 1 e estrutura em árvore.",
                                    "Compare com fluxos máximos pequenos para ilustrar o problema."
                                  ],
                                  "verification": "Crie um grafo onde o algoritmo genérico execute 2^{V/2} iterações e prove isso.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Papel e lápis para desenhar grafos, calculadora para exponenciais.",
                                  "tips": "Use grafos com capacidades decrescentes para forçar caminhos ruins.",
                                  "learningObjective": "Identificar e quantificar o comportamento exponencial em casos patológicos.",
                                  "commonMistakes": "Ignorar que F pode ser exponencial, assumindo sempre polinomial."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Introduzir e Entender o Algoritmo Edmonds-Karp",
                                  "subSteps": [
                                    "Descreva Edmonds-Karp como Ford-Fulkerson usando BFS para caminhos mais curtos.",
                                    "Explique a propriedade chave: cada caminho aumentante reduz o número de caminhos curtos críticos.",
                                    "Mostre que o número de iterações é no máximo O(VE).",
                                    "Calcule custo por iteração: O(E) para BFS.",
                                    "Implemente pseudocódigo modificado com fila BFS."
                                  ],
                                  "verification": "Implemente BFS em um grafo pequeno e compare número de iterações com DFS.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Editor de código ou pseudocódigo, grafo de teste.",
                                  "tips": "Sempre use BFS de origem para destino no grafo residual.",
                                  "learningObjective": "Diferenciar a heurística BFS e suas implicações na complexidade.",
                                  "commonMistakes": "Usar DFS em vez de BFS, perdendo a garantia O(VE)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar Complexidades e Verificar Limites",
                                  "subSteps": [
                                    "Derive a complexidade total de Edmonds-Karp: O(VE * E) = O(VE²).",
                                    "Compare com Ford-Fulkerson: exponencial vs. polinomial.",
                                    "Teste em um grafo onde FF falha: execute ambos e meça iterações.",
                                    "Discuta trade-offs: simplicidade vs. eficiência prática.",
                                    "Resuma quando usar cada um."
                                  ],
                                  "verification": "Escreva um relatório comparativo com notação Big O para ambos.",
                                  "estimatedTime": "35 minutos",
                                  "materials": "Tabela comparativa, exemplos de grafos.",
                                  "tips": "Lembre-se: O(VE²) é polinomial, mas pode ser lento para grafos densos.",
                                  "learningObjective": "Sintetizar análises de complexidade e suas implicações práticas.",
                                  "commonMistakes": "Esquecer o fator E no custo por iteração."
                                }
                              ],
                              "practicalExample": "Considere um grafo com 4 vértices e capacidades unitárias em uma estrutura que força Ford-Fulkerson genérico (DFS) a executar 4 iterações desnecessárias, enquanto Edmonds-Karp (BFS) resolve em 2 iterações. Implemente ambos e compare o tempo de execução em código Python.",
                              "finalVerifications": [
                                "Explicar corretamente por que Ford-Fulkerson pode ser exponencial com um exemplo concreto.",
                                "Derivar O(VE²) para Edmonds-Karp mostrando limite de iterações O(VE).",
                                "Identificar um grafo onde FF excede 100 iterações e EK usa menos de 10.",
                                "Comparar notações Big O verbalmente sem erros.",
                                "Implementar EK corretamente em pseudocódigo.",
                                "Discutir limitações práticas de ambos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na derivação de complexidades (100% correto).",
                                "Uso correto de notação Big O e Theta.",
                                "Qualidade dos exemplos: realistas e ilustrativos.",
                                "Profundidade na análise de casos ruins.",
                                "Clareza na comparação entre algoritmos.",
                                "Capacidade de implementação e verificação prática."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Análise assintótica e teoria dos grafos.",
                                "Programação: Implementação de algoritmos em grafos com bibliotecas como NetworkX.",
                                "Engenharia: Otimização de redes de fluxo em sistemas reais.",
                                "Estatística: Análise empírica de performance em benchmarks."
                              ],
                              "realWorldApplication": "Em redes de telecomunicações para maximizar largura de banda, onde Edmonds-Karp garante tempo polinomial evitando falhas exponenciais em rotas dinâmicas; usado em roteadores Cisco e otimização logística como no Google Maps para fluxos de tráfego."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.3.4",
                            "name": "Implementar em código",
                            "description": "Codificar o algoritmo em pseudocódigo ou linguagem como Python/C++, testando com exemplos de redes de fluxo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir a estrutura de dados para o grafo de fluxo",
                                  "subSteps": [
                                    "Escolha uma representação de grafo adjacente com capacidades e fluxos residuais (use dicionário de dicionários em Python).",
                                    "Crie classes ou estruturas para nós, arestas com capacidade e fluxo atual.",
                                    "Inicialize o grafo com source, sink e todas as arestas com suas capacidades iniciais (fluxo = 0).",
                                    "Implemente funções auxiliares para adicionar arestas e acessar capacidades residuais.",
                                    "Garanta suporte a grafos direcionados com capacidades assimétricas."
                                  ],
                                  "verification": "Execute uma função de teste que imprime o grafo inicial e verifica se capacidades e fluxos estão corretos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Editor de código (VS Code ou PyCharm)",
                                    "Documentação Python dicts e lists"
                                  ],
                                  "tips": "Use defaultdict para simplificar a inicialização de grafos esparsos.",
                                  "learningObjective": "Compreender e implementar representações eficientes de grafos para fluxos de rede.",
                                  "commonMistakes": [
                                    "Esquecer de inicializar fluxos residuais para arestas reversas.",
                                    "Não tratar grafos não conectados.",
                                    "Usar listas fixas em vez de estruturas dinâmicas."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar a busca de caminho aumentante com BFS",
                                  "subSteps": [
                                    "Crie uma função BFS que parta do source e explore nós usando fila (queue).",
                                    "Mantenha um array de pais (parent) para rastrear o caminho e o fluxo mínimo possível no caminho.",
                                    "Para cada aresta u-v, verifique se capacidade residual > 0 e atualize o parent se melhor caminho encontrado.",
                                    "Continue até alcançar o sink ou esgotar a fila; retorne o caminho e path_flow se encontrado.",
                                    "Implemente detecção de ciclo ou caminhos inválidos."
                                  ],
                                  "verification": "Teste BFS isoladamente com um grafo simples; verifique se retorna o caminho correto e path_flow.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Biblioteca collections.deque para queue eficiente",
                                    "Exemplos de grafos de fluxo de livros como CLRS"
                                  ],
                                  "tips": "Sempre verifique capacidade residual (capacidade - fluxo) antes de enfileirar.",
                                  "learningObjective": "Dominar BFS adaptado para encontrar caminhos com gargalos mínimos em grafos de fluxo.",
                                  "commonMistakes": [
                                    "Não atualizar path_flow com o mínimo ao longo do caminho.",
                                    "Visitar nós já visitados sem marcação.",
                                    "Ignorar arestas reversas com capacidade residual."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar o loop principal do algoritmo Ford-Fulkerson",
                                  "subSteps": [
                                    "Inicie um fluxo total em 0.",
                                    "Em um loop while: chame BFS para encontrar caminho aumentante.",
                                    "Se não encontrar, break; senão, calcule path_flow e atualize fluxos ao longo do caminho.",
                                    "Para cada aresta no caminho, atualize fluxo forward e crie/atualize residual backward.",
                                    "Some path_flow ao fluxo total."
                                  ],
                                  "verification": "Execute o algoritmo completo em um grafo de teste e imprima fluxos finais e total.",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Pseudocódigo do Ford-Fulkerson de referências acadêmicas",
                                    "Debugger do IDE"
                                  ],
                                  "tips": "Use uma cópia do grafo residual para evitar modificações in-place prematuras.",
                                  "learningObjective": "Integrar BFS com atualizações de fluxo para computar o fluxo máximo.",
                                  "commonMistakes": [
                                    "Atualizar fluxos sem usar path_flow mínimo.",
                                    "Não criar arestas reversas quando necessário.",
                                    "Loop infinito por não detectar ausência de caminhos."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Testar e depurar a implementação com exemplos",
                                  "subSteps": [
                                    "Crie um grafo de teste com source=0, sink=3 e arestas conhecidas (ex: fluxo máx=5).",
                                    "Execute o algoritmo e compare com resultado esperado.",
                                    "Adicione prints ou logs para rastrear caminhos e atualizações.",
                                    "Teste casos edge: grafo sem caminho, fluxo zero, grafos com múltiplos caminhos.",
                                    "Otimize para eficiência e valide com mais exemplos."
                                  ],
                                  "verification": "Todos os testes passam com fluxos corretos; código roda em <1s para grafos médios.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Conjuntos de testes unitários (unittest em Python)",
                                    "Grafos de exemplo online"
                                  ],
                                  "tips": "Use asserts para verificações automáticas nos testes.",
                                  "learningObjective": "Garantir robustez e correção da implementação através de testes abrangentes.",
                                  "commonMistakes": [
                                    "Testar apenas casos felizes.",
                                    "Ignorar overflow em capacidades grandes.",
                                    "Não validar grafos cíclicos."
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente em Python para o grafo: nós 0(source)-1(3), 0-2(2), 1-2(2), 1-3(3), 2-3(2). O algoritmo deve encontrar caminhos como 0-1-3 (fluxo 3) e 0-2-3 (fluxo 2), totalizando fluxo máximo de 5. Imprima o grafo residual final.",
                              "finalVerifications": [
                                "O código executa sem erros de sintaxe ou runtime.",
                                "O fluxo máximo computado é idêntico ao valor esperado para exemplos padrão.",
                                "Capacidades residuais são atualizadas corretamente (forward=0 quando saturado, backward>0).",
                                "BFS não entra em loop infinito e termina em tempo polinomial.",
                                "Função lida com grafos desconectados (retorna 0 corretamente).",
                                "Testes unitários cobrem 100% dos casos edge."
                              ],
                              "assessmentCriteria": [
                                "Correção: Fluxo máximo matches teorema de fluxo máximo-minimo corte.",
                                "Eficiência: BFS O(VE^2) no pior caso, otimizado com queue.",
                                "Clareza: Código comentado, variáveis nomeadas intuitivamente.",
                                "Robustez: Trata entradas inválidas (ex: capacidades negativas).",
                                "Modularidade: Funções separadas para BFS, update e main.",
                                "Documentação: Docstrings em funções principais."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de grafos, teorema de fluxo máximo-minimo corte.",
                                "Programação: Estruturas de dados (grafos, queues), algoritmos de busca.",
                                "Engenharia de Software: Testes unitários e depuração.",
                                "Otimização: Modelagem de problemas de alocação como fluxos de rede.",
                                "Física: Modelagem de fluxos em redes hidráulicas ou elétricas."
                              ],
                              "realWorldApplication": "Otimização de rotas em logística (ex: entrega de pacotes maximizando throughput), alocação de banda em redes de telecomunicações, planejamento de produção em fábricas com restrições de recursos compartilhados."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.1",
                              "10.1.7.3.3.2"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.3.4",
                        "name": "Aplicações e Exemplos",
                        "description": "Exemplos práticos e aplicações do algoritmo de fluxo máximo.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.3.4.1",
                            "name": "Resolver problema de transporte",
                            "description": "Modelar um problema de transporte de mercadorias como rede de fluxo e aplicar Ford-Fulkerson para fluxo máximo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Definir e analisar o problema de transporte",
                                  "subSteps": [
                                    "Identifique as fontes (ex: fábricas), sumidouros (ex: armazéns) e nós intermediários (ex: centros de distribuição).",
                                    "Liste as capacidades de oferta nas fontes e demanda nos sumidouros.",
                                    "Registre as capacidades de arestas entre nós (limites de transporte em estradas ou rotas).",
                                    "Defina o objetivo: maximizar o fluxo total de mercadorias da fonte superfonte ao sumidouro supersumidouro.",
                                    "Crie um diagrama esquemático inicial do problema."
                                  ],
                                  "verification": "Verifique se todos os elementos (fontes, sumidouros, capacidades) estão listados em uma tabela clara sem ambiguidades.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Papel, lápis, calculadora, template de tabela para capacidades.",
                                  "tips": "Comece com um problema pequeno (3-4 nós) para praticar antes de escalar.",
                                  "learningObjective": "Compreender os componentes essenciais de um problema de transporte e prepará-lo para modelagem em rede de fluxo.",
                                  "commonMistakes": "Confundir capacidades de oferta com capacidades de arestas; ignorar demandas nos sumidouros."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Modelar o problema como uma rede de fluxo",
                                  "subSteps": [
                                    "Adicione uma superfonte conectada às fontes com capacidades iguais às ofertas.",
                                    "Adicione um supersumidouro conectado aos sumidouros com capacidades iguais às demandas.",
                                    "Desenhe as arestas existentes com suas capacidades de transporte.",
                                    "Atribua capacidades residuais iniciais iguais às capacidades originais.",
                                    "Valide o modelo garantindo que o grafo seja dirigido e acíclico se possível."
                                  ],
                                  "verification": "Desenhe o grafo completo e confirme que superfonte → fontes → intermediários → sumidouros → supersumidouro está correto.",
                                  "estimatedTime": "45 minutos",
                                  "materials": "Software de grafos (Graphviz, Draw.io) ou papel quadriculado.",
                                  "tips": "Use setas direcionais claras e rotule todas as capacidades numericamente.",
                                  "learningObjective": "Transformar um problema descritivo em uma rede de fluxo padrão para aplicação de algoritmos.",
                                  "commonMistakes": "Esquecer superfonte/supersumidouro; inverter direções de arestas."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o algoritmo Ford-Fulkerson",
                                  "subSteps": [
                                    "Inicialize o fluxo em zero em todas as arestas.",
                                    "Use BFS para encontrar um caminho da superfonte ao supersumidouro na rede residual.",
                                    "Encontre o gargalo (menor capacidade residual no caminho).",
                                    "Aumente o fluxo pelo gargalo e atualize a rede residual (frente: +gargalo, trás: -gargalo).",
                                    "Repita até não haver mais caminhos augmentantes."
                                  ],
                                  "verification": "Registre cada iteração em uma tabela (caminho, gargalo, fluxo total atualizado) até o fluxo não aumentar.",
                                  "estimatedTime": "60 minutos",
                                  "materials": "Planilha Excel para rastrear fluxos residuais, pseudocódigo do Ford-Fulkerson.",
                                  "tips": "Implemente BFS manualmente primeiro antes de codificar para entender o processo.",
                                  "learningObjective": "Executar iterativamente o Ford-Fulkerson para computar o fluxo máximo.",
                                  "commonMistakes": "Não atualizar corretamente a rede residual; usar DFS em vez de BFS para Edmonds-Karp (variante eficiente)."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar resultados e verificar maximidade",
                                  "subSteps": [
                                    "Calcule o fluxo máximo total da superfonte.",
                                    "Verifique se há corte mínimo igual ao fluxo máximo (Teorema Max-Flow Min-Cut).",
                                    "Analise o fluxo em cada aresta para decisões de roteamento.",
                                    "Compare com demandas: identifique se todas foram atendidas ou sobras.",
                                    "Documente o plano de transporte final."
                                  ],
                                  "verification": "Confirme que não há caminho augmentante e que fluxo = capacidade do corte mínimo.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Gráfico final com fluxos anotados, calculadora.",
                                  "tips": "Desenhe o corte mínimo para validação visual.",
                                  "learningObjective": "Interpretar o output do algoritmo em termos práticos de transporte.",
                                  "commonMistakes": "Ignorar verificação de maximidade; não relacionar fluxo com o problema original."
                                }
                              ],
                              "practicalExample": "Uma fábrica A (oferta 100) e B (oferta 80) enviam mercadorias para armazéns X (demanda 90) e Y (demanda 90) via centro C. Capacidades: A-C:50, B-C:70, C-X:80, C-Y:80. Modele com superfonte S e supersumidouro T, aplique Ford-Fulkerson para fluxo máximo de 170.",
                              "finalVerifications": [
                                "O grafo modelado reflete corretamente ofertas, demandas e capacidades.",
                                "Nenhuma aresta residual permite caminho da superfonte ao supersumidouro.",
                                "Fluxo máximo equals capacidade do corte mínimo.",
                                "Fluxos por aresta são inteiros e respeitam capacidades.",
                                "Plano de transporte atende todas as demandas possíveis.",
                                "Documentação inclui todas as iterações do algoritmo."
                              ],
                              "assessmentCriteria": [
                                "Precisão na modelagem da rede de fluxo (20%)",
                                "Corretude na execução do Ford-Fulkerson (30%)",
                                "Verificação de maximidade via rede residual e min-cut (20%)",
                                "Interpretação prática dos resultados (15%)",
                                "Clareza na documentação e diagramas (10%)",
                                "Eficiência computacional (número de iterações) (5%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Otimização Linear",
                                "Logística e Gestão de Cadeia de Suprimentos",
                                "Programação: Implementação em Python (NetworkX)",
                                "Economia: Alocação de Recursos e Custos de Transporte"
                              ],
                              "realWorldApplication": "Otimização de rotas em logística de e-commerce (ex: Amazon), gerenciamento de fluxo em redes de oleodutos ou tráfego aéreo para maximizar capacidade sem exceder limites de infraestrutura."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.1"
                            ]
                          },
                          {
                            "id": "10.1.7.3.4.2",
                            "name": "Aplicar em emparelhamento bipartido",
                            "description": "Reduzir problema de emparelhamento máximo bipartido a fluxo máximo e resolver com Ford-Fulkerson.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender o problema de emparelhamento bipartido máximo",
                                  "subSteps": [
                                    "Defina um grafo bipartido G = (U ∪ V, E), onde U e V são conjuntos disjuntos de vértices.",
                                    "Explique o conceito de emparelhamento: um subconjunto de arestas sem vértices comuns.",
                                    "Descreva o emparelhamento máximo como o de maior cardinalidade.",
                                    "Relacione com o problema de fluxo máximo, destacando a redução.",
                                    "Identifique exemplos reais, como atribuição de tarefas."
                                  ],
                                  "verification": "Escreva uma definição precisa e dê um exemplo simples de grafo bipartido com emparelhamento máximo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e lápis ou software de desenho de grafos (ex: Draw.io)",
                                  "tips": "Desenhe grafos pequenos para visualizar melhor as partições U e V.",
                                  "learningObjective": "Entender a estrutura do grafo bipartido e o objetivo do emparelhamento máximo.",
                                  "commonMistakes": "Confundir grafo bipartido com grafo geral; ignorar que arestas não conectam dentro de U ou V."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a rede de fluxo equivalente",
                                  "subSteps": [
                                    "Adicione uma fonte s conectada a todos os vértices de U com capacidades 1.",
                                    "Adicione um sumidouro t conectado a todos os vértices de V com capacidades 1.",
                                    "Para cada aresta (u,v) em E, adicione aresta u → v com capacidade 1 na rede.",
                                    "Verifique que todas as capacidades são unitárias (1).",
                                    "Desenhe a rede completa e anote capacidades."
                                  ],
                                  "verification": "Desenhe a rede de fluxo para um grafo bipartido dado e confirme que o fluxo máximo corresponde ao matching.",
                                  "estimatedTime": "30 minutos",
                                  "materials": "Software de grafos (ex: Graphviz ou Python com NetworkX)",
                                  "tips": "Use setas direcionadas para arestas de fluxo e rotule capacidades claramente.",
                                  "learningObjective": "Modelar corretamente o matching bipartido como rede de fluxo com capacidades unitárias.",
                                  "commonMistakes": "Esquecer capacidades 1 nas arestas originais ou conectar s/t incorretamente."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar o algoritmo Ford-Fulkerson",
                                  "subSteps": [
                                    "Inicialize o fluxo em zero em todas as arestas.",
                                    "Encontre caminhos aumentantes de s a t usando BFS ou DFS na rede residual.",
                                    "Aumente o fluxo pelo gargalo mínimo do caminho encontrado.",
                                    "Repita até não haver mais caminhos aumentantes.",
                                    "Registre o valor do fluxo máximo."
                                  ],
                                  "verification": "Execute o algoritmo passo a passo em uma rede pequena e calcule o fluxo final.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Planilha ou código Python simples para simular fluxos",
                                  "tips": "Mantenha uma tabela da rede residual para rastrear capacidades residuais.",
                                  "learningObjective": "Executar Ford-Fulkerson corretamente em redes com capacidades unitárias.",
                                  "commonMistakes": "Não atualizar corretamente a rede residual; ignorar arestas reversas."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Interpretar o resultado e verificar o emparelhamento",
                                  "subSteps": [
                                    "Identifique as arestas com fluxo 1 entre U e V como o emparelhamento.",
                                    "Confirme que não há vértices compartilhados no matching.",
                                    "Verifique se o tamanho do matching equals o valor do fluxo máximo.",
                                    "Compare com um emparelhamento manual para validar.",
                                    "Discuta otimalidade via teorema de fluxo-máximo-matching."
                                  ],
                                  "verification": "Extraia o matching do fluxo e prove que é máximo.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Gráfico da rede final com fluxos anotados",
                                  "tips": "Só arestas U→V com fluxo 1 contam; ignore fluxos de s e t.",
                                  "learningObjective": "Converter fluxo máximo de volta em emparelhamento máximo.",
                                  "commonMistakes": "Incluir arestas com fluxo 0 ou múltiplos matches por vértice."
                                }
                              ],
                              "practicalExample": "Considere um grafo bipartido com U = {u1, u2, u3} (trabalhadores) e V = {v1, v2, v3} (tarefas), arestas: u1-v1, u1-v2, u2-v2, u3-v3. Construa a rede: s→u_i (cap=1), u_i→v_j (cap=1), v_j→t (cap=1). Ford-Fulkerson encontra fluxo 3, matching: u1-v1, u2-v2, u3-v3.",
                              "finalVerifications": [
                                "A rede de fluxo foi construída com capacidades corretas (todas 1).",
                                "Ford-Fulkerson foi executado sem erros na rede residual.",
                                "O valor do fluxo máximo equals o tamanho do matching extraído.",
                                "O matching é válido (sem vértices compartilhados).",
                                "Teorema de redução foi aplicado corretamente."
                              ],
                              "assessmentCriteria": [
                                "Precisão na construção da rede de fluxo (100% das arestas corretas).",
                                "Execução correta de Ford-Fulkerson (caminhos aumentantes identificados).",
                                "Interpretação precisa do fluxo como matching.",
                                "Explicação clara da redução teórica.",
                                "Eficiência: tempo de execução polinomial demonstrado.",
                                "Validação com exemplo numérico."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Otimização Linear.",
                                "Economia: Alocação ótima de recursos escassos.",
                                "Engenharia de Software: Modelagem de dependências em projetos.",
                                "Inteligência Artificial: Matching em sistemas de recomendação."
                              ],
                              "realWorldApplication": "Em recrutamento, matching candidatos-vagas; em logística, atribuição de veículos-rotas; em redes sociais, pareamento de perfis compatíveis."
                            },
                            "estimatedTime": "2.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.3.3.4",
                              "10.1.7.3.4.1"
                            ]
                          }
                        ]
                      }
                    ]
                  },
                  {
                    "id": "10.1.7.4",
                    "name": "Problemas de Emparelhamento em Grafos",
                    "description": "Algoritmos para encontrar emparelhamentos máximos em grafos bipartidos e gerais.",
                    "individualConcepts": [
                      {
                        "id": "10.1.7.4.1",
                        "name": "Emparelhamento Máximo em Grafos Bipartidos",
                        "description": "Conceitos e algoritmos para encontrar emparelhamentos máximos em grafos bipartidos, incluindo modelagem via fluxo máximo e algoritmos de caminhos aumentantes.",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.1.1",
                            "name": "Definir emparelhamento e teoremas fundamentais",
                            "description": "Explicar o conceito de emparelhamento, emparelhamento máximo, emparelhamento perfeito e o Teorema de König que relaciona o tamanho do emparelhamento máximo ao número de vértices cobrindo as arestas mínimas em grafos bipartidos.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender grafos bipartidos e definição básica de emparelhamento",
                                  "subSteps": [
                                    "Estude a definição de grafo bipartido: vértices divididos em duas partições disjuntas sem arestas internas.",
                                    "Desenhe exemplos simples de grafos bipartidos com 4-6 vértices.",
                                    "Defina emparelhamento como um conjunto de arestas sem vértices comuns.",
                                    "Identifique emparelhamentos válidos em um grafo dado.",
                                    "Diferencie emparelhamento de caminhos ou ciclos."
                                  ],
                                  "verification": "Desenhe um grafo bipartido e destaque um emparelhamento válido, explicando por quê.",
                                  "estimatedTime": "25 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Ferramenta online como Graphviz ou yEd"
                                  ],
                                  "tips": "Use cores diferentes para as partições para visualizar melhor.",
                                  "learningObjective": "Dominar a estrutura de grafos bipartidos e o conceito fundamental de emparelhamento.",
                                  "commonMistakes": [
                                    "Incluir arestas dentro da mesma partição",
                                    "Permitir vértices compartilhados nas arestas do emparelhamento"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Definir emparelhamento máximo e emparelhamento perfeito",
                                  "subSteps": [
                                    "Defina emparelhamento máximo como um emparelhamento que não pode ser estendido adicionando mais arestas.",
                                    "Compare emparelhamentos de tamanhos diferentes no mesmo grafo.",
                                    "Defina emparelhamento perfeito como um emparelhamento que cobre todos os vértices.",
                                    "Identifique condições para existência de emparelhamento perfeito em grafos bipartidos.",
                                    "Construa exemplos onde emparelhamento máximo não é perfeito."
                                  ],
                                  "verification": "Em um grafo bipartido dado, encontre e justifique um emparelhamento máximo e verifique se é perfeito.",
                                  "estimatedTime": "30 minutos",
                                  "materials": [
                                    "Papel e lápis",
                                    "Exemplos impressos de grafos bipartidos"
                                  ],
                                  "tips": "Teste adicionando arestas para confirmar maximalidade.",
                                  "learningObjective": "Diferenciar e identificar tipos avançados de emparelhamentos em grafos bipartidos.",
                                  "commonMistakes": [
                                    "Confundir máximo com maior tamanho possível sem prova",
                                    "Ignorar vértices isolados em emparelhamento perfeito"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Estudar o Teorema de König e suas implicações",
                                  "subSteps": [
                                    "Enuncie o Teorema de König: Em grafos bipartidos, o tamanho do emparelhamento máximo equals o tamanho da cobertura mínima de vértices.",
                                    "Defina cobertura de vértices: conjunto mínimo de vértices que incide sobre todas as arestas.",
                                    "Construa exemplos ilustrando a igualdade.",
                                    "Discuta a prova intuitiva via dualidade em programação linear ou fluxos.",
                                    "Aplique o teorema para resolver problemas de cobertura."
                                  ],
                                  "verification": "Prove ou ilustre o teorema em um grafo pequeno, calculando ambos os lados.",
                                  "estimatedTime": "40 minutos",
                                  "materials": [
                                    "Livro de grafos ou PDF do teorema",
                                    "Software de grafos para simulação"
                                  ],
                                  "tips": "Use o algoritmo de Hopcroft-Karp para computar emparelhamento máximo e compare.",
                                  "learningObjective": "Compreender e aplicar o Teorema de König relacionando emparelhamentos e coberturas.",
                                  "commonMistakes": [
                                    "Aplicar o teorema em grafos não bipartidos",
                                    "Confundir cobertura de vértices com cobertura de arestas"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo bipartido com partições U={u1,u2} e V={v1,v2,v3}, arestas: u1-v1, u1-v2, u2-v2, u2-v3. Um emparelhamento máximo é {u1-v1, u2-v3} (tamanho 2). Uma cobertura mínima de vértices é {u1, u2} ou {v1,v3,v2? Não, {v2,u2?} na verdade {u1,u2} cobre todas. Pelo Teorema de König, tamanhos iguais=2. Não é perfeito pois v2 fica descoberto.",
                              "finalVerifications": [
                                "Definir corretamente emparelhamento, máximo e perfeito com exemplos.",
                                "Enunciar precisamente o Teorema de König.",
                                "Identificar cobertura mínima em um grafo bipartido dado.",
                                "Verificar se um emparelhamento é máximo comparando tamanhos.",
                                "Explicar por que o teorema falha em grafos não bipartidos.",
                                "Construir grafo com emparelhamento perfeito."
                              ],
                              "assessmentCriteria": [
                                "Precisão nas definições (sem ambiguidades).",
                                "Capacidade de ilustrar teoremas com exemplos concretos.",
                                "Compreensão da relação entre emparelhamento máximo e cobertura mínima.",
                                "Identificação correta de erros comuns em exercícios.",
                                "Aplicação intuitiva do teorema sem fórmulas avançadas.",
                                "Criatividade em exemplos personalizados."
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de conjuntos e cardinalidade.",
                                "Otimização: Programação linear e dualidade.",
                                "Teoria dos Jogos: Equilíbrios em pareamentos estáveis.",
                                "Ciência da Computação: Algoritmos de fluxo máximo (Ford-Fulkerson)."
                              ],
                              "realWorldApplication": "Atribuição ótima de tarefas em empresas (ex: matching funcionários-projetos), pareamento em sistemas de recomendação (ex: Tinder ou redes profissionais), planejamento de rotas em logística bipartida (fornecedores-clientes), e análise de redes sociais para conexões mutuamente exclusivas."
                            },
                            "estimatedTime": "1 hora",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.2",
                            "name": "Implementar algoritmo de caminhos aumentantes (Kuhn/Munkres)",
                            "description": "Implementar o algoritmo guloso que utiliza Busca em Largura (BFS) para encontrar caminhos aumentantes múltiplos a partir de vértices livres, atualizando o emparelhamento até não haver mais caminhos, com complexidade O(VE).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar o Grafo Bipartido e Inicializar Estruturas de Dados",
                                  "subSteps": [
                                    "Defina as partições U e V do grafo bipartido usando listas ou arrays.",
                                    "Crie uma matriz de adjacência ou lista de adjacência para representar as arestas entre U e V.",
                                    "Inicialize arrays pairU (para pares de U), pairV (para pares de V) e vistos (para rastrear visitas na BFS).",
                                    "Implemente uma função para ler o grafo de entrada (ex: número de vértices e arestas).",
                                    "Defina variáveis globais ou de classe para o tamanho das partições (m e n)."
                                  ],
                                  "verification": "Verifique se as estruturas estão vazias inicialmente (todos pairU e pairV = -1) e se a adjacência reflete corretamente as conexões.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Linguagem de programação (Python/C++), editor de código (VS Code), grafo de exemplo bipartido"
                                  ],
                                  "tips": "Use NIL (-1) para representar vértices livres. Teste a inicialização com um grafo pequeno.",
                                  "learningObjective": "Compreender e codificar a representação padrão de grafos bipartidos para emparelhamento.",
                                  "commonMistakes": [
                                    "Índices off-by-one nas partições",
                                    "Confundir U com V",
                                    "Não inicializar pair arrays corretamente"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Função BFS para Encontrar Caminho Aumentante",
                                  "subSteps": [
                                    "Crie uma fila para BFS e marque todos pairU como não visitados.",
                                    "Para cada vértice livre em U (pairU[u] == -1), inicie BFS a partir dele.",
                                    "Na BFS, explore vizinhos v em V: se pairV[v] == -1 (livre), retorne o caminho; senão, enfileire pairV[v] se não visitado.",
                                    "Use um array 'vistos' para evitar ciclos e revisitar vértices.",
                                    "Retorne true se encontrou caminho aumentante, false caso contrário; armazene o caminho via pairU/pairV."
                                  ],
                                  "verification": "Execute BFS em um grafo simples e imprima o caminho encontrado ou confirme ausência.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pseudocódigo do algoritmo Hungarian/Kuhn",
                                    "Debugger no IDE",
                                    "Grafo de teste com caminho aumentante conhecido"
                                  ],
                                  "tips": "A BFS deve simular busca em níveis, priorizando livres primeiro. Desenhe o grafo à mão antes de codificar.",
                                  "learningObjective": "Dominar a busca gulosa por caminhos aumentantes usando BFS em grafos residuais.",
                                  "commonMistakes": [
                                    "Não resetar 'vistos' por tentativa",
                                    "Explorar de V para U incorretamente",
                                    "Perder o rastro do caminho pai"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Implementar Atualização do Emparelhamento Após Encontrar Caminho",
                                  "subSteps": [
                                    "Após BFS retornar true, reconstrua o caminho aumentante retrocedendo de u via pairU até a raiz.",
                                    "Inverta as arestas ao longo do caminho: para cada par consecutivo (v, u = pairV[v]), atualize pairU[u] = v e pairV[v] = u.",
                                    "Continue invertendo até o vértice livre em V.",
                                    "Implemente isso em uma função separada augmentPath() chamada pela BFS.",
                                    "Aumente um contador de matching size."
                                  ],
                                  "verification": "Após atualização, verifique se o tamanho do matching aumentou em 1 e todos pares são consistentes (pairU[u] == v iff pairV[v] == u).",
                                  "estimatedTime": "1.5 horas",
                                  "materials": [
                                    "Código do Step 2",
                                    "Exemplo manual de augmentação",
                                    "Ferramenta de visualização de grafos (opcional)"
                                  ],
                                  "tips": "A inversão cria o 'zigzag' característico do caminho aumentante. Teste com printfs intermediários.",
                                  "learningObjective": "Aprender a modificar o emparelhamento atual usando caminhos aumentantes para maximização.",
                                  "commonMistakes": [
                                    "Atualizar apenas uma direção",
                                    "Não inverter todo o caminho",
                                    "Loop infinito na reconstrução"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Loop Principal e Executar Algoritmo Completo",
                                  "subSteps": [
                                    "No loop principal, enquanto houver um caminho aumentante (BFS retorna true), chame augmentPath().",
                                    "Repita até BFS falhar para todos livres em U.",
                                    "Registre o tamanho final do matching.",
                                    "Adicione função main para ler input, rodar algoritmo e imprimir pares.",
                                    "Otimize para complexidade O(VE) evitando recálculos desnecessários."
                                  ],
                                  "verification": "Rode em grafos conhecidos: matching deve ser máximo (ex: grafo completo bipartido K_{n,n} deve dar n).",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Código completo dos steps anteriores",
                                    "Casos de teste variados (pequeno, denso, esparso)"
                                  ],
                                  "tips": "Limite iterações para debug. Meça tempo para confirmar eficiência.",
                                  "learningObjective": "Integrar componentes em algoritmo guloso completo para emparelhamento máximo.",
                                  "commonMistakes": [
                                    "Loop infinito sem break",
                                    "Não checar todos u livres",
                                    "Ignorar grafos não-conectados"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Testar, Depurar e Verificar Corretude",
                                  "subSteps": [
                                    "Crie testes unitários para BFS, augmentPath e loop principal.",
                                    "Teste com grafos onde matching ótimo é conhecido (ex: ciclo par, árvore).",
                                    "Verifique invariantes: matching sempre válido, BFS correta.",
                                    "Meça complexidade empiricamente com grafos crescentes.",
                                    "Documente código com comentários."
                                  ],
                                  "verification": "Todos testes passam; matching size correto em 10+ casos.",
                                  "estimatedTime": "1 hora",
                                  "materials": [
                                    "Framework de testes (pytest/unittest)",
                                    "Gerador de grafos aleatórios",
                                    "Referência teórica"
                                  ],
                                  "tips": "Use asserts para invariantes. Compare com implementações existentes.",
                                  "learningObjective": "Garantir robustez e corretude da implementação via testes sistemáticos.",
                                  "commonMistakes": [
                                    "Testes só em casos felizes",
                                    "Ignorar edge cases (grafo vazio, 1 vértice)",
                                    "Não checar simetria pairU/pairV"
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo bipartido com U={1,2}, V={A,B,C} e arestas 1-A,1-B,2-B,2-C: Inicial matching vazio. BFS de 1 encontra 1-A (livre). Augmenta para {1-A}. BFS de 2 encontra 2-B (livre). Augmenta para {1-A,2-B}. Sem mais caminhos livres. Matching size=2.",
                              "finalVerifications": [
                                "pairU e pairV são simétricos e todos valores válidos (-1 ou parceiro correto).",
                                "Tamanho do matching é máximo (não há caminho aumentante via BFS).",
                                "Algoritmo termina em tempo razoável (O(VE) empírico).",
                                "Funciona em grafos esparsos, densos e desconectados.",
                                "Todos testes unitários passam sem erros.",
                                "Código limpo, comentado e modular."
                              ],
                              "assessmentCriteria": [
                                "Corretude: matching máximo em todos casos de teste (100%).",
                                "Eficiência: complexidade O(VE) confirmada empiricamente.",
                                "Estrutura: código modular com funções claras (BFS, augment, main).",
                                "Robustez: lida com edge cases (V=0, matching perfeito).",
                                "Documentação: comentários explicam lógica chave.",
                                "Testes: cobertura >80% com asserts."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria de Grafos e Otimização Combinatória.",
                                "Ciência da Computação: Algoritmos de Fluxo Máximo (Ford-Fulkerson).",
                                "Engenharia de Software: Testes Unitários e Depuração.",
                                "Inteligência Artificial: Matching em sistemas de recomendação.",
                                "Economia: Alocação ótima de recursos bipartidos."
                              ],
                              "realWorldApplication": "Atribuição de tarefas em empresas (funcionários a projetos), pareamento em apps de namoro (usuários bipartidos por gênero/interesses), agendamento de aulas (professores a turmas), redes sociais (matching de amigos potenciais)."
                            },
                            "estimatedTime": "3 horas",
                            "difficulty": "intermediate",
                            "status": "not_started",
                            "prerequisites": []
                          },
                          {
                            "id": "10.1.7.4.1.3",
                            "name": "Aplicar modelagem como fluxo máximo",
                            "description": "Modelar o problema de emparelhamento bipartido como um grafo de fluxo com capacidades unitárias, aplicando algoritmos como Ford-Fulkerson ou Dinic para computar o emparelhamento máximo.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Compreender e Representar o Grafo Bipartido",
                                  "subSteps": [
                                    "Identifique os dois conjuntos de vértices disjuntos (U e V) no grafo bipartido.",
                                    "Liste todas as arestas entre U e V, garantindo ausência de arestas intra-conjuntos.",
                                    "Desenhe o grafo bipartido visualmente para clareza.",
                                    "Defina o problema como encontrar o maior número de arestas sem vértices compartilhados.",
                                    "Anote o tamanho dos conjuntos |U| e |V|."
                                  ],
                                  "verification": "Confirme que o grafo é bipartido (sem arestas dentro de U ou V) e listo todas as arestas corretamente.",
                                  "estimatedTime": "20 minutos",
                                  "materials": "Papel e caneta ou software de desenho de grafos (ex: draw.io, Graphviz)",
                                  "tips": "Use cores diferentes para U e V para visualização fácil.",
                                  "learningObjective": "Reconhecer a estrutura bipartida e preparar para modelagem de fluxo.",
                                  "commonMistakes": "Confundir vértices de U e V ou incluir arestas não bipartidas."
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Construir a Rede de Fluxo",
                                  "subSteps": [
                                    "Adicione uma fonte S conectada a todos os vértices de U com capacidades 1.",
                                    "Adicione um sumidouro T conectado de todos os vértices de V com capacidades 1.",
                                    "Mantenha as arestas originais entre U e V com capacidades 1.",
                                    "Verifique que todas as capacidades são unitárias (1).",
                                    "Desenhe a rede completa de fluxo."
                                  ],
                                  "verification": "Inspecione o grafo: S → U (cap=1), U → V (cap=1), V → T (cap=1), sem outras conexões.",
                                  "estimatedTime": "25 minutos",
                                  "materials": "Papel, caneta ou Python com NetworkX para modelagem gráfica",
                                  "tips": "Rotule capacidades em cada aresta para evitar confusão.",
                                  "learningObjective": "Transformar grafo bipartido em rede de fluxo equivalente.",
                                  "commonMistakes": "Esquecer capacidades unitárias ou conectar S diretamente a V."
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Aplicar Algoritmo de Fluxo Máximo",
                                  "subSteps": [
                                    "Escolha Ford-Fulkerson (BFS/DFS) ou Dinic e implemente inicializando fluxo zero.",
                                    "Encontre caminhos aumentantes da fonte ao sumidouro repetidamente.",
                                    "Aumente o fluxo em cada caminho encontrado até não haver mais.",
                                    "Registre o valor máximo do fluxo computado.",
                                    "Implemente em código se possível para automação."
                                  ],
                                  "verification": "O algoritmo para quando não há caminhos saturados restantes; valor do fluxo é inteiro.",
                                  "estimatedTime": "40 minutos",
                                  "materials": "Python com NetworkX ou biblioteca de fluxos (ex: networkx.algorithms.flow), calculadora",
                                  "tips": "Use BFS para Edmonds-Karp (versão eficiente de Ford-Fulkerson).",
                                  "learningObjective": "Executar fluxo máximo para resolver emparelhamento.",
                                  "commonMistakes": "Não saturar arestas corretamente ou ignorar capacidades residuais."
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Extrair e Verificar o Emparelhamento Máximo",
                                  "subSteps": [
                                    "Identifique arestas U→V com fluxo 1 na solução final.",
                                    "Liste os pares emparelhados sem duplicatas.",
                                    "Confirme que o número de pares equals o valor do fluxo máximo.",
                                    "Verifique se é um emparelhamento válido (sem vértices compartilhados).",
                                    "Compare com teorema de König para grafos pequenos."
                                  ],
                                  "verification": "Número de arestas com fluxo 1 = fluxo máximo; cada vértice usado no máximo uma vez.",
                                  "estimatedTime": "15 minutos",
                                  "materials": "Solução do passo anterior, papel para listar pares",
                                  "tips": "Siga apenas fluxos plenos nas arestas originais.",
                                  "learningObjective": "Interpretar fluxo como emparelhamento ótimo.",
                                  "commonMistakes": "Incluir arestas com fluxo 0 ou duplicar vértices."
                                }
                              ],
                              "practicalExample": "Grafo bipartido: U={A,B,C}, V={X,Y,Z}, arestas A-X, A-Y, B-Y, B-Z, C-X. Construa rede: S→A,B,C (cap=1), A→X,Y(1), etc., V→T(1). Fluxo máx=2 (ex: A-X, B-Y). Emparelhamento: A-X, B-Y.",
                              "finalVerifications": [
                                "O valor do fluxo máximo equals o tamanho do emparelhamento.",
                                "Todas arestas de emparelhamento têm fluxo 1 e são disjuntas.",
                                "Não há caminho aumentante residual da fonte ao sumidouro.",
                                "Capacidades de S e T estão saturadas corretamente.",
                                "Solução corresponde a um emparelhamento válido no grafo original.",
                                "Teste com grafo pequeno manualmente."
                              ],
                              "assessmentCriteria": [
                                "Correta construção da rede de fluxo com capacidades unitárias.",
                                "Implementação precisa do algoritmo sem erros de fluxo residual.",
                                "Interpretação correta do fluxo como emparelhamento.",
                                "Eficiência: tempo polinomial para instâncias razoáveis.",
                                "Verificação teórica (teorema fluxo-emparelhamento).",
                                "Capacidade de generalizar para grafos maiores."
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Otimização linear e dualidade (teorema de König).",
                                "Economia: Alocação de recursos e mercados bipartidos.",
                                "Ciência da Computação: Algoritmos de matching em IA e recomendação.",
                                "Engenharia: Atribuição de tarefas em redes.",
                                "Estatística: Modelos de rede em análise de dados sociais."
                              ],
                              "realWorldApplication": "Atribuição de empregos (trabalhadores vs vagas), pareamento de doadores/órgãos em medicina, agendamento de aulas (professores vs salas), sistemas de recomendação (usuários vs itens) e redes de transporte para maximizar emparelhamentos."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.1"
                            ]
                          }
                        ]
                      },
                      {
                        "id": "10.1.7.4.2",
                        "name": "Emparelhamento Máximo em Grafos Gerais",
                        "description": "Algoritmos avançados para emparelhamento máximo em grafos não-bipartidos, focando no algoritmo de Edmonds e estruturas como flores (blossoms).",
                        "specificSkills": [
                          {
                            "id": "10.1.7.4.2.1",
                            "name": "Compreender caminhos aumentantes e flores",
                            "description": "Explicar caminhos aumentantes em grafos gerais, a estrutura de flores (blossoms) que impedem caminhos simples e como contrair flores para encontrar emparelhamentos maiores.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar conceitos básicos de emparelhamento e caminhos aumentantes em grafos bipartidos",
                                  "subSteps": [
                                    "Defina emparelhamento como um conjunto de arestas sem vértices comuns.",
                                    "Explique o teorema de Berge: um emparelhamento é máximo se não existir caminho aumentante.",
                                    "Descreva como encontrar caminhos aumentantes em grafos bipartidos usando busca em largura (BFS).",
                                    "Implemente um exemplo simples de augmenting path em um grafo bipartido.",
                                    "Verifique se o emparelhamento aumenta após alternar o caminho."
                                  ],
                                  "verification": "Construa um grafo bipartido pequeno e encontre manualmente um caminho aumentante, confirmando o aumento do tamanho do matching.",
                                  "estimatedTime": "45 minutos",
                                  "materials": [
                                    "Papel e lápis para desenhar grafos",
                                    "Software de grafos como Graphviz ou yEd"
                                  ],
                                  "tips": "Sempre comece labelando vértices livres e alternando arestas livres/ocupadas.",
                                  "learningObjective": "Compreender a base teórica de emparelhamentos e caminhos aumentantes para transição a grafos gerais.",
                                  "commonMistakes": [
                                    "Confundir grafos bipartidos com gerais",
                                    "Ignorar vértices livres no início da busca"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Introduzir caminhos aumentantes em grafos gerais",
                                  "subSteps": [
                                    "Explique que em grafos gerais, caminhos aumentantes podem formar ciclos ímpares.",
                                    "Defina um caminho aumentante como alternância de arestas livres/ocupadas começando e terminando em vértices livres.",
                                    "Discuta por que BFS simples falha em grafos gerais devido a ciclos.",
                                    "Use busca em profundidade (DFS) com rótulos para explorar caminhos.",
                                    "Simule uma busca DFS em um grafo geral sem flores."
                                  ],
                                  "verification": "Em um grafo geral sem flores, encontre um caminho aumentante usando DFS e aumente o matching.",
                                  "estimatedTime": "60 minutos",
                                  "materials": [
                                    "Editor de texto para pseudocódigo",
                                    "Ferramenta online de grafos interativos como Gephi"
                                  ],
                                  "tips": "Mantenha pilha de rótulos para evitar ciclos pares durante a DFS.",
                                  "learningObjective": "Diferenciar busca por caminhos aumentantes em grafos bipartidos vs. gerais.",
                                  "commonMistakes": [
                                    "Usar BFS em grafos gerais sem adaptações",
                                    "Perder o rastro de arestas alternadas"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Compreender a estrutura de flores (blossoms)",
                                  "subSteps": [
                                    "Defina uma flor como um ciclo ímpar onde a aresta livre está no topo, com haste conectada a um vértice livre.",
                                    "Identifique por que flores impedem caminhos aumentantes simples: elas criam ciclos que confundem a alternância.",
                                    "Desenhe exemplos de flores simples e compostas.",
                                    "Explique o papel da base da flor (vértice de menor índice no ciclo).",
                                    "Discuta como flores bloqueiam a expansão do matching."
                                  ],
                                  "verification": "Dada uma figura de grafo, circule e label uma flor, identificando haste, ciclo e base.",
                                  "estimatedTime": "50 minutos",
                                  "materials": [
                                    "Figuras impressas de grafos com flores",
                                    "Vídeos tutoriais sobre algoritmo de Edmonds"
                                  ],
                                  "tips": "Procure ciclos ímpares durante DFS quando encontrar caminhos sobrepostos.",
                                  "learningObjective": "Reconhecer visual e conceitualmente estruturas de flores em emparelhamentos.",
                                  "commonMistakes": [
                                    "Confundir flores com ciclos pares",
                                    "Ignorar a paridade do ciclo"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Aprender detecção e contração de flores para encontrar emparelhamentos maiores",
                                  "subSteps": [
                                    "Descreva o processo de detecção: durante DFS, quando dois ramos se encontram em um vértice ancestro, forma-se uma flor.",
                                    "Explique contração: contraia a flor em um super-vértice, preservando arestas externas.",
                                    "Continue a busca no grafo contraído até encontrar caminho aumentante.",
                                    "Expanda o matching após encontrar o caminho, revertendo contrações.",
                                    "Implemente pseudocódigo para contração e expansão."
                                  ],
                                  "verification": "Aplique contração em um grafo com flor, encontre caminho aumentante no grafo contraído e expanda corretamente.",
                                  "estimatedTime": "75 minutos",
                                  "materials": [
                                    "Pseudocódigo do algoritmo de Edmonds",
                                    "Simulador de grafos online"
                                  ],
                                  "tips": "Sempre escolha a base da flor como o vértice de menor rótulo para consistência.",
                                  "learningObjective": "Dominar a técnica de contração de flores para superar obstáculos em grafos gerais.",
                                  "commonMistakes": [
                                    "Contração incorreta de múltiplas flores",
                                    "Falha na expansão pós-augmentação"
                                  ]
                                }
                              ],
                              "practicalExample": "Considere um grafo com vértices A,B,C,D,E,F. Emparelhamento inicial: A-B, C-D. Há uma flor em C-E-F-C (ciclo ímpar com haste de um vértice livre G para E). Contraia a flor em super-vértice X (base F), encontre caminho G-X-A (aumentante), expanda para matching maior: G-E, F-B, C-D.",
                              "finalVerifications": [
                                "Identifique corretamente um caminho aumentante em grafo sem flores.",
                                "Desenhe e label uma flor em um grafo dado.",
                                "Aplique contração e encontre matching aumentado em grafo com flor.",
                                "Explique verbalmente por que flores impedem caminhos simples.",
                                "Implemente pseudocódigo para detecção de flor.",
                                "Verifique matching máximo em grafo pequeno."
                              ],
                              "assessmentCriteria": [
                                "Precisão na identificação de flores e caminhos aumentantes (30%)",
                                "Correta aplicação de contração e expansão (25%)",
                                "Completude dos passos do algoritmo (20%)",
                                "Uso adequado de terminologia técnica (15%)",
                                "Explicação clara de conceitos (10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática Discreta: Teoria de grafos e ciclos ímpares.",
                                "Algoritmos e Estruturas de Dados: DFS modificada e contrações.",
                                "Otimização Combinatória: Problemas de emparelhamento em redes.",
                                "Inteligência Artificial: Aplicações em matching de recursos."
                              ],
                              "realWorldApplication": "Em telecomunicações, otimizar emparelhamentos de canais em redes não-bipartidas; em bioinformática, parear sequências genéticas em grafos gerais; em logística, alocar recursos com restrições cíclicas como turnos de trabalho."
                            },
                            "estimatedTime": "2 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.1.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.2.2",
                            "name": "Implementar algoritmo de Edmonds (Blossom)",
                            "description": "Implementar o algoritmo de Edmonds que utiliza busca em profundidade com contração de flores para encontrar emparelhamentos máximos, gerenciando estruturas auxiliares para flores e vértices livres, com complexidade O(V^4).",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Representar o Grafo e Inicializar Estruturas Auxiliares",
                                  "subSteps": [
                                    "Represente o grafo não-dirigido como lista de adjacência usando um dicionário ou array de listas.",
                                    "Inicialize o array de emparelhamento 'match' com -1 para todos os vértices (indicando livres).",
                                    "Crie arrays auxiliares: 'label' (0 ou 1 para outer/inner), 'parent' para rastrear caminhos, 'base' para raízes de blossoms.",
                                    "Implemente função para encontrar vértice livre não visitado.",
                                    "Defina estruturas para flores: dicionário de sets ou listas para vértices em cada blossom."
                                  ],
                                  "verification": "Execute uma inicialização em um grafo de teste pequeno; verifique se match é todo -1 e adj lista está correta via print.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Linguagem de programação (Python ou C++)",
                                    "Editor de código (VS Code)",
                                    "Biblioteca de grafos opcional (networkx para testes)"
                                  ],
                                  "tips": [
                                    "Use 0-based indexing para vértices; normalize nomes de vértices para inteiros de 0 a V-1."
                                  ],
                                  "learningObjective": "Configurar corretamente as estruturas de dados essenciais para o algoritmo de Edmonds.",
                                  "commonMistakes": [
                                    "Confundir representação dirigida/não-dirigida",
                                    "Índices off-by-one em arrays",
                                    "Não tratar grafos desconectados"
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Implementar Busca em Profundidade (DFS) Básica para Caminhos Aumentantes",
                                  "subSteps": [
                                    "Defina função DFS(v) que retorna True se encontrar caminho aumentante a partir de v livre.",
                                    "Para cada vizinho u de v: se u livre e label[u]==0, defina parent e label[u]=1, retorne True.",
                                    "Se u emparelhado com w=match[u], e label[w]==0, defina label[w]=1, parent[w]=u, e chame recursivamente DFS(w).",
                                    "Marque v como visitado para evitar ciclos.",
                                    "Retorne False se nenhum caminho encontrado."
                                  ],
                                  "verification": "Teste em grafo bipartido simples; deve encontrar matching máximo sem blossoms.",
                                  "estimatedTime": "2 hours",
                                  "materials": [
                                    "Código do Step 1",
                                    "Grafos de teste bipartidos (ex: K_{3,3})"
                                  ],
                                  "tips": [
                                    "Use rótulos S/T (label 1/2) para alternância externa/interna no caminho."
                                  ],
                                  "learningObjective": "Implementar DFS para detectar caminhos aumentantes em ausência de blossoms.",
                                  "commonMistakes": [
                                    "Ciclos infinitos sem visited",
                                    "Não alternar corretamente labels",
                                    "Ignorar vértices livres"
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Detectar e Identificar Blossoms (Flores)",
                                  "subSteps": [
                                    "Durante DFS, para vizinho u de v com label[u]==label[v], verifique se existe ancestro comum via LCA.",
                                    "Implemente função find_base(u, v) para encontrar o menor base comum no caminho de u e v.",
                                    "Se base encontrada b != None, identifique blossom como ciclo de b a u e b a v.",
                                    "Colete vértices do blossom em um set.",
                                    "Atribua base[i] = b para todos i no blossom."
                                  ],
                                  "verification": "Insira print/debug em grafo com blossom conhecido; confirme detecção correta do ciclo ímpar.",
                                  "estimatedTime": "2.5 hours",
                                  "materials": [
                                    "Código dos Steps 1-2",
                                    "Grafo de teste com blossom (ex: ciclo ímpar de 5 vértices)"
                                  ],
                                  "tips": [
                                    "Use union-find like para base eficiente; priorize menor vértice como base."
                                  ],
                                  "learningObjective": "Detectar estruturas de blossom durante a busca DFS.",
                                  "commonMistakes": [
                                    "LCA incorreta em árvores de busca",
                                    "Não detectar ciclos ímpares",
                                    "Blossoms sobrepostos mal gerenciados"
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Implementar Contração de Blossoms e Chamada Recursiva",
                                  "subSteps": [
                                    "Ao detectar blossom com base b, contraia-o em super-vértice b removendo arestas internas.",
                                    "Atualize adjacências: para vértices fora, conecte a b se conectado a qualquer no blossom.",
                                    "Chame DFS recursivamente no super-grafo a partir de v, ignorando arestas dentro do blossom.",
                                    "Após recursão bem-sucedida, expanda o blossom restaurando matching local.",
                                    "Atualize match e labels globalmente."
                                  ],
                                  "verification": "Teste completo em grafo com um blossom; matching deve aumentar em 1.",
                                  "estimatedTime": "3 hours",
                                  "materials": [
                                    "Código anterior",
                                    "Implementação temporária de contração via subgrafos"
                                  ],
                                  "tips": [
                                    "Simule contração logicamente sem copiar grafo inteiro para eficiência."
                                  ],
                                  "learningObjective": "Gerenciar contrações de blossoms para reduzir grafo efetivamente.",
                                  "commonMistakes": [
                                    "Perda de matching interno ao expandir",
                                    "Arestas duplicadas pós-contração",
                                    "Recursão profunda excessiva"
                                  ]
                                },
                                {
                                  "stepNumber": 5,
                                  "title": "Loop Principal, Augmentação e Verificação Final",
                                  "subSteps": [
                                    "No loop principal: enquanto houver vértice livre, reset labels/parents, chame DFS(v).",
                                    "Se DFS retorna True, augamente matching invertendo ao longo do caminho via parent.",
                                    "Repita até nenhum augmenting path.",
                                    "Implemente função para computar tamanho do matching.",
                                    "Adicione logging para rastrear iterações e blossoms contraídos."
                                  ],
                                  "verification": "Rode em múltiplos grafos; compare com matching ótimo conhecido.",
                                  "estimatedTime": "1.5 hours",
                                  "materials": [
                                    "Código completo",
                                    "Suite de testes (Petersen graph, etc.)"
                                  ],
                                  "tips": [
                                    "Limite recursão para evitar stack overflow em grafos grandes."
                                  ],
                                  "learningObjective": "Completar o algoritmo iterativo com augmentação correta.",
                                  "commonMistakes": [
                                    "Não resetar estados entre iterações",
                                    "Augmentação errada em caminhos",
                                    "Parada prematura"
                                  ]
                                }
                              ],
                              "practicalExample": "Implemente o algoritmo em Python para um grafo de 8 vértices representando pareamento de 4 voluntários a 4 tarefas com incompatibilidades (ex: arestas ausentes para conflitos). O grafo tem um blossom; o algoritmo deve encontrar matching máximo de tamanho 4 após contrair o ciclo ímpar e augmentar.",
                              "finalVerifications": [
                                "O tamanho do matching é máximo (verificado por algoritmo de brute-force em grafos pequenos).",
                                "Nenhum caminho aumentante existe no grafo final com labels resetados.",
                                "Todos blossoms são corretamente detectados e contraídos sem perda de matching.",
                                "Complexidade observada é O(V^4) em testes com V<=20.",
                                "Implementação passa em 10 grafos de teste aleatórios e conhecidos.",
                                "Logs mostram contrações e augmentações corretas."
                              ],
                              "assessmentCriteria": [
                                "Correção: matching ótimo em todos casos de teste (100%).",
                                "Eficiência: tempo de execução dentro de O(V^4) para V=15.",
                                "Robustez: lida com grafos desconectados, isolados e com múltiplos blossoms.",
                                "Clareza: código comentado, funções modulares e nomes descritivos.",
                                "Completo: todos auxiliares (label, base, parent) gerenciados corretamente.",
                                "Escalabilidade: sem erros de recursão em grafos médios."
                              ],
                              "crossCurricularConnections": [
                                "Teoria dos Grafos (Matemática): conceitos de ciclos ímpares e matching perfeito.",
                                "Estruturas de Dados Avançadas: union-find para bases e LCA eficiente.",
                                "Algoritmos de Otimização: similar a Hungarian para bipartidos.",
                                "Programação Competitiva: aplicações em problemas de fluxo e matching.",
                                "Inteligência Artificial: pareamento em grafos para atribuição de agentes."
                              ],
                              "realWorldApplication": "Aplicado em pareamento estável para alocação hospital-residente, agendamento de tarefas em redes sem fio (parear canais sem interferência), matching em plataformas de dating com preferências complexas, e otimização de pareamentos em logística para maximizar compatibilidades em grafos gerais."
                            },
                            "estimatedTime": "4 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.2.1"
                            ]
                          },
                          {
                            "id": "10.1.7.4.2.3",
                            "name": "Analisar complexidade e otimizações",
                            "description": "Analisar a complexidade temporal do algoritmo de Edmonds e discutir otimizações como versões O(V^3) usando estruturas de dados eficientes, comparando com abordagens bipartidas.",
                            "atomicExpansion": {
                              "steps": [
                                {
                                  "stepNumber": 1,
                                  "title": "Revisar o Algoritmo de Edmonds e sua Complexidade Básica",
                                  "subSteps": [
                                    "Estude a estrutura do algoritmo de Edmonds para emparelhamento máximo em grafos gerais, focando em fases de busca de caminhos aumentantes.",
                                    "Identifique as operações principais: construção da floresta alternante, busca de flor e contração de flores.",
                                    "Calcule a complexidade naive: O(V * E) por augmentação, com até V/2 augmentações, resultando em O(V^2 E).",
                                    "Implemente uma versão simples em pseudocódigo para visualizar o fluxo.",
                                    "Registre os gargalos iniciais em cada fase."
                                  ],
                                  "verification": "Explique verbalmente ou por escrito os componentes principais e derive a complexidade O(V^2 E) com justificativa.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Pseudocódigo do algoritmo de Edmonds (Wikipedia ou 'Introduction to Algorithms' de Cormen)",
                                    "Editor de texto ou Jupyter Notebook para pseudocódigo"
                                  ],
                                  "tips": "Desenhe grafos pequenos manualmente para simular uma execução completa.",
                                  "learningObjective": "Compreender os componentes fundamentais do algoritmo e sua complexidade padrão.",
                                  "commonMistakes": [
                                    "Confundir grafos bipartidos com gerais; ignorar a necessidade de flores em grafos não-bipartidos."
                                  ]
                                },
                                {
                                  "stepNumber": 2,
                                  "title": "Analisar Detalhadamente a Complexidade Temporal",
                                  "subSteps": [
                                    "Quebre a complexidade por fase: analisar custo de BFS/DFS na floresta alternante (O(E)) e detecção de flores (O(V)).",
                                    "Some os custos sobre todas as augmentações: prove que há O(V) augmentações no pior caso.",
                                    "Use notação Big-O para formalizar: discuta dependências em V e E.",
                                    "Simule com grafos de tamanhos variados (V=10,20,50) usando ferramentas de profiling.",
                                    "Documente uma tabela comparativa de tempos por operação."
                                  ],
                                  "verification": "Produza um relatório com derivação matemática da complexidade O(V^2 E) e evidências de simulação.",
                                  "estimatedTime": "3 horas",
                                  "materials": [
                                    "Papel 'Network Flows' de Ahuja et al.",
                                    "Python com NetworkX para grafos e timing",
                                    "Calculadora ou SymPy para análise assintótica"
                                  ],
                                  "tips": "Use recorrências para modelar: T(V,E) = V * (E + V^2) ou similar.",
                                  "learningObjective": "Dominar a análise assintótica precisa do algoritmo original.",
                                  "commonMistakes": [
                                    "Subestimar o custo de contrações de flores; confundir complexidade com implementações otimizadas."
                                  ]
                                },
                                {
                                  "stepNumber": 3,
                                  "title": "Explorar Otimizações para O(V^3)",
                                  "subSteps": [
                                    "Estude otimizações usando estruturas de dados: heaps para labels em buscas, union-find para contrações.",
                                    "Implemente versão otimizada: substitua listas por Fibonacci heaps ou arrays eficientes para O(V^3).",
                                    "Compare tempos empíricos: rode benchmarks em grafos densos e esparsos.",
                                    "Discuta trade-offs: espaço vs. tempo, aplicabilidade prática.",
                                    "Proponha uma otimização personalizada, como pré-processamento de matching inicial."
                                  ],
                                  "verification": "Demonstre código funcional com profiling mostrando redução para ~O(V^3) e explique mudanças.",
                                  "estimatedTime": "4 horas",
                                  "materials": [
                                    "Implementação em C++/Python (GitHub repos de blossom algorithm)",
                                    "Ferramentas de profiling: timeit em Python ou gprof"
                                  ],
                                  "tips": "Comece com grafos pequenos para depurar antes de escalar.",
                                  "learningObjective": "Aplicar técnicas de estruturas de dados para otimizar algoritmos gráficos.",
                                  "commonMistakes": [
                                    "Ignorar overhead de heaps em grafos pequenos; não testar em casos densos onde V^3 domina."
                                  ]
                                },
                                {
                                  "stepNumber": 4,
                                  "title": "Comparar com Abordagens Bipartidas e Discutir Implicações",
                                  "subSteps": [
                                    "Revise Hopcroft-Karp para bipartidos: O(E sqrt(V)) vs. Edmonds O(V^3).",
                                    "Crie tabela comparativa: casos onde bipartido é viável vs. geral necessário.",
                                    "Discuta quando reduzir geral a bipartido (não sempre possível).",
                                    "Analise aplicações: stable matching vs. general matching.",
                                    "Conclua com recomendações de escolha de algoritmo."
                                  ],
                                  "verification": "Escreva um ensaio comparativo de 1 página com exemplos e métricas.",
                                  "estimatedTime": "2 horas",
                                  "materials": [
                                    "Artigos sobre Hopcroft-Karp",
                                    "Ferramenta de grafos como Graphviz para visualizações comparativas"
                                  ],
                                  "tips": "Use casos reais como redes sociais para ilustrar diferenças.",
                                  "learningObjective": "Avaliar trade-offs entre algoritmos e escolher adequadamente.",
                                  "commonMistakes": [
                                    "Assumir que todos os problemas são bipartidos; ignorar constantes ocultas em Big-O."
                                  ]
                                }
                              ],
                              "practicalExample": "Em um grafo de 10 vértices representando tarefas e agentes com preferências gerais (não bipartido), execute Edmonds original (O(V^2 E) ~ 1000 ops) vs. otimizado O(V^3) ~ 1000 ops, medindo tempo real e identificando flores contraídas para matching ótimo de 5 pares.",
                              "finalVerifications": [
                                "Derivar corretamente complexidade O(V^2 E) e explicar otimizações para O(V^3).",
                                "Implementar e benchmark versão otimizada com redução mensurável de tempo.",
                                "Comparar precisamente com Hopcroft-Karp, citando casos de uso.",
                                "Identificar gargalos e propor pelo menos uma otimização adicional.",
                                "Explicar verbalmente o papel de flores em grafos não-bipartidos."
                              ],
                              "assessmentCriteria": [
                                "Precisão na análise assintótica (derivations corretas: 30%)",
                                "Qualidade da implementação e benchmarks (evidências empíricas: 25%)",
                                "Profundidade da comparação com bipartidos (insights relevantes: 20%)",
                                "Clareza na documentação e visualizações (comunicação: 15%)",
                                "Criatividade em otimizações propostas (inovação: 10%)"
                              ],
                              "crossCurricularConnections": [
                                "Matemática: Teoria dos Grafos e Análise Assintótica",
                                "Ciência da Computação: Estruturas de Dados Avançadas (Heaps, Union-Find)",
                                "Otimização: Programação Linear e Fluxos de Rede",
                                "Engenharia de Software: Profiling e Benchmarking de Algoritmos"
                              ],
                              "realWorldApplication": "Em sistemas de recomendação de vagas de emprego (agentes e tarefas com afinidades gerais), otimizar matching para maximizar satisfação usando Edmonds O(V^3) em redes de 1000 usuários, reduzindo tempo de computação de horas para minutos em plataformas como LinkedIn ou agências de recrutamento."
                            },
                            "estimatedTime": "1.5 horas",
                            "difficulty": "advanced",
                            "status": "not_started",
                            "prerequisites": [
                              "10.1.7.4.2.2"
                            ]
                          }
                        ]
                      }
                    ]
                  }
                ]
              }
            ],
            "totalSkills": 320
          }
        ],
        "totalSkills": 320,
        "percentage": 0
      }
    ]
  }
}